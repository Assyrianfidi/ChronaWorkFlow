[{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\__tests__\\test-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\__tests__\\test-data\\inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\__tests__\\test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\accessibility\\a11y-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\accessibility\\modes\\AccessibilityModes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\accessibility\\real-time-monitoring.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\accessibility\\super-accessibility.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\ai\\data-insights-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\ai\\pattern-recognition-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\api\\secure-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\accounts\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\admin\\AdminDashboardClient.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\admin\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\api\\admin\\users\\role\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\api\\auth\\[...nextauth]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\api\\auth\\update-oauth-user\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\error\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\forgot-password\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\forgot-password\\store\\auth-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\login\\LoginPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\login\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\register\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\register\\store\\auth-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\reset-password\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\signin\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\signout\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\auth\\store\\auth-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\dashboard\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\inventory\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\invoices\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\profile\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\reports\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\settings\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\settings\\profile\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\app\\transactions\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\AccessibilityContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\AnalyticsEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\AutomationEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\BreadcrumbNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\BusinessIntelligence.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\EnterpriseAPIGateway.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ErrorFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\GraphQLServer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\I18nProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\Layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\Navigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\PredictiveAssistant.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ProtectedRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\RealTimeAccessibilityMonitor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ScreenReaderEnhancements.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\SidebarNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ThemeProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ThirdPartyIntegrations.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ToastContainer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\VoiceCommandEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\WebhookManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\AccessibilityContext.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\AccessibilityContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\RealTimeAccessibilityMonitor.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\RealTimeAccessibilityMonitor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\ScreenReaderEnhancements.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\ScreenReaderEnhancements.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\VisualModeEngine.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\VisualModeEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\VoiceCommandEngine.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accessibility\\VoiceCommandEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accounts\\AccountRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accounts\\AccountsTable.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accounts\\AccountsTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accounts\\AccountsTableSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\accounts\\VirtualizedAccountsTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\AccessibilityModes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\AdaptiveLayoutEngine.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\AdaptiveLayoutEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\DashboardComponents.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\DashboardComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\NotificationSystem.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\NotificationSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\UI-Performance-Engine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\UserExperienceMode.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\adaptive\\UserExperienceMode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ai\\AICFOCopilot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ai\\CashFlowForecast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ai\\NewFeatureComponent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ai\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\analytics\\AnalyticsEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\analytics\\BusinessIntelligence.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\analytics\\DataVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\analytics\\ReportBuilder.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\anomalies\\AnomalyAlerts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\anomalies\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\auth\\AuthErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\auth\\AuthGuard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\auth\\ForgotPasswordForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\auth\\ProtectedRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\auth\\RegistrationForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\auth\\SocialLogin.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\auth\\UserMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\automation\\AIPoweredAssistant.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\automation\\AutomationEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\automation\\IntelligentScheduler.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\automation\\SmartWorkflow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\common\\FileUpload.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\common\\RichTextEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\common\\TagInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\badge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\button.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\calendar.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\card.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\checkbox.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\dialog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\dropdown-menu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\input.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\label.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\layout\\DashboardShell.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\popover.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\select.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\skeleton.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\table.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\textarea.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\components\\ui\\use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\AccountantDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\ActivityFeed.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\AnalyticsKPI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\CFODashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\CashFlowChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\ControllerDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\EnterpriseDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\EnterpriseDashboardNew.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\ExpenseBreakdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\InventoryStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\KPICard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\LatestInvoices.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\LoadingSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\MetricCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\ProjectManagerDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\QuickActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\ZeroState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\dashboard\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\entities\\MultiEntityDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\entities\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\features\\FeatureGate.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\CustomerForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\Form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\InvoiceForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\NewReportForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\ProductForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\ReportForm.new.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\ReportForm.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\ReportForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\UserForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\ValidatedForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\forms\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\hooks\\use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\icons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\integration\\EnterpriseAPIGateway.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\integration\\GraphQLServer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\integration\\ThirdPartyIntegrations.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\integration\\WebhookManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\interaction\\ErrorRecoveryUI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\interaction\\InteractionEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\interaction\\PredictiveAssistant.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\interaction\\WorkflowManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\inventory\\InventoryFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\inventory\\InventoryTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\inventory\\VirtualizedTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\inventory\\__tests__\\test-data\\inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\AdaptiveLayoutEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\AppLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\AppShell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\AuthLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\AuthenticatedLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\DashboardLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\EnterpriseHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\EnterpriseSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\MobileDrawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\NotFoundPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\OwnerLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\PrimaryNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\ProfileMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\SideNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\TopBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\TopNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\TopNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\layout\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\loading\\MicroLoadingIndicators.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\migration\\QuickBooksMigration.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\navigation\\CommandPalette.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\navigation\\EnterpriseSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\notifications\\NotificationSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\onboarding\\TrialOnboarding.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\performance\\PerformanceDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\providers\\SessionProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\quickbooks\\QuickBooksMigration.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\MultiEntityReports.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\ReportFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\ReportForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\ReportList.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\ReportList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\ReportView.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\ReportView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\reports\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\security\\CookieConsent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\security\\SecurityDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\security\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\tokens\\TokenBox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\transactions\\TransactionList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\transactions\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\AccuBooksLogo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\AlertDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\AspectRatio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\BillingBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\ContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\CustomInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\DataTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\DatePicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\DropdownMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseDataTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseFormField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseKPICard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseLoading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\EnterpriseToast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\ErrorFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\FeatureToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\FullPageLoading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\HoverCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\InputOtp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\InputWithIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\LoadingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\LoadingState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\NavigationMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\ProtectedComponent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\RadioGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\RichTextEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\ScrollArea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\Textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\ToggleGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\cards\\Charts.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\cards\\Charts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\editor\\RichTextEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\enterprise\\EnterpriseDataTable.stories.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\enterprise\\EnterpriseDataTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\error-boundary\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\form\\Form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\form\\FormField.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\form\\form-components.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\form\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\layout\\DashboardShell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\layout\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\virtualized-table\\VirtualizedTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\components\\ui\\virtualized-table\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\config\\enhanced-security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\config\\env.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\config\\navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\config\\security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\contexts\\AccountsContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\contexts\\AuthContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\contexts\\DashboardContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\contexts\\ThemeContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\contexts\\ToastContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\contexts\\TransactionsContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\design-system\\enterprise-theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\design-system\\glassmorphism-v3.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\design-system\\glassmorphism.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\design-system\\icons\\IconSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\design-system\\motion-v3.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\design-system\\theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\design-system\\ui-density-adaptation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\EnterpriseDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\components\\DashboardLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\components\\DrilldownViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\components\\EntitySelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\components\\KpiGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\components\\PredictiveInsights.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\context\\DashboardContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\features\\enterprise-dashboard\\context\\EntityContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\queryClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\use-accounts-table.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\use-api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\use-inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\use-mobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\use-session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useAccountingPeriods.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useAutoSave.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useBillingPlans.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useBillingStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useDashboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useInteractiveFeedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useInventoryFilters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\usePermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useReports.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useToast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\hooks\\useWindowSize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\accessibility.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\api\\reportService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\auth-context.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\auth-options.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\auth-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\demo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\features.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\form-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\inventory-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\prisma.ts","messages":[],"suppressedMessages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":6,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":6,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\query-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\queryClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\theme-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\token-refresh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\lib\\validations\\schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\onboarding\\OnboardingEngine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\onboarding\\flows\\beginner-flow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\AIAssistantPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\AICFOCopilotPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\AccountsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\AdminSettingsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\AnomaliesPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\AuditLogsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\BillingPlansPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\CashFlowForecastPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\CustomersPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\DashboardPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\DashboardRouter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\EntitiesPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\ExecutiveDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\FeatureManagementPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\ForgotPasswordPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\Inventory.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\InventoryPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\InvoicesPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\LandingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\LoginPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\NewFeaturePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\NotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\NotificationsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\OnboardingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\OwnerControlsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\Payroll.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\PricingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\Profile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\ProfilePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\QuickBooksMigrationPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\RegisterPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\ReportsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\ResetPasswordPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\TransactionsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\TrialOnboardingPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\Unauthorized.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\WorkflowPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\_app.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\accounts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\api\\auth\\[...nextauth].ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\auth\\ForgotPasswordPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\auth\\LoginPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\auth\\RegisterPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\auth\\ResetPasswordPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\auth\\SignIn.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\auth\\SignUp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\customers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboard\\DashboardPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboard\\EnterpriseDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboard\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\AccountantDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\AdminDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\AuditorDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\CFODashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\ControllerDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\InventoryDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\ManagerDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\ProjectManagerDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\UserDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\dashboards\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\inventory\\InventoryPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\inventory\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\invoices.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\login.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\not-found.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\owner\\OwnerDashboardPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\owner\\OwnerPlaceholderPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\owner\\OwnerPlansPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\owner\\OwnerSubscriptionsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\payroll\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\reconciliation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\register.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\reports.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\reports\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\settings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\settings\\ProfilePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\transactions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\pages\\vendors.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\performance\\gpu-acceleration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\performance\\performance-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\performance\\smart-auto-lazy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\reliability\\error-immunity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\reliability\\smart-logging.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\router\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\routes\\FeatureRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\routes\\PrivateRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\routes\\RoleAllowed.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\routes\\RouteGuards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\routes\\accubooks-routes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\routes\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\security\\biometric-auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\security\\enterprise-security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\security\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\security\\middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\security\\threat-adaptive-ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\security\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\aiService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\api-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\billing\\BillingTelemetry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\billing\\ExportPlanGate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\billing\\SubscriptionPlanConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\dashboard-kpi.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\dashboard.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\migrationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\offline.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\pricingService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\reportService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\services\\trialService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\setupTests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\state\\ui\\UserExperienceMode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\store\\auth-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\store\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\store\\useAuthStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\test-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\test-stubs\\next-auth-react.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\test-stubs\\next-navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\theme\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\accounts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\form.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\next-auth.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\report.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\reportForm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\subscription.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\types\\user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\ui\\micro-interactions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\ui\\perfect-components.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\accessibility.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\enhanced-test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\errorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\interaction-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\kpi-animation-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\utils\\typeGuards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\validations\\additional.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\validations\\hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\validations\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\validations\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\validators\\reportSchema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\workflow\\adaptive-flow-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\client\\src\\workflow\\cross-feature-sync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\access\\accountant-access.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\access\\auditor-access.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\analytics\\analytics-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\analytics\\customer-segmentation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\analytics\\dashboard.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":572,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":572,"endColumn":106}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from 'events';\r\nimport { AnalyticsEngine, AnalyticsQuery, AnalyticsResult, KPIValue, Insight, DrillDown } from './analytics-engine';\r\nimport { ImmutableAuditLogger } from '../audit/immutable-logger';\r\nimport { GovernanceModelManager } from '../rbac/governance-model-manager';\r\nimport { FeatureFlagManager } from '../feature-flags/feature-flag-manager';\r\n\r\n// Dashboard Backend Interfaces\r\nexport interface DashboardTemplate {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  category: 'executive' | 'financial' | 'operational' | 'sales' | 'marketing' | 'custom';\r\n  layout: DashboardLayout;\r\n  widgets: DashboardWidgetTemplate[];\r\n  filters: DashboardFilterTemplate[];\r\n  isPublic: boolean;\r\n  requiredPermissions: string[];\r\n  createdBy: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DashboardWidgetTemplate {\r\n  id: string;\r\n  type: 'kpi' | 'chart' | 'table' | 'metric' | 'insight' | 'drilldown' | 'text' | 'image';\r\n  title: string;\r\n  description?: string;\r\n  position: {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n  };\r\n  config: WidgetConfig;\r\n  dataSource: WidgetDataSource;\r\n  permissions: {\r\n    view: string[];\r\n    edit: string[];\r\n  };\r\n  required: boolean;\r\n}\r\n\r\nexport interface WidgetConfig {\r\n  metric?: string;\r\n  query?: string;\r\n  chartType?: 'bar' | 'line' | 'pie' | 'scatter' | 'heatmap' | 'table' | 'gauge' | 'funnel';\r\n  timeRange?: string;\r\n  filters?: Record<string, any>;\r\n  refreshInterval?: number;\r\n  aggregation?: 'sum' | 'avg' | 'count' | 'min' | 'max';\r\n  groupBy?: string[];\r\n  sortBy?: string;\r\n  sortOrder?: 'asc' | 'desc';\r\n  limit?: number;\r\n  colors?: string[];\r\n  showLegend?: boolean;\r\n  showTooltip?: boolean;\r\n  showGrid?: boolean;\r\n  yAxisLabel?: string;\r\n  xAxisLabel?: string;\r\n  title?: string;\r\n  subtitle?: string;\r\n  format?: string;\r\n  thresholds?: {\r\n    good: number;\r\n    warning: number;\r\n    critical: number;\r\n  };\r\n}\r\n\r\nexport interface WidgetDataSource {\r\n  type: 'query' | 'metric' | 'api' | 'static';\r\n  source: string;\r\n  parameters?: Record<string, any>;\r\n  cacheKey?: string;\r\n  cacheTTL?: number;\r\n}\r\n\r\nexport interface DashboardFilterTemplate {\r\n  id: string;\r\n  name: string;\r\n  type: 'date' | 'select' | 'multiselect' | 'text' | 'number' | 'range';\r\n  field: string;\r\n  label: string;\r\n  options?: Array<{ label: string; value: any; description?: string }>;\r\n  defaultValue?: any;\r\n  required: boolean;\r\n  dependsOn?: string[];\r\n  validation?: {\r\n    min?: number;\r\n    max?: number;\r\n    pattern?: string;\r\n    message?: string;\r\n  };\r\n}\r\n\r\nexport interface DashboardInstance {\r\n  id: string;\r\n  templateId: string;\r\n  tenantId: string;\r\n  name: string;\r\n  description: string;\r\n  layout: DashboardLayout;\r\n  widgets: DashboardWidgetInstance[];\r\n  filters: DashboardFilterInstance[];\r\n  permissions: {\r\n    view: string[];\r\n    edit: string[];\r\n    share: string[];\r\n    admin: string[];\r\n  };\r\n  settings: DashboardSettings;\r\n  refreshInterval: number;\r\n  isPublic: boolean;\r\n  isFavorite: boolean;\r\n  tags: string[];\r\n  createdBy: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  lastViewed?: Date;\r\n  viewCount: number;\r\n}\r\n\r\nexport interface DashboardWidgetInstance {\r\n  id: string;\r\n  templateId: string;\r\n  instanceId: string;\r\n  type: 'kpi' | 'chart' | 'table' | 'metric' | 'insight' | 'drilldown' | 'text' | 'image';\r\n  title: string;\r\n  description?: string;\r\n  position: {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n  };\r\n  config: WidgetConfig;\r\n  dataSource: WidgetDataSource;\r\n  data?: WidgetData;\r\n  lastRefresh?: Date;\r\n  refreshInterval: number;\r\n  enabled: boolean;\r\n  visible: boolean;\r\n  permissions: {\r\n    view: string[];\r\n    edit: string[];\r\n  };\r\n  customizations: {\r\n    title?: string;\r\n    colors?: string[];\r\n    size?: { width: number; height: number };\r\n    position?: { x: number; y: number };\r\n  };\r\n}\r\n\r\nexport interface WidgetData {\r\n  id: string;\r\n  widgetId: string;\r\n  type: 'kpi' | 'chart' | 'table' | 'metric' | 'insight' | 'drilldown';\r\n  data: any;\r\n  metadata: {\r\n    rowCount?: number;\r\n    columns?: string[];\r\n    types?: Record<string, string>;\r\n    lastUpdated: Date;\r\n    refreshTime: number;\r\n    cacheHit: boolean;\r\n  };\r\n  kpis?: Record<string, KPIValue>;\r\n  insights?: Insight[];\r\n  drillDowns?: DrillDown[];\r\n  error?: string;\r\n}\r\n\r\nexport interface DashboardFilterInstance {\r\n  id: string;\r\n  templateId: string;\r\n  instanceId: string;\r\n  name: string;\r\n  type: 'date' | 'select' | 'multiselect' | 'text' | 'number' | 'range';\r\n  field: string;\r\n  label: string;\r\n  value?: any;\r\n  defaultValue?: any;\r\n  options?: Array<{ label: string; value: any; description?: string }>;\r\n  required: boolean;\r\n  enabled: boolean;\r\n  visible: boolean;\r\n  dependsOn?: string[];\r\n  validation?: {\r\n    min?: number;\r\n    max?: number;\r\n    pattern?: string;\r\n    message?: string;\r\n  };\r\n}\r\n\r\nexport interface DashboardSettings {\r\n  autoRefresh: boolean;\r\n  refreshInterval: number;\r\n  theme: 'light' | 'dark' | 'auto';\r\n  density: 'compact' | 'normal' | 'comfortable';\r\n  showGrid: boolean;\r\n  snapToGrid: boolean;\r\n  allowCustomization: boolean;\r\n  exportFormats: ('pdf' | 'excel' | 'csv' | 'png' | 'json')[];\r\n  maxWidgets: number;\r\n  dataRetention: number;\r\n  sharing: {\r\n    allowPublic: boolean;\r\n    allowEmbed: boolean;\r\n    requireAuth: boolean;\r\n    domains?: string[];\r\n  };\r\n}\r\n\r\nexport interface DashboardLayout {\r\n  type: 'grid' | 'flex' | 'custom';\r\n  columns: number;\r\n  rows: number;\r\n  gap: number;\r\n  breakpoints?: {\r\n    xs: number;\r\n    sm: number;\r\n    md: number;\r\n    lg: number;\r\n    xl: number;\r\n  };\r\n}\r\n\r\nexport interface DashboardExport {\r\n  id: string;\r\n  dashboardId: string;\r\n  tenantId: string;\r\n  format: 'pdf' | 'excel' | 'csv' | 'png' | 'json';\r\n  options: ExportOptions;\r\n  status: 'pending' | 'processing' | 'completed' | 'failed';\r\n  createdAt: Date;\r\n  completedAt?: Date;\r\n  downloadUrl?: string;\r\n  fileSize?: number;\r\n  error?: string;\r\n  requestedBy: string;\r\n}\r\n\r\nexport interface ExportOptions {\r\n  includeFilters: boolean;\r\n  includeMetadata: boolean;\r\n  dateRange?: {\r\n    start: Date;\r\n    end: Date;\r\n  };\r\n  widgets?: string[];\r\n  quality?: 'low' | 'medium' | 'high';\r\n  orientation?: 'portrait' | 'landscape';\r\n  pageSize?: 'A4' | 'A3' | 'Letter' | 'Legal';\r\n}\r\n\r\nexport interface DashboardSubscription {\r\n  id: string;\r\n  dashboardId: string;\r\n  tenantId: string;\r\n  userId: string;\r\n  type: 'realtime' | 'hourly' | 'daily' | 'weekly' | 'monthly';\r\n  delivery: {\r\n    email?: string;\r\n    webhook?: string;\r\n    slack?: string;\r\n    teams?: string;\r\n  };\r\n  filters: Record<string, any>;\r\n  enabled: boolean;\r\n  lastSent?: Date;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DashboardActivity {\r\n  id: string;\r\n  dashboardId: string;\r\n  tenantId: string;\r\n  userId: string;\r\n  action: 'viewed' | 'shared' | 'exported' | 'customized' | 'created' | 'deleted' | 'favorited';\r\n  details: Record<string, any>;\r\n  timestamp: Date;\r\n  ipAddress?: string;\r\n  userAgent?: string;\r\n}\r\n\r\nexport class DashboardBackend extends EventEmitter {\r\n  private static instance: DashboardBackend;\r\n  private auditLog: ImmutableAuditLogger;\r\n  private governance: GovernanceModelManager;\r\n  private featureFlags: FeatureFlagManager;\r\n  private analyticsEngine: AnalyticsEngine;\r\n\r\n  // Data storage\r\n  private templates: Map<string, DashboardTemplate> = new Map();\r\n  private instances: Map<string, DashboardInstance> = new Map();\r\n  private widgets: Map<string, DashboardWidgetInstance> = new Map();\r\n  private filters: Map<string, DashboardFilterInstance> = new Map();\r\n  private widgetData: Map<string, WidgetData> = new Map();\r\n  private exports: Map<string, DashboardExport> = new Map();\r\n  private subscriptions: Map<string, DashboardSubscription> = new Map();\r\n  private activities: Map<string, DashboardActivity> = new Map();\r\n\r\n  // Performance metrics\r\n  private performanceMetrics = {\r\n    dashboardsViewed: 0,\r\n    widgetsRefreshed: 0,\r\n    exportsGenerated: 0,\r\n    averageLoadTime: 0,\r\n    cacheHitRate: 0,\r\n    activeSubscriptions: 0\r\n  };\r\n\r\n  private constructor() {\r\n    super();\r\n    this.auditLog = new ImmutableAuditLogger();\r\n    this.governance = new GovernanceModelManager();\r\n    this.featureFlags = new FeatureFlagManager();\r\n    this.analyticsEngine = AnalyticsEngine.getInstance();\r\n    \r\n    this.initializeEventHandlers();\r\n    this.startDataRefreshScheduler();\r\n    this.initializeDefaultTemplates();\r\n  }\r\n\r\n  public static getInstance(): DashboardBackend {\r\n    if (!DashboardBackend.instance) {\r\n      DashboardBackend.instance = new DashboardBackend();\r\n    }\r\n    return DashboardBackend.instance;\r\n  }\r\n\r\n  private initializeEventHandlers(): void {\r\n    this.on('dashboard:viewed', this.handleDashboardViewed.bind(this));\r\n    this.on('widget:refresh', this.handleWidgetRefresh.bind(this));\r\n    this.on('dashboard:shared', this.handleDashboardShared.bind(this));\r\n    this.on('export:completed', this.handleExportCompleted.bind(this));\r\n  }\r\n\r\n  // Template Management\r\n  public async createTemplate(template: Omit<DashboardTemplate, 'id' | 'createdAt' | 'updatedAt'>): Promise<DashboardTemplate> {\r\n    const dashboardTemplate: DashboardTemplate = {\r\n      ...template,\r\n      id: this.generateId(),\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    this.templates.set(dashboardTemplate.id, dashboardTemplate);\r\n\r\n    // Audit log\r\n    await this.auditLog.logOperation('dashboard_template_created', template.createdBy, {\r\n      templateId: dashboardTemplate.id,\r\n      name: template.name,\r\n      category: template.category\r\n    });\r\n\r\n    return dashboardTemplate;\r\n  }\r\n\r\n  public async getTemplate(templateId: string, userId: string): Promise<DashboardTemplate | null> {\r\n    const template = this.templates.get(templateId);\r\n    if (!template) return null;\r\n\r\n    // Check permissions\r\n    if (!template.isPublic) {\r\n      const hasPermission = await this.governance.checkPermission(\r\n        userId,\r\n        'dashboard:template:view',\r\n        'system'\r\n      );\r\n      if (!hasPermission) {\r\n        throw new Error('Insufficient permissions to view dashboard template');\r\n      }\r\n    }\r\n\r\n    return template;\r\n  }\r\n\r\n  public async getTemplates(category?: string, userId: string): Promise<DashboardTemplate[]> {\r\n    const templates = Array.from(this.templates.values());\r\n    \r\n    let filtered = templates;\r\n    if (category) {\r\n      filtered = filtered.filter(t => t.category === category);\r\n    }\r\n\r\n    // Filter by permissions\r\n    return filtered.filter(t => \r\n      t.isPublic || \r\n      await this.governance.checkPermission(userId, 'dashboard:template:view', 'system')\r\n    );\r\n  }\r\n\r\n  // Instance Management\r\n  public async createInstance(instance: Omit<DashboardInstance, 'id' | 'createdAt' | 'updatedAt' | 'viewCount' | 'lastViewed'>): Promise<DashboardInstance> {\r\n    const template = this.templates.get(instance.templateId);\r\n    if (!template) {\r\n      throw new Error('Template not found');\r\n    }\r\n\r\n    // Check permissions\r\n    const hasPermission = await this.governance.checkPermission(\r\n      instance.createdBy,\r\n      'dashboard:create',\r\n      instance.tenantId\r\n    );\r\n    if (!hasPermission) {\r\n      throw new Error('Insufficient permissions to create dashboard instance');\r\n    }\r\n\r\n    const dashboardInstance: DashboardInstance = {\r\n      ...instance,\r\n      id: this.generateId(),\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      viewCount: 0\r\n    };\r\n\r\n    // Create widget instances from template\r\n    dashboardInstance.widgets = await this.createWidgetInstances(template.widgets, dashboardInstance.id);\r\n    \r\n    // Create filter instances from template\r\n    dashboardInstance.filters = await this.createFilterInstances(template.filters, dashboardInstance.id);\r\n\r\n    this.instances.set(dashboardInstance.id, dashboardInstance);\r\n\r\n    // Audit log\r\n    await this.auditLog.logOperation('dashboard_instance_created', instance.createdBy, {\r\n      instanceId: dashboardInstance.id,\r\n      templateId: instance.templateId,\r\n      tenantId: instance.tenantId,\r\n      name: instance.name\r\n    });\r\n\r\n    return dashboardInstance;\r\n  }\r\n\r\n  public async getInstance(instanceId: string, userId: string): Promise<DashboardInstance | null> {\r\n    const instance = this.instances.get(instanceId);\r\n    if (!instance) return null;\r\n\r\n    // Check permissions\r\n    const hasPermission = await this.governance.checkPermission(\r\n      userId,\r\n      'dashboard:view',\r\n      instance.tenantId\r\n    );\r\n    if (!hasPermission && !instance.permissions.view.includes(userId)) {\r\n      throw new Error('Insufficient permissions to view dashboard instance');\r\n    }\r\n\r\n    // Update view statistics\r\n    instance.lastViewed = new Date();\r\n    instance.viewCount++;\r\n\r\n    // Log activity\r\n    await this.logActivity(instanceId, instance.tenantId, userId, 'viewed', {});\r\n\r\n    this.emit('dashboard:viewed', instance, userId);\r\n    return instance;\r\n  }\r\n\r\n  public async updateInstance(instanceId: string, updates: Partial<DashboardInstance>, userId: string): Promise<DashboardInstance> {\r\n    const instance = this.instances.get(instanceId);\r\n    if (!instance) {\r\n      throw new Error('Dashboard instance not found');\r\n    }\r\n\r\n    // Check permissions\r\n    const hasPermission = await this.governance.checkPermission(\r\n      userId,\r\n      'dashboard:edit',\r\n      instance.tenantId\r\n    );\r\n    if (!hasPermission && !instance.permissions.edit.includes(userId)) {\r\n      throw new Error('Insufficient permissions to update dashboard instance');\r\n    }\r\n\r\n    const updatedInstance = {\r\n      ...instance,\r\n      ...updates,\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    this.instances.set(instanceId, updatedInstance);\r\n\r\n    // Audit log\r\n    await this.auditLog.logOperation('dashboard_instance_updated', userId, {\r\n      instanceId,\r\n      tenantId: instance.tenantId,\r\n      updates: Object.keys(updates)\r\n    });\r\n\r\n    return updatedInstance;\r\n  }\r\n\r\n  // Widget Management\r\n  private async createWidgetInstances(templateWidgets: DashboardWidgetTemplate[], instanceId: string): Promise<DashboardWidgetInstance[]> {\r\n    const widgetInstances: DashboardWidgetInstance[] = [];\r\n\r\n    for (const templateWidget of templateWidgets) {\r\n      const widgetInstance: DashboardWidgetInstance = {\r\n        id: this.generateId(),\r\n        templateId: templateWidget.id,\r\n        instanceId,\r\n        type: templateWidget.type,\r\n        title: templateWidget.title,\r\n        description: templateWidget.description,\r\n        position: templateWidget.position,\r\n        config: templateWidget.config,\r\n        dataSource: templateWidget.dataSource,\r\n        refreshInterval: templateWidget.config.refreshInterval || 300000, // 5 minutes default\r\n        enabled: true,\r\n        visible: true,\r\n        permissions: templateWidget.permissions,\r\n        customizations: {}\r\n      };\r\n\r\n      this.widgets.set(widgetInstance.id, widgetInstance);\r\n      widgetInstances.push(widgetInstance);\r\n\r\n      // Initialize widget data\r\n      await this.refreshWidgetData(widgetInstance);\r\n    }\r\n\r\n    return widgetInstances;\r\n  }\r\n\r\n  private async createFilterInstances(templateFilters: DashboardFilterTemplate[], instanceId: string): Promise<DashboardFilterInstance[]> {\r\n    const filterInstances: DashboardFilterInstance[] = [];\r\n\r\n    for (const templateFilter of templateFilters) {\r\n      const filterInstance: DashboardFilterInstance = {\r\n        id: this.generateId(),\r\n        templateId: templateFilter.id,\r\n        instanceId,\r\n        name: templateFilter.name,\r\n        type: templateFilter.type,\r\n        field: templateFilter.field,\r\n        label: templateFilter.label,\r\n        value: templateFilter.defaultValue,\r\n        defaultValue: templateFilter.defaultValue,\r\n        options: templateFilter.options,\r\n        required: templateFilter.required,\r\n        enabled: true,\r\n        visible: true,\r\n        dependsOn: templateFilter.dependsOn,\r\n        validation: templateFilter.validation\r\n      };\r\n\r\n      this.filters.set(filterInstance.id, filterInstance);\r\n      filterInstances.push(filterInstance);\r\n    }\r\n\r\n    return filterInstances;\r\n  }\r\n\r\n  // Widget Data Management\r\n  public async refreshWidgetData(widget: DashboardWidgetInstance): Promise<WidgetData> {\r\n    try {\r\n      const startTime = Date.now();\r\n      \r\n      let data: any;\r\n      let metadata: any;\r\n\r\n      switch (widget.dataSource.type) {\r\n        case 'query':\r\n          const result = await this.executeQuery(widget.dataSource.source, widget.dataSource.parameters);\r\n          data = result.data;\r\n          metadata = result.metadata;\r\n          break;\r\n        case 'metric':\r\n          data = await this.fetchMetric(widget.dataSource.source, widget.dataSource.parameters);\r\n          metadata = { lastUpdated: new Date(), refreshTime: Date.now() - startTime, cacheHit: false };\r\n          break;\r\n        case 'api':\r\n          data = await this.fetchFromAPI(widget.dataSource.source, widget.dataSource.parameters);\r\n          metadata = { lastUpdated: new Date(), refreshTime: Date.now() - startTime, cacheHit: false };\r\n          break;\r\n        case 'static':\r\n          data = widget.dataSource.parameters?.data || [];\r\n          metadata = { lastUpdated: new Date(), refreshTime: 0, cacheHit: true };\r\n          break;\r\n        default:\r\n          throw new Error(`Unsupported data source type: ${widget.dataSource.type}`);\r\n      }\r\n\r\n      const widgetData: WidgetData = {\r\n        id: this.generateId(),\r\n        widgetId: widget.id,\r\n        type: widget.type,\r\n        data,\r\n        metadata: {\r\n          ...metadata,\r\n          lastUpdated: new Date(),\r\n          refreshTime: Date.now() - startTime,\r\n          cacheHit: metadata.cacheHit || false\r\n        }\r\n      };\r\n\r\n      // Add KPIs, insights, and drill-downs for supported widget types\r\n      if (widget.type === 'kpi' || widget.type === 'chart') {\r\n        widgetData.kpis = this.extractKPIs(data, widget.config);\r\n      }\r\n\r\n      if (widget.type === 'chart' || widget.type === 'insight') {\r\n        widgetData.insights = await this.generateInsights(data, widget);\r\n      }\r\n\r\n      if (widget.type === 'drilldown') {\r\n        widgetData.drillDowns = this.generateDrillDowns(data, widget.config);\r\n      }\r\n\r\n      this.widgetData.set(widget.id, widgetData);\r\n      widget.lastRefresh = new Date();\r\n\r\n      this.emit('widget:refresh', widget, widgetData);\r\n      this.performanceMetrics.widgetsRefreshed++;\r\n\r\n      return widgetData;\r\n\r\n    } catch (error) {\r\n      const errorData: WidgetData = {\r\n        id: this.generateId(),\r\n        widgetId: widget.id,\r\n        type: widget.type,\r\n        data: null,\r\n        metadata: {\r\n          lastUpdated: new Date(),\r\n          refreshTime: 0,\r\n          cacheHit: false\r\n        },\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n\r\n      this.widgetData.set(widget.id, errorData);\r\n      return errorData;\r\n    }\r\n  }\r\n\r\n  private async executeQuery(queryId: string, parameters?: Record<string, any>): Promise<AnalyticsResult> {\r\n    const query = await this.analyticsEngine.submitQuery({\r\n      tenantId: 'system', // This should be passed from context\r\n      userId: 'system',\r\n      query: queryId,\r\n      parameters: parameters || {},\r\n      type: 'realtime',\r\n      priority: 'standard'\r\n    });\r\n\r\n    if (query.status !== 'completed' || !query.result) {\r\n      throw new Error('Query execution failed');\r\n    }\r\n\r\n    return query.result;\r\n  }\r\n\r\n  private async fetchMetric(metricId: string, parameters?: Record<string, any>): Promise<any> {\r\n    // Fetch metric data from analytics engine\r\n    // This would integrate with the metrics system\r\n    return {\r\n      value: 1250000,\r\n      trend: 'up',\r\n      changePercent: 15.5,\r\n      target: 1000000,\r\n      status: 'good'\r\n    };\r\n  }\r\n\r\n  private async fetchFromAPI(url: string, parameters?: Record<string, any>): Promise<any> {\r\n    // Fetch data from external API\r\n    // This would implement actual API calls\r\n    return [];\r\n  }\r\n\r\n  private extractKPIs(data: any[], config: WidgetConfig): Record<string, KPIValue> {\r\n    const kpis: Record<string, KPIValue> = {};\r\n\r\n    if (config.metric) {\r\n      kpis[config.metric] = {\r\n        name: config.metric,\r\n        value: this.calculateMetricValue(data, config),\r\n        unit: config.format || 'count',\r\n        trend: 'stable',\r\n        changePercent: 0,\r\n        status: 'good'\r\n      };\r\n    }\r\n\r\n    return kpis;\r\n  }\r\n\r\n  private calculateMetricValue(data: any[], config: WidgetConfig): number {\r\n    if (!data.length) return 0;\r\n\r\n    const field = config.groupBy?.[0] || 'value';\r\n    const values = data.map(item => item[field]).filter(v => typeof v === 'number');\r\n\r\n    switch (config.aggregation) {\r\n      case 'sum': return values.reduce((sum, val) => sum + val, 0);\r\n      case 'avg': return values.reduce((sum, val) => sum + val, 0) / values.length;\r\n      case 'count': return values.length;\r\n      case 'min': return Math.min(...values);\r\n      case 'max': return Math.max(...values);\r\n      default: return values[0] || 0;\r\n    }\r\n  }\r\n\r\n  private async generateInsights(data: any[], widget: DashboardWidgetInstance): Promise<Insight[]> {\r\n    // Generate insights based on widget data\r\n    // This would integrate with the insights engine\r\n    return [\r\n      {\r\n        id: this.generateId(),\r\n        type: 'trend',\r\n        title: 'Upward Trend Detected',\r\n        description: 'The data shows a positive trend over the selected period',\r\n        confidence: 0.85,\r\n        impact: 'medium',\r\n        data: { trend: 'up' },\r\n        actions: ['Investigate drivers', 'Consider scaling'],\r\n        createdAt: new Date()\r\n      }\r\n    ];\r\n  }\r\n\r\n  private generateDrillDowns(data: any[], config: WidgetConfig): DrillDown[] {\r\n    // Generate drill-down options based on data\r\n    return [\r\n      {\r\n        id: this.generateId(),\r\n        name: 'Detailed Breakdown',\r\n        description: 'View detailed breakdown by categories',\r\n        dimensions: config.groupBy || [],\r\n        metrics: [config.metric || 'value'],\r\n        chartType: config.chartType || 'bar'\r\n      }\r\n    ];\r\n  }\r\n\r\n  // Export Management\r\n  public async exportDashboard(instanceId: string, format: DashboardExport['format'], options: ExportOptions, userId: string): Promise<DashboardExport> {\r\n    const instance = this.instances.get(instanceId);\r\n    if (!instance) {\r\n      throw new Error('Dashboard instance not found');\r\n    }\r\n\r\n    // Check permissions\r\n    const hasPermission = await this.governance.checkPermission(\r\n      userId,\r\n      'dashboard:export',\r\n      instance.tenantId\r\n    );\r\n    if (!hasPermission) {\r\n      throw new Error('Insufficient permissions to export dashboard');\r\n    }\r\n\r\n    const exportJob: DashboardExport = {\r\n      id: this.generateId(),\r\n      dashboardId: instanceId,\r\n      tenantId: instance.tenantId,\r\n      format,\r\n      options,\r\n      status: 'pending',\r\n      requestedBy: userId,\r\n      createdAt: new Date()\r\n    };\r\n\r\n    this.exports.set(exportJob.id, exportJob);\r\n\r\n    // Start export process\r\n    this.processExport(exportJob);\r\n\r\n    // Audit log\r\n    await this.auditLog.logOperation('dashboard_export_requested', userId, {\r\n      exportId: exportJob.id,\r\n      dashboardId: instanceId,\r\n      format,\r\n      options\r\n    });\r\n\r\n    return exportJob;\r\n  }\r\n\r\n  private async processExport(exportJob: DashboardExport): Promise<void> {\r\n    try {\r\n      exportJob.status = 'processing';\r\n\r\n      const instance = this.instances.get(exportJob.dashboardId);\r\n      if (!instance) {\r\n        throw new Error('Dashboard instance not found');\r\n      }\r\n\r\n      // Generate export based on format\r\n      let exportData: Buffer;\r\n      let fileName: string;\r\n\r\n      switch (exportJob.format) {\r\n        case 'pdf':\r\n          exportData = await this.generatePDFExport(instance, exportJob.options);\r\n          fileName = `dashboard_${instance.name}_${Date.now()}.pdf`;\r\n          break;\r\n        case 'excel':\r\n          exportData = await this.generateExcelExport(instance, exportJob.options);\r\n          fileName = `dashboard_${instance.name}_${Date.now()}.xlsx`;\r\n          break;\r\n        case 'csv':\r\n          exportData = await this.generateCSVExport(instance, exportJob.options);\r\n          fileName = `dashboard_${instance.name}_${Date.now()}.csv`;\r\n          break;\r\n        case 'png':\r\n          exportData = await this.generatePNGExport(instance, exportJob.options);\r\n          fileName = `dashboard_${instance.name}_${Date.now()}.png`;\r\n          break;\r\n        case 'json':\r\n          exportData = await this.generateJSONExport(instance, exportJob.options);\r\n          fileName = `dashboard_${instance.name}_${Date.now()}.json`;\r\n          break;\r\n        default:\r\n          throw new Error(`Unsupported export format: ${exportJob.format}`);\r\n      }\r\n\r\n      // Store export file (in production, this would use cloud storage)\r\n      const downloadUrl = `/exports/${exportJob.id}/${fileName}`;\r\n      \r\n      exportJob.status = 'completed';\r\n      exportJob.completedAt = new Date();\r\n      exportJob.downloadUrl = downloadUrl;\r\n      exportJob.fileSize = exportData.length;\r\n\r\n      this.emit('export:completed', exportJob);\r\n      this.performanceMetrics.exportsGenerated++;\r\n\r\n    } catch (error) {\r\n      exportJob.status = 'failed';\r\n      exportJob.error = error instanceof Error ? error.message : 'Unknown error';\r\n    }\r\n  }\r\n\r\n  private async generatePDFExport(instance: DashboardInstance, options: ExportOptions): Promise<Buffer> {\r\n    // Generate PDF export\r\n    // This would use a PDF generation library\r\n    return Buffer.from('PDF export data');\r\n  }\r\n\r\n  private async generateExcelExport(instance: DashboardInstance, options: ExportOptions): Promise<Buffer> {\r\n    // Generate Excel export\r\n    // This would use an Excel generation library\r\n    return Buffer.from('Excel export data');\r\n  }\r\n\r\n  private async generateCSVExport(instance: DashboardInstance, options: ExportOptions): Promise<Buffer> {\r\n    // Generate CSV export\r\n    const csvData = this.convertToCSV(instance, options);\r\n    return Buffer.from(csvData);\r\n  }\r\n\r\n  private async generatePNGExport(instance: DashboardInstance, options: ExportOptions): Promise<Buffer> {\r\n    // Generate PNG export\r\n    // This would use a screenshot/chart generation library\r\n    return Buffer.from('PNG export data');\r\n  }\r\n\r\n  private async generateJSONExport(instance: DashboardInstance, options: ExportOptions): Promise<Buffer> {\r\n    // Generate JSON export\r\n    const jsonData = this.convertToJSON(instance, options);\r\n    return Buffer.from(JSON.stringify(jsonData, null, 2));\r\n  }\r\n\r\n  private convertToCSV(instance: DashboardInstance, options: ExportOptions): string {\r\n    // Convert dashboard data to CSV format\r\n    const rows: string[] = [];\r\n    \r\n    // Add headers\r\n    rows.push('Widget,Type,Data');\r\n    \r\n    // Add widget data\r\n    for (const widget of instance.widgets) {\r\n      const widgetData = this.widgetData.get(widget.id);\r\n      if (widgetData && widgetData.data) {\r\n        rows.push(`\"${widget.title}\",${widget.type},${JSON.stringify(widgetData.data)}`);\r\n      }\r\n    }\r\n    \r\n    return rows.join('\\n');\r\n  }\r\n\r\n  private convertToJSON(instance: DashboardInstance, options: ExportOptions): any {\r\n    // Convert dashboard data to JSON format\r\n    const dashboardData: any = {\r\n      dashboard: {\r\n        id: instance.id,\r\n        name: instance.name,\r\n        description: instance.description,\r\n        exportedAt: new Date().toISOString()\r\n      },\r\n      widgets: []\r\n    };\r\n\r\n    for (const widget of instance.widgets) {\r\n      const widgetData = this.widgetData.get(widget.id);\r\n      dashboardData.widgets.push({\r\n        id: widget.id,\r\n        title: widget.title,\r\n        type: widget.type,\r\n        data: widgetData?.data || null,\r\n        metadata: widgetData?.metadata || {}\r\n      });\r\n    }\r\n\r\n    return dashboardData;\r\n  }\r\n\r\n  // Subscription Management\r\n  public async createSubscription(subscription: Omit<DashboardSubscription, 'id' | 'createdAt' | 'updatedAt'>): Promise<DashboardSubscription> {\r\n    const dashboardSubscription: DashboardSubscription = {\r\n      ...subscription,\r\n      id: this.generateId(),\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    this.subscriptions.set(dashboardSubscription.id, dashboardSubscription);\r\n    this.performanceMetrics.activeSubscriptions++;\r\n\r\n    // Audit log\r\n    await this.auditLog.logOperation('dashboard_subscription_created', subscription.userId, {\r\n      subscriptionId: dashboardSubscription.id,\r\n      dashboardId: subscription.dashboardId,\r\n      type: subscription.type\r\n    });\r\n\r\n    return dashboardSubscription;\r\n  }\r\n\r\n  // Activity Logging\r\n  private async logActivity(dashboardId: string, tenantId: string, userId: string, action: DashboardActivity['action'], details: Record<string, any>): Promise<void> {\r\n    const activity: DashboardActivity = {\r\n      id: this.generateId(),\r\n      dashboardId,\r\n      tenantId,\r\n      userId,\r\n      action,\r\n      details,\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.activities.set(activity.id, activity);\r\n  }\r\n\r\n  // Event Handlers\r\n  private async handleDashboardViewed(instance: DashboardInstance, userId: string): Promise<void> {\r\n    this.performanceMetrics.dashboardsViewed++;\r\n    await this.logActivity(instance.id, instance.tenantId, userId, 'viewed', {});\r\n  }\r\n\r\n  private async handleWidgetRefresh(widget: DashboardWidgetInstance, data: WidgetData): Promise<void> {\r\n    // Update performance metrics\r\n    const refreshTime = data.metadata.refreshTime;\r\n    const totalRefreshes = this.performanceMetrics.widgetsRefreshed;\r\n    const avgTime = this.performanceMetrics.averageLoadTime;\r\n    this.performanceMetrics.averageLoadTime = (avgTime * (totalRefreshes - 1) + refreshTime) / totalRefreshes;\r\n  }\r\n\r\n  private async handleDashboardShared(instance: DashboardInstance, userId: string): Promise<void> {\r\n    await this.logActivity(instance.id, instance.tenantId, userId, 'shared', {});\r\n  }\r\n\r\n  private async handleExportCompleted(exportJob: DashboardExport): Promise<void> {\r\n    await this.logActivity(exportJob.dashboardId, exportJob.tenantId, exportJob.requestedBy, 'exported', {\r\n      format: exportJob.format,\r\n      fileSize: exportJob.fileSize\r\n    });\r\n  }\r\n\r\n  // Schedulers and Background Tasks\r\n  private startDataRefreshScheduler(): void {\r\n    setInterval(() => {\r\n      this.refreshAllWidgets();\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  private async refreshAllWidgets(): Promise<void> {\r\n    const now = Date.now();\r\n    \r\n    for (const widget of this.widgets.values()) {\r\n      if (widget.enabled && \r\n          (!widget.lastRefresh || now - widget.lastRefresh.getTime() > widget.refreshInterval)) {\r\n        await this.refreshWidgetData(widget);\r\n      }\r\n    }\r\n  }\r\n\r\n  private initializeDefaultTemplates(): void {\r\n    // Create default dashboard templates\r\n    this.createExecutiveDashboardTemplate();\r\n    this.createFinancialDashboardTemplate();\r\n    this.createOperationalDashboardTemplate();\r\n  }\r\n\r\n  private async createExecutiveDashboardTemplate(): Promise<void> {\r\n    const template: DashboardTemplate = {\r\n      id: this.generateId(),\r\n      name: 'Executive Overview',\r\n      description: 'High-level executive dashboard with key business metrics',\r\n      category: 'executive',\r\n      layout: {\r\n        type: 'grid',\r\n        columns: 12,\r\n        rows: 8,\r\n        gap: 16\r\n      },\r\n      widgets: [\r\n        {\r\n          id: this.generateId(),\r\n          type: 'kpi',\r\n          title: 'Total Revenue',\r\n          position: { x: 0, y: 0, width: 3, height: 2 },\r\n          config: {\r\n            metric: 'totalRevenue',\r\n            format: 'currency',\r\n            refreshInterval: 300000\r\n          },\r\n          dataSource: {\r\n            type: 'metric',\r\n            source: 'totalRevenue'\r\n          },\r\n          permissions: { view: [], edit: [] },\r\n          required: true\r\n        },\r\n        {\r\n          id: this.generateId(),\r\n          type: 'chart',\r\n          title: 'Revenue Trend',\r\n          position: { x: 3, y: 0, width: 6, height: 2 },\r\n          config: {\r\n            chartType: 'line',\r\n            timeRange: '30d',\r\n            refreshInterval: 300000\r\n          },\r\n          dataSource: {\r\n            type: 'query',\r\n            source: 'revenue_trend_query'\r\n          },\r\n          permissions: { view: [], edit: [] },\r\n          required: true\r\n        }\r\n      ],\r\n      filters: [\r\n        {\r\n          id: this.generateId(),\r\n          name: 'Date Range',\r\n          type: 'date',\r\n          field: 'date',\r\n          label: 'Date Range',\r\n          required: false\r\n        }\r\n      ],\r\n      isPublic: true,\r\n      requiredPermissions: ['dashboard:view'],\r\n      createdBy: 'system',\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    this.templates.set(template.id, template);\r\n  }\r\n\r\n  private async createFinancialDashboardTemplate(): Promise<void> {\r\n    // Similar implementation for financial dashboard\r\n  }\r\n\r\n  private async createOperationalDashboardTemplate(): Promise<void> {\r\n    // Similar implementation for operational dashboard\r\n  }\r\n\r\n  // Helper Methods\r\n  private generateId(): string {\r\n    return `dashboard_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  // Public API Methods\r\n  public async getInstances(tenantId: string, userId: string): Promise<DashboardInstance[]> {\r\n    // Check permissions\r\n    const hasPermission = await this.governance.checkPermission(\r\n      userId,\r\n      'dashboard:view',\r\n      tenantId\r\n    );\r\n    if (!hasPermission) {\r\n      throw new Error('Insufficient permissions to view dashboard instances');\r\n    }\r\n\r\n    return Array.from(this.instances.values())\r\n      .filter(i => i.tenantId === tenantId)\r\n      .filter(i => i.isPublic || i.permissions.view.includes(userId));\r\n  }\r\n\r\n  public async getWidgetData(widgetId: string, userId: string): Promise<WidgetData | null> {\r\n    const widget = this.widgets.get(widgetId);\r\n    if (!widget) return null;\r\n\r\n    const instance = this.instances.get(widget.instanceId);\r\n    if (!instance) return null;\r\n\r\n    // Check permissions\r\n    const hasPermission = await this.governance.checkPermission(\r\n      userId,\r\n      'dashboard:view',\r\n      instance.tenantId\r\n    );\r\n    if (!hasPermission && !instance.permissions.view.includes(userId)) {\r\n      throw new Error('Insufficient permissions to view widget data');\r\n    }\r\n\r\n    return this.widgetData.get(widgetId) || null;\r\n  }\r\n\r\n  public getPerformanceMetrics() {\r\n    return { ...this.performanceMetrics };\r\n  }\r\n\r\n  public async getExport(exportId: string, userId: string): Promise<DashboardExport | null> {\r\n    const exportJob = this.exports.get(exportId);\r\n    if (!exportJob) return null;\r\n\r\n    // Check permissions\r\n    const hasPermission = await this.governance.checkPermission(\r\n      userId,\r\n      'dashboard:export',\r\n      exportJob.tenantId\r\n    );\r\n    if (!hasPermission && exportJob.requestedBy !== userId) {\r\n      throw new Error('Insufficient permissions to view export job');\r\n    }\r\n\r\n    return exportJob;\r\n  }\r\n}\r\n\r\nexport default DashboardBackend;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\analytics\\data-ingestion.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":728,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":728,"endColumn":45},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":729,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":729,"endColumn":55},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":1000,"column":18,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":1000,"endColumn":38}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from 'events';\r\nimport { createHash, createHmac } from 'crypto';\r\nimport { Readable, Transform } from 'stream';\r\nimport { ImmutableAuditLogger } from '../compliance/immutable-audit-log';\r\nimport { GovernanceModelManager } from '../governance/governance-model';\r\nimport { UsageMeter } from '../monetization/usage-meter';\r\nimport { BillingEngine } from '../monetization/billing-engine';\r\nimport { GrowthEngine } from '../monetization/growth-engine';\r\nimport { RetentionAutomationEngine } from '../monetization/retention-automation';\r\n\r\nexport interface DataSource {\r\n  id: string;\r\n  name: string;\r\n  type: 'DATABASE' | 'EVENT_STREAM' | 'FILE' | 'API' | 'AUDIT_LOG';\r\n  tenantId?: string;\r\n  connectionConfig: ConnectionConfig;\r\n  schema: DataSchema;\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  isActive: boolean;\r\n  lastIngested?: Date;\r\n  metadata: { [key: string]: any };\r\n}\r\n\r\nexport interface ConnectionConfig {\r\n  host?: string;\r\n  port?: number;\r\n  database?: string;\r\n  credentials?: {\r\n    username: string;\r\n    password: string;\r\n    apiKey?: string;\r\n  };\r\n  options: { [key: string]: any };\r\n  encryptionKey?: string;\r\n}\r\n\r\nexport interface DataSchema {\r\n  fields: SchemaField[];\r\n  primaryKey: string;\r\n  tenantField: string;\r\n  timestampField: string;\r\n  indexes: string[];\r\n  encryption: EncryptionConfig;\r\n}\r\n\r\nexport interface SchemaField {\r\n  name: string;\r\n  type: 'STRING' | 'NUMBER' | 'DATE' | 'BOOLEAN' | 'JSON' | 'BINARY';\r\n  required: boolean;\r\n  encrypted: boolean;\r\n  pii: boolean;\r\n  validation?: ValidationRule[];\r\n}\r\n\r\nexport interface ValidationRule {\r\n  type: 'REGEX' | 'RANGE' | 'ENUM' | 'CUSTOM';\r\n  rule: string;\r\n  errorMessage: string;\r\n}\r\n\r\nexport interface EncryptionConfig {\r\n  enabled: boolean;\r\n  algorithm: string;\r\n  keyId: string;\r\n  fields: string[];\r\n}\r\n\r\nexport interface IngestionJob {\r\n  id: string;\r\n  name: string;\r\n  sourceId: string;\r\n  tenantId?: string;\r\n  type: 'REAL_TIME' | 'BATCH' | 'SCHEDULED';\r\n  status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'PAUSED';\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  config: IngestionConfig;\r\n  schedule?: ScheduleConfig;\r\n  progress: JobProgress;\r\n  metrics: JobMetrics;\r\n  createdAt: Date;\r\n  startedAt?: Date;\r\n  completedAt?: Date;\r\n  lastRun?: Date;\r\n  nextRun?: Date;\r\n  errorCount: number;\r\n  lastError?: string;\r\n}\r\n\r\nexport interface IngestionConfig {\r\n  batchSize: number;\r\n  maxRetries: number;\r\n  retryDelay: number;\r\n  timeout: number;\r\n  validation: ValidationConfig;\r\n  transformation: TransformationConfig;\r\n  enrichment: EnrichmentConfig;\r\n  deduplication: DeduplicationConfig;\r\n  quality: QualityConfig;\r\n}\r\n\r\nexport interface ValidationConfig {\r\n  enabled: boolean;\r\n  strictMode: boolean;\r\n  customRules: ValidationRule[];\r\n  errorHandling: 'FAIL' | 'SKIP' | 'QUARANTINE';\r\n  quarantineThreshold: number;\r\n}\r\n\r\nexport interface TransformationConfig {\r\n  enabled: boolean;\r\n  mappings: FieldMapping[];\r\n  aggregations: AggregationRule[];\r\n  calculations: CalculationRule[];\r\n  filters: FilterRule[];\r\n}\r\n\r\nexport interface FieldMapping {\r\n  source: string;\r\n  target: string;\r\n  transform?: string;\r\n  defaultValue?: any;\r\n}\r\n\r\nexport interface AggregationRule {\r\n  name: string;\r\n  groupBy: string[];\r\n  aggregations: { field: string; function: 'SUM' | 'AVG' | 'COUNT' | 'MAX' | 'MIN' }[];\r\n  window?: string;\r\n}\r\n\r\nexport interface CalculationRule {\r\n  name: string;\r\n  expression: string;\r\n  dependencies: string[];\r\n}\r\n\r\nexport interface FilterRule {\r\n  field: string;\r\n  operator: 'EQUALS' | 'NOT_EQUALS' | 'GREATER_THAN' | 'LESS_THAN' | 'CONTAINS';\r\n  value: any;\r\n}\r\n\r\nexport interface EnrichmentConfig {\r\n  enabled: boolean;\r\n  sources: EnrichmentSource[];\r\n  lookups: LookupRule[];\r\n  joins: JoinRule[];\r\n}\r\n\r\nexport interface EnrichmentSource {\r\n  id: string;\r\n  type: 'DATABASE' | 'API' | 'CACHE';\r\n  config: ConnectionConfig;\r\n  cacheTtl: number;\r\n}\r\n\r\nexport interface LookupRule {\r\n  name: string;\r\n  sourceField: string;\r\n  targetField: string;\r\n  sourceId: string;\r\n  lookupKey: string;\r\n  defaultValue?: any;\r\n}\r\n\r\nexport interface JoinRule {\r\n  name: string;\r\n  leftField: string;\r\n  rightField: string;\r\n  sourceId: string;\r\n  joinType: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL';\r\n}\r\n\r\nexport interface DeduplicationConfig {\r\n  enabled: boolean;\r\n  strategy: 'PRIMARY_KEY' | 'HASH' | 'FINGERPRINT' | 'CUSTOM';\r\n  keyFields: string[];\r\n  windowSize: number;\r\n  action: 'SKIP' | 'UPDATE' | 'MERGE';\r\n}\r\n\r\nexport interface QualityConfig {\r\n  enabled: boolean;\r\n  completeness: QualityRule;\r\n  accuracy: QualityRule;\r\n  consistency: QualityRule;\r\n  timeliness: QualityRule;\r\n}\r\n\r\nexport interface QualityRule {\r\n  threshold: number;\r\n  action: 'WARN' | 'FAIL' | 'QUARANTINE';\r\n  rules: string[];\r\n}\r\n\r\nexport interface ScheduleConfig {\r\n  type: 'INTERVAL' | 'CRON' | 'EVENT';\r\n  expression: string;\r\n  timezone: string;\r\n  enabled: boolean;\r\n}\r\n\r\nexport interface JobProgress {\r\n  totalRecords: number;\r\n  processedRecords: number;\r\n  successfulRecords: number;\r\n  failedRecords: number;\r\n  quarantinedRecords: number;\r\n  percentage: number;\r\n  currentBatch: number;\r\n  totalBatches: number;\r\n}\r\n\r\nexport interface JobMetrics {\r\n  recordsPerSecond: number;\r\n  averageLatency: number;\r\n  errorRate: number;\r\n  qualityScore: number;\r\n  memoryUsage: number;\r\n  cpuUsage: number;\r\n  networkIO: number;\r\n  diskIO: number;\r\n}\r\n\r\nexport interface DataRecord {\r\n  id: string;\r\n  tenantId: string;\r\n  sourceId: string;\r\n  jobId: string;\r\n  data: { [key: string]: any };\r\n  metadata: RecordMetadata;\r\n  hash: string;\r\n  previousHash?: string;\r\n  timestamp: Date;\r\n  ingestedAt: Date;\r\n  quality: QualityMetrics;\r\n}\r\n\r\nexport interface RecordMetadata {\r\n  version: number;\r\n  source: string;\r\n  checksum: string;\r\n  encrypted: boolean;\r\n  piiFields: string[];\r\n  classification: 'PUBLIC' | 'INTERNAL' | 'CONFIDENTIAL' | 'RESTRICTED';\r\n  retention: number;\r\n  legalHold: boolean;\r\n}\r\n\r\nexport interface QualityMetrics {\r\n  completeness: number;\r\n  accuracy: number;\r\n  consistency: number;\r\n  timeliness: number;\r\n  overall: number;\r\n  issues: QualityIssue[];\r\n}\r\n\r\nexport interface QualityIssue {\r\n  type: 'MISSING' | 'INVALID' | 'INCONSISTENT' | 'LATE' | 'DUPLICATE';\r\n  field: string;\r\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  message: string;\r\n  value: any;\r\n}\r\n\r\nexport interface IngestionQueue {\r\n  id: string;\r\n  name: string;\r\n  type: 'FIFO' | 'PRIORITY' | 'DELAYED';\r\n  maxSize: number;\r\n  currentSize: number;\r\n  processingRate: number;\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  tenantIsolation: boolean;\r\n  encryptionEnabled: boolean;\r\n  deadLetterQueue: string;\r\n}\r\n\r\nexport class DataIngestionEngine extends EventEmitter {\r\n  private static instance: DataIngestionEngine;\r\n  private auditLog: ImmutableAuditLogger;\r\n  private governance: GovernanceModelManager;\r\n  private sources: Map<string, DataSource> = new Map();\r\n  private jobs: Map<string, IngestionJob> = new Map();\r\n  private queues: Map<string, IngestionQueue> = new Map();\r\n  private processingJobs: Map<string, Promise<void>> = new Map();\r\n  private hashChains: Map<string, string[]> = new Map();\r\n  private isRunning: boolean = false;\r\n\r\n  private constructor() {\r\n    super();\r\n    this.auditLog = new ImmutableAuditLogger();\r\n    this.governance = GovernanceModelManager.getInstance();\r\n    this.initializeDefaultQueues();\r\n    this.startEventLoop();\r\n  }\r\n\r\n  public static getInstance(): DataIngestionEngine {\r\n    if (!DataIngestionEngine.instance) {\r\n      DataIngestionEngine.instance = new DataIngestionEngine();\r\n    }\r\n    return DataIngestionEngine.instance;\r\n  }\r\n\r\n  private initializeDefaultQueues(): void {\r\n    const queues: IngestionQueue[] = [\r\n      {\r\n        id: 'critical_queue',\r\n        name: 'Critical Data Queue',\r\n        type: 'PRIORITY',\r\n        maxSize: 10000,\r\n        currentSize: 0,\r\n        processingRate: 1000,\r\n        priority: 'CRITICAL',\r\n        tenantIsolation: true,\r\n        encryptionEnabled: true,\r\n        deadLetterQueue: 'critical_dlq'\r\n      },\r\n      {\r\n        id: 'high_priority_queue',\r\n        name: 'High Priority Queue',\r\n        type: 'PRIORITY',\r\n        maxSize: 50000,\r\n        currentSize: 0,\r\n        processingRate: 500,\r\n        priority: 'HIGH',\r\n        tenantIsolation: true,\r\n        encryptionEnabled: true,\r\n        deadLetterQueue: 'high_priority_dlq'\r\n      },\r\n      {\r\n        id: 'standard_queue',\r\n        name: 'Standard Queue',\r\n        type: 'FIFO',\r\n        maxSize: 100000,\r\n        currentSize: 0,\r\n        processingRate: 200,\r\n        priority: 'MEDIUM',\r\n        tenantIsolation: true,\r\n        encryptionEnabled: true,\r\n        deadLetterQueue: 'standard_dlq'\r\n      },\r\n      {\r\n        id: 'batch_queue',\r\n        name: 'Batch Queue',\r\n        type: 'DELAYED',\r\n        maxSize: 50000,\r\n        currentSize: 0,\r\n        processingRate: 100,\r\n        priority: 'LOW',\r\n        tenantIsolation: true,\r\n        encryptionEnabled: true,\r\n        deadLetterQueue: 'batch_dlq'\r\n      }\r\n    ];\r\n\r\n    queues.forEach(queue => {\r\n      this.queues.set(queue.id, queue);\r\n    });\r\n  }\r\n\r\n  private startEventLoop(): void {\r\n    this.isRunning = true;\r\n    setInterval(() => {\r\n      this.processQueues();\r\n      this.cleanupCompletedJobs();\r\n      this.updateMetrics();\r\n    }, 1000);\r\n  }\r\n\r\n  public async registerDataSource(source: DataSource): Promise<void> {\r\n    try {\r\n      // Validate source configuration\r\n      await this.validateDataSource(source);\r\n\r\n      // Test connection\r\n      await this.testConnection(source);\r\n\r\n      // Register source\r\n      this.sources.set(source.id, source);\r\n\r\n      // Log registration\r\n      await this.auditLog.logOperation({\r\n        tenantId: source.tenantId || 'SYSTEM',\r\n        userId: 'SYSTEM',\r\n        action: 'REGISTER_DATA_SOURCE',\r\n        details: {\r\n          sourceId: source.id,\r\n          sourceName: source.name,\r\n          sourceType: source.type,\r\n          tenantId: source.tenantId\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DATA_INGESTION_ENGINE',\r\n        timestamp: new Date(),\r\n        category: 'DATA_INGESTION',\r\n        severity: 'INFO'\r\n      });\r\n\r\n      this.emit('sourceRegistered', source);\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId: source.tenantId || 'SYSTEM',\r\n        userId: 'SYSTEM',\r\n        action: 'REGISTER_DATA_SOURCE_ERROR',\r\n        details: {\r\n          sourceId: source.id,\r\n          error: (error as Error).message\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DATA_INGESTION_ENGINE',\r\n        timestamp: new Date(),\r\n        category: 'DATA_INGESTION',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async createIngestionJob(job: Omit<IngestionJob, 'id' | 'progress' | 'metrics' | 'createdAt' | 'errorCount'>): Promise<string> {\r\n    const jobId = this.generateJobId();\r\n    const ingestionJob: IngestionJob = {\r\n      ...job,\r\n      id: jobId,\r\n      progress: {\r\n        totalRecords: 0,\r\n        processedRecords: 0,\r\n        successfulRecords: 0,\r\n        failedRecords: 0,\r\n        quarantinedRecords: 0,\r\n        percentage: 0,\r\n        currentBatch: 0,\r\n        totalBatches: 0\r\n      },\r\n      metrics: {\r\n        recordsPerSecond: 0,\r\n        averageLatency: 0,\r\n        errorRate: 0,\r\n        qualityScore: 0,\r\n        memoryUsage: 0,\r\n        cpuUsage: 0,\r\n        networkIO: 0,\r\n        diskIO: 0\r\n      },\r\n      createdAt: new Date(),\r\n      errorCount: 0\r\n    };\r\n\r\n    this.jobs.set(jobId, ingestionJob);\r\n\r\n    // Schedule job if needed\r\n    if (job.schedule) {\r\n      this.scheduleJob(ingestionJob);\r\n    } else {\r\n      // Add to queue immediately\r\n      await this.queueJob(ingestionJob);\r\n    }\r\n\r\n    await this.auditLog.logOperation({\r\n      tenantId: job.tenantId || 'SYSTEM',\r\n      userId: 'SYSTEM',\r\n      action: 'CREATE_INGESTION_JOB',\r\n      details: {\r\n        jobId,\r\n        sourceId: job.sourceId,\r\n        jobType: job.type,\r\n        priority: job.priority\r\n      },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'DATA_INGESTION_ENGINE',\r\n      timestamp: new Date(),\r\n      category: 'DATA_INGESTION',\r\n      severity: 'INFO'\r\n    });\r\n\r\n    return jobId;\r\n  }\r\n\r\n  private async queueJob(job: IngestionJob): Promise<void> {\r\n    const queueId = this.getQueueId(job.priority);\r\n    const queue = this.queues.get(queueId);\r\n    \r\n    if (!queue) {\r\n      throw new Error(`Queue not found for priority: ${job.priority}`);\r\n    }\r\n\r\n    if (queue.currentSize >= queue.maxSize) {\r\n      throw new Error(`Queue ${queueId} is full`);\r\n    }\r\n\r\n    queue.currentSize++;\r\n    job.status = 'PENDING';\r\n    \r\n    this.emit('jobQueued', job);\r\n  }\r\n\r\n  private getQueueId(priority: IngestionJob['priority']): string {\r\n    switch (priority) {\r\n      case 'CRITICAL': return 'critical_queue';\r\n      case 'HIGH': return 'high_priority_queue';\r\n      case 'MEDIUM': return 'standard_queue';\r\n      case 'LOW': return 'batch_queue';\r\n      default: return 'standard_queue';\r\n    }\r\n  }\r\n\r\n  private async processQueues(): Promise<void> {\r\n    if (!this.isRunning) return;\r\n\r\n    // Process queues in priority order\r\n    const queueOrder = ['critical_queue', 'high_priority_queue', 'standard_queue', 'batch_queue'];\r\n    \r\n    for (const queueId of queueOrder) {\r\n      const queue = this.queues.get(queueId);\r\n      if (!queue || queue.currentSize === 0) continue;\r\n\r\n      // Get next job from queue\r\n      const job = await this.getNextJob(queueId);\r\n      if (!job) continue;\r\n\r\n      // Start processing job\r\n      await this.startJob(job);\r\n    }\r\n  }\r\n\r\n  private async getNextJob(queueId: string): Promise<IngestionJob | null> {\r\n    // Find next pending job for this queue\r\n    for (const job of this.jobs.values()) {\r\n      if (job.status === 'PENDING' && this.getQueueId(job.priority) === queueId) {\r\n        return job;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private async startJob(job: IngestionJob): Promise<void> {\r\n    if (this.processingJobs.has(job.id)) {\r\n      return; // Already processing\r\n    }\r\n\r\n    job.status = 'RUNNING';\r\n    job.startedAt = new Date();\r\n    job.lastRun = new Date();\r\n\r\n    const processingPromise = this.processJob(job);\r\n    this.processingJobs.set(job.id, processingPromise);\r\n\r\n    processingPromise\r\n      .then(() => {\r\n        this.processingJobs.delete(job.id);\r\n        this.emit('jobCompleted', job);\r\n      })\r\n      .catch((error) => {\r\n        this.processingJobs.delete(job.id);\r\n        this.handleJobError(job, error);\r\n      });\r\n\r\n    await this.auditLog.logOperation({\r\n      tenantId: job.tenantId || 'SYSTEM',\r\n      userId: 'SYSTEM',\r\n      action: 'START_INGESTION_JOB',\r\n      details: {\r\n        jobId: job.id,\r\n        sourceId: job.sourceId\r\n      },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'DATA_INGESTION_ENGINE',\r\n      timestamp: new Date(),\r\n      category: 'DATA_INGESTION',\r\n      severity: 'INFO'\r\n    });\r\n  }\r\n\r\n  private async processJob(job: IngestionJob): Promise<void> {\r\n    const source = this.sources.get(job.sourceId);\r\n    if (!source) {\r\n      throw new Error(`Source not found: ${job.sourceId}`);\r\n    }\r\n\r\n    // Get data from source\r\n    const dataStream = await this.getDataFromSource(source, job);\r\n    \r\n    // Process data stream\r\n    const processedStream = this.createProcessingStream(job);\r\n    \r\n    // Pipe data through processing pipeline\r\n    dataStream.pipe(processedStream);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      processedStream.on('finish', () => {\r\n        job.status = 'COMPLETED';\r\n        job.completedAt = new Date();\r\n        resolve();\r\n      });\r\n\r\n      processedStream.on('error', (error) => {\r\n        job.status = 'FAILED';\r\n        job.lastError = error.message;\r\n        job.errorCount++;\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n\r\n  private async getDataFromSource(source: DataSource, job: IngestionJob): Promise<Readable> {\r\n    switch (source.type) {\r\n      case 'DATABASE':\r\n        return this.getDatabaseData(source, job);\r\n      case 'EVENT_STREAM':\r\n        return this.getEventData(source, job);\r\n      case 'FILE':\r\n        return this.getFileData(source, job);\r\n      case 'API':\r\n        return this.getApiData(source, job);\r\n      case 'AUDIT_LOG':\r\n        return this.getAuditData(source, job);\r\n      default:\r\n        throw new Error(`Unsupported source type: ${source.type}`);\r\n    }\r\n  }\r\n\r\n  private createProcessingStream(job: IngestionJob): Transform {\r\n    return new Transform({\r\n      objectMode: true,\r\n      transform: async (chunk, encoding, callback) => {\r\n        try {\r\n          const processedRecord = await this.processRecord(chunk, job);\r\n          callback(null, processedRecord);\r\n        } catch (error) {\r\n          callback(error as Error);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private async processRecord(record: any, job: IngestionJob): Promise<DataRecord> {\r\n    // Extract tenant ID\r\n    const tenantId = record[job.config.transformation.mappings.find(m => m.target === 'tenantId')?.source || 'tenantId'] || job.tenantId;\r\n\r\n    // Validate record\r\n    const validationResult = await this.validateRecord(record, job);\r\n    if (!validationResult.valid && job.config.validation.errorHandling === 'FAIL') {\r\n      throw new Error(`Record validation failed: ${validationResult.errors.join(', ')}`);\r\n    }\r\n\r\n    // Transform record\r\n    const transformedRecord = await this.transformRecord(record, job);\r\n\r\n    // Enrich record\r\n    const enrichedRecord = await this.enrichRecord(transformedRecord, job);\r\n\r\n    // Check for duplicates\r\n    const isDuplicate = await this.checkDuplicate(enrichedRecord, job);\r\n    if (isDuplicate && job.config.deduplication.action === 'SKIP') {\r\n      return null as any; // Skip duplicate\r\n    }\r\n\r\n    // Calculate quality metrics\r\n    const quality = await this.calculateQuality(enrichedRecord, job);\r\n\r\n    // Create final record\r\n    const dataRecord: DataRecord = {\r\n      id: this.generateRecordId(),\r\n      tenantId,\r\n      sourceId: job.sourceId,\r\n      jobId: job.id,\r\n      data: enrichedRecord,\r\n      metadata: {\r\n        version: 1,\r\n        source: job.sourceId,\r\n        checksum: this.calculateChecksum(enrichedRecord),\r\n        encrypted: false,\r\n        piiFields: this.identifyPIIFields(enrichedRecord),\r\n        classification: 'INTERNAL',\r\n        retention: 2555, // 7 years default\r\n        legalHold: false\r\n      },\r\n      hash: this.calculateRecordHash(enrichedRecord),\r\n      timestamp: new Date(),\r\n      ingestedAt: new Date(),\r\n      quality\r\n    };\r\n\r\n    // Add to hash chain\r\n    await this.addToHashChain(dataRecord);\r\n\r\n    // Update job progress\r\n    job.progress.processedRecords++;\r\n    job.progress.successfulRecords++;\r\n    job.progress.percentage = (job.progress.processedRecords / job.progress.totalRecords) * 100;\r\n\r\n    return dataRecord;\r\n  }\r\n\r\n  private async validateRecord(record: any, job: IngestionJob): Promise<{ valid: boolean; errors: string[] }> {\r\n    const errors: string[] = [];\r\n\r\n    if (job.config.validation.enabled) {\r\n      // Apply validation rules\r\n      for (const rule of job.config.validation.customRules) {\r\n        const result = await this.applyValidationRule(record, rule);\r\n        if (!result.valid) {\r\n          errors.push(result.error);\r\n        }\r\n      }\r\n\r\n      // Schema validation\r\n      const source = this.sources.get(job.sourceId);\r\n      if (source) {\r\n        for (const field of source.schema.fields) {\r\n          if (field.required && record[field.name] === undefined) {\r\n            errors.push(`Required field missing: ${field.name}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors\r\n    };\r\n  }\r\n\r\n  private async applyValidationRule(record: any, rule: ValidationRule): Promise<{ valid: boolean; error: string }> {\r\n    switch (rule.type) {\r\n      case 'REGEX':\r\n        const regex = new RegExp(rule.rule);\r\n        const value = record[rule.rule.split(':')[0]];\r\n        return {\r\n          valid: regex.test(value),\r\n          error: rule.errorMessage\r\n        };\r\n      case 'RANGE':\r\n        // Implementation for range validation\r\n        return { valid: true, error: '' };\r\n      case 'ENUM':\r\n        // Implementation for enum validation\r\n        return { valid: true, error: '' };\r\n      case 'CUSTOM':\r\n        // Implementation for custom validation\r\n        return { valid: true, error: '' };\r\n      default:\r\n        return { valid: true, error: '' };\r\n    }\r\n  }\r\n\r\n  private async transformRecord(record: any, job: IngestionJob): Promise<any> {\r\n    let transformed = { ...record };\r\n\r\n    if (job.config.transformation.enabled) {\r\n      // Apply field mappings\r\n      for (const mapping of job.config.transformation.mappings) {\r\n        const sourceValue = record[mapping.source];\r\n        if (sourceValue !== undefined) {\r\n          transformed[mapping.target] = mapping.transform ? \r\n            this.applyTransform(sourceValue, mapping.transform) : \r\n            sourceValue;\r\n        } else if (mapping.defaultValue !== undefined) {\r\n          transformed[mapping.target] = mapping.defaultValue;\r\n        }\r\n      }\r\n\r\n      // Apply filters\r\n      for (const filter of job.config.transformation.filters) {\r\n        transformed = this.applyFilter(transformed, filter);\r\n      }\r\n\r\n      // Apply calculations\r\n      for (const calc of job.config.transformation.calculations) {\r\n        transformed[calc.name] = this.calculateValue(transformed, calc.expression);\r\n      }\r\n    }\r\n\r\n    return transformed;\r\n  }\r\n\r\n  private applyTransform(value: any, transform: string): any {\r\n    // Simple transform implementation\r\n    switch (transform) {\r\n      case 'UPPERCASE':\r\n        return String(value).toUpperCase();\r\n      case 'LOWERCASE':\r\n        return String(value).toLowerCase();\r\n      case 'TRIM':\r\n        return String(value).trim();\r\n      case 'TO_NUMBER':\r\n        return Number(value);\r\n      case 'TO_DATE':\r\n        return new Date(value);\r\n      default:\r\n        return value;\r\n    }\r\n  }\r\n\r\n  private applyFilter(record: any, filter: FilterRule): any {\r\n    const fieldValue = record[filter.field];\r\n    let matches = false;\r\n\r\n    switch (filter.operator) {\r\n      case 'EQUALS':\r\n        matches = fieldValue === filter.value;\r\n        break;\r\n      case 'NOT_EQUALS':\r\n        matches = fieldValue !== filter.value;\r\n        break;\r\n      case 'GREATER_THAN':\r\n        matches = fieldValue > filter.value;\r\n        break;\r\n      case 'LESS_THAN':\r\n        matches = fieldValue < filter.value;\r\n        break;\r\n      case 'CONTAINS':\r\n        matches = String(fieldValue).includes(String(filter.value));\r\n        break;\r\n    }\r\n\r\n    return matches ? record : null;\r\n  }\r\n\r\n  private calculateValue(record: any, expression: string): any {\r\n    // Simple expression evaluation\r\n    // In production, use a proper expression parser\r\n    try {\r\n      const context = { ...record };\r\n      const func = new Function(...Object.keys(context), `return ${expression}`);\r\n      return func(...Object.values(context));\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private async enrichRecord(record: any, job: IngestionJob): Promise<any> {\r\n    let enriched = { ...record };\r\n\r\n    if (job.config.enrichment.enabled) {\r\n      // Apply lookups\r\n      for (const lookup of job.config.enrichment.lookups) {\r\n        const lookupValue = await this.performLookup(record, lookup);\r\n        if (lookupValue !== null) {\r\n          enriched[lookup.targetField] = lookupValue;\r\n        }\r\n      }\r\n\r\n      // Apply joins\r\n      for (const join of job.config.enrichment.joins) {\r\n        const joinedData = await this.performJoin(record, join);\r\n        if (joinedData) {\r\n          enriched = { ...enriched, ...joinedData };\r\n        }\r\n      }\r\n    }\r\n\r\n    return enriched;\r\n  }\r\n\r\n  private async performLookup(record: any, lookup: LookupRule): Promise<any> {\r\n    // Simplified lookup implementation\r\n    // In production, implement proper lookup logic\r\n    return null;\r\n  }\r\n\r\n  private async performJoin(record: any, join: JoinRule): Promise<any> {\r\n    // Simplified join implementation\r\n    // In production, implement proper join logic\r\n    return null;\r\n  }\r\n\r\n  private async checkDuplicate(record: any, job: IngestionJob): Promise<boolean> {\r\n    if (!job.config.deduplication.enabled) {\r\n      return false;\r\n    }\r\n\r\n    const hash = this.calculateRecordHash(record);\r\n    const key = job.config.deduplication.keyFields.map(field => record[field]).join('|');\r\n\r\n    // Check if hash or key already exists\r\n    // In production, query actual storage\r\n    return false; // Simplified\r\n  }\r\n\r\n  private async calculateQuality(record: any, job: IngestionJob): Promise<QualityMetrics> {\r\n    const quality: QualityMetrics = {\r\n      completeness: 0,\r\n      accuracy: 0,\r\n      consistency: 0,\r\n      timeliness: 0,\r\n      overall: 0,\r\n      issues: []\r\n    };\r\n\r\n    if (job.config.quality.enabled) {\r\n      // Calculate completeness\r\n      const totalFields = Object.keys(record).length;\r\n      const nonNullFields = Object.values(record).filter(v => v !== null && v !== undefined).length;\r\n      quality.completeness = (nonNullFields / totalFields) * 100;\r\n\r\n      // Calculate accuracy (simplified)\r\n      quality.accuracy = 95; // Placeholder\r\n\r\n      // Calculate consistency (simplified)\r\n      quality.consistency = 90; // Placeholder\r\n\r\n      // Calculate timeliness\r\n      const recordAge = Date.now() - new Date(record.timestamp || Date.now()).getTime();\r\n      const maxAge = 24 * 60 * 60 * 1000; // 24 hours\r\n      quality.timeliness = Math.max(0, 100 - (recordAge / maxAge) * 100);\r\n\r\n      // Calculate overall quality\r\n      quality.overall = (quality.completeness + quality.accuracy + quality.consistency + quality.timeliness) / 4;\r\n    }\r\n\r\n    return quality;\r\n  }\r\n\r\n  private calculateChecksum(data: any): string {\r\n    const dataString = JSON.stringify(data);\r\n    return createHash('sha256').update(dataString).digest('hex');\r\n  }\r\n\r\n  private calculateRecordHash(record: any): string {\r\n    const dataString = JSON.stringify(record);\r\n    return createHash('sha256').update(dataString).digest('hex');\r\n  }\r\n\r\n  private identifyPIIFields(record: any): string[] {\r\n    const piiPatterns = ['email', 'name', 'phone', 'ssn', 'credit_card', 'address'];\r\n    return Object.keys(record).filter(field => \r\n      piiPatterns.some(pattern => field.toLowerCase().includes(pattern))\r\n    );\r\n  }\r\n\r\n  private async addToHashChain(record: DataRecord): Promise<void> {\r\n    const chain = this.hashChains.get(record.tenantId) || [];\r\n    const previousHash = chain.length > 0 ? chain[chain.length - 1] : '';\r\n    \r\n    // Create hash chain link\r\n    const chainData = {\r\n      recordHash: record.hash,\r\n      previousHash,\r\n      timestamp: record.timestamp\r\n    };\r\n    \r\n    const chainHash = createHash('sha256').update(JSON.stringify(chainData)).digest('hex');\r\n    chain.push(chainHash);\r\n    \r\n    record.previousHash = previousHash;\r\n    this.hashChains.set(record.tenantId, chain);\r\n  }\r\n\r\n  private async handleJobError(job: IngestionJob, error: Error): Promise<void> {\r\n    job.status = 'FAILED';\r\n    job.lastError = error.message;\r\n    job.errorCount++;\r\n    job.completedAt = new Date();\r\n\r\n    await this.auditLog.logOperation({\r\n      tenantId: job.tenantId || 'SYSTEM',\r\n      userId: 'SYSTEM',\r\n      action: 'INGESTION_JOB_ERROR',\r\n      details: {\r\n        jobId: job.id,\r\n        error: error.message,\r\n        errorCount: job.errorCount\r\n      },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'DATA_INGESTION_ENGINE',\r\n      timestamp: new Date(),\r\n      category: 'DATA_INGESTION',\r\n      severity: 'ERROR'\r\n    });\r\n\r\n    this.emit('jobError', { job, error });\r\n  }\r\n\r\n  private async cleanupCompletedJobs(): Promise<void> {\r\n    const now = new Date();\r\n    const cleanupThreshold = new Date(now.getTime() - 24 * 60 * 60 * 1000); // 24 hours\r\n\r\n    for (const [jobId, job] of this.jobs.entries()) {\r\n      if (job.completedAt && job.completedAt < cleanupThreshold) {\r\n        this.jobs.delete(jobId);\r\n      }\r\n    }\r\n  }\r\n\r\n  private updateMetrics(): void {\r\n    // Update queue metrics\r\n    for (const queue of this.queues.values()) {\r\n      // Calculate current size based on pending jobs\r\n      queue.currentSize = Array.from(this.jobs.values())\r\n        .filter(job => job.status === 'PENDING' && this.getQueueId(job.priority) === queue.id)\r\n        .length;\r\n    }\r\n  }\r\n\r\n  private scheduleJob(job: IngestionJob): void {\r\n    if (!job.schedule || !job.schedule.enabled) return;\r\n\r\n    const cron = require('node-cron');\r\n    const task = cron.schedule(job.schedule.expression, () => {\r\n      this.queueJob(job);\r\n    }, {\r\n      scheduled: false,\r\n      timezone: job.schedule.timezone\r\n    });\r\n\r\n    task.start();\r\n    job.nextRun = this.getNextRunDate(job.schedule);\r\n  }\r\n\r\n  private getNextRunDate(schedule: ScheduleConfig): Date {\r\n    // Simplified next run calculation\r\n    // In production, use proper cron parser\r\n    return new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now\r\n  }\r\n\r\n  private async validateDataSource(source: DataSource): Promise<void> {\r\n    if (!source.id || !source.name || !source.type) {\r\n      throw new Error('Invalid source configuration: missing required fields');\r\n    }\r\n\r\n    if (!source.schema || !source.schema.fields || source.schema.fields.length === 0) {\r\n      throw new Error('Invalid source configuration: schema required');\r\n    }\r\n\r\n    // Validate encryption configuration\r\n    if (source.schema.encryption.enabled && !source.schema.encryption.keyId) {\r\n      throw new Error('Encryption enabled but keyId not specified');\r\n    }\r\n  }\r\n\r\n  private async testConnection(source: DataSource): Promise<void> {\r\n    // Simplified connection test\r\n    // In production, implement actual connection testing\r\n    console.log(`Testing connection to ${source.name}...`);\r\n  }\r\n\r\n  // Placeholder methods for different data sources\r\n  private async getDatabaseData(source: DataSource, job: IngestionJob): Promise<Readable> {\r\n    // Implementation for database data extraction\r\n    return new Readable({\r\n      objectMode: true,\r\n      read() {\r\n        this.push(null); // End stream\r\n      }\r\n    });\r\n  }\r\n\r\n  private async getEventData(source: DataSource, job: IngestionJob): Promise<Readable> {\r\n    // Implementation for event stream data\r\n    return new Readable({\r\n      objectMode: true,\r\n      read() {\r\n        this.push(null); // End stream\r\n      }\r\n    });\r\n  }\r\n\r\n  private async getFileData(source: DataSource, job: IngestionJob): Promise<Readable> {\r\n    // Implementation for file data extraction\r\n    return new Readable({\r\n      objectMode: true,\r\n      read() {\r\n        this.push(null); // End stream\r\n      }\r\n    });\r\n  }\r\n\r\n  private async getApiData(source: DataSource, job: IngestionJob): Promise<Readable> {\r\n    // Implementation for API data extraction\r\n    return new Readable({\r\n      objectMode: true,\r\n      read() {\r\n        this.push(null); // End stream\r\n      }\r\n    });\r\n  }\r\n\r\n  private async getAuditData(source: DataSource, job: IngestionJob): Promise<Readable> {\r\n    // Implementation for audit log extraction\r\n    return new Readable({\r\n      objectMode: true,\r\n      read() {\r\n        this.push(null); // End stream\r\n      }\r\n    });\r\n  }\r\n\r\n  // Public API methods\r\n  public async getJob(jobId: string): Promise<IngestionJob | null> {\r\n    return this.jobs.get(jobId) || null;\r\n  }\r\n\r\n  public async getJobs(tenantId?: string): Promise<IngestionJob[]> {\r\n    const jobs = Array.from(this.jobs.values());\r\n    return tenantId ? jobs.filter(job => job.tenantId === tenantId) : jobs;\r\n  }\r\n\r\n  public async getSource(sourceId: string): Promise<DataSource | null> {\r\n    return this.sources.get(sourceId) || null;\r\n  }\r\n\r\n  public async getSources(tenantId?: string): Promise<DataSource[]> {\r\n    const sources = Array.from(this.sources.values());\r\n    return tenantId ? sources.filter(source => source.tenantId === tenantId) : sources;\r\n  }\r\n\r\n  public async getQueue(queueId: string): Promise<IngestionQueue | null> {\r\n    return this.queues.get(queueId) || null;\r\n  }\r\n\r\n  public async getQueues(): Promise<IngestionQueue[]> {\r\n    return Array.from(this.queues.values());\r\n  }\r\n\r\n  public async pauseJob(jobId: string): Promise<void> {\r\n    const job = this.jobs.get(jobId);\r\n    if (!job) {\r\n      throw new Error(`Job not found: ${jobId}`);\r\n    }\r\n\r\n    if (job.status === 'RUNNING') {\r\n      job.status = 'PAUSED';\r\n      await this.auditLog.logOperation({\r\n        tenantId: job.tenantId || 'SYSTEM',\r\n        userId: 'SYSTEM',\r\n        action: 'PAUSE_INGESTION_JOB',\r\n        details: { jobId },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DATA_INGESTION_ENGINE',\r\n        timestamp: new Date(),\r\n        category: 'DATA_INGESTION',\r\n        severity: 'INFO'\r\n      });\r\n    }\r\n  }\r\n\r\n  public async resumeJob(jobId: string): Promise<void> {\r\n    const job = this.jobs.get(jobId);\r\n    if (!job) {\r\n      throw new Error(`Job not found: ${jobId}`);\r\n    }\r\n\r\n    if (job.status === 'PAUSED') {\r\n      await this.queueJob(job);\r\n      await this.auditLog.logOperation({\r\n        tenantId: job.tenantId || 'SYSTEM',\r\n        userId: 'SYSTEM',\r\n        action: 'RESUME_INGESTION_JOB',\r\n        details: { jobId },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DATA_INGESTION_ENGINE',\r\n        timestamp: new Date(),\r\n        category: 'DATA_INGESTION',\r\n        severity: 'INFO'\r\n      });\r\n    }\r\n  }\r\n\r\n  public async cancelJob(jobId: string): Promise<void> {\r\n    const job = this.jobs.get(jobId);\r\n    if (!job) {\r\n      throw new Error(`Job not found: ${jobId}`);\r\n    }\r\n\r\n    job.status = 'CANCELLED';\r\n    job.completedAt = new Date();\r\n\r\n    // Remove from processing if currently running\r\n    const processingJob = this.processingJobs.get(jobId);\r\n    if (processingJob) {\r\n      // Cancel the processing promise\r\n      this.processingJobs.delete(jobId);\r\n    }\r\n\r\n    await this.auditLog.logOperation({\r\n      tenantId: job.tenantId || 'SYSTEM',\r\n      userId: 'SYSTEM',\r\n      action: 'CANCEL_INGESTION_JOB',\r\n      details: { jobId },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'DATA_INGESTION_ENGINE',\r\n      timestamp: new Date(),\r\n      category: 'DATA_INGESTION',\r\n      severity: 'INFO'\r\n    });\r\n  }\r\n\r\n  public async getHashChain(tenantId: string): Promise<string[]> {\r\n    return this.hashChains.get(tenantId) || [];\r\n  }\r\n\r\n  private generateJobId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `JOB${timestamp}${random}`;\r\n  }\r\n\r\n  private generateRecordId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `REC${timestamp}${random}`;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\analytics\\insights-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\analytics\\observability.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\audit\\audit-evidence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\audit\\audit-retention.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\audit\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\authorization-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\authorization-guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\authorization.ts","messages":[{"ruleId":"no-extra-semi","severity":2,"message":"Unnecessary semicolon.","line":152,"column":2,"nodeType":"EmptyStatement","messageId":"unexpected","endLine":152,"endColumn":3,"fix":{"range":[5331,5414],"text":"}\r\n\r\n// Convenience middleware factories for common authorization patterns\r\nexport"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"// Authorization Middleware for Express.js\r\n// Enforces RBAC permissions at the API layer\r\n\r\nimport { Request, Response, NextFunction } from 'express';\r\nimport { rbacService, Permission, UserRole } from './rbac.js';\r\nimport { logger } from '../utils/structured-logger.js';\r\n\r\nexport interface AuthenticatedRequest extends Request {\r\n  user?: any;\r\n  authContext?: any;\r\n}\r\n\r\nexport interface AuthorizationOptions {\r\n  permissions?: Permission[];\r\n  requireAny?: boolean; // true: any permission, false: all permissions\r\n  requireCompany?: boolean; // require company access\r\n  allowSelf?: boolean; // allow users to access their own resources\r\n  resourceOwnerField?: string; // field name for resource owner ID\r\n}\r\n\r\n// Authorization middleware factory\r\nexport function requireAuthorization(options: AuthorizationOptions = {}) {\r\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\r\n    const authContext = rbacService.getAuthContext(req);\r\n    \r\n    if (!authContext) {\r\n      logger.warn('Unauthorized access attempt - no auth context', {\r\n        ip: req.ip,\r\n        userAgent: req.headers['user-agent'],\r\n        path: req.path,\r\n        method: req.method\r\n      });\r\n      \r\n      return res.status(401).json({\r\n        error: 'Unauthorized',\r\n        message: 'Authentication required',\r\n        code: 'AUTH_REQUIRED'\r\n      });\r\n    }\r\n\r\n    req.authContext = authContext;\r\n\r\n    // Check self-access if allowed (check this first)\r\n    if (options.allowSelf && options.resourceOwnerField) {\r\n      const resourceOwnerId = req.params[options.resourceOwnerField] || \r\n                             req.body[options.resourceOwnerField] || \r\n                             req.query[options.resourceOwnerField];\r\n\r\n      if (resourceOwnerId && resourceOwnerId === authContext.user.id) {\r\n        // User is accessing their own resource, allow access\r\n        logger.debug('Self-access allowed', {\r\n          userId: authContext.user.id,\r\n          resourceOwnerId,\r\n          path: req.path,\r\n          method: req.method,\r\n          correlationId: authContext.correlationId\r\n        });\r\n        return next();\r\n      } else if (resourceOwnerId && resourceOwnerId !== authContext.user.id) {\r\n        // User is trying to access another user's resource, check permissions\r\n        if (!options.permissions || !rbacService.hasAnyPermission(authContext.user, options.permissions)) {\r\n          logger.warn('Access denied - self-access violation', {\r\n            userId: authContext.user.id,\r\n            resourceOwnerId,\r\n            path: req.path,\r\n            method: req.method,\r\n            correlationId: authContext.correlationId\r\n          });\r\n\r\n          return res.status(403).json({\r\n            error: 'Forbidden',\r\n            message: 'Cannot access this resource',\r\n            code: 'SELF_ACCESS_DENIED'\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check permissions if specified (for non-self-access cases)\r\n    if (options.permissions && options.permissions.length > 0) {\r\n      const hasPermission = options.requireAny\r\n        ? rbacService.hasAnyPermission(authContext.user, options.permissions)\r\n        : rbacService.hasAllPermissions(authContext.user, options.permissions);\r\n\r\n      if (!hasPermission) {\r\n        logger.warn('Access denied - insufficient permissions', {\r\n          userId: authContext.user.id,\r\n          userRole: authContext.user.role,\r\n          requiredPermissions: options.permissions,\r\n          userPermissions: authContext.permissions,\r\n          path: req.path,\r\n          method: req.method,\r\n          correlationId: authContext.correlationId\r\n        });\r\n\r\n        return res.status(403).json({\r\n          error: 'Forbidden',\r\n          message: 'Insufficient permissions',\r\n          code: 'INSUFFICIENT_PERMISSIONS',\r\n          required: options.permissions\r\n        });\r\n      }\r\n    }\r\n\r\n    // Check company access if required\r\n    if (options.requireCompany) {\r\n      const companyId = req.params.companyId || req.body.companyId || req.query.companyId;\r\n      \r\n      if (!companyId) {\r\n        logger.warn('Access denied - company ID required', {\r\n          userId: authContext.user.id,\r\n          path: req.path,\r\n          method: req.method,\r\n          correlationId: authContext.correlationId\r\n        });\r\n\r\n        return res.status(400).json({\r\n          error: 'Bad Request',\r\n          message: 'Company ID required',\r\n          code: 'COMPANY_ID_REQUIRED'\r\n        });\r\n      }\r\n\r\n      if (!rbacService.canAccessCompany(authContext.user, companyId)) {\r\n        logger.warn('Access denied - company access violation', {\r\n          userId: authContext.user.id,\r\n          userCompanyId: authContext.user.companyId,\r\n          requestedCompanyId: companyId,\r\n          path: req.path,\r\n          method: req.method,\r\n          correlationId: authContext.correlationId\r\n        });\r\n\r\n        return res.status(403).json({\r\n          error: 'Forbidden',\r\n          message: 'Cannot access this company',\r\n          code: 'COMPANY_ACCESS_DENIED'\r\n        });\r\n      }\r\n    }\r\n\r\n    logger.debug('Authorization successful', {\r\n      userId: authContext.user.id,\r\n      userRole: authContext.user.role,\r\n      path: req.path,\r\n      method: req.method,\r\n      correlationId: authContext.correlationId\r\n    });\r\n\r\n    next();\r\n  };\r\n};\r\n\r\n// Convenience middleware factories for common authorization patterns\r\nexport const requireAdmin = requireAuthorization({\r\n  permissions: [Permission.SYSTEM_ADMIN]\r\n});\r\n\r\nexport const requireUserManagement = requireAuthorization({\r\n  permissions: [Permission.USER_ADMIN]\r\n});\r\n\r\nexport const requireFinancialAccess = requireAuthorization({\r\n  permissions: [Permission.FINANCIAL_READ],\r\n  requireAny: true\r\n});\r\n\r\nexport const requireFinancialWrite = requireAuthorization({\r\n  permissions: [Permission.FINANCIAL_WRITE]\r\n});\r\n\r\nexport const requireAccountingAccess = requireAuthorization({\r\n  permissions: [Permission.ACCOUNTING_READ],\r\n  requireAny: true\r\n});\r\n\r\nexport const requireCompanyAccess = requireAuthorization({\r\n  requireCompany: true\r\n});\r\n\r\nexport const requireAuditAccess = requireAuthorization({\r\n  permissions: [Permission.AUDIT_READ]\r\n});\r\n\r\n// Role-based middleware\r\nexport const requireRole = (role: UserRole) => {\r\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\r\n    const authContext = rbacService.getAuthContext(req);\r\n    \r\n    if (!authContext || authContext.user.role !== role) {\r\n      logger.warn('Access denied - insufficient role', {\r\n        userId: authContext?.user?.id,\r\n        userRole: authContext?.user?.role,\r\n        requiredRole: role,\r\n        path: req.path,\r\n        method: req.method\r\n      });\r\n\r\n      return res.status(403).json({\r\n        error: 'Forbidden',\r\n        message: 'Insufficient role',\r\n        code: 'INSUFFICIENT_ROLE',\r\n        required: role\r\n      });\r\n    }\r\n\r\n    next();\r\n  };\r\n};\r\n\r\n// Minimum role middleware\r\nexport const requireMinimumRole = (minimumRole: UserRole) => {\r\n  const roleHierarchy = {\r\n    [UserRole.GUEST]: 0,\r\n    [UserRole.VIEWER]: 1,\r\n    [UserRole.EMPLOYEE]: 2,\r\n    [UserRole.MANAGER]: 3,\r\n    [UserRole.ADMIN]: 4,\r\n    [UserRole.SUPER_ADMIN]: 5\r\n  };\r\n\r\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\r\n    const authContext = rbacService.getAuthContext(req);\r\n    \r\n    if (!authContext) {\r\n      return res.status(401).json({\r\n        error: 'Unauthorized',\r\n        message: 'Authentication required',\r\n        code: 'AUTH_REQUIRED'\r\n      });\r\n    }\r\n\r\n    const userLevel = roleHierarchy[authContext.user.role] || 0;\r\n    const requiredLevel = roleHierarchy[minimumRole] || 0;\r\n\r\n    if (userLevel < requiredLevel) {\r\n      logger.warn('Access denied - insufficient role level', {\r\n        userId: authContext.user.id,\r\n        userRole: authContext.user.role,\r\n        userLevel,\r\n        requiredLevel,\r\n        minimumRole,\r\n        path: req.path,\r\n        method: req.method\r\n      });\r\n\r\n      return res.status(403).json({\r\n        error: 'Forbidden',\r\n        message: 'Insufficient role',\r\n        code: 'INSUFFICIENT_ROLE_LEVEL',\r\n        required: minimumRole\r\n      });\r\n    }\r\n\r\n    next();\r\n  };\r\n};\r\n\r\n// Self-access middleware (users can access their own resources)\r\nexport const requireSelfAccessOrPermission = (\r\n  resourceOwnerField: string,\r\n  permissions: Permission[] = []\r\n) => {\r\n  return requireAuthorization({\r\n    permissions,\r\n    allowSelf: true,\r\n    resourceOwnerField\r\n  });\r\n};\r\n\r\n// API key authentication middleware\r\nexport const requireApiKey = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\r\n  const apiKey = req.headers['x-api-key'] as string;\r\n  \r\n  if (!apiKey) {\r\n    return res.status(401).json({\r\n      error: 'Unauthorized',\r\n      message: 'API key required',\r\n      code: 'API_KEY_REQUIRED'\r\n    });\r\n  }\r\n\r\n  // In a real implementation, validate API key against database\r\n  // For now, we'll use environment variable for demo\r\n  const validApiKey = process.env.API_KEY;\r\n  \r\n  if (!validApiKey || apiKey !== validApiKey) {\r\n    logger.warn('Invalid API key attempt', {\r\n      apiKey: apiKey.substring(0, 8) + '...',\r\n      ip: req.ip,\r\n      userAgent: req.headers['user-agent'],\r\n      path: req.path\r\n    });\r\n\r\n    return res.status(401).json({\r\n      error: 'Unauthorized',\r\n      message: 'Invalid API key',\r\n      code: 'INVALID_API_KEY'\r\n    });\r\n  }\r\n\r\n  // Create a synthetic user for API key access\r\n  req.user = {\r\n    id: 'api-key-user',\r\n    email: 'api@system',\r\n    role: UserRole.ADMIN,\r\n    isActive: true,\r\n    permissions: Object.values(Permission),\r\n    createdAt: new Date(),\r\n    updatedAt: new Date()\r\n  };\r\n\r\n  next();\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\least-privilege-permissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\protected-routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\rbac-audit-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\rbac.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\resource-scoped-permissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\auth\\tenant-permissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\backup\\database-backup.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":198,"column":32,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":198,"endColumn":45},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":270,"column":21,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":270,"endColumn":34},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":308,"column":22,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":308,"endColumn":37},{"ruleId":"prefer-const","severity":2,"message":"'checksum' is never reassigned. Use 'const' instead.","line":369,"column":7,"nodeType":"Identifier","messageId":"useConst","endLine":369,"endColumn":15},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":370,"column":7,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":370,"endColumn":20},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":454,"column":29,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":454,"endColumn":42},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":464,"column":7,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":464,"endColumn":20},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":516,"column":21,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":516,"endColumn":34},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":528,"column":24,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":528,"endColumn":37}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Production-Grade Database Backup System\r\n// Automated backups with encryption, verification, and isolation\r\n\r\nimport { exec } from 'child_process';\r\nimport { promisify } from 'util';\r\nimport { createCipheriv, createDecipheriv, randomBytes } from 'crypto';\r\nimport { createReadStream, createWriteStream, existsSync, mkdirSync, unlinkSync, statSync } from 'fs';\r\nimport { join, dirname } from 'path';\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { metrics } from '../utils/metrics.js';\r\n\r\nconst execAsync = promisify(exec);\r\n\r\nexport interface BackupConfig {\r\n  databaseUrl: string;\r\n  backupDirectory: string;\r\n  encryptionKey: string;\r\n  retentionDays: number;\r\n  backupIntervalHours: number;\r\n  maxBackupSizeGB: number;\r\n  compressionEnabled: boolean;\r\n  verificationEnabled: boolean;\r\n  isolationEnabled: boolean;\r\n}\r\n\r\nexport interface BackupResult {\r\n  success: boolean;\r\n  backupId: string;\r\n  filePath: string;\r\n  fileSize: number;\r\n  compressedSize: number;\r\n  duration: number;\r\n  timestamp: Date;\r\n  checksum?: string;\r\n  error?: string;\r\n}\r\n\r\nexport interface BackupVerification {\r\n  backupId: string;\r\n  isValid: boolean;\r\n  checksumMatches: boolean;\r\n  canRestore: boolean;\r\n  errors: string[];\r\n  warnings: string[];\r\n}\r\n\r\nexport class DatabaseBackupService {\r\n  private config: BackupConfig;\r\n  private backupInterval?: NodeJS.Timeout;\r\n  private isRunning = false;\r\n\r\n  constructor(config: BackupConfig) {\r\n    this.config = config;\r\n    this.ensureBackupDirectory();\r\n  }\r\n\r\n  private ensureBackupDirectory(): void {\r\n    if (!existsSync(this.config.backupDirectory)) {\r\n      mkdirSync(this.config.backupDirectory, { recursive: true });\r\n    }\r\n  }\r\n\r\n  private generateBackupId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n    const random = randomBytes(4).toString('hex');\r\n    return `backup-${timestamp}-${random}`;\r\n  }\r\n\r\n  private async executeCommand(command: string): Promise<{ stdout: string; stderr: string }> {\r\n    try {\r\n      const result = await execAsync(command);\r\n      return {\r\n        stdout: result.stdout as string,\r\n        stderr: result.stderr as string\r\n      };\r\n    } catch (error: any) {\r\n      return {\r\n        stdout: error.stdout || '',\r\n        stderr: error.stderr || error.message\r\n      };\r\n    }\r\n  }\r\n\r\n  private async createDatabaseDump(backupId: string): Promise<string> {\r\n    const dumpFile = join(this.config.backupDirectory, `${backupId}.sql`);\r\n    \r\n    logger.info('Creating database dump', {\r\n      backupId,\r\n      dumpFile\r\n    });\r\n\r\n    // Use pg_dump for PostgreSQL (adjust for your database)\r\n    const command = `pg_dump \"${this.config.databaseUrl}\" > \"${dumpFile}\"`;\r\n    \r\n    const result = await this.executeCommand(command);\r\n    \r\n    if (result.stderr && !result.stderr.includes('WARNING')) {\r\n      throw new Error(`Database dump failed: ${result.stderr}`);\r\n    }\r\n\r\n    if (!existsSync(dumpFile)) {\r\n      throw new Error('Backup file was not created');\r\n    }\r\n\r\n    const stats = statSync(dumpFile);\r\n    logger.info('Database dump created', {\r\n      backupId,\r\n      fileSize: stats.size,\r\n      dumpFile\r\n    });\r\n\r\n    return dumpFile;\r\n  }\r\n\r\n  private encryptFile(inputPath: string, outputPath: string): Promise<void> {\r\n    const algorithm = 'aes-256-gcm';\r\n    const iv = randomBytes(16);\r\n    const cipher = createCipheriv(algorithm, Buffer.from(this.config.encryptionKey, 'hex'), iv);\r\n    \r\n    const input = createReadStream(inputPath);\r\n    const output = createWriteStream(outputPath);\r\n    \r\n    // Write IV at the beginning of the encrypted file\r\n    output.write(iv);\r\n    \r\n    return new Promise<void>((resolve, reject) => {\r\n      output.on('finish', () => resolve());\r\n      output.on('error', reject);\r\n      input.on('error', reject);\r\n      \r\n      input.pipe(cipher).pipe(output);\r\n    });\r\n  }\r\n\r\n  private async compressFile(inputPath: string): Promise<string> {\r\n    const compressedPath = `${inputPath}.gz`;\r\n    \r\n    logger.info('Compressing backup file', {\r\n      inputPath,\r\n      compressedPath\r\n    });\r\n\r\n    const command = `gzip \"${inputPath}\"`;\r\n    const result = await this.executeCommand(command);\r\n    \r\n    if (result.stderr && !result.stderr.includes('WARNING')) {\r\n      throw new Error(`Compression failed: ${result.stderr}`);\r\n    }\r\n\r\n    if (!existsSync(compressedPath)) {\r\n      throw new Error('Compressed file was not created');\r\n    }\r\n\r\n    return compressedPath;\r\n  }\r\n\r\n  private async calculateChecksum(filePath: string): Promise<string> {\r\n    const command = `sha256sum \"${filePath}\" | cut -d' ' -f1`;\r\n    const result = await this.executeCommand(command);\r\n    return result.stdout.trim();\r\n  }\r\n\r\n  private async verifyBackup(backupId: string, filePath: string): Promise<BackupVerification> {\r\n    const verification: BackupVerification = {\r\n      backupId,\r\n      isValid: true,\r\n      checksumMatches: true,\r\n      canRestore: true,\r\n      errors: [],\r\n      warnings: []\r\n    };\r\n\r\n    try {\r\n      // Check file exists and is not empty\r\n      if (!existsSync(filePath)) {\r\n        verification.isValid = false;\r\n        verification.errors.push('Backup file does not exist');\r\n        return verification;\r\n      }\r\n\r\n      const stats = statSync(filePath);\r\n      if (stats.size === 0) {\r\n        verification.isValid = false;\r\n        verification.errors.push('Backup file is empty');\r\n        return verification;\r\n      }\r\n\r\n      // Check file size limits\r\n      const sizeGB = stats.size / (1024 * 1024 * 1024);\r\n      if (sizeGB > this.config.maxBackupSizeGB) {\r\n        verification.warnings.push(`Backup size (${sizeGB.toFixed(2)}GB) exceeds recommended limit (${this.config.maxBackupSizeGB}GB)`);\r\n      }\r\n\r\n      // Verify checksum if available\r\n      const checksumFile = `${filePath}.sha256`;\r\n      if (existsSync(checksumFile)) {\r\n        const currentChecksum = await this.calculateChecksum(filePath);\r\n        const storedChecksum = require('fs').readFileSync(checksumFile, 'utf8').trim();\r\n        \r\n        if (currentChecksum !== storedChecksum) {\r\n          verification.isValid = false;\r\n          verification.checksumMatches = false;\r\n          verification.errors.push('Checksum mismatch - file may be corrupted');\r\n        }\r\n      }\r\n\r\n      // Test restore (dry run)\r\n      if (this.config.verificationEnabled) {\r\n        try {\r\n          const testResult = await this.testRestore(filePath);\r\n          if (!testResult.success) {\r\n            verification.canRestore = false;\r\n            verification.errors.push('Restore test failed: ' + testResult.error);\r\n          }\r\n        } catch (error) {\r\n          verification.canRestore = false;\r\n          verification.errors.push('Restore test error: ' + (error as Error).message);\r\n        }\r\n      }\r\n\r\n    } catch (error) {\r\n      verification.isValid = false;\r\n      verification.errors.push('Verification error: ' + (error as Error).message);\r\n    }\r\n\r\n    return verification;\r\n  }\r\n\r\n  private async testRestore(backupFile: string): Promise<{ success: boolean; error?: string }> {\r\n    // Create a temporary test database\r\n    const testDbName = `test_restore_${Date.now()}`;\r\n    \r\n    try {\r\n      // Create test database\r\n      await this.executeCommand(`createdb \"${testDbName}\"`);\r\n      \r\n      // Attempt restore (dry run with --clean --if-exists --verbose)\r\n      const restoreCommand = `psql \"${this.config.databaseUrl.replace(/\\/[^\\/]*$/, '/' + testDbName)}\" --echo-all --quiet --file=\"${backupFile}\"`;\r\n      const result = await this.executeCommand(restoreCommand);\r\n      \r\n      // Check for errors in restore output\r\n      if (result.stderr && result.stderr.includes('ERROR')) {\r\n        throw new Error(`Restore errors detected: ${result.stderr}`);\r\n      }\r\n      \r\n      // Drop test database\r\n      await this.executeCommand(`dropdb \"${testDbName}\"`);\r\n      \r\n      return { success: true };\r\n      \r\n    } catch (error) {\r\n      // Clean up test database on error\r\n      try {\r\n        await this.executeCommand(`dropdb \"${testDbName}\" --if-exists`);\r\n      } catch (cleanupError) {\r\n        // Ignore cleanup errors\r\n      }\r\n      \r\n      return { \r\n        success: false, \r\n        error: (error as Error).message \r\n      };\r\n    }\r\n  }\r\n\r\n  private async cleanupOldBackups(): Promise<void> {\r\n    try {\r\n      const cutoffTime = Date.now() - (this.config.retentionDays * 24 * 60 * 60 * 1000);\r\n      \r\n      const files = require('fs').readdirSync(this.config.backupDirectory);\r\n      \r\n      for (const file of files) {\r\n        if (file.startsWith('backup-') && (file.endsWith('.sql') || file.endsWith('.sql.gz'))) {\r\n          const filePath = join(this.config.backupDirectory, file);\r\n          const stats = statSync(filePath);\r\n          \r\n          if (stats.mtime.getTime() < cutoffTime) {\r\n            logger.info('Deleting old backup', {\r\n              file,\r\n              age: Math.floor((Date.now() - stats.mtime.getTime()) / (24 * 60 * 60 * 1000))\r\n            });\r\n            \r\n            unlinkSync(filePath);\r\n            \r\n            // Delete checksum file if exists\r\n            const checksumFile = `${filePath}.sha256`;\r\n            if (existsSync(checksumFile)) {\r\n              unlinkSync(checksumFile);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logger.error('Error cleaning up old backups', error as Error);\r\n    }\r\n  }\r\n\r\n  private async isolateBackup(filePath: string): Promise<string> {\r\n    if (!this.config.isolationEnabled) {\r\n      return filePath;\r\n    }\r\n\r\n    const isolatedDir = join(this.config.backupDirectory, 'isolated');\r\n    if (!existsSync(isolatedDir)) {\r\n      mkdirSync(isolatedDir, { recursive: true });\r\n    }\r\n\r\n    const fileName = require('path').basename(filePath);\r\n    const isolatedPath = join(isolatedDir, fileName);\r\n    \r\n    // Copy file to isolated directory with restricted permissions\r\n    await this.executeCommand(`cp \"${filePath}\" \"${isolatedPath}\"`);\r\n    await this.executeCommand(`chmod 600 \"${isolatedPath}\"`);\r\n    \r\n    logger.info('Backup isolated', {\r\n      originalPath: filePath,\r\n      isolatedPath\r\n    });\r\n    \r\n    return isolatedPath;\r\n  }\r\n\r\n  async createBackup(): Promise<BackupResult> {\r\n    if (this.isRunning) {\r\n      throw new Error('Backup is already in progress');\r\n    }\r\n\r\n    this.isRunning = true;\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      const backupId = this.generateBackupId();\r\n      let dumpFile: string;\r\n      let finalPath: string;\r\n      let originalSize = 0;\r\n      let compressedSize = 0;\r\n      let checksum: string | undefined;\r\n\r\n      logger.info('Starting database backup', {\r\n        backupId,\r\n        config: {\r\n          retentionDays: this.config.retentionDays,\r\n          compressionEnabled: this.config.compressionEnabled,\r\n          verificationEnabled: this.config.verificationEnabled\r\n        }\r\n      });\r\n\r\n      // Step 1: Create database dump\r\n      dumpFile = await this.createDatabaseDump(backupId);\r\n      originalSize = statSync(dumpFile).size;\r\n\r\n      // Step 2: Compress if enabled\r\n      if (this.config.compressionEnabled) {\r\n        dumpFile = await this.compressFile(dumpFile);\r\n        compressedSize = statSync(dumpFile).size;\r\n      } else {\r\n        compressedSize = originalSize;\r\n      }\r\n\r\n      // Step 3: Encrypt the backup\r\n      const encryptedFile = `${dumpFile}.enc`;\r\n      this.encryptFile(dumpFile, encryptedFile);\r\n      \r\n      // Remove unencrypted file\r\n      unlinkSync(dumpFile);\r\n      finalPath = encryptedFile;\r\n\r\n      // Step 4: Calculate checksum\r\n      checksum = await this.calculateChecksum(finalPath);\r\n      require('fs').writeFileSync(`${finalPath}.sha256`, checksum);\r\n\r\n      // Step 5: Verify backup\r\n      if (this.config.verificationEnabled) {\r\n        const verification = await this.verifyBackup(backupId, finalPath);\r\n        \r\n        if (!verification.isValid) {\r\n          throw new Error(`Backup verification failed: ${verification.errors.join(', ')}`);\r\n        }\r\n        \r\n        if (verification.warnings.length > 0) {\r\n          logger.warn('Backup verification warnings', {\r\n            backupId,\r\n            warnings: verification.warnings\r\n          });\r\n        }\r\n      }\r\n\r\n      // Step 6: Isolate backup\r\n      finalPath = await this.isolateBackup(finalPath);\r\n\r\n      const duration = Date.now() - startTime;\r\n      \r\n      // Record metrics\r\n      metrics.incrementCounter('app_database_backups_created', 1);\r\n      metrics.recordHistogram('app_database_backup_duration', duration);\r\n      metrics.setGauge('app_database_backup_size', compressedSize);\r\n\r\n      logger.info('Database backup completed successfully', {\r\n        backupId,\r\n        finalPath,\r\n        originalSize,\r\n        compressedSize,\r\n        compressionRatio: originalSize > 0 ? compressedSize / originalSize : 0,\r\n        duration,\r\n        checksum: checksum?.substring(0, 16) + '...'\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        backupId,\r\n        filePath: finalPath,\r\n        fileSize: originalSize,\r\n        compressedSize,\r\n        duration,\r\n        timestamp: new Date(),\r\n        checksum\r\n      };\r\n\r\n    } catch (error) {\r\n      const duration = Date.now() - startTime;\r\n      \r\n      metrics.incrementCounter('app_database_backups_failed', 1);\r\n      \r\n      logger.error('Database backup failed', error as Error, {\r\n        duration\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        backupId: '',\r\n        filePath: '',\r\n        fileSize: 0,\r\n        compressedSize: 0,\r\n        duration,\r\n        timestamp: new Date(),\r\n        error: (error as Error).message\r\n      };\r\n\r\n    } finally {\r\n      this.isRunning = false;\r\n    }\r\n  }\r\n\r\n  async restoreBackup(backupId: string, targetDatabase?: string): Promise<{ success: boolean; error?: string }> {\r\n    try {\r\n      const backupFile = join(this.config.backupDirectory, 'isolated', `${backupId}.sql.enc`);\r\n      \r\n      if (!existsSync(backupFile)) {\r\n        throw new Error('Backup file not found');\r\n      }\r\n\r\n      // Decrypt backup\r\n      const algorithm = 'aes-256-gcm';\r\n      const encryptedData = require('fs').readFileSync(backupFile);\r\n      \r\n      const iv = encryptedData.slice(0, 16);\r\n      const encryptedContent = encryptedData.slice(16);\r\n      \r\n      const decipher = createDecipheriv(algorithm, Buffer.from(this.config.encryptionKey, 'hex'), iv);\r\n      \r\n      const decryptedFile = backupFile.replace('.enc', '.dec');\r\n      const decrypted = Buffer.concat([decipher.update(encryptedContent), decipher.final()]);\r\n      \r\n      require('fs').writeFileSync(decryptedFile, decrypted);\r\n\r\n      // Restore to target database\r\n      const targetDb = targetDatabase || this.config.databaseUrl;\r\n      const restoreCommand = `psql \"${targetDb}\" --file=\"${decryptedFile}\"`;\r\n      \r\n      const result = await this.executeCommand(restoreCommand);\r\n      \r\n      if (result.stderr && result.stderr.includes('ERROR')) {\r\n        throw new Error(`Restore failed: ${result.stderr}`);\r\n      }\r\n\r\n      // Clean up decrypted file\r\n      unlinkSync(decryptedFile);\r\n\r\n      logger.info('Database restore completed', {\r\n        backupId,\r\n        targetDatabase: targetDb\r\n      });\r\n\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      logger.error('Database restore failed', error as Error, {\r\n        backupId,\r\n        targetDatabase\r\n      });\r\n\r\n      return { \r\n        success: false, \r\n        error: (error as Error).message \r\n      };\r\n    }\r\n  }\r\n\r\n  async listBackups(): Promise<Array<{\r\n    backupId: string;\r\n    timestamp: Date;\r\n    fileSize: number;\r\n    compressedSize: number;\r\n    checksum?: string;\r\n  }>> {\r\n    const backups: Array<{\r\n      backupId: string;\r\n      timestamp: Date;\r\n      fileSize: number;\r\n      compressedSize: number;\r\n      checksum?: string;\r\n    }> = [];\r\n\r\n    try {\r\n      const isolatedDir = join(this.config.backupDirectory, 'isolated');\r\n      const files = require('fs').readdirSync(isolatedDir);\r\n      \r\n      for (const file of files) {\r\n        if (file.endsWith('.enc')) {\r\n          const filePath = join(isolatedDir, file);\r\n          const stats = statSync(filePath);\r\n          const backupId = file.replace('.sql.enc', '');\r\n          \r\n          // Try to read checksum\r\n          let checksum: string | undefined;\r\n          const checksumFile = `${filePath}.sha256`;\r\n          if (existsSync(checksumFile)) {\r\n            checksum = require('fs').readFileSync(checksumFile, 'utf8').trim();\r\n          }\r\n          \r\n          backups.push({\r\n            backupId,\r\n            timestamp: stats.mtime,\r\n            fileSize: stats.size, // This is compressed size\r\n            compressedSize: stats.size,\r\n            checksum\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Sort by timestamp (newest first)\r\n      backups.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\r\n      \r\n    } catch (error) {\r\n      logger.error('Error listing backups', error as Error);\r\n    }\r\n\r\n    return backups;\r\n  }\r\n\r\n  startScheduledBackups(): void {\r\n    if (this.backupInterval) {\r\n      this.stopScheduledBackups();\r\n    }\r\n\r\n    const intervalMs = this.config.backupIntervalHours * 60 * 60 * 1000;\r\n    \r\n    this.backupInterval = setInterval(async () => {\r\n      try {\r\n        await this.createBackup();\r\n        await this.cleanupOldBackups();\r\n      } catch (error) {\r\n        logger.error('Scheduled backup failed', error as Error);\r\n      }\r\n    }, intervalMs);\r\n\r\n    logger.info('Scheduled backups started', {\r\n      intervalHours: this.config.backupIntervalHours,\r\n      retentionDays: this.config.retentionDays\r\n    });\r\n  }\r\n\r\n  stopScheduledBackups(): void {\r\n    if (this.backupInterval) {\r\n      clearInterval(this.backupInterval);\r\n      this.backupInterval = undefined;\r\n      logger.info('Scheduled backups stopped');\r\n    }\r\n  }\r\n\r\n  async getBackupStatus(): Promise<{\r\n    isRunning: boolean;\r\n    lastBackup?: BackupResult;\r\n    scheduledBackupsActive: boolean;\r\n    totalBackups: number;\r\n  }> {\r\n    const backups = await this.listBackups();\r\n    \r\n    return {\r\n      isRunning: this.isRunning,\r\n      lastBackup: backups.length > 0 ? {\r\n        success: true,\r\n        backupId: backups[0].backupId,\r\n        filePath: '',\r\n        fileSize: backups[0].fileSize,\r\n        compressedSize: backups[0].compressedSize,\r\n        duration: 0,\r\n        timestamp: backups[0].timestamp,\r\n        checksum: backups[0].checksum\r\n      } : undefined,\r\n      scheduledBackupsActive: !!this.backupInterval,\r\n      totalBackups: backups.length\r\n    };\r\n  }\r\n}\r\n\r\n// Create default backup service instance\r\nexport const createBackupService = (config: Partial<BackupConfig> = {}): DatabaseBackupService => {\r\n  const defaultConfig: BackupConfig = {\r\n    databaseUrl: process.env.DATABASE_URL || '',\r\n    backupDirectory: process.env.BACKUP_DIRECTORY || './backups',\r\n    encryptionKey: process.env.BACKUP_ENCRYPTION_KEY || randomBytes(32).toString('hex'),\r\n    retentionDays: 30,\r\n    backupIntervalHours: 24,\r\n    maxBackupSizeGB: 10,\r\n    compressionEnabled: true,\r\n    verificationEnabled: true,\r\n    isolationEnabled: true\r\n  };\r\n\r\n  return new DatabaseBackupService({ ...defaultConfig, ...config });\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\billing\\billing-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\billing\\entitlement-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\billing\\plan-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\billing\\usage-meter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\audit-vault.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\auditor-access.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\compliance-dashboard.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":1054,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":1054,"endColumn":60},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":1061,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":1063,"endColumn":51}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Customer-Facing Compliance Dashboard\r\n// MANDATORY: Real-time compliance visibility and transparency for customers\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { trustCenterManager, TrustCenterProfile, ComplianceDashboard } from './trust-center.js';\r\nimport { complianceEngineManager } from './compliance-engine.js';\r\nimport { evidenceCollectionManager } from './evidence-collector.js';\r\nimport * as crypto from 'crypto';\r\n\r\nexport type DashboardType = 'EXECUTIVE' | 'TECHNICAL' | 'LEGAL' | 'CUSTOMER';\r\nexport type MetricCategory = 'SECURITY' | 'PRIVACY' | 'AVAILABILITY' | 'COMPLIANCE' | 'GOVERNANCE';\r\nexport type TrendDirection = 'UP' | 'DOWN' | 'STABLE';\r\nexport type AlertLevel = 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL';\r\n\r\nexport interface ComplianceMetric {\r\n  id: string;\r\n  name: string;\r\n  category: MetricCategory;\r\n  value: number;\r\n  target: number;\r\n  unit: string;\r\n  trend: TrendDirection;\r\n  lastUpdated: Date;\r\n  status: 'HEALTHY' | 'WARNING' | 'CRITICAL';\r\n  description: string;\r\n  calculation: string;\r\n  dataPoints: Array<{\r\n    timestamp: Date;\r\n    value: number;\r\n  }>;\r\n  alerts: Array<{\r\n    level: AlertLevel;\r\n    message: string;\r\n    triggeredAt: Date;\r\n    acknowledged: boolean;\r\n  }>;\r\n}\r\n\r\nexport interface ComplianceAlert {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  level: AlertLevel;\r\n  category: MetricCategory;\r\n  triggeredAt: Date;\r\n  acknowledged: boolean;\r\n  acknowledgedBy?: string;\r\n  acknowledgedAt?: Date;\r\n  resolved: boolean;\r\n  resolvedBy?: string;\r\n  resolvedAt?: Date;\r\n  affectedMetrics: string[];\r\n  recommendedActions: string[];\r\n  escalationLevel: number;\r\n  autoResolved: boolean;\r\n}\r\n\r\nexport interface ComplianceReport {\r\n  id: string;\r\n  organizationId: string;\r\n  type: 'MONTHLY' | 'QUARTERLY' | 'ANNUAL' | 'ADHOC';\r\n  period: {\r\n    start: Date;\r\n    end: Date;\r\n  };\r\n  generatedAt: Date;\r\n  generatedBy: string;\r\n  status: 'DRAFT' | 'REVIEW' | 'APPROVED' | 'PUBLISHED';\r\n  summary: {\r\n    overallScore: number;\r\n    complianceStatus: 'COMPLIANT' | 'NON_COMPLIANT' | 'PARTIALLY_COMPLIANT';\r\n    criticalIssues: number;\r\n    recommendations: number;\r\n    improvements: number;\r\n  };\r\n  sections: Array<{\r\n    title: string;\r\n    content: string;\r\n    metrics: ComplianceMetric[];\r\n    charts: Array<{\r\n      type: 'LINE' | 'BAR' | 'PIE' | 'GAUGE';\r\n      title: string;\r\n      data: any;\r\n    }>;\r\n    findings: Array<{\r\n      severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n      description: string;\r\n      recommendation: string;\r\n      dueDate: Date;\r\n    }>;\r\n  }>;\r\n  approvals: Array<{\r\n    role: string;\r\n    name: string;\r\n    approvedAt: Date;\r\n    comments?: string;\r\n  }>;\r\n  distribution: {\r\n    internal: boolean;\r\n    customers: boolean;\r\n    public: boolean;\r\n    regulators: boolean;\r\n  };\r\n}\r\n\r\nexport interface DashboardConfiguration {\r\n  id: string;\r\n  organizationId: string;\r\n  type: DashboardType;\r\n  name: string;\r\n  description: string;\r\n  layout: {\r\n    columns: number;\r\n    widgets: Array<{\r\n      id: string;\r\n      type: 'METRIC' | 'CHART' | 'ALERT' | 'REPORT' | 'TABLE';\r\n      title: string;\r\n      position: {\r\n        x: number;\r\n        y: number;\r\n        width: number;\r\n        height: number;\r\n      };\r\n      config: Record<string, any>;\r\n      dataSource: string;\r\n      refreshInterval: number;\r\n    }>;\r\n  };\r\n  permissions: {\r\n    viewRoles: string[];\r\n    editRoles: string[];\r\n    shareRoles: string[];\r\n  };\r\n  branding: {\r\n    logo?: string;\r\n    colors: {\r\n      primary: string;\r\n      secondary: string;\r\n      accent: string;\r\n      background: string;\r\n    };\r\n    fonts: {\r\n      heading: string;\r\n      body: string;\r\n    };\r\n  };\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n/**\r\n * CRITICAL: Compliance Dashboard Manager\r\n * \r\n * Provides customer-facing compliance dashboards with real-time metrics,\r\n * alerts, and comprehensive reporting capabilities.\r\n */\r\nexport class ComplianceDashboardManager {\r\n  private static instance: ComplianceDashboardManager;\r\n  private auditLogger: any;\r\n  private metrics: Map<string, ComplianceMetric> = new Map();\r\n  private alerts: Map<string, ComplianceAlert> = new Map();\r\n  private reports: Map<string, ComplianceReport> = new Map();\r\n  private configurations: Map<string, DashboardConfiguration> = new Map();\r\n  private updateInterval: NodeJS.Timeout | null = null;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.initializeDefaultMetrics();\r\n    this.startPeriodicUpdates();\r\n  }\r\n\r\n  static getInstance(): ComplianceDashboardManager {\r\n    if (!ComplianceDashboardManager.instance) {\r\n      ComplianceDashboardManager.instance = new ComplianceDashboardManager();\r\n    }\r\n    return ComplianceDashboardManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create compliance dashboard configuration\r\n   */\r\n  async createDashboardConfiguration(\r\n    organizationId: string,\r\n    type: DashboardType,\r\n    name: string,\r\n    description: string,\r\n    createdBy: string\r\n  ): Promise<string> {\r\n    const configId = this.generateConfigId();\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Create dashboard configuration\r\n      const config: DashboardConfiguration = {\r\n        id: configId,\r\n        organizationId,\r\n        type,\r\n        name,\r\n        description,\r\n        layout: await this.generateDefaultLayout(type),\r\n        permissions: this.generateDefaultPermissions(type),\r\n        branding: this.generateDefaultBranding(),\r\n        createdAt: timestamp,\r\n        updatedAt: timestamp\r\n      };\r\n\r\n      this.configurations.set(configId, config);\r\n\r\n      // CRITICAL: Log configuration creation\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: createdBy,\r\n        action: 'DASHBOARD_CONFIGURATION_CREATED',\r\n        resourceType: 'DASHBOARD_CONFIGURATION',\r\n        resourceId: configId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          organizationId,\r\n          type,\r\n          name,\r\n          widgetCount: config.layout.widgets.length\r\n        }\r\n      });\r\n\r\n      logger.info('Dashboard configuration created', {\r\n        configId,\r\n        organizationId,\r\n        type,\r\n        name\r\n      });\r\n\r\n      return configId;\r\n\r\n    } catch (error) {\r\n      logger.error('Dashboard configuration creation failed', {\r\n        organizationId,\r\n        type,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update compliance metric\r\n   */\r\n  async updateComplianceMetric(\r\n    metricId: string,\r\n    value: number,\r\n    updatedBy: string\r\n  ): Promise<void> {\r\n    const metric = this.metrics.get(metricId);\r\n    if (!metric) {\r\n      throw new Error(`Metric not found: ${metricId}`);\r\n    }\r\n\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Update metric value\r\n      const previousValue = metric.value;\r\n      metric.value = value;\r\n      metric.lastUpdated = timestamp;\r\n      metric.dataPoints.push({\r\n        timestamp,\r\n        value\r\n      });\r\n\r\n      // CRITICAL: Calculate trend\r\n      if (metric.dataPoints.length >= 2) {\r\n        const recent = metric.dataPoints.slice(-2);\r\n        metric.trend = recent[1].value > recent[0].value ? 'UP' : \r\n                     recent[1].value < recent[0].value ? 'DOWN' : 'STABLE';\r\n      }\r\n\r\n      // CRITICAL: Update status\r\n      metric.status = this.calculateMetricStatus(value, metric.target);\r\n\r\n      // CRITICAL: Check for alerts\r\n      await this.checkMetricAlerts(metric);\r\n\r\n      // CRITICAL: Log metric update\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: updatedBy,\r\n        action: 'COMPLIANCE_METRIC_UPDATED',\r\n        resourceType: 'COMPLIANCE_METRIC',\r\n        resourceId: metricId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          category: metric.category,\r\n          previousValue,\r\n          newValue: value,\r\n          status: metric.status,\r\n          trend: metric.trend\r\n        }\r\n      });\r\n\r\n      logger.info('Compliance metric updated', {\r\n        metricId,\r\n        category: metric.category,\r\n        value,\r\n        status: metric.status,\r\n        trend: metric.trend\r\n      });\r\n\r\n    } catch (error) {\r\n      logger.error('Compliance metric update failed', {\r\n        metricId,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create compliance alert\r\n   */\r\n  async createComplianceAlert(\r\n    title: string,\r\n    description: string,\r\n    level: AlertLevel,\r\n    category: MetricCategory,\r\n    affectedMetrics: string[],\r\n    recommendedActions: string[],\r\n    createdBy: string\r\n  ): Promise<string> {\r\n    const alertId = this.generateAlertId();\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Create alert\r\n      const alert: ComplianceAlert = {\r\n        id: alertId,\r\n        title,\r\n        description,\r\n        level,\r\n        category,\r\n        triggeredAt: timestamp,\r\n        acknowledged: false,\r\n        resolved: false,\r\n        affectedMetrics,\r\n        recommendedActions,\r\n        escalationLevel: this.calculateEscalationLevel(level),\r\n        autoResolved: false\r\n      };\r\n\r\n      this.alerts.set(alertId, alert);\r\n\r\n      // CRITICAL: Update affected metrics\r\n      for (const metricId of affectedMetrics) {\r\n        const metric = this.metrics.get(metricId);\r\n        if (metric) {\r\n          metric.alerts.push({\r\n            level,\r\n            message: title,\r\n            triggeredAt: timestamp,\r\n            acknowledged: false\r\n          });\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Send notifications\r\n      await this.sendAlertNotifications(alert);\r\n\r\n      // CRITICAL: Log alert creation\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: createdBy,\r\n        action: 'COMPLIANCE_ALERT_CREATED',\r\n        resourceType: 'COMPLIANCE_ALERT',\r\n        resourceId: alertId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          level,\r\n          category,\r\n          affectedMetrics: affectedMetrics.length,\r\n          escalationLevel: alert.escalationLevel\r\n        }\r\n      });\r\n\r\n      logger.info('Compliance alert created', {\r\n        alertId,\r\n        title,\r\n        level,\r\n        category,\r\n        affectedMetrics: affectedMetrics.length\r\n      });\r\n\r\n      return alertId;\r\n\r\n    } catch (error) {\r\n      logger.error('Compliance alert creation failed', {\r\n        title,\r\n        level,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate compliance report\r\n   */\r\n  async generateComplianceReport(\r\n    organizationId: string,\r\n    type: ComplianceReport['type'],\r\n    period: { start: Date; end: Date },\r\n    requestedBy: string\r\n  ): Promise<string> {\r\n    const reportId = this.generateReportId();\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Generate report content\r\n      const reportContent = await this.generateReportContent(organizationId, period);\r\n\r\n      // CRITICAL: Create compliance report\r\n      const report: ComplianceReport = {\r\n        id: reportId,\r\n        organizationId,\r\n        type,\r\n        period,\r\n        generatedAt: timestamp,\r\n        generatedBy: requestedBy,\r\n        status: 'DRAFT',\r\n        summary: reportContent.summary,\r\n        sections: reportContent.sections,\r\n        approvals: [],\r\n        distribution: {\r\n          internal: true,\r\n          customers: type === 'MONTHLY' || type === 'QUARTERLY',\r\n          public: type === 'ANNUAL',\r\n          regulators: type === 'ANNUAL'\r\n        }\r\n      };\r\n\r\n      this.reports.set(reportId, report);\r\n\r\n      // CRITICAL: Log report generation\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: requestedBy,\r\n        action: 'COMPLIANCE_REPORT_GENERATED',\r\n        resourceType: 'COMPLIANCE_REPORT',\r\n        resourceId: reportId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          organizationId,\r\n          type,\r\n          period: `${period.start.toISOString()}_${period.end.toISOString()}`,\r\n          overallScore: reportContent.summary.overallScore\r\n        }\r\n      });\r\n\r\n      logger.info('Compliance report generated', {\r\n        reportId,\r\n        organizationId,\r\n        type,\r\n        overallScore: reportContent.summary.overallScore\r\n      });\r\n\r\n      return reportId;\r\n\r\n    } catch (error) {\r\n      logger.error('Compliance report generation failed', {\r\n        organizationId,\r\n        type,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get dashboard data\r\n   */\r\n  async getDashboardData(configId: string, requestedBy: string): Promise<any> {\r\n    const config = this.configurations.get(configId);\r\n    if (!config) {\r\n      throw new Error(`Dashboard configuration not found: ${configId}`);\r\n    }\r\n\r\n    try {\r\n      // CRITICAL: Check permissions\r\n      const hasPermission = await this.checkDashboardPermission(config, requestedBy, 'view');\r\n      if (!hasPermission) {\r\n        throw new Error(`Access denied to dashboard: ${configId}`);\r\n      }\r\n\r\n      // CRITICAL: Collect widget data\r\n      const widgetData = await Promise.all(\r\n        config.layout.widgets.map(async (widget) => ({\r\n          id: widget.id,\r\n          type: widget.type,\r\n          data: await this.getWidgetData(widget, config.organizationId)\r\n        }))\r\n      );\r\n\r\n      // CRITICAL: Log dashboard access\r\n      this.auditLogger.logAuthorizationDecision({\r\n        tenantId: 'system',\r\n        actorId: requestedBy,\r\n        action: 'DASHBOARD_ACCESSED',\r\n        resourceType: 'DASHBOARD_CONFIGURATION',\r\n        resourceId: configId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          organizationId: config.organizationId,\r\n          widgetCount: widgetData.length\r\n        }\r\n      });\r\n\r\n      return {\r\n        config: {\r\n          id: config.id,\r\n          name: config.name,\r\n          type: config.type,\r\n          branding: config.branding\r\n        },\r\n        widgets: widgetData,\r\n        lastUpdated: new Date()\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error('Dashboard data retrieval failed', {\r\n        configId,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get compliance metric\r\n   */\r\n  getComplianceMetric(metricId: string): ComplianceMetric | undefined {\r\n    return this.metrics.get(metricId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get compliance alert\r\n   */\r\n  getComplianceAlert(alertId: string): ComplianceAlert | undefined {\r\n    return this.alerts.get(alertId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get compliance report\r\n   */\r\n  getComplianceReport(reportId: string): ComplianceReport | undefined {\r\n    return this.reports.get(reportId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get dashboard configuration\r\n   */\r\n  getDashboardConfiguration(configId: string): DashboardConfiguration | undefined {\r\n    return this.configurations.get(configId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get dashboard statistics\r\n   */\r\n  getDashboardStatistics(): {\r\n    totalMetrics: number;\r\n    totalAlerts: number;\r\n    totalReports: number;\r\n    totalConfigurations: number;\r\n    activeAlerts: number;\r\n    criticalAlerts: number;\r\n    averageMetricScore: number;\r\n    byCategory: Record<string, number>;\r\n    byStatus: Record<string, number>;\r\n  } {\r\n    const metrics = Array.from(this.metrics.values());\r\n    const alerts = Array.from(this.alerts.values());\r\n    const reports = Array.from(this.reports.values());\r\n    const configs = Array.from(this.configurations.values());\r\n\r\n    const byCategory: Record<string, number> = {};\r\n    const byStatus: Record<string, number> = {};\r\n\r\n    for (const metric of metrics) {\r\n      byCategory[metric.category] = (byCategory[metric.category] || 0) + 1;\r\n      byStatus[metric.status] = (byStatus[metric.status] || 0) + 1;\r\n    }\r\n\r\n    const averageMetricScore = metrics.length > 0\r\n      ? metrics.reduce((sum, m) => sum + m.value, 0) / metrics.length\r\n      : 0;\r\n\r\n    return {\r\n      totalMetrics: metrics.length,\r\n      totalAlerts: alerts.length,\r\n      totalReports: reports.length,\r\n      totalConfigurations: configs.length,\r\n      activeAlerts: alerts.filter(a => !a.resolved).length,\r\n      criticalAlerts: alerts.filter(a => a.level === 'CRITICAL' && !a.resolved).length,\r\n      averageMetricScore,\r\n      byCategory,\r\n      byStatus\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize default metrics\r\n   */\r\n  private async initializeDefaultMetrics(): Promise<void> {\r\n    const timestamp = new Date();\r\n\r\n    const defaultMetrics: ComplianceMetric[] = [\r\n      {\r\n        id: 'security_score',\r\n        name: 'Security Score',\r\n        category: 'SECURITY',\r\n        value: 97.3,\r\n        target: 95.0,\r\n        unit: '%',\r\n        trend: 'UP',\r\n        lastUpdated: timestamp,\r\n        status: 'HEALTHY',\r\n        description: 'Overall security posture score based on vulnerability assessments',\r\n        calculation: 'Weighted average of security controls',\r\n        dataPoints: [{\r\n          timestamp,\r\n          value: 97.3\r\n        }],\r\n        alerts: []\r\n      },\r\n      {\r\n        id: 'privacy_compliance',\r\n        name: 'Privacy Compliance',\r\n        category: 'PRIVACY',\r\n        value: 99.1,\r\n        target: 98.0,\r\n        unit: '%',\r\n        trend: 'STABLE',\r\n        lastUpdated: timestamp,\r\n        status: 'HEALTHY',\r\n        description: 'GDPR and CCPA compliance score',\r\n        calculation: 'Privacy control effectiveness measurement',\r\n        dataPoints: [{\r\n          timestamp,\r\n          value: 99.1\r\n        }],\r\n        alerts: []\r\n      },\r\n      {\r\n        id: 'uptime_percentage',\r\n        name: 'Service Uptime',\r\n        category: 'AVAILABILITY',\r\n        value: 99.97,\r\n        target: 99.9,\r\n        unit: '%',\r\n        trend: 'STABLE',\r\n        lastUpdated: timestamp,\r\n        status: 'HEALTHY',\r\n        description: 'Service availability over the last 30 days',\r\n        calculation: 'Available time / Total time * 100',\r\n        dataPoints: [{\r\n          timestamp,\r\n          value: 99.97\r\n        }],\r\n        alerts: []\r\n      },\r\n      {\r\n        id: 'compliance_score',\r\n        name: 'Compliance Score',\r\n        category: 'COMPLIANCE',\r\n        value: 98.4,\r\n        target: 95.0,\r\n        unit: '%',\r\n        trend: 'UP',\r\n        lastUpdated: timestamp,\r\n        status: 'HEALTHY',\r\n        description: 'Overall compliance score across all frameworks',\r\n        calculation: 'Framework compliance weighted average',\r\n        dataPoints: [{\r\n          timestamp,\r\n          value: 98.4\r\n        }],\r\n        alerts: []\r\n      },\r\n      {\r\n        id: 'governance_effectiveness',\r\n        name: 'Governance Effectiveness',\r\n        category: 'GOVERNANCE',\r\n        value: 96.8,\r\n        target: 90.0,\r\n        unit: '%',\r\n        trend: 'UP',\r\n        lastUpdated: timestamp,\r\n        status: 'HEALTHY',\r\n        description: 'Governance process effectiveness measurement',\r\n        calculation: 'Policy compliance and enforcement metrics',\r\n        dataPoints: [{\r\n          timestamp,\r\n          value: 96.8\r\n        }],\r\n        alerts: []\r\n      }\r\n    ];\r\n\r\n    for (const metric of defaultMetrics) {\r\n      this.metrics.set(metric.id, metric);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start periodic updates\r\n   */\r\n  private startPeriodicUpdates(): void {\r\n    this.updateInterval = setInterval(async () => {\r\n      try {\r\n        await this.updateAllMetrics();\r\n        await this.checkAlertEscalations();\r\n        await this.cleanupOldData();\r\n      } catch (error) {\r\n        logger.error('Periodic dashboard update failed', {\r\n          error: (error as Error).message\r\n        });\r\n      }\r\n    }, 300000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update all metrics\r\n   */\r\n  private async updateAllMetrics(): Promise<void> {\r\n    const metrics = Array.from(this.metrics.values());\r\n\r\n    for (const metric of metrics) {\r\n      try {\r\n        // Simulate metric updates\r\n        const variation = (Math.random() - 0.5) * 2; // 1% variation\r\n        const newValue = Math.max(0, Math.min(100, metric.value + variation));\r\n        \r\n        await this.updateComplianceMetric(metric.id, newValue, 'system');\r\n      } catch (error) {\r\n        logger.error('Metric update failed', {\r\n          metricId: metric.id,\r\n          error: (error as Error).message\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check alert escalations\r\n   */\r\n  private async checkAlertEscalations(): Promise<void> {\r\n    const alerts = Array.from(this.alerts.values())\r\n      .filter(a => !a.acknowledged && !a.resolved);\r\n\r\n    for (const alert of alerts) {\r\n      const timeSinceTriggered = Date.now() - alert.triggeredAt.getTime();\r\n      \r\n      // Escalate based on time and severity\r\n      if (timeSinceTriggered > (24 * 60 * 60 * 1000) && alert.escalationLevel < 3) { // 24 hours\r\n        alert.escalationLevel++;\r\n        await this.escalateAlert(alert);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup old data\r\n   */\r\n  private async cleanupOldData(): Promise<void> {\r\n    const cutoffDate = new Date(Date.now() - (90 * 24 * 60 * 60 * 1000)); // 90 days\r\n\r\n    // Clean up old data points\r\n    for (const metric of this.metrics.values()) {\r\n      metric.dataPoints = metric.dataPoints.filter(dp => dp.timestamp > cutoffDate);\r\n    }\r\n\r\n    // Clean up old alerts\r\n    for (const alert of this.alerts.values()) {\r\n      if (alert.resolved && alert.resolvedAt && alert.resolvedAt < cutoffDate) {\r\n        this.alerts.delete(alert.id);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate default layout\r\n   */\r\n  private async generateDefaultLayout(type: DashboardType): Promise<DashboardConfiguration['layout']> {\r\n    const layouts = {\r\n      EXECUTIVE: {\r\n        columns: 3,\r\n        widgets: [\r\n          {\r\n            id: 'overall_score',\r\n            type: 'GAUGE',\r\n            title: 'Overall Compliance Score',\r\n            position: { x: 0, y: 0, width: 1, height: 1 },\r\n            config: { min: 0, max: 100, thresholds: [80, 90, 95] },\r\n            dataSource: 'compliance_score',\r\n            refreshInterval: 300000\r\n          },\r\n          {\r\n            id: 'security_status',\r\n            type: 'METRIC',\r\n            title: 'Security Status',\r\n            position: { x: 1, y: 0, width: 1, height: 1 },\r\n            config: { showTrend: true, showTarget: true },\r\n            dataSource: 'security_score',\r\n            refreshInterval: 300000\r\n          },\r\n          {\r\n            id: 'active_alerts',\r\n            type: 'ALERT',\r\n            title: 'Active Alerts',\r\n            position: { x: 2, y: 0, width: 1, height: 1 },\r\n            config: { maxItems: 5, showSeverity: true },\r\n            dataSource: 'alerts',\r\n            refreshInterval: 60000\r\n          }\r\n        ]\r\n      },\r\n      TECHNICAL: {\r\n        columns: 4,\r\n        widgets: [\r\n          {\r\n            id: 'vulnerability_scan',\r\n            type: 'CHART',\r\n            title: 'Vulnerability Scan Results',\r\n            position: { x: 0, y: 0, width: 2, height: 2 },\r\n            config: { chartType: 'BAR', groupBy: 'severity' },\r\n            dataSource: 'security_scans',\r\n            refreshInterval: 3600000\r\n          },\r\n          {\r\n            id: 'compliance_trends',\r\n            type: 'CHART',\r\n            title: 'Compliance Trends',\r\n            position: { x: 2, y: 0, width: 2, height: 2 },\r\n            config: { chartType: 'LINE', timeRange: '30d' },\r\n            dataSource: 'compliance_metrics',\r\n            refreshInterval: 300000\r\n          }\r\n        ]\r\n      },\r\n      LEGAL: {\r\n        columns: 2,\r\n        widgets: [\r\n          {\r\n            id: 'legal_compliance',\r\n            type: 'TABLE',\r\n            title: 'Legal Compliance Status',\r\n            position: { x: 0, y: 0, width: 2, height: 2 },\r\n            config: { columns: ['framework', 'status', 'score', 'lastAssessed'] },\r\n            dataSource: 'legal_compliance',\r\n            refreshInterval: 3600000\r\n          }\r\n        ]\r\n      },\r\n      CUSTOMER: {\r\n        columns: 2,\r\n        widgets: [\r\n          {\r\n            id: 'trust_score',\r\n            type: 'GAUGE',\r\n            title: 'Trust Score',\r\n            position: { x: 0, y: 0, width: 1, height: 1 },\r\n            config: { min: 0, max: 100, showLabel: true },\r\n            dataSource: 'trust_score',\r\n            refreshInterval: 300000\r\n          },\r\n          {\r\n            id: 'certifications',\r\n            type: 'TABLE',\r\n            title: 'Certifications',\r\n            position: { x: 1, y: 0, width: 1, height: 1 },\r\n            config: { showStatus: true, showExpiry: true },\r\n            dataSource: 'certifications',\r\n            refreshInterval: 86400000\r\n          }\r\n        ]\r\n      }\r\n    };\r\n\r\n    return layouts[type] || layouts.EXECUTIVE;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate default permissions\r\n   */\r\n  private generateDefaultPermissions(type: DashboardType): DashboardConfiguration['permissions'] {\r\n    const permissions = {\r\n      EXECUTIVE: {\r\n        viewRoles: ['EXECUTIVE', 'ADMIN'],\r\n        editRoles: ['ADMIN'],\r\n        shareRoles: ['EXECUTIVE', 'ADMIN']\r\n      },\r\n      TECHNICAL: {\r\n        viewRoles: ['TECHNICAL', 'ADMIN', 'EXECUTIVE'],\r\n        editRoles: ['ADMIN', 'TECHNICAL_LEAD'],\r\n        shareRoles: ['TECHNICAL', 'ADMIN']\r\n      },\r\n      LEGAL: {\r\n        viewRoles: ['LEGAL', 'ADMIN', 'EXECUTIVE'],\r\n        editRoles: ['ADMIN', 'LEGAL_COUNSEL'],\r\n        shareRoles: ['LEGAL', 'ADMIN']\r\n      },\r\n      CUSTOMER: {\r\n        viewRoles: ['CUSTOMER', 'PARTNER', 'PUBLIC'],\r\n        editRoles: ['ADMIN'],\r\n        shareRoles: ['PUBLIC']\r\n      }\r\n    };\r\n\r\n    return permissions[type] || permissions.EXECUTIVE;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate default branding\r\n   */\r\n  private generateDefaultBranding(): DashboardConfiguration['branding'] {\r\n    return {\r\n      colors: {\r\n        primary: '#2563eb',\r\n        secondary: '#64748b',\r\n        accent: '#10b981',\r\n        background: '#f8fafc'\r\n      },\r\n      fonts: {\r\n        heading: 'Inter, sans-serif',\r\n        body: 'Inter, sans-serif'\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate metric status\r\n   */\r\n  private calculateMetricStatus(value: number, target: number): ComplianceMetric['status'] {\r\n    if (value >= target) return 'HEALTHY';\r\n    if (value >= target * 0.9) return 'WARNING';\r\n    return 'CRITICAL';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check metric alerts\r\n   */\r\n  private async checkMetricAlerts(metric: ComplianceMetric): Promise<void> {\r\n    const threshold = metric.target * 0.9; // 90% of target\r\n    \r\n    if (metric.value < threshold && metric.alerts.length === 0) {\r\n      await this.createComplianceAlert(\r\n        `Metric Threshold Breach: ${metric.name}`,\r\n        `${metric.name} has fallen below the acceptable threshold of ${threshold}%. Current value: ${metric.value}%`,\r\n        metric.value < threshold * 0.8 ? 'CRITICAL' : 'WARNING',\r\n        metric.category,\r\n        [metric.id],\r\n        [`Investigate ${metric.name} degradation`, `Implement corrective actions`],\r\n        'system'\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Send alert notifications\r\n   */\r\n  private async sendAlertNotifications(alert: ComplianceAlert): Promise<void> {\r\n    // In a real implementation, send notifications via various channels\r\n    logger.info('Alert notifications sent', {\r\n      alertId: alert.id,\r\n      level: alert.level,\r\n      category: alert.category\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate escalation level\r\n   */\r\n  private calculateEscalationLevel(level: AlertLevel): number {\r\n    switch (level) {\r\n      case 'INFO': return 1;\r\n      case 'WARNING': return 2;\r\n      case 'ERROR': return 3;\r\n      case 'CRITICAL': return 4;\r\n      default: return 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Escalate alert\r\n   */\r\n  private async escalateAlert(alert: ComplianceAlert): Promise<void> {\r\n    // In a real implementation, escalate alert to higher level\r\n    logger.warn('Alert escalated', {\r\n      alertId: alert.id,\r\n      escalationLevel: alert.escalationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate report content\r\n   */\r\n  private async generateReportContent(organizationId: string, period: { start: Date; end: Date }): Promise<any> {\r\n    // In a real implementation, generate comprehensive report content\r\n    return {\r\n      summary: {\r\n        overallScore: 98.4,\r\n        complianceStatus: 'COMPLIANT',\r\n        criticalIssues: 0,\r\n        recommendations: 3,\r\n        improvements: 7\r\n      },\r\n      sections: [\r\n        {\r\n          title: 'Executive Summary',\r\n          content: 'Overall compliance status and key metrics',\r\n          metrics: [],\r\n          charts: [],\r\n          findings: []\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check dashboard permission\r\n   */\r\n  private async checkDashboardPermission(\r\n    config: DashboardConfiguration,\r\n    userId: string,\r\n    action: 'view' | 'edit' | 'share'\r\n  ): Promise<boolean> {\r\n    // In a real implementation, check user permissions\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get widget data\r\n   */\r\n  private async getWidgetData(widget: any, organizationId: string): Promise<any> {\r\n    switch (widget.type) {\r\n      case 'METRIC':\r\n        const metric = this.metrics.get(widget.dataSource);\r\n        return metric || null;\r\n      \r\n      case 'CHART':\r\n        return await this.getChartData(widget.dataSource, widget.config);\r\n      \r\n      case 'ALERT':\r\n        const alerts = Array.from(this.alerts.values())\r\n          .filter(a => !a.resolved)\r\n          .slice(0, widget.config.maxItems || 10);\r\n        return alerts;\r\n      \r\n      case 'TABLE':\r\n        return await this.getTableData(widget.dataSource, widget.config);\r\n      \r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get chart data\r\n   */\r\n  private async getChartData(dataSource: string, config: any): Promise<any> {\r\n    // In a real implementation, get chart data based on data source\r\n    return {\r\n      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],\r\n      datasets: [{\r\n        label: 'Compliance Score',\r\n        data: [95, 96, 97, 98, 98, 99],\r\n        borderColor: '#2563eb',\r\n        backgroundColor: 'rgba(37, 99, 235, 0.1)'\r\n      }]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get table data\r\n   */\r\n  private async getTableData(dataSource: string, config: any): Promise<any> {\r\n    // In a real implementation, get table data based on data source\r\n    return [\r\n      {\r\n        framework: 'SOC 2 Type II',\r\n        status: 'Compliant',\r\n        score: 98.5,\r\n        lastAssessed: new Date()\r\n      },\r\n      {\r\n        framework: 'ISO 27001',\r\n        status: 'Compliant',\r\n        score: 96.2,\r\n        lastAssessed: new Date()\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate config ID\r\n   */\r\n  private generateConfigId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `config_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate alert ID\r\n   */\r\n  private generateAlertId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `alert_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate report ID\r\n   */\r\n  private generateReportId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `report_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global compliance dashboard manager instance\r\n */\r\nexport const complianceDashboardManager = ComplianceDashboardManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const createComplianceDashboardManager = (): ComplianceDashboardManager => {\r\n  return ComplianceDashboardManager.getInstance();\r\n};\r\n\r\nexport const createDashboardConfiguration = async (\r\n  organizationId: string,\r\n  type: DashboardType,\r\n  name: string,\r\n  description: string,\r\n  createdBy: string\r\n): Promise<string> => {\r\n  return complianceDashboardManager.createDashboardConfiguration(organizationId, type, name, description, createdBy);\r\n};\r\n\r\nexport const updateComplianceMetric = async (\r\n  metricId: string,\r\n  value: number,\r\n  updatedBy: string\r\n): Promise<void> => {\r\n  return complianceDashboardManager.updateComplianceMetric(metricId, value, updatedBy);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\compliance-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":934,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":934,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":943,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":943,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":952,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":952,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":961,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":961,"endColumn":37}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Compliance Engine\r\n// MANDATORY: Runtime enforcement of SOC 2, ISO 27001, SOX, and GDPR/CCPA controls\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { governanceModelManager } from '../governance/governance-model.js';\r\n\r\nexport type ComplianceFramework = 'SOC2' | 'ISO27001' | 'SOX' | 'GDPR' | 'CCPA';\r\nexport type ControlCategory = 'ACCESS_CONTROL' | 'SECURITY' | 'PRIVACY' | 'FINANCIAL' | 'OPERATIONAL';\r\nexport type ControlStatus = 'COMPLIANT' | 'NON_COMPLIANT' | 'PARTIALLY_COMPLIANT' | 'NOT_APPLICABLE';\r\nexport type RiskLevel = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n\r\nexport interface ComplianceControl {\r\n  id: string;\r\n  framework: ComplianceFramework;\r\n  category: ControlCategory;\r\n  controlId: string;\r\n  title: string;\r\n  description: string;\r\n  requirements: string[];\r\n  implementation: string;\r\n  evidence: string[];\r\n  status: ControlStatus;\r\n  lastAssessed: Date;\r\n  nextAssessment: Date;\r\n  riskLevel: RiskLevel;\r\n  automated: boolean;\r\n  enforcement: EnforcementRule[];\r\n}\r\n\r\nexport interface EnforcementRule {\r\n  id: string;\r\n  type: 'PREVENT' | 'DETECT' | 'CORRECT' | 'MONITOR';\r\n  condition: string;\r\n  action: string;\r\n  severity: RiskLevel;\r\n  automated: boolean;\r\n  enabled: boolean;\r\n}\r\n\r\nexport interface ComplianceCheck {\r\n  id: string;\r\n  controlId: string;\r\n  framework: ComplianceFramework;\r\n  category: ControlCategory;\r\n  checkType: 'AUTOMATED' | 'MANUAL' | 'HYBRID';\r\n  description: string;\r\n  procedure: string;\r\n  frequency: 'REAL_TIME' | 'HOURLY' | 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'QUARTERLY' | 'ANNUALLY';\r\n  threshold: any;\r\n  lastRun: Date;\r\n  nextRun: Date;\r\n  status: 'PASS' | 'FAIL' | 'WARNING' | 'NOT_RUN';\r\n  result: any;\r\n  evidence: string[];\r\n}\r\n\r\nexport interface ComplianceViolation {\r\n  id: string;\r\n  controlId: string;\r\n  framework: ComplianceFramework;\r\n  category: ControlCategory;\r\n  severity: RiskLevel;\r\n  description: string;\r\n  detectedAt: Date;\r\n  status: 'OPEN' | 'IN_PROGRESS' | 'RESOLVED' | 'FALSE_POSITIVE';\r\n  assignedTo?: string;\r\n  resolvedAt?: Date;\r\n  resolution?: string;\r\n  impact: string;\r\n  remediation: string;\r\n  evidence: string[];\r\n}\r\n\r\nexport interface ComplianceReport {\r\n  id: string;\r\n  framework: ComplianceFramework;\r\n  reportType: 'ASSESSMENT' | 'AUDIT' | 'MONITORING' | 'INCIDENT';\r\n  period: {\r\n    start: Date;\r\n    end: Date;\r\n  };\r\n  overallStatus: ControlStatus;\r\n  totalControls: number;\r\n  compliantControls: number;\r\n  nonCompliantControls: number;\r\n  partiallyCompliantControls: number;\r\n  notApplicableControls: number;\r\n  violations: ComplianceViolation[];\r\n  recommendations: string[];\r\n  generatedAt: Date;\r\n  nextReport: Date;\r\n}\r\n\r\n/**\r\n * CRITICAL: Compliance Engine Manager\r\n * \r\n * This class implements runtime enforcement of compliance controls for\r\n * SOC 2, ISO 27001, SOX, and GDPR/CCPA frameworks.\r\n */\r\nexport class ComplianceEngineManager {\r\n  private static instance: ComplianceEngineManager;\r\n  private auditLogger: any;\r\n  private controls: Map<string, ComplianceControl> = new Map();\r\n  private checks: Map<string, ComplianceCheck> = new Map();\r\n  private violations: Map<string, ComplianceViolation> = new Map();\r\n  private monitoringInterval: NodeJS.Timeout;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.initializeControls();\r\n    this.initializeChecks();\r\n    this.startComplianceMonitoring();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): ComplianceEngineManager {\r\n    if (!ComplianceEngineManager.instance) {\r\n      ComplianceEngineManager.instance = new ComplianceEngineManager();\r\n    }\r\n    return ComplianceEngineManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check compliance for action\r\n   */\r\n  async checkCompliance(\r\n    action: string,\r\n    context: Record<string, any>,\r\n    frameworks: ComplianceFramework[] = ['SOC2', 'ISO27001', 'SOX', 'GDPR', 'CCPA']\r\n  ): Promise<{\r\n    compliant: boolean;\r\n    violations: ComplianceViolation[];\r\n    requiredActions: string[];\r\n    riskLevel: RiskLevel;\r\n    frameworks: ComplianceFramework[];\r\n  }> {\r\n    const violations: ComplianceViolation[] = [];\r\n    const requiredActions: string[] = [];\r\n    let maxRiskLevel: RiskLevel = 'LOW';\r\n\r\n    // CRITICAL: Check each framework\r\n    for (const framework of frameworks) {\r\n      const frameworkControls = this.getControlsByFramework(framework);\r\n      \r\n      for (const control of frameworkControls) {\r\n        if (this.isControlApplicable(control, action, context)) {\r\n          const result = await this.evaluateControl(control, action, context);\r\n          \r\n          if (!result.compliant) {\r\n            violations.push(...result.violations);\r\n            requiredActions.push(...result.requiredActions);\r\n            \r\n            // CRITICAL: Update max risk level\r\n            maxRiskLevel = this.getHigherRiskLevel(maxRiskLevel, result.riskLevel);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const compliant = violations.length === 0;\r\n\r\n    // CRITICAL: Log compliance check\r\n    this.auditLogger.logAuthorizationDecision({\r\n      tenantId: context.tenantId || 'system',\r\n      actorId: context.actorId || 'system',\r\n      action: 'COMPLIANCE_CHECK',\r\n      resourceType: 'COMPLIANCE_CONTROL',\r\n      resourceId: action,\r\n      outcome: compliant ? 'SUCCESS' : 'FAILURE',\r\n      correlationId: this.generateCorrelationId(),\r\n      severity: maxRiskLevel,\r\n      metadata: {\r\n        action,\r\n        frameworks,\r\n        compliant,\r\n        violations: violations.length,\r\n        requiredActions: requiredActions.length,\r\n        riskLevel: maxRiskLevel\r\n      }\r\n    });\r\n\r\n    return {\r\n      compliant,\r\n      violations,\r\n      requiredActions,\r\n      riskLevel: maxRiskLevel,\r\n      frameworks\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Run compliance checks\r\n   */\r\n  async runComplianceChecks(\r\n    framework?: ComplianceFramework,\r\n    category?: ControlCategory\r\n  ): Promise<ComplianceCheck[]> {\r\n    const checksToRun: ComplianceCheck[] = [];\r\n\r\n    // CRITICAL: Determine which checks to run\r\n    for (const check of this.checks.values()) {\r\n      if (framework && check.framework !== framework) continue;\r\n      if (category && check.category !== category) continue;\r\n      \r\n      // CRITICAL: Check if it's time to run\r\n      if (new Date() >= check.nextRun) {\r\n        checksToRun.push(check);\r\n      }\r\n    }\r\n\r\n    const results: ComplianceCheck[] = [];\r\n\r\n    // CRITICAL: Run each check\r\n    for (const check of checksToRun) {\r\n      try {\r\n        const result = await this.executeComplianceCheck(check);\r\n        results.push(result);\r\n      } catch (error) {\r\n        logger.error('Compliance check execution failed', error as Error, {\r\n          checkId: check.id,\r\n          controlId: check.controlId\r\n        });\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate compliance report\r\n   */\r\n  async generateComplianceReport(\r\n    framework: ComplianceFramework,\r\n    reportType: 'ASSESSMENT' | 'AUDIT' | 'MONITORING' | 'INCIDENT',\r\n    period: { start: Date; end: Date }\r\n  ): Promise<ComplianceReport> {\r\n    const reportId = this.generateReportId();\r\n    const frameworkControls = this.getControlsByFramework(framework);\r\n    const periodViolations = this.getViolationsByPeriod(framework, period);\r\n\r\n    // CRITICAL: Calculate compliance statistics\r\n    const totalControls = frameworkControls.length;\r\n    const compliantControls = frameworkControls.filter(c => c.status === 'COMPLIANT').length;\r\n    const nonCompliantControls = frameworkControls.filter(c => c.status === 'NON_COMPLIANT').length;\r\n    const partiallyCompliantControls = frameworkControls.filter(c => c.status === 'PARTIALLY_COMPLIANT').length;\r\n    const notApplicableControls = frameworkControls.filter(c => c.status === 'NOT_APPLICABLE').length;\r\n\r\n    // CRITICAL: Determine overall status\r\n    let overallStatus: ControlStatus = 'COMPLIANT';\r\n    if (nonCompliantControls > 0) {\r\n      overallStatus = 'NON_COMPLIANT';\r\n    } else if (partiallyCompliantControls > 0) {\r\n      overallStatus = 'PARTIALLY_COMPLIANT';\r\n    }\r\n\r\n    // CRITICAL: Generate recommendations\r\n    const recommendations = this.generateRecommendations(frameworkControls, periodViolations);\r\n\r\n    const report: ComplianceReport = {\r\n      id: reportId,\r\n      framework,\r\n      reportType,\r\n      period,\r\n      overallStatus,\r\n      totalControls,\r\n      compliantControls,\r\n      nonCompliantControls,\r\n      partiallyCompliantControls,\r\n      notApplicableControls,\r\n      violations: periodViolations,\r\n      recommendations,\r\n      generatedAt: new Date(),\r\n      nextReport: this.calculateNextReportDate(reportType)\r\n    };\r\n\r\n    // CRITICAL: Log report generation\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: 'system',\r\n      actorId: 'compliance-engine',\r\n      action: 'COMPLIANCE_REPORT_GENERATED',\r\n      resourceType: 'COMPLIANCE_REPORT',\r\n      resourceId: reportId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: this.generateCorrelationId(),\r\n      severity: 'MEDIUM',\r\n      metadata: {\r\n        framework,\r\n        reportType,\r\n        overallStatus,\r\n        totalControls,\r\n        compliantControls,\r\n        nonCompliantControls,\r\n        violations: periodViolations.length\r\n      }\r\n    });\r\n\r\n    logger.info('Compliance report generated', {\r\n      reportId,\r\n      framework,\r\n      reportType,\r\n      overallStatus,\r\n      totalControls,\r\n      compliantControls\r\n    });\r\n\r\n    return report;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get compliance controls\r\n   */\r\n  getControls(\r\n    framework?: ComplianceFramework,\r\n    category?: ControlCategory,\r\n    status?: ControlStatus\r\n  ): ComplianceControl[] {\r\n    let controls = Array.from(this.controls.values());\r\n\r\n    // CRITICAL: Apply filters\r\n    if (framework) {\r\n      controls = controls.filter(c => c.framework === framework);\r\n    }\r\n    if (category) {\r\n      controls = controls.filter(c => c.category === category);\r\n    }\r\n    if (status) {\r\n      controls = controls.filter(c => c.status === status);\r\n    }\r\n\r\n    return controls;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get compliance violations\r\n   */\r\n  getViolations(\r\n    framework?: ComplianceFramework,\r\n    severity?: RiskLevel,\r\n    status?: string,\r\n    limit?: number\r\n  ): ComplianceViolation[] {\r\n    let violations = Array.from(this.violations.values());\r\n\r\n    // CRITICAL: Apply filters\r\n    if (framework) {\r\n      violations = violations.filter(v => v.framework === framework);\r\n    }\r\n    if (severity) {\r\n      violations = violations.filter(v => v.severity === severity);\r\n    }\r\n    if (status) {\r\n      violations = violations.filter(v => v.status === status);\r\n    }\r\n\r\n    // CRITICAL: Sort by detection date (newest first)\r\n    violations = violations.sort((a, b) => b.detectedAt.getTime() - a.detectedAt.getTime());\r\n\r\n    // CRITICAL: Apply limit\r\n    if (limit) {\r\n      violations = violations.slice(0, limit);\r\n    }\r\n\r\n    return violations;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update control status\r\n   */\r\n  async updateControlStatus(\r\n    controlId: string,\r\n    status: ControlStatus,\r\n    evidence: string[] = [],\r\n    rationale: string = ''\r\n  ): Promise<void> {\r\n    const control = this.controls.get(controlId);\r\n    if (!control) {\r\n      throw new Error(`Control ${controlId} not found`);\r\n    }\r\n\r\n    const previousStatus = control.status;\r\n    control.status = status;\r\n    control.lastAssessed = new Date();\r\n    control.evidence = [...control.evidence, ...evidence];\r\n\r\n    // CRITICAL: Log status update\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: 'system',\r\n      actorId: 'compliance-engine',\r\n      action: 'CONTROL_STATUS_UPDATED',\r\n      resourceType: 'COMPLIANCE_CONTROL',\r\n      resourceId: controlId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: this.generateCorrelationId(),\r\n      severity: 'MEDIUM',\r\n      metadata: {\r\n        controlId,\r\n        previousStatus,\r\n        newStatus: status,\r\n        evidenceCount: evidence.length,\r\n        rationale\r\n      }\r\n    });\r\n\r\n    logger.info('Control status updated', {\r\n      controlId,\r\n      previousStatus,\r\n      newStatus: status\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Evaluate control\r\n   */\r\n  private async evaluateControl(\r\n    control: ComplianceControl,\r\n    action: string,\r\n    context: Record<string, any>\r\n  ): Promise<{\r\n    compliant: boolean;\r\n    violations: ComplianceViolation[];\r\n    requiredActions: string[];\r\n    riskLevel: RiskLevel;\r\n  }> {\r\n    const violations: ComplianceViolation[] = [];\r\n    const requiredActions: string[] = [];\r\n    let compliant = true;\r\n    let maxRiskLevel: RiskLevel = 'LOW';\r\n\r\n    // CRITICAL: Evaluate enforcement rules\r\n    for (const rule of control.enforcement) {\r\n      if (!rule.enabled) continue;\r\n\r\n      const result = await this.evaluateEnforcementRule(rule, action, context);\r\n      \r\n      if (!result.compliant) {\r\n        compliant = false;\r\n        violations.push(...result.violations);\r\n        requiredActions.push(...result.requiredActions);\r\n        maxRiskLevel = this.getHigherRiskLevel(maxRiskLevel, result.riskLevel);\r\n      }\r\n    }\r\n\r\n    return {\r\n      compliant,\r\n      violations,\r\n      requiredActions,\r\n      riskLevel: maxRiskLevel\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Evaluate enforcement rule\r\n   */\r\n  private async evaluateEnforcementRule(\r\n    rule: EnforcementRule,\r\n    action: string,\r\n    context: Record<string, any>\r\n  ): Promise<{\r\n    compliant: boolean;\r\n    violations: ComplianceViolation[];\r\n    requiredActions: string[];\r\n    riskLevel: RiskLevel;\r\n  }> {\r\n    // CRITICAL: Simplified rule evaluation\r\n    // In production, this would use a sophisticated rule engine\r\n    const violations: ComplianceViolation[] = [];\r\n    const requiredActions: string[] = [];\r\n\r\n    // CRITICAL: Check if rule condition is met\r\n    const conditionMet = this.evaluateCondition(rule.condition, action, context);\r\n    \r\n    if (!conditionMet) {\r\n      const violation: ComplianceViolation = {\r\n        id: this.generateViolationId(),\r\n        controlId: rule.id,\r\n        framework: 'SOC2', // This would be determined from the control\r\n        category: 'ACCESS_CONTROL',\r\n        severity: rule.severity,\r\n        description: `Enforcement rule violation: ${rule.description}`,\r\n        detectedAt: new Date(),\r\n        status: 'OPEN',\r\n        impact: 'Potential compliance violation',\r\n        remediation: rule.action,\r\n        evidence: [`Action: ${action}`, `Context: ${JSON.stringify(context)}`]\r\n      };\r\n\r\n      violations.push(violation);\r\n      requiredActions.push(rule.action);\r\n    }\r\n\r\n    return {\r\n      compliant: conditionMet,\r\n      violations,\r\n      requiredActions,\r\n      riskLevel: rule.severity\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute compliance check\r\n   */\r\n  private async executeComplianceCheck(check: ComplianceCheck): Promise<ComplianceCheck> {\r\n    // CRITICAL: Update check timing\r\n    check.lastRun = new Date();\r\n    check.nextRun = this.calculateNextRunDate(check.frequency);\r\n\r\n    // CRITICAL: Execute check based on type\r\n    let result: any;\r\n    let status: 'PASS' | 'FAIL' | 'WARNING' | 'NOT_RUN' = 'NOT_RUN';\r\n\r\n    try {\r\n      switch (check.checkType) {\r\n        case 'AUTOMATED':\r\n          result = await this.executeAutomatedCheck(check);\r\n          break;\r\n        case 'MANUAL':\r\n          result = await this.executeManualCheck(check);\r\n          break;\r\n        case 'HYBRID':\r\n          result = await this.executeHybridCheck(check);\r\n          break;\r\n      }\r\n\r\n      status = this.determineCheckStatus(result, check.threshold);\r\n      check.result = result;\r\n      check.status = status;\r\n\r\n    } catch (error) {\r\n      status = 'FAIL';\r\n      check.result = { error: (error as Error).message };\r\n      check.status = status;\r\n    }\r\n\r\n    // CRITICAL: Log check execution\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: 'system',\r\n      actorId: 'compliance-engine',\r\n      action: 'COMPLIANCE_CHECK_EXECUTED',\r\n      resourceType: 'COMPLIANCE_CHECK',\r\n      resourceId: check.id,\r\n      outcome: status === 'PASS' ? 'SUCCESS' : 'FAILURE',\r\n      correlationId: this.generateCorrelationId(),\r\n      severity: status === 'FAIL' ? 'HIGH' : 'MEDIUM',\r\n      metadata: {\r\n        checkId: check.id,\r\n        controlId: check.controlId,\r\n        framework: check.framework,\r\n        checkType: check.checkType,\r\n        status,\r\n        result\r\n      }\r\n    });\r\n\r\n    return check;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute automated check\r\n   */\r\n  private async executeAutomatedCheck(check: ComplianceCheck): Promise<any> {\r\n    // CRITICAL: Simplified automated check execution\r\n    // In production, this would run actual compliance checks\r\n    return {\r\n      timestamp: new Date(),\r\n      result: 'PASS',\r\n      details: 'Automated check completed successfully',\r\n      metrics: {\r\n        executionTime: 150,\r\n        resourcesChecked: 42\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute manual check\r\n   */\r\n  private async executeManualCheck(check: ComplianceCheck): Promise<any> {\r\n    // CRITICAL: Manual checks require human intervention\r\n    return {\r\n      timestamp: new Date(),\r\n      result: 'PENDING',\r\n      details: 'Manual check requires human review',\r\n      assignedTo: 'compliance-team',\r\n      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute hybrid check\r\n   */\r\n  private async executeHybridCheck(check: ComplianceCheck): Promise<any> {\r\n    // CRITICAL: Hybrid checks combine automated and manual components\r\n    const automatedResult = await this.executeAutomatedCheck(check);\r\n    \r\n    return {\r\n      timestamp: new Date(),\r\n      result: 'PARTIAL',\r\n      details: 'Hybrid check - automated component completed',\r\n      automatedResult,\r\n      manualComponent: 'PENDING',\r\n      assignedTo: 'compliance-team'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if control is applicable\r\n   */\r\n  private isControlApplicable(control: ComplianceControl, action: string, context: Record<string, any>): boolean {\r\n    // CRITICAL: Simplified applicability check\r\n    // In production, this would use sophisticated logic\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Evaluate condition\r\n   */\r\n  private evaluateCondition(condition: string, action: string, context: Record<string, any>): boolean {\r\n    // CRITICAL: Simplified condition evaluation\r\n    // In production, this would use a rule engine\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Determine check status\r\n   */\r\n  private determineCheckStatus(result: any, threshold: any): 'PASS' | 'FAIL' | 'WARNING' | 'NOT_RUN' {\r\n    // CRITICAL: Simplified status determination\r\n    // In production, this would use sophisticated logic\r\n    if (result.result === 'PASS') return 'PASS';\r\n    if (result.result === 'FAIL') return 'FAIL';\r\n    if (result.result === 'PENDING') return 'WARNING';\r\n    return 'NOT_RUN';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get higher risk level\r\n   */\r\n  private getHigherRiskLevel(current: RiskLevel, newLevel: RiskLevel): RiskLevel {\r\n    const levels = { LOW: 0, MEDIUM: 1, HIGH: 2, CRITICAL: 3 };\r\n    return levels[newLevel] > levels[current] ? newLevel : current;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get controls by framework\r\n   */\r\n  private getControlsByFramework(framework: ComplianceFramework): ComplianceControl[] {\r\n    return Array.from(this.controls.values()).filter(c => c.framework === framework);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get violations by period\r\n   */\r\n  private getViolationsByPeriod(framework: ComplianceFramework, period: { start: Date; end: Date }): ComplianceViolation[] {\r\n    return Array.from(this.violations.values()).filter(v => \r\n      v.framework === framework &&\r\n      v.detectedAt >= period.start &&\r\n      v.detectedAt <= period.end\r\n    );\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate recommendations\r\n   */\r\n  private generateRecommendations(controls: ComplianceControl[], violations: ComplianceViolation[]): string[] {\r\n    const recommendations: string[] = [];\r\n\r\n    // CRITICAL: Analyze violations and generate recommendations\r\n    const violationCounts = new Map<string, number>();\r\n    for (const violation of violations) {\r\n      violationCounts.set(violation.controlId, (violationCounts.get(violation.controlId) || 0) + 1);\r\n    }\r\n\r\n    // CRITICAL: Generate recommendations based on violation patterns\r\n    for (const [controlId, count] of violationCounts.entries()) {\r\n      if (count > 5) {\r\n        recommendations.push(`Control ${controlId} has ${count} violations - consider strengthening controls`);\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Add general recommendations\r\n    if (violations.length > 0) {\r\n      recommendations.push('Review and update compliance policies');\r\n      recommendations.push('Increase monitoring frequency for high-risk controls');\r\n      recommendations.push('Conduct additional staff training');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate next report date\r\n   */\r\n  private calculateNextReportDate(reportType: string): Date {\r\n    const now = new Date();\r\n    \r\n    switch (reportType) {\r\n      case 'ASSESSMENT':\r\n        return new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000); // 90 days\r\n      case 'AUDIT':\r\n        return new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 year\r\n      case 'MONITORING':\r\n        return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days\r\n      case 'INCIDENT':\r\n        return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // 7 days\r\n      default:\r\n        return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate next run date\r\n   */\r\n  private calculateNextRunDate(frequency: string): Date {\r\n    const now = new Date();\r\n    \r\n    switch (frequency) {\r\n      case 'REAL_TIME':\r\n        return new Date(now.getTime() + 60 * 1000); // 1 minute\r\n      case 'HOURLY':\r\n        return new Date(now.getTime() + 60 * 60 * 1000); // 1 hour\r\n      case 'DAILY':\r\n        return new Date(now.getTime() + 24 * 60 * 60 * 1000); // 1 day\r\n      case 'WEEKLY':\r\n        return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // 1 week\r\n      case 'MONTHLY':\r\n        return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days\r\n      case 'QUARTERLY':\r\n        return new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000); // 90 days\r\n      case 'ANNUALLY':\r\n        return new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 year\r\n      default:\r\n        return new Date(now.getTime() + 24 * 60 * 60 * 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize controls\r\n   */\r\n  private initializeControls(): void {\r\n    // CRITICAL: SOC 2 Controls\r\n    this.controls.set('SOC2-CC1.1', {\r\n      id: 'SOC2-CC1.1',\r\n      framework: 'SOC2',\r\n      category: 'SECURITY',\r\n      controlId: 'CC1.1',\r\n      title: 'Control Environment',\r\n      description: 'Demonstrates commitment to integrity and ethical values',\r\n      requirements: ['Code of conduct', 'Leadership oversight', 'Performance accountability'],\r\n      implementation: 'Governance framework with authority hierarchy',\r\n      evidence: ['Governance policies', 'Authority definitions', 'Audit trails'],\r\n      status: 'COMPLIANT',\r\n      lastAssessed: new Date(),\r\n      nextAssessed: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),\r\n      riskLevel: 'LOW',\r\n      automated: true,\r\n      enforcement: [\r\n        {\r\n          id: 'CC1.1-1',\r\n          type: 'PREVENT',\r\n          condition: 'action requires authority',\r\n          action: 'Verify authority before execution',\r\n          severity: 'HIGH',\r\n          automated: true,\r\n          enabled: true\r\n        }\r\n      ]\r\n    });\r\n\r\n    // CRITICAL: ISO 27001 Controls\r\n    this.controls.set('ISO27001-A.9.2.1', {\r\n      id: 'ISO27001-A.9.2.1',\r\n      framework: 'ISO27001',\r\n      category: 'ACCESS_CONTROL',\r\n      controlId: 'A.9.2.1',\r\n      title: 'User Registration and Deregistration',\r\n      description: 'Formal user registration and deregistration process',\r\n      requirements: ['Identity verification', 'Access approval', 'Periodic review'],\r\n      implementation: 'User management system with approval workflows',\r\n      evidence: ['User registration logs', 'Access approval records', 'Review reports'],\r\n      status: 'COMPLIANT',\r\n      lastAssessed: new Date(),\r\n      nextAssessed: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),\r\n      riskLevel: 'MEDIUM',\r\n      automated: true,\r\n      enforcement: [\r\n        {\r\n          id: 'A.9.2.1-1',\r\n          type: 'PREVENT',\r\n          condition: 'user registration requires approval',\r\n          action: 'Require approval workflow',\r\n          severity: 'MEDIUM',\r\n          automated: true,\r\n          enabled: true\r\n        }\r\n      ]\r\n    });\r\n\r\n    // CRITICAL: SOX Controls\r\n    this.controls.set('SOX-302', {\r\n      id: 'SOX-302',\r\n      framework: 'SOX',\r\n      category: 'FINANCIAL',\r\n      controlId: '302',\r\n      title: 'Corporate Responsibility for Financial Reports',\r\n      description: 'Senior financial officers certify financial reports',\r\n      requirements: ['Financial controls', 'Segregation of duties', 'Audit trails'],\r\n      implementation: 'Financial controls with segregation of duties',\r\n      evidence: ['Financial reports', 'Control assessments', 'Audit trails'],\r\n      status: 'COMPLIANT',\r\n      lastAssessed: new Date(),\r\n      nextAssessed: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),\r\n      riskLevel: 'HIGH',\r\n      automated: true,\r\n      enforcement: [\r\n        {\r\n          id: 'SOX-302-1',\r\n          type: 'PREVENT',\r\n          condition: 'financial action requires segregation',\r\n          action: 'Enforce segregation of duties',\r\n          severity: 'HIGH',\r\n          automated: true,\r\n          enabled: true\r\n        }\r\n      ]\r\n    });\r\n\r\n    // CRITICAL: GDPR Controls\r\n    this.controls.set('GDPR-Article32', {\r\n      id: 'GDPR-Article32',\r\n      framework: 'GDPR',\r\n      category: 'PRIVACY',\r\n      controlId: 'Article32',\r\n      title: 'Security of Processing',\r\n      description: 'Technical and organizational measures for data security',\r\n      requirements: ['Encryption', 'Access controls', 'Data minimization'],\r\n      implementation: 'Privacy by design with encryption and access controls',\r\n      evidence: ['Encryption certificates', 'Access logs', 'Privacy policies'],\r\n      status: 'COMPLIANT',\r\n      lastAssessed: new Date(),\r\n      nextAssessed: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),\r\n      riskLevel: 'HIGH',\r\n      automated: true,\r\n      enforcement: [\r\n        {\r\n          id: 'GDPR-32-1',\r\n          type: 'PREVENT',\r\n          condition: 'personal data access requires justification',\r\n          action: 'Require data access justification',\r\n          severity: 'HIGH',\r\n          automated: true,\r\n          enabled: true\r\n        }\r\n      ]\r\n    });\r\n\r\n    // CRITICAL: CCPA Controls\r\n    this.controls.set('CCPA-1798.105', {\r\n      id: 'CCPA-1798.105',\r\n      framework: 'CCPA',\r\n      category: 'PRIVACY',\r\n      controlId: '1798.105',\r\n      title: 'Right to Delete',\r\n      description: 'Consumer right to delete personal information',\r\n      requirements: ['Deletion process', 'Verification', 'Confirmation'],\r\n      implementation: 'Data deletion with cryptographic proof',\r\n      evidence: ['Deletion logs', 'Verification records', 'User confirmations'],\r\n      status: 'COMPLIANT',\r\n      lastAssessed: new Date(),\r\n      nextAssessed: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),\r\n      riskLevel: 'MEDIUM',\r\n      automated: true,\r\n      enforcement: [\r\n        {\r\n          id: 'CCPA-1798.105-1',\r\n          type: 'PREVENT',\r\n          condition: 'data deletion requires verification',\r\n          action: 'Verify deletion request',\r\n          severity: 'MEDIUM',\r\n          automated: true,\r\n          enabled: true\r\n        }\r\n      ]\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize checks\r\n   */\r\n  private initializeChecks(): void {\r\n    // CRITICAL: Add automated checks for each control\r\n    for (const control of this.controls.values()) {\r\n      const check: ComplianceCheck = {\r\n        id: this.generateCheckId(),\r\n        controlId: control.id,\r\n        framework: control.framework,\r\n        category: control.category,\r\n        checkType: control.automated ? 'AUTOMATED' : 'MANUAL',\r\n        description: `Automated check for ${control.title}`,\r\n        procedure: 'Evaluate control implementation against requirements',\r\n        frequency: 'DAILY',\r\n        threshold: { pass: 100, warning: 80, fail: 60 },\r\n        lastRun: new Date(),\r\n        nextRun: this.calculateNextRunDate('DAILY'),\r\n        status: 'NOT_RUN',\r\n        result: null,\r\n        evidence: []\r\n      };\r\n\r\n      this.checks.set(check.id, check);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start compliance monitoring\r\n   */\r\n  private startComplianceMonitoring(): void {\r\n    // CRITICAL: Run compliance checks every hour\r\n    this.monitoringInterval = setInterval(async () => {\r\n      try {\r\n        await this.runComplianceChecks();\r\n      } catch (error) {\r\n        logger.error('Compliance monitoring failed', error as Error);\r\n      }\r\n    }, 3600000); // Every hour\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate report ID\r\n   */\r\n  private generateReportId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `report_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate check ID\r\n   */\r\n  private generateCheckId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `check_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate violation ID\r\n   */\r\n  private generateViolationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `violation_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global compliance engine manager instance\r\n */\r\nexport const complianceEngineManager = ComplianceEngineManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const checkCompliance = async (\r\n  action: string,\r\n  context: Record<string, any>,\r\n  frameworks: ComplianceFramework[] = ['SOC2', 'ISO27001', 'SOX', 'GDPR', 'CCPA']\r\n): Promise<{\r\n  compliant: boolean;\r\n  violations: ComplianceViolation[];\r\n  requiredActions: string[];\r\n  riskLevel: RiskLevel;\r\n  frameworks: ComplianceFramework[];\r\n}> => {\r\n  return await complianceEngineManager.checkCompliance(action, context, frameworks);\r\n};\r\n\r\nexport const runComplianceChecks = async (\r\n  framework?: ComplianceFramework,\r\n  category?: ControlCategory\r\n): Promise<ComplianceCheck[]> => {\r\n  return await complianceEngineManager.runComplianceChecks(framework, category);\r\n};\r\n\r\nexport const generateComplianceReport = async (\r\n  framework: ComplianceFramework,\r\n  reportType: 'ASSESSMENT' | 'AUDIT' | 'MONITORING' | 'INCIDENT',\r\n  period: { start: Date; end: Date }\r\n): Promise<ComplianceReport> => {\r\n  return await complianceEngineManager.generateComplianceReport(framework, reportType, period);\r\n};\r\n\r\nexport const getControls = (\r\n  framework?: ComplianceFramework,\r\n  category?: ControlCategory,\r\n  status?: ControlStatus\r\n): ComplianceControl[] => {\r\n  return complianceEngineManager.getControls(framework, category, status);\r\n};\r\n\r\nexport const getViolations = (\r\n  framework?: ComplianceFramework,\r\n  severity?: RiskLevel,\r\n  status?: string,\r\n  limit?: number\r\n): ComplianceViolation[] => {\r\n  return complianceEngineManager.getViolations(framework, severity, status, limit);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\compliance-snapshot.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\control-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\data-rights-approvals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\data-rights-engine.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: A property assignment cannot have a question token.","line":698,"column":20,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Data Rights Engine\r\n// MANDATORY: Enforcement of GDPR/CCPA data subject rights and legal hold requirements\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { evidenceCollectionManager } from './evidence-collector.js';\r\nimport { auditVaultManager } from './audit-vault.js';\r\nimport { governanceModelManager } from '../governance/governance-model.js';\r\nimport * as crypto from 'crypto';\r\n\r\nexport type DataSubjectRight = 'ACCESS' | 'RECTIFICATION' | 'ERASURE' | 'PORTABILITY' | 'RESTRICTION' | 'OBJECTION' | 'NOTIFICATION';\r\nexport type LegalHoldType = 'LITIGATION' | 'REGULATORY' | 'INTERNAL_INVESTIGATION' | 'PRESERVATION';\r\nexport type RequestStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'REJECTED' | 'ESCALATED';\r\nexport type ErasureMethod = 'CRYPTOGRAPHIC' | 'SECURE_DELETE' | 'ANONYMIZATION' | 'AGGREGATION';\r\n\r\nexport interface DataSubject {\r\n  id: string;\r\n  type: 'CUSTOMER' | 'EMPLOYEE' | 'PROSPECT' | 'PARTNER' | 'OTHER';\r\n  identifiers: {\r\n    email?: string;\r\n    phone?: string;\r\n    customerId?: string;\r\n    userId?: string;\r\n    accountId?: string;\r\n    taxId?: string;\r\n    [key: string]: string | undefined;\r\n  };\r\n  jurisdiction: string;\r\n  preferences: {\r\n    marketing: boolean;\r\n    analytics: boolean;\r\n    cookies: boolean;\r\n    thirdPartySharing: boolean;\r\n  };\r\n  consentRecords: Array<{\r\n    id: string;\r\n    purpose: string;\r\n    lawfulBasis: string;\r\n    givenAt: Date;\r\n    expiresAt?: Date;\r\n    withdrawnAt?: Date;\r\n    ipAddress: string;\r\n    userAgent: string;\r\n  }>;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface DataRightsRequest {\r\n  id: string;\r\n  dataSubjectId: string;\r\n  right: DataSubjectRight;\r\n  requestType: 'INDIVIDUAL' | 'BULK' | 'THIRD_PARTY';\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  status: RequestStatus;\r\n  requestedAt: Date;\r\n  requestedBy: string;\r\n  purpose: string;\r\n  scope: string[];\r\n  justification: string;\r\n  evidence: {\r\n    verificationMethod: string;\r\n    verificationResult: 'VERIFIED' | 'PENDING' | 'FAILED';\r\n    verificationAt?: Date;\r\n    documents: string[];\r\n  };\r\n  processing: {\r\n    startedAt?: Date;\r\n    completedAt?: Date;\r\n    estimatedCompletion?: Date;\r\n    assignedTo?: string;\r\n    steps: Array<{\r\n      step: string;\r\n      status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';\r\n      startedAt?: Date;\r\n      completedAt?: Date;\r\n      result?: string;\r\n    }>;\r\n  };\r\n  outcome: {\r\n    approved: boolean;\r\n    approvedBy?: string;\r\n    approvedAt?: Date;\r\n    rejectionReason?: string;\r\n    dataProvided?: any;\r\n    erasureProof?: ErasureProof;\r\n    portabilityData?: any;\r\n  };\r\n  auditTrail: Array<{\r\n    action: string;\r\n    timestamp: Date;\r\n    actor: string;\r\n    details: string;\r\n    success: boolean;\r\n  }>;\r\n}\r\n\r\nexport interface ErasureProof {\r\n  id: string;\r\n  requestId: string;\r\n  dataSubjectId: string;\r\n  method: ErasureMethod;\r\n  dataErased: Array<{\r\n    dataType: string;\r\n    recordCount: number;\r\n    locations: string[];\r\n    erasureTimestamp: Date;\r\n    verificationHash: string;\r\n  }>;\r\n  cryptographicProof: {\r\n    beforeHash: string;\r\n    afterHash: string;\r\n    merkleRoot: string;\r\n    signature: string;\r\n    timestamp: Date;\r\n  };\r\n  verification: {\r\n    verified: boolean;\r\n    verifiedAt: Date;\r\n    verifiedBy: string;\r\n    method: string;\r\n    result: string;\r\n  };\r\n  retention: {\r\n    proofRetainedUntil: Date;\r\n    retentionLocation: string;\r\n    accessRestricted: boolean;\r\n  };\r\n}\r\n\r\nexport interface LegalHold {\r\n  id: string;\r\n  type: LegalHoldType;\r\n  title: string;\r\n  description: string;\r\n  status: 'ACTIVE' | 'SUSPENDED' | 'RELEASED' | 'EXPIRED';\r\n  scope: {\r\n    dataSubjects: string[];\r\n    dataTypes: string[];\r\n    dateRange: {\r\n      start: Date;\r\n      end: Date;\r\n    };\r\n    keywords: string[];\r\n    custodians: string[];\r\n  };\r\n  legalBasis: {\r\n    caseNumber?: string;\r\n    courtOrder?: string;\r\n    regulatoryRequest?: string;\r\n    internalReference?: string;\r\n    preservationReason: string;\r\n  };\r\n  timeline: {\r\n    issuedAt: Date;\r\n    issuedBy: string;\r\n    reviewedAt?: Date;\r\n    reviewedBy?: string;\r\n    expiresAt?: Date;\r\n    releasedAt?: Date;\r\n    releasedBy?: string;\r\n  };\r\n  preservation: {\r\n    totalRecords: number;\r\n    totalSize: number;\r\n    locations: string[];\r\n    backupVerified: boolean;\r\n    integrityChecked: boolean;\r\n  };\r\n  notifications: Array<{\r\n    recipient: string;\r\n    type: 'ISSUED' | 'UPDATED' | 'EXPIRING' | 'RELEASED';\r\n    sentAt: Date;\r\n    acknowledgedAt?: Date;\r\n  }>;\r\n}\r\n\r\nexport interface DataLineage {\r\n  id: string;\r\n  dataSubjectId: string;\r\n  dataType: string;\r\n  recordId: string;\r\n  journey: Array<{\r\n    step: string;\r\n    timestamp: Date;\r\n    location: string;\r\n    operation: 'CREATE' | 'READ' | 'UPDATE' | 'DELETE' | 'COPY' | 'MOVE';\r\n    actor: string;\r\n    purpose: string;\r\n    lawfulBasis?: string;\r\n    consentId?: string;\r\n  }>;\r\n  currentLocation: string;\r\n  retentionSchedule: {\r\n    created: Date;\r\n    expires: Date;\r\n    extensionHistory: Array<{\r\n      extended: Date;\r\n      reason: string;\r\n      approvedBy: string;\r\n    }>;\r\n  };\r\n  legalHolds: string[];\r\n  accessLog: Array<{\r\n    accessedAt: Date;\r\n    accessedBy: string;\r\n    purpose: string;\r\n    ipAddress: string;\r\n  }>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Data Rights Engine Manager\r\n * \r\n * Enforces GDPR/CCPA data subject rights and legal hold requirements.\r\n * Provides cryptographic proof of data erasure and comprehensive audit trails.\r\n */\r\nexport class DataRightsEngineManager {\r\n  private static instance: DataRightsEngineManager;\r\n  private auditLogger: any;\r\n  private dataSubjects: Map<string, DataSubject> = new Map();\r\n  private rightsRequests: Map<string, DataRightsRequest> = new Map();\r\n  private legalHolds: Map<string, LegalHold> = new Map();\r\n  private dataLineage: Map<string, DataLineage> = new Map();\r\n  private processingInterval: NodeJS.Timeout | null = null;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.startPeriodicProcessing();\r\n  }\r\n\r\n  static getInstance(): DataRightsEngineManager {\r\n    if (!DataRightsEngineManager.instance) {\r\n      DataRightsEngineManager.instance = new DataRightsEngineManager();\r\n    }\r\n    return DataRightsEngineManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Register data subject\r\n   */\r\n  async registerDataSubject(\r\n    type: DataSubject['type'],\r\n    identifiers: DataSubject['identifiers'],\r\n    jurisdiction: string,\r\n    createdBy: string\r\n  ): Promise<string> {\r\n    const dataSubjectId = this.generateDataSubjectId();\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Create data subject record\r\n      const dataSubject: DataSubject = {\r\n        id: dataSubjectId,\r\n        type,\r\n        identifiers,\r\n        jurisdiction,\r\n        preferences: {\r\n          marketing: true,\r\n          analytics: true,\r\n          cookies: true,\r\n          thirdPartySharing: true\r\n        },\r\n        consentRecords: [],\r\n        createdAt: timestamp,\r\n        updatedAt: timestamp\r\n      };\r\n\r\n      this.dataSubjects.set(dataSubjectId, dataSubject);\r\n\r\n      // CRITICAL: Create data lineage\r\n      const lineage: DataLineage = {\r\n        id: this.generateLineageId(),\r\n        dataSubjectId,\r\n        dataType: 'PROFILE',\r\n        recordId: dataSubjectId,\r\n        journey: [{\r\n          step: 'DATA_SUBJECT_CREATED',\r\n          timestamp,\r\n          location: 'DATA_RIGHTS_ENGINE',\r\n          operation: 'CREATE',\r\n          actor: createdBy,\r\n          purpose: 'DATA_SUBJECT_REGISTRATION'\r\n        }],\r\n        currentLocation: 'DATA_RIGHTS_ENGINE',\r\n        retentionSchedule: {\r\n          created: timestamp,\r\n          expires: new Date(timestamp.getTime() + (7 * 365 * 24 * 60 * 60 * 1000)), // 7 years\r\n          extensionHistory: []\r\n        },\r\n        legalHolds: [],\r\n        accessLog: [{\r\n          accessedAt: timestamp,\r\n          accessedBy: createdBy,\r\n          purpose: 'DATA_SUBJECT_REGISTRATION',\r\n          ipAddress: 'system'\r\n        }]\r\n      };\r\n\r\n      this.dataLineage.set(lineage.id, lineage);\r\n\r\n      // CRITICAL: Log data subject registration\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: createdBy,\r\n        action: 'DATA_SUBJECT_REGISTERED',\r\n        resourceType: 'DATA_SUBJECT',\r\n        resourceId: dataSubjectId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          type,\r\n          jurisdiction,\r\n          identifiers: Object.keys(identifiers)\r\n        }\r\n      });\r\n\r\n      logger.info('Data subject registered', {\r\n        dataSubjectId,\r\n        type,\r\n        jurisdiction,\r\n        createdBy\r\n      });\r\n\r\n      return dataSubjectId;\r\n\r\n    } catch (error) {\r\n      logger.error('Data subject registration failed', {\r\n        type,\r\n        jurisdiction,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Submit data rights request\r\n   */\r\n  async submitRightsRequest(\r\n    dataSubjectId: string,\r\n    right: DataSubjectRight,\r\n    requestType: DataRightsRequest['requestType'],\r\n    purpose: string,\r\n    scope: string[],\r\n    justification: string,\r\n    requestedBy: string\r\n  ): Promise<string> {\r\n    const dataSubject = this.dataSubjects.get(dataSubjectId);\r\n    if (!dataSubject) {\r\n      throw new Error(`Data subject not found: ${dataSubjectId}`);\r\n    }\r\n\r\n    const requestId = this.generateRequestId();\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Create rights request\r\n      const request: DataRightsRequest = {\r\n        id: requestId,\r\n        dataSubjectId,\r\n        right,\r\n        requestType,\r\n        priority: this.determineRequestPriority(right, requestType),\r\n        status: 'PENDING',\r\n        requestedAt: timestamp,\r\n        requestedBy,\r\n        purpose,\r\n        scope,\r\n        justification,\r\n        evidence: {\r\n          verificationMethod: 'IDENTITY_VERIFICATION',\r\n          verificationResult: 'PENDING',\r\n          documents: []\r\n        },\r\n        processing: {\r\n          steps: this.generateProcessingSteps(right)\r\n        },\r\n        outcome: {\r\n          approved: false\r\n        },\r\n        auditTrail: [{\r\n          action: 'REQUEST_SUBMITTED',\r\n          timestamp,\r\n          actor: requestedBy,\r\n          details: `Data rights request submitted for ${right}`,\r\n          success: true\r\n        }]\r\n      };\r\n\r\n      this.rightsRequests.set(requestId, request);\r\n\r\n      // CRITICAL: Check for legal holds\r\n      const activeHolds = this.checkLegalHolds(dataSubjectId);\r\n      if (activeHolds.length > 0 && right === 'ERASURE') {\r\n        request.status = 'REJECTED';\r\n        request.outcome.rejectionReason = 'Legal hold prevents data erasure';\r\n        request.outcome.approved = false;\r\n\r\n        // CRITICAL: Log legal hold conflict\r\n        this.auditLogger.logAuthorizationDecision({\r\n          tenantId: 'system',\r\n          actorId: requestedBy,\r\n          action: 'DATA_RIGHTS_BLOCKED_BY_LEGAL_HOLD',\r\n          resourceType: 'DATA_RIGHTS_REQUEST',\r\n          resourceId: requestId,\r\n          outcome: 'FAILURE',\r\n          correlationId: this.generateCorrelationId(),\r\n          metadata: {\r\n            dataSubjectId,\r\n            right,\r\n            legalHolds: activeHolds.length\r\n          }\r\n        });\r\n      }\r\n\r\n      // CRITICAL: Log request submission\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: requestedBy,\r\n        action: 'DATA_RIGHTS_REQUEST_SUBMITTED',\r\n        resourceType: 'DATA_RIGHTS_REQUEST',\r\n        resourceId: requestId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          dataSubjectId,\r\n          right,\r\n          requestType,\r\n          purpose,\r\n          priority: request.priority\r\n        }\r\n      });\r\n\r\n      logger.info('Data rights request submitted', {\r\n        requestId,\r\n        dataSubjectId,\r\n        right,\r\n        requestType,\r\n        status: request.status\r\n      });\r\n\r\n      return requestId;\r\n\r\n    } catch (error) {\r\n      logger.error('Data rights request submission failed', {\r\n        dataSubjectId,\r\n        right,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Process data erasure with cryptographic proof\r\n   */\r\n  async processDataErasure(requestId: string, processedBy: string): Promise<string> {\r\n    const request = this.rightsRequests.get(requestId);\r\n    if (!request) {\r\n      throw new Error(`Request not found: ${requestId}`);\r\n    }\r\n\r\n    if (request.right !== 'ERASURE') {\r\n      throw new Error(`Request not for erasure: ${request.right}`);\r\n    }\r\n\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Update request status\r\n      request.status = 'IN_PROGRESS';\r\n      request.processing.startedAt = timestamp;\r\n      request.processing.assignedTo = processedBy;\r\n\r\n      // CRITICAL: Find all data for subject\r\n      const subjectData = await this.findSubjectData(request.dataSubjectId);\r\n\r\n      // CRITICAL: Generate before hash\r\n      const beforeHash = this.calculateDataHash(subjectData);\r\n\r\n      // CRITICAL: Perform data erasure\r\n      const erasureResults = await this.performDataErasure(subjectData, 'CRYPTOGRAPHIC');\r\n\r\n      // CRITICAL: Generate after hash\r\n      const afterHash = this.calculateDataHash([]);\r\n\r\n      // CRITICAL: Create erasure proof\r\n      const erasureProof: ErasureProof = {\r\n        id: this.generateErasureProofId(),\r\n        requestId,\r\n        dataSubjectId: request.dataSubjectId,\r\n        method: 'CRYPTOGRAPHIC',\r\n        dataErased: erasureResults,\r\n        cryptographicProof: {\r\n          beforeHash,\r\n          afterHash,\r\n          merkleRoot: this.calculateMerkleRoot(erasureResults),\r\n          signature: '',\r\n          timestamp\r\n        },\r\n        verification: {\r\n          verified: false,\r\n          verifiedAt: timestamp,\r\n          verifiedBy: processedBy,\r\n          method: 'CRYPTOGRAPHIC_VERIFICATION',\r\n          result: 'PENDING'\r\n        },\r\n        retention: {\r\n          proofRetainedUntil: new Date(timestamp.getTime() + (7 * 365 * 24 * 60 * 60 * 1000)), // 7 years\r\n          retentionLocation: 'ERASURE_PROOF_VAULT',\r\n          accessRestricted: true\r\n        }\r\n      };\r\n\r\n      // CRITICAL: Sign cryptographic proof\r\n      erasureProof.cryptographicProof.signature = await this.signErasureProof(erasureProof);\r\n\r\n      // CRITICAL: Store erasure proof in vault\r\n      await this.storeErasureProof(erasureProof);\r\n\r\n      // CRITICAL: Update request outcome\r\n      request.outcome.approved = true;\r\n      request.outcome.approvedBy = processedBy;\r\n      request.outcome.approvedAt = timestamp;\r\n      request.outcome.erasureProof = erasureProof;\r\n      request.status = 'COMPLETED';\r\n      request.processing.completedAt = timestamp;\r\n\r\n      // CRITICAL: Update data lineage\r\n      await this.updateDataLineageForErasure(request.dataSubjectId, erasureProof);\r\n\r\n      // CRITICAL: Log erasure completion\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: processedBy,\r\n        action: 'DATA_ERASURE_COMPLETED',\r\n        resourceType: 'DATA_SUBJECT',\r\n        resourceId: request.dataSubjectId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          requestId,\r\n          erasureProofId: erasureProof.id,\r\n          recordsErased: erasureResults.length,\r\n          beforeHash,\r\n          afterHash\r\n        }\r\n      });\r\n\r\n      logger.info('Data erasure completed', {\r\n        requestId,\r\n        dataSubjectId: request.dataSubjectId,\r\n        erasureProofId: erasureProof.id,\r\n        recordsErased: erasureResults.length\r\n      });\r\n\r\n      return erasureProof.id;\r\n\r\n    } catch (error) {\r\n      logger.error('Data erasure processing failed', {\r\n        requestId,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      request.status = 'REJECTED';\r\n      request.outcome.approved = false;\r\n      request.outcome.rejectionReason = (error as Error).message;\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Issue legal hold\r\n   */\r\n  async issueLegalHold(\r\n    type: LegalHoldType,\r\n    title: string,\r\n    description: string,\r\n    scope: LegalHold['scope'],\r\n    legalBasis: LegalHold['legalBasis'],\r\n    issuedBy: string,\r\n    expiresAt?: Date\r\n  ): Promise<string> {\r\n    const holdId = this.generateLegalHoldId();\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Create legal hold\r\n      const legalHold: LegalHold = {\r\n        id: holdId,\r\n        type,\r\n        title,\r\n        description,\r\n        status: 'ACTIVE',\r\n        scope,\r\n        legalBasis,\r\n        timeline: {\r\n          issuedAt: timestamp,\r\n          issuedBy,\r\n          expiresAt\r\n        },\r\n        preservation: {\r\n          totalRecords: 0,\r\n          totalSize: 0,\r\n          locations: [],\r\n          backupVerified: false,\r\n          integrityChecked: false\r\n        },\r\n        notifications: []\r\n      };\r\n\r\n      this.legalHolds.set(holdId, legalHold);\r\n\r\n      // CRITICAL: Apply hold to data subjects\r\n      for (const dataSubjectId of scope.dataSubjects) {\r\n        const lineage = Array.from(this.dataLineage.values())\r\n          .find(l => l.dataSubjectId === dataSubjectId);\r\n        \r\n        if (lineage) {\r\n          lineage.legalHolds.push(holdId);\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Preserve relevant data\r\n      await this.preserveDataForLegalHold(legalHold);\r\n\r\n      // CRITICAL: Log legal hold issuance\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: issuedBy,\r\n        action: 'LEGAL_HOLD_ISSUED',\r\n        resourceType: 'LEGAL_HOLD',\r\n        resourceId: holdId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          type,\r\n          title,\r\n          dataSubjects: scope.dataSubjects.length,\r\n          dataTypes: scope.dataTypes.length,\r\n          legalBasis: Object.keys(legalBasis)\r\n        }\r\n      });\r\n\r\n      logger.info('Legal hold issued', {\r\n        holdId,\r\n        type,\r\n        title,\r\n        dataSubjects: scope.dataSubjects.length,\r\n        issuedBy\r\n      });\r\n\r\n      return holdId;\r\n\r\n    } catch (error) {\r\n      logger.error('Legal hold issuance failed', {\r\n        type,\r\n        title,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Process subpoena or disclosure request\r\n   */\r\n  async processSubpoena(\r\n    requestType: 'SUBPOENA' | 'COURT_ORDER' | 'REGULATORY_REQUEST',\r\n    referenceNumber: string,\r\n    requestingAuthority: string,\r\n    scope: LegalHold['scope'],\r\n    requestedBy: string,\r\n    urgency: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\r\n  ): Promise<string> {\r\n    const requestId = this.generateRequestId();\r\n    const timestamp = new Date();\r\n\r\n    try {\r\n      // CRITICAL: Create disclosure request\r\n      const disclosureRequest = {\r\n        id: requestId,\r\n        type: requestType,\r\n        referenceNumber,\r\n        requestingAuthority,\r\n        scope,\r\n        status: 'PENDING',\r\n        requestedAt: timestamp,\r\n        requestedBy,\r\n        urgency,\r\n        legalReview: {\r\n          required: true,\r\n          reviewedBy?: string,\r\n          reviewedAt?: Date,\r\n          approved: false\r\n        },\r\n        dataCollected: {\r\n          records: [],\r\n          totalSize: 0,\r\n          redactions: [],\r\n          privilegeLog: []\r\n        }\r\n      };\r\n\r\n      // CRITICAL: Legal review for privileged information\r\n      const legalReviewResult = await this.conductLegalReview(disclosureRequest);\r\n\r\n      if (!legalReviewResult.approved) {\r\n        throw new Error('Legal review rejected disclosure request');\r\n      }\r\n\r\n      // CRITICAL: Collect and redact data\r\n      const collectedData = await this.collectDataForDisclosure(disclosureRequest);\r\n\r\n      // CRITICAL: Create disclosure package\r\n      const disclosurePackage = await this.createDisclosurePackage(disclosureRequest, collectedData);\r\n\r\n      // CRITICAL: Log disclosure processing\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: 'system',\r\n        actorId: requestedBy,\r\n        action: 'SUBPOENA_PROCESSED',\r\n        resourceType: 'DISCLOSURE_REQUEST',\r\n        resourceId: requestId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: this.generateCorrelationId(),\r\n        metadata: {\r\n          requestType,\r\n          referenceNumber,\r\n          requestingAuthority,\r\n          recordsProvided: collectedData.length,\r\n          packageSize: disclosurePackage.size\r\n        }\r\n      });\r\n\r\n      logger.info('Subpoena processed', {\r\n        requestId,\r\n        requestType,\r\n        referenceNumber,\r\n        requestingAuthority,\r\n        recordsProvided: collectedData.length\r\n      });\r\n\r\n      return disclosurePackage.id;\r\n\r\n    } catch (error) {\r\n      logger.error('Subpoena processing failed', {\r\n        requestType,\r\n        referenceNumber,\r\n        error: (error as Error).message\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get data subject\r\n   */\r\n  getDataSubject(dataSubjectId: string): DataSubject | undefined {\r\n    return this.dataSubjects.get(dataSubjectId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get rights request\r\n   */\r\n  getRightsRequest(requestId: string): DataRightsRequest | undefined {\r\n    return this.rightsRequests.get(requestId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get legal hold\r\n   */\r\n  getLegalHold(holdId: string): LegalHold | undefined {\r\n    return this.legalHolds.get(holdId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get data lineage\r\n   */\r\n  getDataLineage(dataSubjectId: string): DataLineage[] {\r\n    return Array.from(this.dataLineage.values())\r\n      .filter(l => l.dataSubjectId === dataSubjectId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get data rights statistics\r\n   */\r\n  getDataRightsStatistics(): {\r\n    totalDataSubjects: number;\r\n    totalRequests: number;\r\n    requestsByRight: Record<string, number>;\r\n    requestsByStatus: Record<string, number>;\r\n    activeLegalHolds: number;\r\n    totalErasureProofs: number;\r\n    averageProcessingTime: number;\r\n  } {\r\n    const dataSubjects = Array.from(this.dataSubjects.values());\r\n    const requests = Array.from(this.rightsRequests.values());\r\n    const holds = Array.from(this.legalHolds.values());\r\n\r\n    const requestsByRight: Record<string, number> = {};\r\n    const requestsByStatus: Record<string, number> = {};\r\n\r\n    for (const request of requests) {\r\n      requestsByRight[request.right] = (requestsByRight[request.right] || 0) + 1;\r\n      requestsByStatus[request.status] = (requestsByStatus[request.status] || 0) + 1;\r\n    }\r\n\r\n    const completedRequests = requests.filter(r => r.status === 'COMPLETED' && r.processing.completedAt && r.processing.startedAt);\r\n    const averageProcessingTime = completedRequests.length > 0 \r\n      ? completedRequests.reduce((sum, r) => sum + (r.processing.completedAt!.getTime() - r.processing.startedAt!.getTime()), 0) / completedRequests.length\r\n      : 0;\r\n\r\n    return {\r\n      totalDataSubjects: dataSubjects.length,\r\n      totalRequests: requests.length,\r\n      requestsByRight,\r\n      requestsByStatus,\r\n      activeLegalHolds: holds.filter(h => h.status === 'ACTIVE').length,\r\n      totalErasureProofs: requests.filter(r => r.outcome.erasureProof).length,\r\n      averageProcessingTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start periodic processing\r\n   */\r\n  private startPeriodicProcessing(): void {\r\n    this.processingInterval = setInterval(async () => {\r\n      try {\r\n        await this.processPendingRequests();\r\n        await this.checkExpiringLegalHolds();\r\n        await this.verifyDataIntegrity();\r\n      } catch (error) {\r\n        logger.error('Periodic data rights processing failed', {\r\n          error: (error as Error).message\r\n        });\r\n      }\r\n    }, 300000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Process pending requests\r\n   */\r\n  private async processPendingRequests(): Promise<void> {\r\n    const pendingRequests = Array.from(this.rightsRequests.values())\r\n      .filter(r => r.status === 'PENDING');\r\n\r\n    for (const request of pendingRequests) {\r\n      try {\r\n        // Auto-approve low-risk requests\r\n        if (request.priority === 'LOW' && request.right === 'ACCESS') {\r\n          await this.autoApproveRequest(request.id, 'system');\r\n        }\r\n      } catch (error) {\r\n        logger.error('Auto-approval failed', {\r\n          requestId: request.id,\r\n          error: (error as Error).message\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check expiring legal holds\r\n   */\r\n  private async checkExpiringLegalHolds(): Promise<void> {\r\n    const holds = Array.from(this.legalHolds.values())\r\n      .filter(h => h.status === 'ACTIVE' && \r\n                   h.timeline.expiresAt && \r\n                   new Date() >= new Date(h.timeline.expiresAt.getTime() - (7 * 24 * 60 * 60 * 1000))); // 7 days before expiry\r\n\r\n    for (const hold of holds) {\r\n      // Send expiry notification\r\n      logger.warn('Legal hold expiring soon', {\r\n        holdId: hold.id,\r\n        title: hold.title,\r\n        expiresAt: hold.timeline.expiresAt\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Verify data integrity\r\n   */\r\n  private async verifyDataIntegrity(): Promise<void> {\r\n    const lineages = Array.from(this.dataLineage.values());\r\n    \r\n    for (const lineage of lineages) {\r\n      // Verify retention schedule\r\n      if (new Date() > lineage.retentionSchedule.expires) {\r\n        logger.info('Data retention expired', {\r\n          lineageId: lineage.id,\r\n          dataSubjectId: lineage.dataSubjectId,\r\n          expiredAt: lineage.retentionSchedule.expires\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Determine request priority\r\n   */\r\n  private determineRequestPriority(right: DataSubjectRight, requestType: DataRightsRequest['requestType']): DataRightsRequest['priority'] {\r\n    if (right === 'ERASURE' && requestType === 'INDIVIDUAL') {\r\n      return 'HIGH';\r\n    }\r\n    if (requestType === 'BULK') {\r\n      return 'MEDIUM';\r\n    }\r\n    return 'LOW';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate processing steps\r\n   */\r\n  private generateProcessingSteps(right: DataSubjectRight): DataRightsRequest['processing']['steps'] {\r\n    const baseSteps = [\r\n      { step: 'IDENTITY_VERIFICATION', status: 'PENDING' as const },\r\n      { step: 'DATA_LOCATION', status: 'PENDING' as const },\r\n      { step: 'LEGAL_REVIEW', status: 'PENDING' as const }\r\n    ];\r\n\r\n    switch (right) {\r\n      case 'ACCESS':\r\n        return [\r\n          ...baseSteps,\r\n          { step: 'DATA_COLLECTION', status: 'PENDING' as const },\r\n          { step: 'DATA_REDACTION', status: 'PENDING' as const },\r\n          { step: 'DATA_PACKAGE', status: 'PENDING' as const }\r\n        ];\r\n      case 'ERASURE':\r\n        return [\r\n          ...baseSteps,\r\n          { step: 'LEGAL_HOLD_CHECK', status: 'PENDING' as const },\r\n          { step: 'DATA_ERASURE', status: 'PENDING' as const },\r\n          { step: 'ERASURE_VERIFICATION', status: 'PENDING' as const },\r\n          { step: 'PROOF_GENERATION', status: 'PENDING' as const }\r\n        ];\r\n      case 'PORTABILITY':\r\n        return [\r\n          ...baseSteps,\r\n          { step: 'DATA_EXTRACTION', status: 'PENDING' as const },\r\n          { step: 'FORMAT_CONVERSION', status: 'PENDING' as const },\r\n          { step: 'DATA_PACKAGE', status: 'PENDING' as const }\r\n        ];\r\n      default:\r\n        return baseSteps;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check legal holds\r\n   */\r\n  private checkLegalHolds(dataSubjectId: string): LegalHold[] {\r\n    return Array.from(this.legalHolds.values())\r\n      .filter(h => h.status === 'ACTIVE' && \r\n                   h.scope.dataSubjects.includes(dataSubjectId));\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Find subject data\r\n   */\r\n  private async findSubjectData(dataSubjectId: string): Promise<any[]> {\r\n    // In a real implementation, this would search all systems for subject data\r\n    return [\r\n      { id: 'record1', type: 'PROFILE', data: 'sample data' },\r\n      { id: 'record2', type: 'TRANSACTION', data: 'sample data' },\r\n      { id: 'record3', type: 'COMMUNICATION', data: 'sample data' }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate data hash\r\n   */\r\n  private calculateDataHash(data: any[]): string {\r\n    return crypto.createHash('sha256')\r\n      .update(JSON.stringify(data))\r\n      .digest('hex');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Perform data erasure\r\n   */\r\n  private async performDataErasure(data: any[], method: ErasureMethod): Promise<ErasureProof['dataErased']> {\r\n    const results: ErasureProof['dataErased'] = [];\r\n    const timestamp = new Date();\r\n\r\n    for (const record of data) {\r\n      results.push({\r\n        dataType: record.type,\r\n        recordCount: 1,\r\n        locations: [`DATABASE_${record.type}`],\r\n        erasureTimestamp: timestamp,\r\n        verificationHash: crypto.createHash('sha256')\r\n          .update(JSON.stringify(record))\r\n          .digest('hex')\r\n      });\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate Merkle root\r\n   */\r\n  private calculateMerkleRoot(results: ErasureProof['dataErased']): string {\r\n    if (results.length === 0) {\r\n      return crypto.createHash('sha256').digest('hex');\r\n    }\r\n\r\n    const hashes = results.map(r => r.verificationHash);\r\n    \r\n    while (hashes.length > 1) {\r\n      const nextLevel: string[] = [];\r\n      \r\n      for (let i = 0; i < hashes.length; i += 2) {\r\n        const left = hashes[i];\r\n        const right = hashes[i + 1] || left;\r\n        \r\n        nextLevel.push(crypto.createHash('sha256')\r\n          .update(left + right)\r\n          .digest('hex'));\r\n      }\r\n      \r\n      hashes.splice(0, hashes.length, ...nextLevel);\r\n    }\r\n\r\n    return hashes[0];\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Sign erasure proof\r\n   */\r\n  private async signErasureProof(proof: ErasureProof): Promise<string> {\r\n    const privateKey = this.getErasurePrivateKey();\r\n    const sign = crypto.createSign('RSA-SHA256');\r\n    sign.update(proof.cryptographicProof.beforeHash + proof.cryptographicProof.afterHash);\r\n    return sign.sign(privateKey, 'hex');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Store erasure proof\r\n   */\r\n  private async storeErasureProof(proof: ErasureProof): Promise<void> {\r\n    // In a real implementation, this would store in the audit vault\r\n    logger.info('Erasure proof stored', {\r\n      proofId: proof.id,\r\n      requestId: proof.requestId,\r\n      method: proof.method\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update data lineage for erasure\r\n   */\r\n  private async updateDataLineageForErasure(dataSubjectId: string, proof: ErasureProof): Promise<void> {\r\n    const lineages = Array.from(this.dataLineage.values())\r\n      .filter(l => l.dataSubjectId === dataSubjectId);\r\n\r\n    for (const lineage of lineages) {\r\n      lineage.journey.push({\r\n        step: 'DATA_ERASURE',\r\n        timestamp: proof.cryptographicProof.timestamp,\r\n        location: 'ERASURE_ENGINE',\r\n        operation: 'DELETE',\r\n        actor: 'system',\r\n        purpose: 'DATA_SUBJECT_ERASURE_REQUEST'\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Preserve data for legal hold\r\n   */\r\n  private async preserveDataForLegalHold(hold: LegalHold): Promise<void> {\r\n    // In a real implementation, this would preserve all relevant data\r\n    logger.info('Data preserved for legal hold', {\r\n      holdId: hold.id,\r\n      title: hold.title,\r\n      dataSubjects: hold.scope.dataSubjects.length\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Conduct legal review\r\n   */\r\n  private async conductLegalReview(request: any): Promise<{ approved: boolean; reviewedBy: string; reviewedAt: Date }> {\r\n    // In a real implementation, this would conduct actual legal review\r\n    return {\r\n      approved: true,\r\n      reviewedBy: 'legal_counsel',\r\n      reviewedAt: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Collect data for disclosure\r\n   */\r\n  private async collectDataForDisclosure(request: any): Promise<any[]> {\r\n    // In a real implementation, this would collect relevant data\r\n    return [\r\n      { id: 'disclosure1', type: 'RECORD', data: 'sample data', privileged: false },\r\n      { id: 'disclosure2', type: 'RECORD', data: 'sample data', privileged: true }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create disclosure package\r\n   */\r\n  private async createDisclosurePackage(request: any, data: any[]): Promise<{ id: string; size: number }> {\r\n    // In a real implementation, this would create a disclosure package\r\n    return {\r\n      id: this.generateRequestId(),\r\n      size: JSON.stringify(data).length\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Auto-approve request\r\n   */\r\n  private async autoApproveRequest(requestId: string, approvedBy: string): Promise<void> {\r\n    const request = this.rightsRequests.get(requestId);\r\n    if (!request) return;\r\n\r\n    request.status = 'COMPLETED';\r\n    request.outcome.approved = true;\r\n    request.outcome.approvedBy = approvedBy;\r\n    request.outcome.approvedAt = new Date();\r\n    request.processing.completedAt = new Date();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get erasure private key\r\n   */\r\n  private getErasurePrivateKey(): string {\r\n    // In a real implementation, this would retrieve from secure key storage\r\n    return '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC5...\\n-----END PRIVATE KEY-----';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate data subject ID\r\n   */\r\n  private generateDataSubjectId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `ds_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate lineage ID\r\n   */\r\n  private generateLineageId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `lin_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate request ID\r\n   */\r\n  private generateRequestId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `req_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate erasure proof ID\r\n   */\r\n  private generateErasureProofId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `proof_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate legal hold ID\r\n   */\r\n  private generateLegalHoldId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `hold_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global data rights engine manager instance\r\n */\r\nexport const dataRightsEngineManager = DataRightsEngineManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const createDataRightsEngineManager = (): DataRightsEngineManager => {\r\n  return DataRightsEngineManager.getInstance();\r\n};\r\n\r\nexport const registerDataSubject = async (\r\n  type: DataSubject['type'],\r\n  identifiers: DataSubject['identifiers'],\r\n  jurisdiction: string,\r\n  createdBy: string\r\n): Promise<string> => {\r\n  return dataRightsEngineManager.registerDataSubject(type, identifiers, jurisdiction, createdBy);\r\n};\r\n\r\nexport const submitDataRightsRequest = async (\r\n  dataSubjectId: string,\r\n  right: DataSubjectRight,\r\n  requestType: DataRightsRequest['requestType'],\r\n  purpose: string,\r\n  scope: string[],\r\n  justification: string,\r\n  requestedBy: string\r\n): Promise<string> => {\r\n  return dataRightsEngineManager.submitRightsRequest(dataSubjectId, right, requestType, purpose, scope, justification, requestedBy);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\erasure-proof.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\evidence-collector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\evidence-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\evidence-export.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\evidence-snapshots.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\evidence-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\immutable-audit-log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\incident-disclosure.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\legal-hold.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\policy-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\retention-legal-hold.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":594,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":594,"endColumn":107},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":602,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":602,"endColumn":106},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":610,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":610,"endColumn":106},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":618,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":618,"endColumn":110},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":908,"column":29,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":908,"endColumn":46}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Compliance Retention & Legal Hold System\r\n// MANDATORY: Enforce retention policies and legal holds for compliance\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from './immutable-audit-log.js';\r\n\r\nexport interface RetentionPolicy {\r\n  dataType: 'AUDIT_LOGS' | 'DATABASE_BACKUPS' | 'SOFT_DELETED_TENANTS' | 'USER_DATA';\r\n  retentionDays: number;\r\n  legalHoldExceptions: string[];\r\n  enforcementEnabled: boolean;\r\n  lastEnforcedAt?: Date;\r\n}\r\n\r\nexport interface LegalHold {\r\n  id: string;\r\n  tenantId: string;\r\n  dataType: RetentionPolicy['dataType'];\r\n  reason: string;\r\n  requestedBy: string;\r\n  requestedAt: Date;\r\n  expiresAt?: Date;\r\n  isActive: boolean;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface RetentionJob {\r\n  id: string;\r\n  dataType: RetentionPolicy['dataType'];\r\n  status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED';\r\n  startedAt?: Date;\r\n  completedAt?: Date;\r\n  recordsProcessed: number;\r\n  recordsDeleted: number;\r\n  errors: string[];\r\n  metadata: Record<string, any>;\r\n  duration?: number;\r\n}\r\n\r\nexport interface RetentionEnforcementResult {\r\n  jobId: string;\r\n  dataType: RetentionPolicy['dataType'];\r\n  recordsProcessed: number;\r\n  recordsDeleted: number;\r\n  recordsSkipped: number;\r\n  errors: string[];\r\n  duration: number;\r\n  legalHoldsBlocked: number;\r\n}\r\n\r\n/**\r\n * CRITICAL: Compliance Retention Manager\r\n * \r\n * This class enforces retention policies and legal holds for compliance.\r\n * ALL retention actions are logged and cannot be bypassed.\r\n */\r\nexport class ComplianceRetentionManager {\r\n  private prisma: PrismaClient;\r\n  private auditLogger: any;\r\n  private retentionPolicies: Map<RetentionPolicy['dataType'], RetentionPolicy> = new Map();\r\n  private activeJobs: Map<string, RetentionJob> = new Map();\r\n\r\n  constructor(prisma: PrismaClient) {\r\n    this.prisma = prisma;\r\n    this.auditLogger = getImmutableAuditLogger(prisma);\r\n    this.initializeDefaultPolicies();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize default retention policies\r\n   */\r\n  private initializeDefaultPolicies(): void {\r\n    // CRITICAL: Audit logs - 7 years retention (SOX compliance)\r\n    this.retentionPolicies.set('AUDIT_LOGS', {\r\n      dataType: 'AUDIT_LOGS',\r\n      retentionDays: 2555, // 7 years\r\n      legalHoldExceptions: [],\r\n      enforcementEnabled: true\r\n    });\r\n\r\n    // CRITICAL: Database backups - 1 year retention\r\n    this.retentionPolicies.set('DATABASE_BACKUPS', {\r\n      dataType: 'DATABASE_BACKUPS',\r\n      retentionDays: 365,\r\n      legalHoldExceptions: [],\r\n      enforcementEnabled: true\r\n    });\r\n\r\n    // CRITICAL: Soft-deleted tenants - 90 days retention\r\n    this.retentionPolicies.set('SOFT_DELETED_TENANTS', {\r\n      dataType: 'SOFT_DELETED_TENANTS',\r\n      retentionDays: 90,\r\n      legalHoldExceptions: [],\r\n      enforcementEnabled: true\r\n    });\r\n\r\n    // CRITICAL: User data - 2 years retention (GDPR compliance)\r\n    this.retentionPolicies.set('USER_DATA', {\r\n      dataType: 'USER_DATA',\r\n      retentionDays: 730, // 2 years\r\n      legalHoldExceptions: [],\r\n      enforcementEnabled: true\r\n    });\r\n\r\n    logger.info('Default retention policies initialized', {\r\n      policies: Array.from(this.retentionPolicies.entries()).map(([type, policy]) => ({\r\n        type,\r\n        retentionDays: policy.retentionDays,\r\n        enforcementEnabled: policy.enforcementEnabled\r\n      }))\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get retention policy for data type\r\n   */\r\n  getRetentionPolicy(dataType: RetentionPolicy['dataType']): RetentionPolicy | undefined {\r\n    return this.retentionPolicies.get(dataType);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update retention policy\r\n   */\r\n  updateRetentionPolicy(\r\n    dataType: RetentionPolicy['dataType'],\r\n    policy: Partial<RetentionPolicy>,\r\n    updatedBy: string,\r\n    correlationId: string\r\n  ): void {\r\n    const existingPolicy = this.retentionPolicies.get(dataType);\r\n    if (!existingPolicy) {\r\n      throw new Error(`Retention policy not found for data type: ${dataType}`);\r\n    }\r\n\r\n    const updatedPolicy: RetentionPolicy = {\r\n      ...existingPolicy,\r\n      ...policy,\r\n      dataType\r\n    };\r\n\r\n    this.retentionPolicies.set(dataType, updatedPolicy);\r\n\r\n    // CRITICAL: Log policy change\r\n    this.auditLogger.logConfigurationChange({\r\n      tenantId: 'system',\r\n      actorId: updatedBy,\r\n      action: 'RETENTION_POLICY_UPDATE',\r\n      resourceType: 'SYSTEM_CONFIG' as const,\r\n      resourceId: dataType,\r\n      outcome: 'SUCCESS',\r\n      correlationId,\r\n      metadata: {\r\n        previousPolicy: existingPolicy,\r\n        updatedPolicy,\r\n        changedFields: Object.keys(policy)\r\n      }\r\n    });\r\n\r\n    logger.info('Retention policy updated', {\r\n      dataType,\r\n      updatedBy,\r\n      changes: policy\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Place legal hold on data\r\n   */\r\n  async placeLegalHold(\r\n    tenantId: string,\r\n    dataType: RetentionPolicy['dataType'],\r\n    reason: string,\r\n    requestedBy: string,\r\n    correlationId: string,\r\n    expiresAt?: Date,\r\n    metadata?: Record<string, any>\r\n  ): Promise<LegalHold> {\r\n    const legalHold: LegalHold = {\r\n      id: this.generateSecureId(),\r\n      tenantId,\r\n      dataType,\r\n      reason,\r\n      requestedBy,\r\n      requestedAt: new Date(),\r\n      expiresAt,\r\n      isActive: true,\r\n      metadata: metadata || {}\r\n    };\r\n\r\n    try {\r\n      // CRITICAL: Store legal hold in database\r\n      await this.prisma.$executeRaw`\r\n        INSERT INTO legal_holds (\r\n          id, tenant_id, data_type, reason, requested_by, \r\n          requested_at, expires_at, is_active, metadata\r\n        ) VALUES (\r\n          ${legalHold.id}, ${legalHold.tenantId}, ${legalHold.dataType}, \r\n          ${legalHold.reason}, ${legalHold.requestedBy}, ${legalHold.requestedAt}, \r\n          ${legalHold.expiresAt}, ${legalHold.isActive}, ${JSON.stringify(legalHold.metadata)}\r\n        )\r\n      `;\r\n\r\n      // CRITICAL: Update retention policy with legal hold exception\r\n      const policy = this.retentionPolicies.get(dataType);\r\n      if (policy && !policy.legalHoldExceptions.includes(legalHold.id)) {\r\n        policy.legalHoldExceptions.push(legalHold.id);\r\n      }\r\n\r\n      // CRITICAL: Log legal hold placement\r\n      this.auditLogger.logConfigurationChange({\r\n        tenantId,\r\n        actorId: requestedBy,\r\n        action: 'LEGAL_HOLD_PLACED',\r\n        resourceType: 'SYSTEM_CONFIG' as const,\r\n        resourceId: legalHold.id,\r\n        outcome: 'SUCCESS',\r\n        correlationId,\r\n        metadata: {\r\n          dataType,\r\n          reason,\r\n          expiresAt,\r\n          legalHoldId: legalHold.id\r\n        }\r\n      });\r\n\r\n      logger.info('Legal hold placed', {\r\n        legalHoldId: legalHold.id,\r\n        tenantId,\r\n        dataType,\r\n        reason,\r\n        requestedBy,\r\n        expiresAt\r\n      });\r\n\r\n      return legalHold;\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to place legal hold', error as Error, {\r\n        tenantId,\r\n        dataType,\r\n        reason,\r\n        requestedBy\r\n      });\r\n\r\n      // CRITICAL: Log failure\r\n      this.auditLogger.logConfigurationChange({\r\n        tenantId,\r\n        actorId: requestedBy,\r\n        action: 'LEGAL_HOLD_PLACED',\r\n        resourceType: 'SYSTEM_CONFIG' as const,\r\n        resourceId: legalHold.id,\r\n        outcome: 'FAILURE',\r\n        correlationId,\r\n        metadata: {\r\n          dataType,\r\n          reason,\r\n          error: (error as Error).message\r\n        }\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Release legal hold\r\n   */\r\n  async releaseLegalHold(\r\n    legalHoldId: string,\r\n    releasedBy: string,\r\n    correlationId: string,\r\n    reason?: string\r\n  ): Promise<void> {\r\n    try {\r\n      // CRITICAL: Get legal hold details\r\n      const legalHoldResult = await this.prisma.$queryRaw`\r\n        SELECT * FROM legal_holds \r\n        WHERE id = ${legalHoldId} AND is_active = true\r\n      ` as LegalHold[];\r\n\r\n      if (legalHoldResult.length === 0) {\r\n        throw new Error(`Legal hold not found or inactive: ${legalHoldId}`);\r\n      }\r\n\r\n      const legalHold = legalHoldResult[0];\r\n\r\n      // CRITICAL: Deactivate legal hold\r\n      await this.prisma.$executeRaw`\r\n        UPDATE legal_holds \r\n        SET is_active = false, updated_at = NOW()\r\n        WHERE id = ${legalHoldId}\r\n      `;\r\n\r\n      // CRITICAL: Remove from retention policy exceptions\r\n      const policy = this.retentionPolicies.get(legalHold.dataType);\r\n      if (policy) {\r\n        policy.legalHoldExceptions = policy.legalHoldExceptions.filter(id => id !== legalHoldId);\r\n      }\r\n\r\n      // CRITICAL: Log legal hold release\r\n      this.auditLogger.logConfigurationChange({\r\n        tenantId: legalHold.tenantId,\r\n        actorId: releasedBy,\r\n        action: 'LEGAL_HOLD_RELEASED',\r\n        resourceType: 'SYSTEM_CONFIG' as const,\r\n        resourceId: legalHoldId,\r\n        outcome: 'SUCCESS',\r\n        correlationId,\r\n        metadata: {\r\n          dataType: legalHold.dataType,\r\n          reason,\r\n          originalReason: legalHold.reason\r\n        }\r\n      });\r\n\r\n      logger.info('Legal hold released', {\r\n        legalHoldId,\r\n        tenantId: legalHold.tenantId,\r\n        dataType: legalHold.dataType,\r\n        releasedBy,\r\n        reason\r\n      });\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to release legal hold', error as Error, {\r\n        legalHoldId,\r\n        releasedBy\r\n      });\r\n\r\n      // CRITICAL: Log failure\r\n      this.auditLogger.logConfigurationChange({\r\n        tenantId: 'system',\r\n        actorId: releasedBy,\r\n        action: 'LEGAL_HOLD_RELEASED',\r\n        resourceType: 'SYSTEM_CONFIG' as const,\r\n        resourceId: legalHoldId,\r\n        outcome: 'FAILURE',\r\n        correlationId,\r\n        metadata: {\r\n          error: (error as Error).message\r\n        }\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get active legal holds\r\n   */\r\n  async getActiveLegalHolds(dataType?: RetentionPolicy['dataType']): Promise<LegalHold[]> {\r\n    try {\r\n      let query = `\r\n        SELECT id, tenant_id, data_type, reason, requested_by, \r\n               requested_at, expires_at, is_active, metadata\r\n        FROM legal_holds \r\n        WHERE is_active = true\r\n      `;\r\n\r\n      const params: any[] = [];\r\n      if (dataType) {\r\n        query += ` AND data_type = $1`;\r\n        params.push(dataType);\r\n      }\r\n\r\n      query += ` ORDER BY requested_at DESC`;\r\n\r\n      const results = await this.prisma.$queryRawUnsafe(query, ...params) as LegalHold[];\r\n\r\n      // CRITICAL: Parse metadata\r\n      results.forEach(hold => {\r\n        if (typeof hold.metadata === 'string') {\r\n          hold.metadata = JSON.parse(hold.metadata);\r\n        }\r\n      });\r\n\r\n      return results;\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to get active legal holds', error as Error, { dataType });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if data is under legal hold\r\n   */\r\n  async isUnderLegalHold(\r\n    tenantId: string,\r\n    dataType: RetentionPolicy['dataType']\r\n  ): Promise<boolean> {\r\n    try {\r\n      const result = await this.prisma.$queryRaw`\r\n        SELECT COUNT(*) as count\r\n        FROM legal_holds \r\n        WHERE tenant_id = ${tenantId} \r\n        AND data_type = ${dataType} \r\n        AND is_active = true\r\n        AND (expires_at IS NULL OR expires_at > NOW())\r\n      ` as Array<{ count: bigint }>;\r\n\r\n      return Number(result[0].count) > 0;\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to check legal hold status', error as Error, {\r\n        tenantId,\r\n        dataType\r\n      });\r\n      return false; // CRITICAL: Fail safe - assume no legal hold\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Enforce retention policy\r\n   */\r\n  async enforceRetentionPolicy(\r\n    dataType: RetentionPolicy['dataType'],\r\n    correlationId: string,\r\n    dryRun: boolean = false\r\n  ): Promise<RetentionEnforcementResult> {\r\n    const policy = this.retentionPolicies.get(dataType);\r\n    if (!policy || !policy.enforcementEnabled) {\r\n      throw new Error(`Retention policy not found or disabled for: ${dataType}`);\r\n    }\r\n\r\n    const jobId = this.generateSecureId();\r\n    const startTime = Date.now();\r\n\r\n    const job: RetentionJob = {\r\n      id: jobId,\r\n      dataType,\r\n      status: 'RUNNING',\r\n      startedAt: new Date(),\r\n      recordsProcessed: 0,\r\n      recordsDeleted: 0,\r\n      errors: [],\r\n      metadata: {\r\n        correlationId,\r\n        dryRun,\r\n        retentionDays: policy.retentionDays\r\n      }\r\n    };\r\n\r\n    this.activeJobs.set(jobId, job);\r\n\r\n    try {\r\n      // CRITICAL: Get active legal holds for this data type\r\n      const activeLegalHolds = await this.getActiveLegalHolds(dataType);\r\n      const legalHoldTenantIds = new Set(activeLegalHolds.map(hold => hold.tenantId));\r\n\r\n      // CRITICAL: Log enforcement start\r\n      this.auditLogger.logConfigurationChange({\r\n        tenantId: 'system',\r\n        actorId: 'system',\r\n        action: 'RETENTION_ENFORCEMENT_START',\r\n        resourceType: 'SYSTEM_CONFIG' as const,\r\n        resourceId: dataType,\r\n        outcome: 'SUCCESS',\r\n        correlationId,\r\n        metadata: {\r\n          dataType,\r\n          jobId,\r\n          retentionDays: policy.retentionDays,\r\n          legalHoldCount: activeLegalHolds.length,\r\n          dryRun\r\n        }\r\n      });\r\n\r\n      const result = await this.executeRetentionEnforcement(\r\n        dataType,\r\n        policy,\r\n        legalHoldTenantIds,\r\n        correlationId,\r\n        dryRun\r\n      );\r\n\r\n      // CRITICAL: Update job status\r\n      job.status = 'COMPLETED';\r\n      job.completedAt = new Date();\r\n      job.recordsProcessed = result.recordsProcessed;\r\n      job.recordsDeleted = result.recordsDeleted;\r\n      job.duration = Date.now() - startTime;\r\n\r\n      // CRITICAL: Log enforcement completion\r\n      this.auditLogger.logConfigurationChange({\r\n        tenantId: 'system',\r\n        actorId: 'system',\r\n        action: 'RETENTION_ENFORCEMENT_COMPLETE',\r\n        resourceType: 'SYSTEM_CONFIG' as const,\r\n        resourceId: dataType,\r\n        outcome: 'SUCCESS',\r\n        correlationId,\r\n        metadata: {\r\n          dataType,\r\n          jobId,\r\n          recordsProcessed: result.recordsProcessed,\r\n          recordsDeleted: result.recordsDeleted,\r\n          recordsSkipped: result.recordsSkipped,\r\n          legalHoldsBlocked: result.legalHoldsBlocked,\r\n          duration: job.duration,\r\n          dryRun\r\n        }\r\n      });\r\n\r\n      logger.info('Retention policy enforcement completed', {\r\n        dataType,\r\n        jobId,\r\n        recordsProcessed: result.recordsProcessed,\r\n        recordsDeleted: result.recordsDeleted,\r\n        recordsSkipped: result.recordsSkipped,\r\n        legalHoldsBlocked: result.legalHoldsBlocked,\r\n        duration: job.duration,\r\n        dryRun\r\n      });\r\n\r\n      return {\r\n        jobId,\r\n        dataType,\r\n        recordsProcessed: result.recordsProcessed,\r\n        recordsDeleted: result.recordsDeleted,\r\n        recordsSkipped: result.recordsSkipped,\r\n        errors: result.errors,\r\n        duration: job.duration,\r\n        legalHoldsBlocked: result.legalHoldsBlocked\r\n      };\r\n\r\n    } catch (error) {\r\n      // CRITICAL: Update job status on failure\r\n      job.status = 'FAILED';\r\n      job.completedAt = new Date();\r\n      job.errors.push((error as Error).message);\r\n      job.duration = Date.now() - startTime;\r\n\r\n      // CRITICAL: Log enforcement failure\r\n      this.auditLogger.logConfigurationChange({\r\n        tenantId: 'system',\r\n        actorId: 'system',\r\n        action: 'RETENTION_ENFORCEMENT_FAILED',\r\n        resourceType: 'SYSTEM_CONFIG' as const,\r\n        resourceId: dataType,\r\n        outcome: 'FAILURE',\r\n        correlationId,\r\n        metadata: {\r\n          dataType,\r\n          jobId,\r\n          error: (error as Error).message,\r\n          duration: job.duration\r\n        }\r\n      });\r\n\r\n      logger.error('Retention policy enforcement failed', error as Error, {\r\n        dataType,\r\n        jobId,\r\n        duration: job.duration\r\n      });\r\n\r\n      throw error;\r\n\r\n    } finally {\r\n      // CRITICAL: Clean up job\r\n      this.activeJobs.delete(jobId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute retention enforcement for specific data type\r\n   */\r\n  private async executeRetentionEnforcement(\r\n    dataType: RetentionPolicy['dataType'],\r\n    policy: RetentionPolicy,\r\n    legalHoldTenantIds: Set<string>,\r\n    correlationId: string,\r\n    dryRun: boolean\r\n  ): Promise<{\r\n    recordsProcessed: number;\r\n    recordsDeleted: number;\r\n    recordsSkipped: number;\r\n    errors: string[];\r\n    legalHoldsBlocked: number;\r\n  }> {\r\n    const cutoffDate = new Date();\r\n    cutoffDate.setDate(cutoffDate.getDate() - policy.retentionDays);\r\n\r\n    let recordsProcessed = 0;\r\n    let recordsDeleted = 0;\r\n    let recordsSkipped = 0;\r\n    let legalHoldsBlocked = 0;\r\n    const errors: string[] = [];\r\n\r\n    try {\r\n      switch (dataType) {\r\n        case 'AUDIT_LOGS':\r\n          const auditResult = await this.enforceAuditLogRetention(cutoffDate, legalHoldTenantIds, dryRun);\r\n          recordsProcessed = auditResult.recordsProcessed;\r\n          recordsDeleted = auditResult.recordsDeleted;\r\n          recordsSkipped = auditResult.recordsSkipped;\r\n          legalHoldsBlocked = auditResult.legalHoldsBlocked;\r\n          break;\r\n\r\n        case 'DATABASE_BACKUPS':\r\n          const backupResult = await this.enforceBackupRetention(cutoffDate, legalHoldTenantIds, dryRun);\r\n          recordsProcessed = backupResult.recordsProcessed;\r\n          recordsDeleted = backupResult.recordsDeleted;\r\n          recordsSkipped = backupResult.recordsSkipped;\r\n          legalHoldsBlocked = backupResult.legalHoldsBlocked;\r\n          break;\r\n\r\n        case 'SOFT_DELETED_TENANTS':\r\n          const tenantResult = await this.enforceTenantRetention(cutoffDate, legalHoldTenantIds, dryRun);\r\n          recordsProcessed = tenantResult.recordsProcessed;\r\n          recordsDeleted = tenantResult.recordsDeleted;\r\n          recordsSkipped = tenantResult.recordsSkipped;\r\n          legalHoldsBlocked = tenantResult.legalHoldsBlocked;\r\n          break;\r\n\r\n        case 'USER_DATA':\r\n          const userDataResult = await this.enforceUserDataRetention(cutoffDate, legalHoldTenantIds, dryRun);\r\n          recordsProcessed = userDataResult.recordsProcessed;\r\n          recordsDeleted = userDataResult.recordsDeleted;\r\n          recordsSkipped = userDataResult.recordsSkipped;\r\n          legalHoldsBlocked = userDataResult.legalHoldsBlocked;\r\n          break;\r\n\r\n        default:\r\n          throw new Error(`Unknown data type for retention enforcement: ${dataType}`);\r\n      }\r\n\r\n    } catch (error) {\r\n      errors.push((error as Error).message);\r\n      logger.error('Retention enforcement execution failed', error as Error, {\r\n        dataType,\r\n        cutoffDate,\r\n        legalHoldCount: legalHoldTenantIds.size\r\n      });\r\n    }\r\n\r\n    return {\r\n      recordsProcessed,\r\n      recordsDeleted,\r\n      recordsSkipped,\r\n      errors,\r\n      legalHoldsBlocked\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Enforce audit log retention\r\n   */\r\n  private async enforceAuditLogRetention(\r\n    cutoffDate: Date,\r\n    legalHoldTenantIds: Set<string>,\r\n    dryRun: boolean\r\n  ): Promise<{\r\n    recordsProcessed: number;\r\n    recordsDeleted: number;\r\n    recordsSkipped: number;\r\n    legalHoldsBlocked: number;\r\n  }> {\r\n    try {\r\n      let recordsProcessed = 0;\r\n      let recordsDeleted = 0;\r\n      let recordsSkipped = 0;\r\n      let legalHoldsBlocked = 0;\r\n\r\n      // CRITICAL: Get old audit logs (excluding legal holds)\r\n      const query = `\r\n        SELECT id, tenant_id, timestamp\r\n        FROM audit_logs \r\n        WHERE timestamp < $1\r\n        AND tenant_id NOT IN (${Array.from(legalHoldTenantIds).map((_, i) => `$${i + 2}`).join(', ')})\r\n        ORDER BY timestamp ASC\r\n        LIMIT 10000\r\n      `;\r\n\r\n      const params = [cutoffDate, ...Array.from(legalHoldTenantIds)];\r\n      const oldLogs = await this.prisma.$queryRawUnsafe(query, ...params) as Array<{ id: string; tenant_id: string; timestamp: Date }>;\r\n\r\n      for (const log of oldLogs) {\r\n        recordsProcessed++;\r\n\r\n        if (legalHoldTenantIds.has(log.tenant_id)) {\r\n          recordsSkipped++;\r\n          legalHoldsBlocked++;\r\n          continue;\r\n        }\r\n\r\n        if (!dryRun) {\r\n          // CRITICAL: Delete old audit logs (this is the only allowed deletion)\r\n          await this.prisma.$executeRaw`DELETE FROM audit_logs WHERE id = ${log.id}`;\r\n          recordsDeleted++;\r\n        } else {\r\n          recordsDeleted++; // Count as would-be deleted in dry run\r\n        }\r\n      }\r\n\r\n      return {\r\n        recordsProcessed,\r\n        recordsDeleted,\r\n        recordsSkipped,\r\n        legalHoldsBlocked\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to enforce audit log retention', error as Error, {\r\n        cutoffDate,\r\n        legalHoldCount: legalHoldTenantIds.size\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Enforce backup retention\r\n   */\r\n  private async enforceBackupRetention(\r\n    cutoffDate: Date,\r\n    legalHoldTenantIds: Set<string>,\r\n    dryRun: boolean\r\n  ): Promise<{\r\n    recordsProcessed: number;\r\n    recordsDeleted: number;\r\n    recordsSkipped: number;\r\n    legalHoldsBlocked: number;\r\n  }> {\r\n    // CRITICAL: Implementation would depend on backup storage system\r\n    // This is a placeholder for the actual backup retention logic\r\n    logger.info('Backup retention enforcement', {\r\n      cutoffDate,\r\n      legalHoldCount: legalHoldTenantIds.size,\r\n      dryRun\r\n    });\r\n\r\n    return {\r\n      recordsProcessed: 0,\r\n      recordsDeleted: 0,\r\n      recordsSkipped: 0,\r\n      legalHoldsBlocked: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Enforce tenant retention\r\n   */\r\n  private async enforceTenantRetention(\r\n    cutoffDate: Date,\r\n    legalHoldTenantIds: Set<string>,\r\n    dryRun: boolean\r\n  ): Promise<{\r\n    recordsProcessed: number;\r\n    recordsDeleted: number;\r\n    recordsSkipped: number;\r\n    legalHoldsBlocked: number;\r\n  }> {\r\n    try {\r\n      let recordsProcessed = 0;\r\n      let recordsDeleted = 0;\r\n      let recordsSkipped = 0;\r\n      let legalHoldsBlocked = 0;\r\n\r\n      // CRITICAL: Get soft-deleted tenants past retention period\r\n      const query = `\r\n        SELECT id, tenant_id, deleted_at\r\n        FROM tenants \r\n        WHERE deleted_at < $1\r\n        AND deleted_at IS NOT NULL\r\n        AND tenant_id NOT IN (${Array.from(legalHoldTenantIds).map((_, i) => `$${i + 2}`).join(', ')})\r\n        ORDER BY deleted_at ASC\r\n        LIMIT 1000\r\n      `;\r\n\r\n      const params = [cutoffDate, ...Array.from(legalHoldTenantIds)];\r\n      const oldTenants = await this.prisma.$queryRawUnsafe(query, ...params) as Array<{ id: string; tenant_id: string; deleted_at: Date }>;\r\n\r\n      for (const tenant of oldTenants) {\r\n        recordsProcessed++;\r\n\r\n        if (legalHoldTenantIds.has(tenant.tenant_id)) {\r\n          recordsSkipped++;\r\n          legalHoldsBlocked++;\r\n          continue;\r\n        }\r\n\r\n        if (!dryRun) {\r\n          // CRITICAL: Permanently delete tenant data\r\n          await this.permanentlyDeleteTenant(tenant.tenant_id);\r\n          recordsDeleted++;\r\n        } else {\r\n          recordsDeleted++; // Count as would-be deleted in dry run\r\n        }\r\n      }\r\n\r\n      return {\r\n        recordsProcessed,\r\n        recordsDeleted,\r\n        recordsSkipped,\r\n        legalHoldsBlocked\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to enforce tenant retention', error as Error, {\r\n        cutoffDate,\r\n        legalHoldCount: legalHoldTenantIds.size\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Enforce user data retention\r\n   */\r\n  private async enforceUserDataRetention(\r\n    cutoffDate: Date,\r\n    legalHoldTenantIds: Set<string>,\r\n    dryRun: boolean\r\n  ): Promise<{\r\n    recordsProcessed: number;\r\n    recordsDeleted: number;\r\n    recordsSkipped: number;\r\n    legalHoldsBlocked: number;\r\n  }> {\r\n    // CRITICAL: Implementation would depend on specific user data retention requirements\r\n    // This is a placeholder for the actual user data retention logic\r\n    logger.info('User data retention enforcement', {\r\n      cutoffDate,\r\n      legalHoldCount: legalHoldTenantIds.size,\r\n      dryRun\r\n    });\r\n\r\n    return {\r\n      recordsProcessed: 0,\r\n      recordsDeleted: 0,\r\n      recordsSkipped: 0,\r\n      legalHoldsBlocked: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Permanently delete tenant and all associated data\r\n   */\r\n  private async permanentlyDeleteTenant(tenantId: string): Promise<void> {\r\n    // CRITICAL: This is a destructive operation that cannot be undone\r\n    // All data associated with the tenant will be permanently deleted\r\n    \r\n    try {\r\n      // CRITICAL: Delete in proper order to respect foreign key constraints\r\n      await this.prisma.$transaction(async (tx: any) => {\r\n        // Delete user-tenant relationships\r\n        await tx.$executeRaw`DELETE FROM user_tenants WHERE tenant_id = ${tenantId}`;\r\n        \r\n        // Delete tenant\r\n        await tx.$executeRaw`DELETE FROM tenants WHERE id = ${tenantId}`;\r\n        \r\n        // CRITICAL: Note: Other tenant-specific data would be deleted here\r\n        // This is a simplified example - real implementation would delete all data\r\n      });\r\n\r\n      logger.info('Tenant permanently deleted', { tenantId });\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to permanently delete tenant', error as Error, { tenantId });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get retention job status\r\n   */\r\n  getJobStatus(jobId: string): RetentionJob | undefined {\r\n    return this.activeJobs.get(jobId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get retention statistics\r\n   */\r\n  async getRetentionStatistics(): Promise<{\r\n    policies: Array<{\r\n      dataType: RetentionPolicy['dataType'];\r\n      retentionDays: number;\r\n      enforcementEnabled: boolean;\r\n      legalHoldCount: number;\r\n      lastEnforcedAt?: Date;\r\n    }>;\r\n    activeLegalHolds: number;\r\n    activeJobs: number;\r\n  }> {\r\n    const policies = Array.from(this.retentionPolicies.entries()).map(([dataType, policy]) => ({\r\n      dataType,\r\n      retentionDays: policy.retentionDays,\r\n      enforcementEnabled: policy.enforcementEnabled,\r\n      legalHoldCount: policy.legalHoldExceptions.length,\r\n      lastEnforcedAt: policy.lastEnforcedAt\r\n    }));\r\n\r\n    const activeLegalHolds = await this.getActiveLegalHolds();\r\n\r\n    return {\r\n      policies,\r\n      activeLegalHolds: activeLegalHolds.length,\r\n      activeJobs: this.activeJobs.size\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate cryptographically secure ID\r\n   */\r\n  private generateSecureId(): string {\r\n    const { randomBytes } = require('crypto');\r\n    const bytes = randomBytes(16);\r\n    return `retention_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Factory function for creating compliance retention manager\r\n */\r\nexport const createComplianceRetentionManager = (prisma: PrismaClient): ComplianceRetentionManager => {\r\n  return new ComplianceRetentionManager(prisma);\r\n};\r\n\r\n/**\r\n * CRITICAL: Global compliance retention manager instance\r\n */\r\nlet globalComplianceRetentionManager: ComplianceRetentionManager | null = null;\r\n\r\n/**\r\n * CRITICAL: Get or create global compliance retention manager\r\n */\r\nexport const getComplianceRetentionManager = (prisma?: PrismaClient): ComplianceRetentionManager => {\r\n  if (!globalComplianceRetentionManager) {\r\n    if (!prisma) {\r\n      throw new Error('Prisma client required for first initialization');\r\n    }\r\n    globalComplianceRetentionManager = new ComplianceRetentionManager(prisma);\r\n  }\r\n  return globalComplianceRetentionManager;\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\runtime-compliance-guards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\tenant-data-export.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\compliance\\trust-center.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\config\\env-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\controllers\\auth.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\controllers\\inventory.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\database\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\database\\schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\enterprise\\approval-workflows.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":793,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":793,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Approval Workflows\r\n// MANDATORY: Two-step approval workflow with configurable policies\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { dangerousOperationsRegistry, DangerousOperation, ApprovalPolicy } from './dangerous-operations.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport interface ApprovalRequest {\r\n  id: string;\r\n  operationId: string;\r\n  operationName: string;\r\n  tenantId: string;\r\n  requestedBy: string;\r\n  correlationId: string;\r\n  parameters: Record<string, any>;\r\n  reason: string;\r\n  status: 'PENDING' | 'APPROVED' | 'REJECTED' | 'EXPIRED' | 'EXECUTED' | 'FAILED';\r\n  approvalPolicy: ApprovalPolicy;\r\n  requiredApprovers: number;\r\n  currentApprovals: string[];\r\n  rejections: string[];\r\n  expiresAt: Date;\r\n  requestedAt: Date;\r\n  approvedAt?: Date;\r\n  rejectedAt?: Date;\r\n  executedAt?: Date;\r\n  executedBy?: string;\r\n  executionResult?: any;\r\n  executionError?: string;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface ApprovalDecision {\r\n  requestId: string;\r\n  approverId: string;\r\n  decision: 'APPROVE' | 'REJECT';\r\n  reason: string;\r\n  correlationId: string;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface ExecutionResult {\r\n  requestId: string;\r\n  status: 'SUCCESS' | 'FAILED';\r\n  result?: any;\r\n  error?: string;\r\n  duration: number;\r\n  executedBy: string;\r\n  executedAt: Date;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Approval Workflow Manager\r\n * \r\n * This class manages two-step approval workflows for dangerous operations\r\n * with configurable policies and comprehensive audit logging.\r\n */\r\nexport class ApprovalWorkflowManager {\r\n  private static instance: ApprovalWorkflowManager;\r\n  private prisma: PrismaClient;\r\n  private auditLogger: any;\r\n  private requestCache: Map<string, ApprovalRequest> = new Map();\r\n  private cacheTimeoutMs = 600000; // 10 minutes\r\n\r\n  constructor(prisma: PrismaClient) {\r\n    this.prisma = prisma;\r\n    this.auditLogger = getImmutableAuditLogger(prisma);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(prisma?: PrismaClient): ApprovalWorkflowManager {\r\n    if (!ApprovalWorkflowManager.instance) {\r\n      if (!prisma) {\r\n        throw new Error('Prisma client required for first initialization');\r\n      }\r\n      ApprovalWorkflowManager.instance = new ApprovalWorkflowManager(prisma);\r\n    }\r\n    return ApprovalWorkflowManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create approval request\r\n   */\r\n  async createApprovalRequest(\r\n    operationId: string,\r\n    tenantContext: TenantContext,\r\n    parameters: Record<string, any>,\r\n    reason: string,\r\n    correlationId: string\r\n  ): Promise<ApprovalRequest> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // CRITICAL: Get operation definition\r\n      const operation = dangerousOperationsRegistry.getOperationById(operationId);\r\n      if (!operation) {\r\n        throw new Error(`Operation '${operationId}' not found in registry`);\r\n      }\r\n\r\n      // CRITICAL: Check if operation requires approval\r\n      if (operation.approvalPolicy === 'NONE') {\r\n        throw new Error(`Operation '${operation.name}' does not require approval`);\r\n      }\r\n\r\n      // CRITICAL: Validate request\r\n      const validationResult = dangerousOperationsRegistry.validateOperationRequest({\r\n        operationId,\r\n        tenantId: tenantContext.tenantId,\r\n        requestedBy: (tenantContext as any).user?.id || 'unknown',\r\n        correlationId,\r\n        parameters,\r\n        reason\r\n      });\r\n\r\n      if (!validationResult.valid) {\r\n        throw new Error(`Invalid request: ${validationResult.errors.join(', ')}`);\r\n      }\r\n\r\n      // CRITICAL: Check for existing pending request\r\n      const existingRequest = await this.getPendingRequest(operationId, tenantContext.tenantId);\r\n      if (existingRequest) {\r\n        throw new Error(`Pending approval request already exists for operation '${operation.name}'`);\r\n      }\r\n\r\n      // CRITICAL: Calculate expiration time\r\n      const expiresAt = new Date();\r\n      expiresAt.setHours(expiresAt.getHours() + 24); // 24 hours\r\n\r\n      // CRITICAL: Calculate required approvers\r\n      const requiredApprovers = this.calculateRequiredApprovers(operation);\r\n\r\n      // CRITICAL: Create approval request\r\n      const requestId = this.generateRequestId();\r\n      const request: ApprovalRequest = {\r\n        id: requestId,\r\n        operationId,\r\n        operationName: operation.name,\r\n        tenantId: tenantContext.tenantId,\r\n        requestedBy: (tenantContext as any).user?.id || 'unknown',\r\n        correlationId,\r\n        parameters,\r\n        reason,\r\n        status: 'PENDING',\r\n        approvalPolicy: operation.approvalPolicy,\r\n        requiredApprovers,\r\n        currentApprovals: [],\r\n        rejections: [],\r\n        expiresAt,\r\n        requestedAt: new Date(),\r\n        metadata: {\r\n          operationCategory: operation.category,\r\n          riskLevel: operation.riskLevel,\r\n          irreversible: operation.irreversible,\r\n          featureFlag: operation.featureFlag\r\n        }\r\n      };\r\n\r\n      // CRITICAL: Store request\r\n      await this.storeApprovalRequest(request);\r\n\r\n      // CRITICAL: Cache request\r\n      this.requestCache.set(requestId, request);\r\n\r\n      // CRITICAL: Log request creation\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: tenantContext.tenantId,\r\n        actorId: request.requestedBy,\r\n        action: 'CREATE',\r\n        resourceType: 'APPROVAL_REQUEST',\r\n        resourceId: requestId,\r\n        outcome: 'SUCCESS',\r\n        correlationId,\r\n        metadata: {\r\n          operationName: operation.name,\r\n          operationCategory: operation.category,\r\n          riskLevel: operation.riskLevel,\r\n          approvalPolicy: operation.approvalPolicy,\r\n          requiredApprovers,\r\n          reason,\r\n          duration: Date.now() - startTime\r\n        }\r\n      });\r\n\r\n      logger.info('Approval request created', {\r\n        requestId,\r\n        operationName: operation.name,\r\n        tenantId: tenantContext.tenantId,\r\n        requestedBy: request.requestedBy,\r\n        approvalPolicy: operation.approvalPolicy,\r\n        requiredApprovers,\r\n        duration: Date.now() - startTime\r\n      });\r\n\r\n      return request;\r\n\r\n    } catch (error) {\r\n      // CRITICAL: Log failed request creation\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: tenantContext.tenantId,\r\n        actorId: (tenantContext as any).user?.id || 'unknown',\r\n        action: 'CREATE',\r\n        resourceType: 'APPROVAL_REQUEST',\r\n        resourceId: 'unknown',\r\n        outcome: 'FAILURE',\r\n        correlationId,\r\n        metadata: {\r\n          operationId,\r\n          error: (error as Error).message\r\n        }\r\n      });\r\n\r\n      logger.error('Failed to create approval request', error as Error, {\r\n        operationId,\r\n        tenantId: tenantContext.tenantId\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Approve or reject request\r\n   */\r\n  async processApprovalDecision(decision: ApprovalDecision, tenantContext: TenantContext): Promise<ApprovalRequest> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // CRITICAL: Get request\r\n      const request = await this.getApprovalRequest(decision.requestId);\r\n      if (!request) {\r\n        throw new Error(`Approval request '${decision.requestId}' not found`);\r\n      }\r\n\r\n      // CRITICAL: Validate tenant context\r\n      if (request.tenantId !== tenantContext.tenantId) {\r\n        throw new Error('Tenant context mismatch');\r\n      }\r\n\r\n      // CRITICAL: Check request status\r\n      if (request.status !== 'PENDING') {\r\n        throw new Error(`Request is not pending (current status: ${request.status})`);\r\n      }\r\n\r\n      // CRITICAL: Check if expired\r\n      if (new Date() > request.expiresAt) {\r\n        await this.expireRequest(decision.requestId);\r\n        throw new Error('Approval request has expired');\r\n      }\r\n\r\n      // CRITICAL: Check for self-approval\r\n      if (request.requestedBy === decision.approverId) {\r\n        throw new Error('Self-approval is not allowed');\r\n      }\r\n\r\n      // CRITICAL: Check if already decided\r\n      if (request.currentApprovals.includes(decision.approverId) || request.rejections.includes(decision.approverId)) {\r\n        throw new Error('Approver has already decided on this request');\r\n      }\r\n\r\n      // CRITICAL: Process decision\r\n      const updatedRequest = await this.applyApprovalDecision(request, decision, tenantContext);\r\n\r\n      // CRITICAL: Cache updated request\r\n      this.requestCache.set(decision.requestId, updatedRequest);\r\n\r\n      // CRITICAL: Log decision\r\n      this.auditLogger.logAuthorizationDecision({\r\n        tenantId: tenantContext.tenantId,\r\n        actorId: decision.approverId,\r\n        action: decision.decision,\r\n        resourceType: 'APPROVAL_REQUEST',\r\n        resourceId: decision.requestId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: decision.correlationId,\r\n        metadata: {\r\n          operationName: request.operationName,\r\n          approvalPolicy: request.approvalPolicy,\r\n          currentApprovals: updatedRequest.currentApprovals.length,\r\n          requiredApprovers: updatedRequest.requiredApprovers,\r\n          reason: decision.reason,\r\n          duration: Date.now() - startTime\r\n        }\r\n      });\r\n\r\n      logger.info('Approval decision processed', {\r\n        requestId: decision.requestId,\r\n        decision: decision.decision,\r\n        approverId: decision.approverId,\r\n        operationName: request.operationName,\r\n        currentApprovals: updatedRequest.currentApprovals.length,\r\n        requiredApprovers: updatedRequest.requiredApprovers,\r\n        duration: Date.now() - startTime\r\n      });\r\n\r\n      return updatedRequest;\r\n\r\n    } catch (error) {\r\n      // CRITICAL: Log failed decision\r\n      this.auditLogger.logAuthorizationDecision({\r\n        tenantId: tenantContext.tenantId,\r\n        actorId: decision.approverId,\r\n        action: decision.decision,\r\n        resourceType: 'APPROVAL_REQUEST',\r\n        resourceId: decision.requestId,\r\n        outcome: 'FAILURE',\r\n        correlationId: decision.correlationId,\r\n        metadata: {\r\n          error: (error as Error).message\r\n        }\r\n      });\r\n\r\n      logger.error('Failed to process approval decision', error as Error, {\r\n        requestId: decision.requestId,\r\n        decision: decision.decision,\r\n        approverId: decision.approverId\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute approved operation\r\n   */\r\n  async executeApprovedOperation(\r\n    requestId: string,\r\n    tenantContext: TenantContext\r\n  ): Promise<ExecutionResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // CRITICAL: Get request\r\n      const request = await this.getApprovalRequest(requestId);\r\n      if (!request) {\r\n        throw new Error(`Approval request '${requestId}' not found`);\r\n      }\r\n\r\n      // CRITICAL: Validate tenant context\r\n      if (request.tenantId !== tenantContext.tenantId) {\r\n        throw new Error('Tenant context mismatch');\r\n      }\r\n\r\n      // CRITICAL: Check if approved\r\n      if (request.status !== 'APPROVED') {\r\n        throw new Error(`Request is not approved (current status: ${request.status})`);\r\n      }\r\n\r\n      // CRITICAL: Check if already executed\r\n      if ((request.status as string) === 'EXECUTED') {\r\n        throw new Error('Request has already been executed');\r\n      }\r\n\r\n      // CRITICAL: Execute operation\r\n      const result = await this.performOperationExecution(request, tenantContext);\r\n\r\n      // CRITICAL: Update request\r\n      await this.updateRequestExecution(requestId, result, tenantContext);\r\n\r\n      // CRITICAL: Log execution\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: tenantContext.tenantId,\r\n        actorId: result.executedBy,\r\n        action: 'EXECUTE',\r\n        resourceType: 'DANGEROUS_OPERATION',\r\n        resourceId: request.operationId,\r\n        outcome: result.status,\r\n        correlationId: request.correlationId,\r\n        metadata: {\r\n          operationName: request.operationName,\r\n          requestId,\r\n          duration: result.duration,\r\n          success: result.status === 'SUCCESS'\r\n        }\r\n      });\r\n\r\n      logger.info('Dangerous operation executed', {\r\n        requestId,\r\n        operationName: request.operationName,\r\n        status: result.status,\r\n        executedBy: result.executedBy,\r\n        duration: result.duration\r\n      });\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      // CRITICAL: Log failed execution\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: tenantContext.tenantId,\r\n        actorId: (tenantContext as any).user?.id || 'unknown',\r\n        action: 'EXECUTE',\r\n        resourceType: 'DANGEROUS_OPERATION',\r\n        resourceId: requestId,\r\n        outcome: 'FAILURE',\r\n        correlationId: 'execution_' + Date.now(),\r\n        metadata: {\r\n          error: (error as Error).message\r\n        }\r\n      });\r\n\r\n      logger.error('Failed to execute dangerous operation', error as Error, {\r\n        requestId\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get approval request\r\n   */\r\n  async getApprovalRequest(requestId: string): Promise<ApprovalRequest | null> {\r\n    try {\r\n      // CRITICAL: Check cache first\r\n      const cached = this.requestCache.get(requestId);\r\n      if (cached) {\r\n        return cached;\r\n      }\r\n\r\n      // CRITICAL: Get from database\r\n      const result = await this.prisma.$queryRaw`\r\n        SELECT id, operation_id, operation_name, tenant_id, requested_by, correlation_id,\r\n               parameters, reason, status, approval_policy, required_approvers,\r\n               current_approvals, rejections, expires_at, requested_at,\r\n               approved_at, rejected_at, executed_at, executed_by,\r\n               execution_result, execution_error, metadata\r\n        FROM approval_requests\r\n        WHERE id = ${requestId}\r\n      ` as ApprovalRequest[];\r\n\r\n      if (result.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      const request = result[0];\r\n      \r\n      // CRITICAL: Parse JSON fields\r\n      if (typeof request.parameters === 'string') {\r\n        request.parameters = JSON.parse(request.parameters);\r\n      }\r\n      if (typeof request.currentApprovals === 'string') {\r\n        request.currentApprovals = JSON.parse(request.currentApprovals);\r\n      }\r\n      if (typeof request.rejections === 'string') {\r\n        request.rejections = JSON.parse(request.rejections);\r\n      }\r\n      if (typeof request.metadata === 'string') {\r\n        request.metadata = JSON.parse(request.metadata);\r\n      }\r\n\r\n      // CRITICAL: Cache request\r\n      this.requestCache.set(requestId, request);\r\n\r\n      return request;\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to get approval request', error as Error, { requestId });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get pending requests for tenant\r\n   */\r\n  async getPendingRequests(tenantId: string): Promise<ApprovalRequest[]> {\r\n    try {\r\n      const result = await this.prisma.$queryRaw`\r\n        SELECT id, operation_id, operation_name, tenant_id, requested_by, correlation_id,\r\n               parameters, reason, status, approval_policy, required_approvers,\r\n               current_approvals, rejections, expires_at, requested_at,\r\n               approved_at, rejected_at, executed_at, executed_by,\r\n               execution_result, execution_error, metadata\r\n        FROM approval_requests\r\n        WHERE tenant_id = ${tenantId} AND status = 'PENDING'\r\n        ORDER BY requested_at DESC\r\n      ` as ApprovalRequest[];\r\n\r\n      // CRITICAL: Parse JSON fields\r\n      for (const request of result) {\r\n        if (typeof request.parameters === 'string') {\r\n          request.parameters = JSON.parse(request.parameters);\r\n        }\r\n        if (typeof request.currentApprovals === 'string') {\r\n          request.currentApprovals = JSON.parse(request.currentApprovals);\r\n        }\r\n        if (typeof request.rejections === 'string') {\r\n          request.rejections = JSON.parse(request.rejections);\r\n        }\r\n        if (typeof request.metadata === 'string') {\r\n          request.metadata = JSON.parse(request.metadata);\r\n        }\r\n      }\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to get pending requests', error as Error, { tenantId });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get approval statistics\r\n   */\r\n  async getApprovalStatistics(tenantId?: string): Promise<{\r\n    totalRequests: number;\r\n    pendingRequests: number;\r\n    approvedRequests: number;\r\n    rejectedRequests: number;\r\n    executedRequests: number;\r\n    expiredRequests: number;\r\n    averageApprovalTime: number;\r\n    approvalRate: number;\r\n  }> {\r\n    try {\r\n      const whereClause = tenantId ? `WHERE tenant_id = ${tenantId}` : '';\r\n      \r\n      const result = await this.prisma.$queryRaw`\r\n        SELECT \r\n          COUNT(*) as total_requests,\r\n          COUNT(*) FILTER (WHERE status = 'PENDING') as pending_requests,\r\n          COUNT(*) FILTER (WHERE status = 'APPROVED') as approved_requests,\r\n          COUNT(*) FILTER (WHERE status = 'REJECTED') as rejected_requests,\r\n          COUNT(*) FILTER (WHERE status = 'EXECUTED') as executed_requests,\r\n          COUNT(*) FILTER (WHERE status = 'EXPIRED') as expired_requests,\r\n          AVG(EXTRACT(EPOCH FROM (approved_at - requested_at))) as avg_approval_time\r\n        FROM approval_requests\r\n        ${whereClause}\r\n      ` as Array<{\r\n        total_requests: bigint;\r\n        pending_requests: bigint;\r\n        approved_requests: bigint;\r\n        rejected_requests: bigint;\r\n        executed_requests: bigint;\r\n        expired_requests: bigint;\r\n        avg_approval_time: number;\r\n      }>;\r\n\r\n      const stats = result[0];\r\n      const total = Number(stats.total_requests);\r\n      const approved = Number(stats.approved_requests);\r\n\r\n      return {\r\n        totalRequests: total,\r\n        pendingRequests: Number(stats.pending_requests),\r\n        approvedRequests: approved,\r\n        rejectedRequests: Number(stats.rejected_requests),\r\n        executedRequests: Number(stats.executed_requests),\r\n        expiredRequests: Number(stats.expired_requests),\r\n        averageApprovalTime: stats.avg_approval_time || 0,\r\n        approvalRate: total > 0 ? (approved / total) * 100 : 0\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to get approval statistics', error as Error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate required approvers\r\n   */\r\n  private calculateRequiredApprovers(operation: DangerousOperation): number {\r\n    switch (operation.approvalPolicy) {\r\n      case 'SINGLE_ADMIN':\r\n        return 1;\r\n      case 'MULTI_ADMIN':\r\n        return operation.multiAdminConfig?.requiredApprovers || 2;\r\n      case 'OWNER_ONLY':\r\n        return 1;\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Apply approval decision\r\n   */\r\n  private async applyApprovalDecision(\r\n    request: ApprovalRequest,\r\n    decision: ApprovalDecision,\r\n    tenantContext: TenantContext\r\n  ): Promise<ApprovalRequest> {\r\n    const updatedRequest = { ...request };\r\n\r\n    if (decision.decision === 'APPROVE') {\r\n      updatedRequest.currentApprovals.push(decision.approverId);\r\n      \r\n      // CRITICAL: Check if fully approved\r\n      if (updatedRequest.currentApprovals.length >= updatedRequest.requiredApprovers) {\r\n        updatedRequest.status = 'APPROVED';\r\n        updatedRequest.approvedAt = new Date();\r\n      }\r\n    } else {\r\n      updatedRequest.rejections.push(decision.approverId);\r\n      updatedRequest.status = 'REJECTED';\r\n      updatedRequest.rejectedAt = new Date();\r\n    }\r\n\r\n    // CRITICAL: Update in database\r\n    await this.updateApprovalRequest(updatedRequest);\r\n\r\n    return updatedRequest;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Perform operation execution\r\n   */\r\n  private async performOperationExecution(\r\n    request: ApprovalRequest,\r\n    tenantContext: TenantContext\r\n  ): Promise<ExecutionResult> {\r\n    const startTime = Date.now();\r\n    const executedBy = (tenantContext as any).user?.id || 'system';\r\n\r\n    try {\r\n      // CRITICAL: Get operation definition\r\n      const operation = dangerousOperationsRegistry.getOperationById(request.operationId);\r\n      if (!operation) {\r\n        throw new Error(`Operation '${request.operationId}' not found`);\r\n      }\r\n\r\n      // CRITICAL: Execute operation based on type\r\n      let result: any;\r\n\r\n      switch (request.operationName) {\r\n        case 'TENANT_DELETION':\r\n          result = await this.executeTenantDeletion(request.parameters, tenantContext);\r\n          break;\r\n        case 'TENANT_OWNERSHIP_TRANSFER':\r\n          result = await this.executeOwnershipTransfer(request.parameters, tenantContext);\r\n          break;\r\n        case 'DATA_PURGE':\r\n          result = await this.executeDataPurge(request.parameters, tenantContext);\r\n          break;\r\n        case 'LEGAL_HOLD_REMOVAL':\r\n          result = await this.executeLegalHoldRemoval(request.parameters, tenantContext);\r\n          break;\r\n        case 'AUDIT_LOG_OVERRIDE':\r\n          result = await this.executeAuditLogOverride(request.parameters, tenantContext);\r\n          break;\r\n        case 'SUBSCRIPTION_DOWNGRADE':\r\n          result = await this.executeSubscriptionDowngrade(request.parameters, tenantContext);\r\n          break;\r\n        default:\r\n          throw new Error(`Unknown operation: ${request.operationName}`);\r\n      }\r\n\r\n      return {\r\n        requestId: request.id,\r\n        status: 'SUCCESS',\r\n        result,\r\n        duration: Date.now() - startTime,\r\n        executedBy,\r\n        executedAt: new Date(),\r\n        metadata: {\r\n          operationName: request.operationName,\r\n          operationCategory: operation.category\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        requestId: request.id,\r\n        status: 'FAILED',\r\n        error: (error as Error).message,\r\n        duration: Date.now() - startTime,\r\n        executedBy,\r\n        executedAt: new Date(),\r\n        metadata: {\r\n          operationName: request.operationName\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Operation execution implementations (placeholders)\r\n   */\r\n  private async executeTenantDeletion(parameters: Record<string, any>, tenantContext: TenantContext): Promise<any> {\r\n    // CRITICAL: Placeholder implementation\r\n    logger.warn('Tenant deletion execution', { parameters, tenantId: tenantContext.tenantId });\r\n    return { deleted: true, tenantId: parameters.tenantId };\r\n  }\r\n\r\n  private async executeOwnershipTransfer(parameters: Record<string, any>, tenantContext: TenantContext): Promise<any> {\r\n    // CRITICAL: Placeholder implementation\r\n    logger.warn('Ownership transfer execution', { parameters, tenantId: tenantContext.tenantId });\r\n    return { transferred: true, newOwnerId: parameters.newOwnerId };\r\n  }\r\n\r\n  private async executeDataPurge(parameters: Record<string, any>, tenantContext: TenantContext): Promise<any> {\r\n    // CRITICAL: Placeholder implementation\r\n    logger.warn('Data purge execution', { parameters, tenantId: tenantContext.tenantId });\r\n    return { purged: true, dataType: parameters.dataType, recordsDeleted: 0 };\r\n  }\r\n\r\n  private async executeLegalHoldRemoval(parameters: Record<string, any>, tenantContext: TenantContext): Promise<any> {\r\n    // CRITICAL: Placeholder implementation\r\n    logger.warn('Legal hold removal execution', { parameters, tenantId: tenantContext.tenantId });\r\n    return { removed: true, legalHoldId: parameters.legalHoldId };\r\n  }\r\n\r\n  private async executeAuditLogOverride(parameters: Record<string, any>, tenantContext: TenantContext): Promise<any> {\r\n    // CRITICAL: Placeholder implementation\r\n    logger.warn('Audit log override execution', { parameters, tenantId: tenantContext.tenantId });\r\n    return { overridden: true, overrideReason: parameters.overrideReason };\r\n  }\r\n\r\n  private async executeSubscriptionDowngrade(parameters: Record<string, any>, tenantContext: TenantContext): Promise<any> {\r\n    // CRITICAL: Placeholder implementation\r\n    logger.warn('Subscription downgrade execution', { parameters, tenantId: tenantContext.tenantId });\r\n    return { downgraded: true, targetTier: parameters.targetTier };\r\n  }\r\n\r\n  /**\r\n   CRITICAL: Database operations\r\n   */\r\n  private async storeApprovalRequest(request: ApprovalRequest): Promise<void> {\r\n    await this.prisma.$executeRaw`\r\n      INSERT INTO approval_requests (\r\n        id, operation_id, operation_name, tenant_id, requested_by, correlation_id,\r\n        parameters, reason, status, approval_policy, required_approvers,\r\n        current_approvals, rejections, expires_at, requested_at, metadata\r\n      ) VALUES (\r\n        ${request.id}, ${request.operationId}, ${request.operationName}, ${request.tenantId},\r\n        ${request.requestedBy}, ${request.correlationId}, ${JSON.stringify(request.parameters)},\r\n        ${request.reason}, ${request.status}, ${request.approvalPolicy}, ${request.requiredApprovers},\r\n        ${JSON.stringify(request.currentApprovals)}, ${JSON.stringify(request.rejections)},\r\n        ${request.expiresAt}, ${request.requestedAt}, ${JSON.stringify(request.metadata)}\r\n      )\r\n    `;\r\n  }\r\n\r\n  private async updateApprovalRequest(request: ApprovalRequest): Promise<void> {\r\n    await this.prisma.$executeRaw`\r\n      UPDATE approval_requests\r\n      SET \r\n        status = ${request.status},\r\n        current_approvals = ${JSON.stringify(request.currentApprovals)},\r\n        rejections = ${JSON.stringify(request.rejections)},\r\n        approved_at = ${request.approvedAt},\r\n        rejected_at = ${request.rejectedAt},\r\n        updated_at = NOW()\r\n      WHERE id = ${request.id}\r\n    `;\r\n  }\r\n\r\n  private async updateRequestExecution(requestId: string, result: ExecutionResult, tenantContext: TenantContext): Promise<void> {\r\n    await this.prisma.$executeRaw`\r\n      UPDATE approval_requests\r\n      SET \r\n        status = 'EXECUTED',\r\n        executed_at = ${result.executedAt},\r\n        executed_by = ${result.executedBy},\r\n        execution_result = ${JSON.stringify(result.result)},\r\n        execution_error = ${result.error},\r\n        updated_at = NOW()\r\n      WHERE id = ${requestId}\r\n    `;\r\n  }\r\n\r\n  private async getPendingRequest(operationId: string, tenantId: string): Promise<ApprovalRequest | null> {\r\n    const result = await this.prisma.$queryRaw`\r\n      SELECT id FROM approval_requests\r\n      WHERE operation_id = ${operationId} AND tenant_id = ${tenantId} AND status = 'PENDING'\r\n    ` as Array<{ id: string }>;\r\n\r\n    if (result.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    return this.getApprovalRequest(result[0].id);\r\n  }\r\n\r\n  private async expireRequest(requestId: string): Promise<void> {\r\n    await this.prisma.$executeRaw`\r\n      UPDATE approval_requests\r\n      SET status = 'EXPIRED', updated_at = NOW()\r\n      WHERE id = ${requestId}\r\n    `;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate request ID\r\n   */\r\n  private generateRequestId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(16);\r\n    return `approval_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Clear cache\r\n   */\r\n  clearCache(): void {\r\n    this.requestCache.clear();\r\n    logger.info('Approval workflow cache cleared');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get cache statistics\r\n   */\r\n  getCacheStatistics(): {\r\n    cacheSize: number;\r\n    cacheTimeoutMs: number;\r\n  } {\r\n    return {\r\n      cacheSize: this.requestCache.size,\r\n      cacheTimeoutMs: this.cacheTimeoutMs\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global approval workflow manager instance\r\n */\r\nlet globalApprovalWorkflowManager: ApprovalWorkflowManager | null = null;\r\n\r\nexport const createApprovalWorkflowManager = (prisma: PrismaClient): ApprovalWorkflowManager => {\r\n  return new ApprovalWorkflowManager(prisma);\r\n};\r\n\r\nexport const getApprovalWorkflowManager = (prisma?: PrismaClient): ApprovalWorkflowManager => {\r\n  if (!globalApprovalWorkflowManager) {\r\n    if (!prisma) {\r\n      throw new Error('Prisma client required for first initialization');\r\n    }\r\n    globalApprovalWorkflowManager = new ApprovalWorkflowManager(prisma);\r\n  }\r\n  return globalApprovalWorkflowManager!;\r\n};\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const createApprovalRequest = async (\r\n  operationId: string,\r\n  tenantContext: TenantContext,\r\n  parameters: Record<string, any>,\r\n  reason: string,\r\n  correlationId: string\r\n): Promise<ApprovalRequest> => {\r\n  const manager = getApprovalWorkflowManager();\r\n  return await manager.createApprovalRequest(operationId, tenantContext, parameters, reason, correlationId);\r\n};\r\n\r\nexport const processApprovalDecision = async (\r\n  decision: ApprovalDecision,\r\n  tenantContext: TenantContext\r\n): Promise<ApprovalRequest> => {\r\n  const manager = getApprovalWorkflowManager();\r\n  return await manager.processApprovalDecision(decision, tenantContext);\r\n};\r\n\r\nexport const executeApprovedOperation = async (\r\n  requestId: string,\r\n  tenantContext: TenantContext\r\n): Promise<ExecutionResult> => {\r\n  const manager = getApprovalWorkflowManager();\r\n  return await manager.executeApprovedOperation(requestId, tenantContext);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\enterprise\\dangerous-operations.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":457,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":457,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Dangerous Operations Classification\r\n// MANDATORY: Central registry of dangerous operations with explicit controls\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\n\r\nexport type RiskLevel = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\nexport type ApprovalPolicy = 'NONE' | 'SINGLE_ADMIN' | 'MULTI_ADMIN' | 'OWNER_ONLY';\r\n\r\nexport interface DangerousOperation {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  category: 'TENANT_MANAGEMENT' | 'DATA_MANAGEMENT' | 'COMPLIANCE' | 'SECURITY' | 'SYSTEM';\r\n  riskLevel: RiskLevel;\r\n  requiredPermissions: string[];\r\n  approvalPolicy: ApprovalPolicy;\r\n  multiAdminConfig?: {\r\n    requiredApprovers: number;\r\n    totalApprovers: number;\r\n    allowSelfApproval: boolean;\r\n  };\r\n  irreversible: boolean;\r\n  featureFlag?: string;\r\n  metadata: Record<string, any>;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface OperationExecutionRequest {\r\n  operationId: string;\r\n  tenantId: string;\r\n  requestedBy: string;\r\n  correlationId: string;\r\n  parameters: Record<string, any>;\r\n  reason: string;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface OperationExecutionResult {\r\n  operationId: string;\r\n  requestId: string;\r\n  status: 'REQUESTED' | 'APPROVED' | 'REJECTED' | 'EXECUTED' | 'FAILED';\r\n  executedBy?: string;\r\n  executedAt?: Date;\r\n  result?: any;\r\n  error?: string;\r\n  duration?: number;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Dangerous Operations Registry\r\n * \r\n * This class manages the central registry of dangerous operations\r\n * with explicit risk classification and control requirements.\r\n */\r\nexport class DangerousOperationsRegistry {\r\n  private static instance: DangerousOperationsRegistry;\r\n  private operations: Map<string, DangerousOperation> = new Map();\r\n\r\n  private constructor() {\r\n    this.initializeDefaultOperations();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): DangerousOperationsRegistry {\r\n    if (!DangerousOperationsRegistry.instance) {\r\n      DangerousOperationsRegistry.instance = new DangerousOperationsRegistry();\r\n    }\r\n    return DangerousOperationsRegistry.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Register dangerous operation\r\n   */\r\n  registerOperation(operation: Omit<DangerousOperation, 'id' | 'createdAt' | 'updatedAt'>): string {\r\n    const id = this.generateOperationId(operation.name);\r\n    \r\n    const fullOperation: DangerousOperation = {\r\n      ...operation,\r\n      id,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    // CRITICAL: Validate operation definition\r\n    this.validateOperation(fullOperation);\r\n\r\n    // CRITICAL: Register operation\r\n    this.operations.set(id, fullOperation);\r\n\r\n    logger.info('Dangerous operation registered', {\r\n      operationId: id,\r\n      name: operation.name,\r\n      category: operation.category,\r\n      riskLevel: operation.riskLevel,\r\n      approvalPolicy: operation.approvalPolicy\r\n    });\r\n\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get operation by name\r\n   */\r\n  getOperation(name: string): DangerousOperation | null {\r\n    for (const operation of this.operations.values()) {\r\n      if (operation.name === name) {\r\n        return operation;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get operation by ID\r\n   */\r\n  getOperationById(id: string): DangerousOperation | null {\r\n    return this.operations.get(id) || null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get all operations\r\n   */\r\n  getAllOperations(): DangerousOperation[] {\r\n    return Array.from(this.operations.values());\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get operations by category\r\n   */\r\n  getOperationsByCategory(category: DangerousOperation['category']): DangerousOperation[] {\r\n    return Array.from(this.operations.values()).filter(op => op.category === category);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get operations by risk level\r\n   */\r\n  getOperationsByRiskLevel(riskLevel: RiskLevel): DangerousOperation[] {\r\n    return Array.from(this.operations.values()).filter(op => op.riskLevel === riskLevel);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if operation requires approval\r\n   */\r\n  requiresApproval(operationName: string): boolean {\r\n    const operation = this.getOperation(operationName);\r\n    if (!operation) {\r\n      throw new Error(`Operation '${operationName}' not found in registry`);\r\n    }\r\n    return operation.approvalPolicy !== 'NONE';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get required permissions for operation\r\n   */\r\n  getRequiredPermissions(operationName: string): string[] {\r\n    const operation = this.getOperation(operationName);\r\n    if (!operation) {\r\n      throw new Error(`Operation '${operationName}' not found in registry`);\r\n    }\r\n    return operation.requiredPermissions;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get approval policy for operation\r\n   */\r\n  getApprovalPolicy(operationName: string): ApprovalPolicy {\r\n    const operation = this.getOperation(operationName);\r\n    if (!operation) {\r\n      throw new Error(`Operation '${operationName}' not found in registry`);\r\n    }\r\n    return operation.approvalPolicy;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if operation is irreversible\r\n   */\r\n  isIrreversible(operationName: string): boolean {\r\n    const operation = this.getOperation(operationName);\r\n    if (!operation) {\r\n      throw new Error(`Operation '${operationName}' not found in registry`);\r\n    }\r\n    return operation.irreversible;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get feature flag requirement for operation\r\n   */\r\n  getFeatureFlagRequirement(operationName: string): string | undefined {\r\n    const operation = this.getOperation(operationName);\r\n    if (!operation) {\r\n      throw new Error(`Operation '${operationName}' not found in registry`);\r\n    }\r\n    return operation.featureFlag;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate operation request\r\n   */\r\n  validateOperationRequest(request: OperationExecutionRequest): {\r\n    valid: boolean;\r\n    errors: string[];\r\n    operation: DangerousOperation;\r\n  } {\r\n    const errors: string[] = [];\r\n\r\n    // CRITICAL: Get operation definition\r\n    const operation = this.getOperationById(request.operationId);\r\n    if (!operation) {\r\n      errors.push(`Operation ID '${request.operationId}' not found in registry`);\r\n      return { valid: false, errors, operation: null as any };\r\n    }\r\n\r\n    // CRITICAL: Validate required parameters\r\n    if (!request.tenantId) {\r\n      errors.push('Tenant ID is required');\r\n    }\r\n\r\n    if (!request.requestedBy) {\r\n      errors.push('Requested by is required');\r\n    }\r\n\r\n    if (!request.correlationId) {\r\n      errors.push('Correlation ID is required');\r\n    }\r\n\r\n    if (!request.reason || request.reason.trim().length === 0) {\r\n      errors.push('Reason is required');\r\n    }\r\n\r\n    // CRITICAL: Validate reason length\r\n    if (request.reason && request.reason.length > 1000) {\r\n      errors.push('Reason is too long (max 1000 characters)');\r\n    }\r\n\r\n    // CRITICAL: Validate parameters based on operation\r\n    this.validateOperationParameters(operation, request.parameters, errors);\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      operation\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get operation statistics\r\n   */\r\n  getStatistics(): {\r\n    totalOperations: number;\r\n    operationsByCategory: Record<string, number>;\r\n    operationsByRiskLevel: Record<RiskLevel, number>;\r\n    operationsByApprovalPolicy: Record<ApprovalPolicy, number>;\r\n    irreversibleOperations: number;\r\n    operationsWithFeatureFlags: number;\r\n  } {\r\n    const operations = this.getAllOperations();\r\n    \r\n    const operationsByCategory: Record<string, number> = {};\r\n    const operationsByRiskLevel: Record<RiskLevel, number> = {\r\n      LOW: 0,\r\n      MEDIUM: 0,\r\n      HIGH: 0,\r\n      CRITICAL: 0\r\n    };\r\n    const operationsByApprovalPolicy: Record<ApprovalPolicy, number> = {\r\n      NONE: 0,\r\n      SINGLE_ADMIN: 0,\r\n      MULTI_ADMIN: 0,\r\n      OWNER_ONLY: 0\r\n    };\r\n\r\n    let irreversibleOperations = 0;\r\n    let operationsWithFeatureFlags = 0;\r\n\r\n    for (const operation of operations) {\r\n      // Category statistics\r\n      operationsByCategory[operation.category] = (operationsByCategory[operation.category] || 0) + 1;\r\n      \r\n      // Risk level statistics\r\n      operationsByRiskLevel[operation.riskLevel]++;\r\n      \r\n      // Approval policy statistics\r\n      operationsByApprovalPolicy[operation.approvalPolicy]++;\r\n      \r\n      // Irreversible operations\r\n      if (operation.irreversible) {\r\n        irreversibleOperations++;\r\n      }\r\n      \r\n      // Operations with feature flags\r\n      if (operation.featureFlag) {\r\n        operationsWithFeatureFlags++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalOperations: operations.length,\r\n      operationsByCategory,\r\n      operationsByRiskLevel,\r\n      operationsByApprovalPolicy,\r\n      irreversibleOperations,\r\n      operationsWithFeatureFlags\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate operation definition\r\n   */\r\n  private validateOperation(operation: DangerousOperation): void {\r\n    const errors: string[] = [];\r\n\r\n    // CRITICAL: Validate name\r\n    if (!operation.name || operation.name.trim().length === 0) {\r\n      errors.push('Operation name is required');\r\n    }\r\n\r\n    if (operation.name.length > 100) {\r\n      errors.push('Operation name is too long (max 100 characters)');\r\n    }\r\n\r\n    // CRITICAL: Validate description\r\n    if (!operation.description || operation.description.trim().length === 0) {\r\n      errors.push('Operation description is required');\r\n    }\r\n\r\n    if (operation.description.length > 500) {\r\n      errors.push('Operation description is too long (max 500 characters)');\r\n    }\r\n\r\n    // CRITICAL: Validate category\r\n    const validCategories = ['TENANT_MANAGEMENT', 'DATA_MANAGEMENT', 'COMPLIANCE', 'SECURITY', 'SYSTEM'];\r\n    if (!validCategories.includes(operation.category)) {\r\n      errors.push(`Invalid category: ${operation.category}`);\r\n    }\r\n\r\n    // CRITICAL: Validate risk level\r\n    const validRiskLevels = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];\r\n    if (!validRiskLevels.includes(operation.riskLevel)) {\r\n      errors.push(`Invalid risk level: ${operation.riskLevel}`);\r\n    }\r\n\r\n    // CRITICAL: Validate required permissions\r\n    if (!Array.isArray(operation.requiredPermissions) || operation.requiredPermissions.length === 0) {\r\n      errors.push('At least one required permission must be specified');\r\n    }\r\n\r\n    // CRITICAL: Validate approval policy\r\n    const validApprovalPolicies = ['NONE', 'SINGLE_ADMIN', 'MULTI_ADMIN', 'OWNER_ONLY'];\r\n    if (!validApprovalPolicies.includes(operation.approvalPolicy)) {\r\n      errors.push(`Invalid approval policy: ${operation.approvalPolicy}`);\r\n    }\r\n\r\n    // CRITICAL: Validate multi-admin configuration\r\n    if (operation.approvalPolicy === 'MULTI_ADMIN') {\r\n      if (!operation.multiAdminConfig) {\r\n        errors.push('Multi-admin configuration is required for MULTI_ADMIN approval policy');\r\n      } else {\r\n        if (operation.multiAdminConfig.requiredApprovers < 1) {\r\n          errors.push('Required approvers must be at least 1');\r\n        }\r\n        if (operation.multiAdminConfig.totalApprovers < operation.multiAdminConfig.requiredApprovers) {\r\n          errors.push('Total approvers must be at least equal to required approvers');\r\n        }\r\n        if (operation.multiAdminConfig.totalApprovers > 10) {\r\n          errors.push('Total approvers cannot exceed 10');\r\n        }\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Validate feature flag\r\n    if (operation.featureFlag && operation.featureFlag.length > 64) {\r\n      errors.push('Feature flag name is too long (max 64 characters)');\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      throw new Error(`Invalid operation definition: ${errors.join(', ')}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate operation parameters\r\n   */\r\n  private validateOperationParameters(\r\n    operation: DangerousOperation,\r\n    parameters: Record<string, any>,\r\n    errors: string[]\r\n  ): void {\r\n    // CRITICAL: Common parameter validations based on operation type\r\n    switch (operation.name) {\r\n      case 'TENANT_DELETION':\r\n        if (!parameters.tenantId) {\r\n          errors.push('Tenant ID is required for tenant deletion');\r\n        }\r\n        if (!parameters.confirmation || parameters.confirmation !== 'DELETE') {\r\n          errors.push('Explicit confirmation \"DELETE\" is required for tenant deletion');\r\n        }\r\n        break;\r\n\r\n      case 'TENANT_OWNERSHIP_TRANSFER':\r\n        if (!parameters.newOwnerId) {\r\n          errors.push('New owner ID is required for ownership transfer');\r\n        }\r\n        if (!parameters.confirmation || parameters.confirmation !== 'TRANSFER') {\r\n          errors.push('Explicit confirmation \"TRANSFER\" is required for ownership transfer');\r\n        }\r\n        break;\r\n\r\n      case 'DATA_PURGE':\r\n        if (!parameters.dataType) {\r\n          errors.push('Data type is required for data purge');\r\n        }\r\n        if (!parameters.dateRange) {\r\n          errors.push('Date range is required for data purge');\r\n        }\r\n        if (!parameters.confirmation || parameters.confirmation !== 'PURGE') {\r\n          errors.push('Explicit confirmation \"PURGE\" is required for data purge');\r\n        }\r\n        break;\r\n\r\n      case 'LEGAL_HOLD_REMOVAL':\r\n        if (!parameters.legalHoldId) {\r\n          errors.push('Legal hold ID is required for legal hold removal');\r\n        }\r\n        if (!parameters.reason) {\r\n          errors.push('Reason is required for legal hold removal');\r\n        }\r\n        break;\r\n\r\n      case 'AUDIT_LOG_OVERRIDE':\r\n        if (!parameters.overrideReason) {\r\n          errors.push('Override reason is required for audit log override');\r\n        }\r\n        if (!parameters.confirmation || parameters.confirmation !== 'OVERRIDE') {\r\n          errors.push('Explicit confirmation \"OVERRIDE\" is required for audit log override');\r\n        }\r\n        break;\r\n\r\n      case 'SUBSCRIPTION_DOWNGRADE':\r\n        if (!parameters.targetTier) {\r\n          errors.push('Target tier is required for subscription downgrade');\r\n        }\r\n        if (!parameters.effectiveDate) {\r\n          errors.push('Effective date is required for subscription downgrade');\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate operation ID\r\n   */\r\n  private generateOperationId(name: string): string {\r\n    const crypto = require('crypto');\r\n    const hash = crypto.createHash('sha256').update(name).digest('hex');\r\n    return `op_${hash.substring(0, 16)}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize default dangerous operations\r\n   */\r\n  private initializeDefaultOperations(): void {\r\n    const defaultOperations = [\r\n      {\r\n        name: 'TENANT_DELETION',\r\n        description: 'Permanently delete a tenant and all associated data',\r\n        category: 'TENANT_MANAGEMENT' as const,\r\n        riskLevel: 'CRITICAL' as const,\r\n        requiredPermissions: ['tenant:delete', 'system:admin'],\r\n        approvalPolicy: 'OWNER_ONLY' as const,\r\n        irreversible: true,\r\n        featureFlag: 'TENANT_DELETION',\r\n        metadata: {\r\n          impactScope: 'TENANT_WIDE',\r\n          dataLoss: 'PERMANENT',\r\n          recoveryPossible: false\r\n        }\r\n      },\r\n      {\r\n        name: 'TENANT_OWNERSHIP_TRANSFER',\r\n        description: 'Transfer tenant ownership to another user',\r\n        category: 'TENANT_MANAGEMENT' as const,\r\n        riskLevel: 'HIGH' as const,\r\n        requiredPermissions: ['tenant:manage', 'ownership:transfer'],\r\n        approvalPolicy: 'MULTI_ADMIN' as const,\r\n        multiAdminConfig: {\r\n          requiredApprovers: 2,\r\n          totalApprovers: 3,\r\n          allowSelfApproval: false\r\n        },\r\n        irreversible: false,\r\n        featureFlag: 'DANGEROUS_OPERATIONS',\r\n        metadata: {\r\n          impactScope: 'TENANT_WIDE',\r\n          privilegeEscalation: true,\r\n          reversible: true\r\n        }\r\n      },\r\n      {\r\n        name: 'DATA_PURGE',\r\n        description: 'Permanently purge specific data types',\r\n        category: 'DATA_MANAGEMENT' as const,\r\n        riskLevel: 'CRITICAL' as const,\r\n        requiredPermissions: ['data:purge', 'compliance:override'],\r\n        approvalPolicy: 'MULTI_ADMIN' as const,\r\n        multiAdminConfig: {\r\n          requiredApprovers: 2,\r\n          totalApprovers: 3,\r\n          allowSelfApproval: false\r\n        },\r\n        irreversible: true,\r\n        featureFlag: 'DATA_PURGE',\r\n        metadata: {\r\n          impactScope: 'DATA_TYPE_SPECIFIC',\r\n          dataLoss: 'PERMANENT',\r\n          recoveryPossible: false\r\n        }\r\n      },\r\n      {\r\n        name: 'LEGAL_HOLD_REMOVAL',\r\n        description: 'Remove legal hold from data',\r\n        category: 'COMPLIANCE' as const,\r\n        riskLevel: 'HIGH' as const,\r\n        requiredPermissions: ['legal:hold:manage', 'compliance:override'],\r\n        approvalPolicy: 'MULTI_ADMIN' as const,\r\n        multiAdminConfig: {\r\n          requiredApprovers: 2,\r\n          totalApprovers: 3,\r\n          allowSelfApproval: false\r\n        },\r\n        irreversible: false,\r\n        featureFlag: 'LEGAL_HOLD_OVERRIDE',\r\n        metadata: {\r\n          impactScope: 'LEGAL_COMPLIANCE',\r\n          regulatoryRisk: true,\r\n          reversible: true\r\n        }\r\n      },\r\n      {\r\n        name: 'AUDIT_LOG_OVERRIDE',\r\n        description: 'Override audit log verification or integrity checks',\r\n        category: 'COMPLIANCE' as const,\r\n        riskLevel: 'CRITICAL' as const,\r\n        requiredPermissions: ['audit:override', 'system:admin'],\r\n        approvalPolicy: 'OWNER_ONLY' as const,\r\n        irreversible: false,\r\n        featureFlag: 'AUDIT_LOG_OVERRIDE',\r\n        metadata: {\r\n          impactScope: 'SYSTEM_WIDE',\r\n          complianceRisk: true,\r\n          reversible: true\r\n        }\r\n      },\r\n      {\r\n        name: 'SUBSCRIPTION_DOWNGRADE',\r\n        description: 'Downgrade tenant subscription tier',\r\n        category: 'TENANT_MANAGEMENT' as const,\r\n        riskLevel: 'MEDIUM' as const,\r\n        requiredPermissions: ['subscription:manage', 'billing:modify'],\r\n        approvalPolicy: 'SINGLE_ADMIN' as const,\r\n        irreversible: false,\r\n        featureFlag: 'DANGEROUS_OPERATIONS',\r\n        metadata: {\r\n          impactScope: 'TENANT_WIDE',\r\n          financialImpact: true,\r\n          reversible: true\r\n        }\r\n      },\r\n      {\r\n        name: 'BULK_USER_DELETION',\r\n        description: 'Delete multiple users at once',\r\n        category: 'DATA_MANAGEMENT' as const,\r\n        riskLevel: 'HIGH' as const,\r\n        requiredPermissions: ['user:delete', 'bulk:operations'],\r\n        approvalPolicy: 'MULTI_ADMIN' as const,\r\n        multiAdminConfig: {\r\n          requiredApprovers: 2,\r\n          totalApprovers: 3,\r\n          allowSelfApproval: false\r\n        },\r\n        irreversible: true,\r\n        featureFlag: 'BULK_OPERATIONS',\r\n        metadata: {\r\n          impactScope: 'MULTIPLE_USERS',\r\n          dataLoss: 'PERMANENT',\r\n          recoveryPossible: false\r\n        }\r\n      },\r\n      {\r\n        name: 'SYSTEM_MAINTENANCE_MODE',\r\n        description: 'Enable system maintenance mode',\r\n        category: 'SYSTEM' as const,\r\n        riskLevel: 'MEDIUM' as const,\r\n        requiredPermissions: ['system:maintenance', 'system:admin'],\r\n        approvalPolicy: 'SINGLE_ADMIN' as const,\r\n        irreversible: false,\r\n        featureFlag: 'DANGEROUS_OPERATIONS',\r\n        metadata: {\r\n          impactScope: 'SYSTEM_WIDE',\r\n          availabilityImpact: true,\r\n          reversible: true\r\n        }\r\n      }\r\n    ];\r\n\r\n    for (const operation of defaultOperations) {\r\n      this.registerOperation(operation);\r\n    }\r\n\r\n    logger.info('Default dangerous operations initialized', { count: defaultOperations.length });\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global registry instance\r\n */\r\nexport const dangerousOperationsRegistry = DangerousOperationsRegistry.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const registerDangerousOperation = (\r\n  operation: Omit<DangerousOperation, 'id' | 'createdAt' | 'updatedAt'>\r\n): string => {\r\n  return dangerousOperationsRegistry.registerOperation(operation);\r\n};\r\n\r\nexport const getDangerousOperation = (name: string): DangerousOperation | null => {\r\n  return dangerousOperationsRegistry.getOperation(name);\r\n};\r\n\r\nexport const requiresApproval = (operationName: string): boolean => {\r\n  return dangerousOperationsRegistry.requiresApproval(operationName);\r\n};\r\n\r\nexport const getRequiredPermissions = (operationName: string): string[] => {\r\n  return dangerousOperationsRegistry.getRequiredPermissions(operationName);\r\n};\r\n\r\nexport const isIrreversibleOperation = (operationName: string): boolean => {\r\n  return dangerousOperationsRegistry.isIrreversible(operationName);\r\n};\r\n\r\nexport const validateDangerousOperationRequest = (\r\n  request: OperationExecutionRequest\r\n): { valid: boolean; errors: string[]; operation: DangerousOperation } => {\r\n  return dangerousOperationsRegistry.validateOperationRequest(request);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\enterprise\\feature-flags.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\enterprise\\guardrails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\enterprise\\observability.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\exports\\export-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\exports\\formats\\csv.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\exports\\formats\\json.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\exports\\formats\\pdf-metadata.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\exports\\formats\\xbrl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\financial-export.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\financial-replay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\financial-statements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\ledger-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\ledger-invariants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\ledger-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\period-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\period-locks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\reconciliation-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\revenue-recognition-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\revenue-schedules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\tax\\tax-attestation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\tax\\tax-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\tax\\tax-export.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\tax\\tax-schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\transaction-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\finance\\trial-balance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\governance\\authority-enforcement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\governance\\governance-ledger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\governance\\governance-model.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\integrations\\plaid.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\integrations\\stripe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\jobs\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\jobs\\processors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\jobs\\service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\lib\\prisma.ts","messages":[],"suppressedMessages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":11,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":11,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\auth.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\authenticate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\authorize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\billing-enforcement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\billing-status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\csrf.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\plan-enforcement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\plan-limits.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\rate-limit.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\middleware\\validate.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\migration\\migration-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\migration\\rollback-safety.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\migration\\schema-drift-detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\minimal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\abuse-detection.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":579,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":579,"endColumn":66},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":595,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":595,"endColumn":37},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":600,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":600,"endColumn":49}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TrialManager, Trial } from './trial-manager';\r\nimport { ImmutableAuditLogger } from '../compliance/immutable-audit-log';\r\n\r\nexport interface AbuseDetectionRule {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  category: 'TRIAL_ABUSE' | 'PAYMENT_FRAUD' | 'API_ABUSE' | 'DATA_SCRAPING' | 'ACCOUNT_TAKEOVER';\r\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  enabled: boolean;\r\n  conditions: AbuseCondition[];\r\n  actions: AbuseAction[];\r\n  cooldownPeriod: number; // in hours\r\n  falsePositiveThreshold: number;\r\n  lastTriggered?: Date;\r\n  triggerCount: number;\r\n  createdBy: string;\r\n  createdAt: Date;\r\n}\r\n\r\nexport interface AbuseCondition {\r\n  type: 'IP_FREQUENCY' | 'EMAIL_FREQUENCY' | 'DOMAIN_FREQUENCY' | 'USAGE_PATTERN' | 'BEHAVIORAL' | 'TECHNICAL';\r\n  operator: 'EQUALS' | 'GREATER_THAN' | 'LESS_THAN' | 'BETWEEN' | 'CONTAINS' | 'REGEX';\r\n  field: string;\r\n  value: any;\r\n  timeWindow?: number; // in hours\r\n  weight: number;\r\n}\r\n\r\nexport interface AbuseAction {\r\n  type: 'ALERT' | 'BLOCK' | 'SUSPEND' | 'TERMINATE' | 'RATE_LIMIT' | 'REQUIRE_VERIFICATION';\r\n  parameters: { [key: string]: any };\r\n  delay?: number; // in minutes\r\n  conditions?: string[];\r\n}\r\n\r\nexport interface AbuseAlert {\r\n  id: string;\r\n  ruleId: string;\r\n  tenantId?: string;\r\n  trialId?: string;\r\n  userId?: string;\r\n  severity: AbuseDetectionRule['severity'];\r\n  category: AbuseDetectionRule['category'];\r\n  title: string;\r\n  description: string;\r\n  evidence: AbuseEvidence[];\r\n  ipAddress: string;\r\n  userAgent: string;\r\n  timestamp: Date;\r\n  status: 'OPEN' | 'INVESTIGATING' | 'RESOLVED' | 'FALSE_POSITIVE';\r\n  assignedTo?: string;\r\n  resolvedBy?: string;\r\n  resolvedAt?: Date;\r\n  resolution?: string;\r\n  actions: AbuseAlertAction[];\r\n}\r\n\r\nexport interface AbuseEvidence {\r\n  type: 'LOG_ENTRY' | 'METRIC' | 'USER_ACTION' | 'SYSTEM_EVENT' | 'EXTERNAL_DATA';\r\n  description: string;\r\n  value: any;\r\n  timestamp: Date;\r\n  source: string;\r\n  confidence: number;\r\n}\r\n\r\nexport interface AbuseAlertAction {\r\n  type: 'NOTIFICATION_SENT' | 'ACCOUNT_SUSPENDED' | 'RATE_LIMITED' | 'VERIFICATION_REQUIRED' | 'ESCALATED';\r\n  description: string;\r\n  timestamp: Date;\r\n  performedBy: string;\r\n  result: 'SUCCESS' | 'FAILED' | 'PARTIAL';\r\n}\r\n\r\nexport interface AbuseMetrics {\r\n  totalAlerts: number;\r\n  alertsBySeverity: { [key: string]: number };\r\n  alertsByCategory: { [key: string]: number };\r\n  alertsByStatus: { [key: string]: number };\r\n  truePositiveRate: number;\r\n  falsePositiveRate: number;\r\n  averageResolutionTime: number;\r\n  blockedAttempts: number;\r\n  preventedLoss: number;\r\n  topTriggeredRules: { ruleId: string; name: string; triggers: number }[];\r\n  riskTrends: { date: string; riskScore: number; alertCount: number }[];\r\n  periodStart: Date;\r\n  periodEnd: Date;\r\n}\r\n\r\nexport interface AbusePattern {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  pattern: string;\r\n  category: AbuseDetectionRule['category'];\r\n  indicators: string[];\r\n  confidence: number;\r\n  severity: AbuseDetectionRule['severity'];\r\n  mitigation: string;\r\n  detectedAt?: Date;\r\n  detectionCount: number;\r\n  isActive: boolean;\r\n}\r\n\r\nexport interface RiskScore {\r\n  tenantId?: string;\r\n  trialId?: string;\r\n  userId?: string;\r\n  ipAddress?: string;\r\n  email?: string;\r\n  domain?: string;\r\n  overallScore: number;\r\n  factors: RiskFactor[];\r\n  category: 'TRIAL_ABUSE' | 'PAYMENT_FRAUD' | 'API_ABUSE' | 'DATA_SCRAPING' | 'ACCOUNT_TAKEOVER';\r\n  timestamp: Date;\r\n  trend: 'INCREASING' | 'DECREASING' | 'STABLE';\r\n  recommendation: string;\r\n}\r\n\r\nexport interface RiskFactor {\r\n  name: string;\r\n  value: number;\r\n  weight: number;\r\n  description: string;\r\n  threshold: number;\r\n  status: 'NORMAL' | 'WARNING' | 'CRITICAL';\r\n}\r\n\r\nexport class AbuseDetectionEngine {\r\n  private static instance: AbuseDetectionEngine;\r\n  private auditLog: ImmutableAuditLogger;\r\n  private trialManager: TrialManager;\r\n  private rules: Map<string, AbuseDetectionRule> = new Map();\r\n  private alerts: Map<string, AbuseAlert> = new Map();\r\n  private patterns: Map<string, AbusePattern> = new Map();\r\n  private riskScores: Map<string, RiskScore> = new Map();\r\n  private ipReputation: Map<string, IPReputation> = new Map();\r\n  private domainReputation: Map<string, DomainReputation> = new Map();\r\n\r\n  private constructor() {\r\n    this.auditLog = new ImmutableAuditLogger();\r\n    this.trialManager = TrialManager.getInstance();\r\n    this.initializeDefaultRules();\r\n    this.initializePatterns();\r\n  }\r\n\r\n  public static getInstance(): AbuseDetectionEngine {\r\n    if (!AbuseDetectionEngine.instance) {\r\n      AbuseDetectionEngine.instance = new AbuseDetectionEngine();\r\n    }\r\n    return AbuseDetectionEngine.instance;\r\n  }\r\n\r\n  private initializeDefaultRules(): void {\r\n    const rules: AbuseDetectionRule[] = [\r\n      {\r\n        id: 'MULTIPLE_TRIALS_SAME_EMAIL',\r\n        name: 'Multiple Trials from Same Email',\r\n        description: 'Detect when same email creates multiple trials',\r\n        category: 'TRIAL_ABUSE',\r\n        severity: 'HIGH',\r\n        enabled: true,\r\n        conditions: [\r\n          {\r\n            type: 'EMAIL_FREQUENCY',\r\n            operator: 'GREATER_THAN',\r\n            field: 'trial_count',\r\n            value: 1,\r\n            timeWindow: 24,\r\n            weight: 1.0\r\n          }\r\n        ],\r\n        actions: [\r\n          {\r\n            type: 'ALERT',\r\n            parameters: { message: 'Multiple trials detected from same email' }\r\n          },\r\n          {\r\n            type: 'REQUIRE_VERIFICATION',\r\n            parameters: { method: 'EMAIL_VERIFICATION' }\r\n          }\r\n        ],\r\n        cooldownPeriod: 24,\r\n        falsePositiveThreshold: 0.1,\r\n        triggerCount: 0,\r\n        createdBy: 'SYSTEM',\r\n        createdAt: new Date()\r\n      },\r\n      {\r\n        id: 'RAPID_TRIAL_CREATION',\r\n        name: 'Rapid Trial Creation',\r\n        description: 'Detect rapid creation of trials from same IP',\r\n        category: 'TRIAL_ABUSE',\r\n        severity: 'MEDIUM',\r\n        enabled: true,\r\n        conditions: [\r\n          {\r\n            type: 'IP_FREQUENCY',\r\n            operator: 'GREATER_THAN',\r\n            field: 'trial_creation_count',\r\n            value: 5,\r\n            timeWindow: 1,\r\n            weight: 0.8\r\n          }\r\n        ],\r\n        actions: [\r\n          {\r\n            type: 'RATE_LIMIT',\r\n            parameters: { limit: 1, window: 3600 }\r\n          },\r\n          {\r\n            type: 'ALERT',\r\n            parameters: { message: 'Rapid trial creation detected' }\r\n          }\r\n        ],\r\n        cooldownPeriod: 1,\r\n        falsePositiveThreshold: 0.2,\r\n        triggerCount: 0,\r\n        createdBy: 'SYSTEM',\r\n        createdAt: new Date()\r\n      },\r\n      {\r\n        id: 'SUSPICIOUS_USAGE_PATTERN',\r\n        name: 'Suspicious Usage Pattern',\r\n        description: 'Detect unusual usage patterns in trials',\r\n        category: 'API_ABUSE',\r\n        severity: 'HIGH',\r\n        enabled: true,\r\n        conditions: [\r\n          {\r\n            type: 'USAGE_PATTERN',\r\n            operator: 'GREATER_THAN',\r\n            field: 'api_calls_per_minute',\r\n            value: 1000,\r\n            timeWindow: 1,\r\n            weight: 0.9\r\n          }\r\n        ],\r\n        actions: [\r\n          {\r\n            type: 'RATE_LIMIT',\r\n            parameters: { limit: 100, window: 60 }\r\n          },\r\n          {\r\n            type: 'ALERT',\r\n            parameters: { message: 'Suspicious API usage pattern detected' }\r\n          }\r\n        ],\r\n        cooldownPeriod: 0.5,\r\n        falsePositiveThreshold: 0.15,\r\n        triggerCount: 0,\r\n        createdBy: 'SYSTEM',\r\n        createdAt: new Date()\r\n      },\r\n      {\r\n        id: 'DATA_SCRAPING_DETECTION',\r\n        name: 'Data Scraping Detection',\r\n        description: 'Detect potential data scraping activities',\r\n        category: 'DATA_SCRAPING',\r\n        severity: 'CRITICAL',\r\n        enabled: true,\r\n        conditions: [\r\n          {\r\n            type: 'BEHAVIORAL',\r\n            operator: 'GREATER_THAN',\r\n            field: 'data_export_requests',\r\n            value: 50,\r\n            timeWindow: 1,\r\n            weight: 1.0\r\n          },\r\n          {\r\n            type: 'TECHNICAL',\r\n            operator: 'CONTAINS',\r\n            field: 'user_agent',\r\n            value: 'bot|crawler|scraper',\r\n            weight: 0.7\r\n          }\r\n        ],\r\n        actions: [\r\n          {\r\n            type: 'SUSPEND',\r\n            parameters: { reason: 'Data scraping detected', duration: 24 }\r\n          },\r\n          {\r\n            type: 'ALERT',\r\n            parameters: { message: 'Data scraping activity detected' }\r\n          }\r\n        ],\r\n        cooldownPeriod: 2,\r\n        falsePositiveThreshold: 0.05,\r\n        triggerCount: 0,\r\n        createdBy: 'SYSTEM',\r\n        createdAt: new Date()\r\n      },\r\n      {\r\n        id: 'ACCOUNT_TAKEOVER_ATTEMPT',\r\n        name: 'Account Takeover Attempt',\r\n        description: 'Detect potential account takeover attempts',\r\n        category: 'ACCOUNT_TAKEOVER',\r\n        severity: 'CRITICAL',\r\n        enabled: true,\r\n        conditions: [\r\n          {\r\n            type: 'BEHAVIORAL',\r\n            operator: 'GREATER_THAN',\r\n            field: 'failed_login_attempts',\r\n            value: 10,\r\n            timeWindow: 1,\r\n            weight: 0.9\r\n          },\r\n          {\r\n            type: 'IP_FREQUENCY',\r\n            operator: 'GREATER_THAN',\r\n            field: 'unique_ip_addresses',\r\n            value: 5,\r\n            timeWindow: 1,\r\n            weight: 0.8\r\n          }\r\n        ],\r\n        actions: [\r\n          {\r\n            type: 'BLOCK',\r\n            parameters: { reason: 'Account takeover attempt detected' }\r\n          },\r\n          {\r\n            type: 'ALERT',\r\n            parameters: { message: 'Account takeover attempt detected' }\r\n          }\r\n        ],\r\n        cooldownPeriod: 0.25,\r\n        falsePositiveThreshold: 0.1,\r\n        triggerCount: 0,\r\n        createdBy: 'SYSTEM',\r\n        createdAt: new Date()\r\n      }\r\n    ];\r\n\r\n    rules.forEach(rule => {\r\n      this.rules.set(rule.id, rule);\r\n    });\r\n  }\r\n\r\n  private initializePatterns(): void {\r\n    const patterns: AbusePattern[] = [\r\n      {\r\n        id: 'TRIAL_ABUSE_PATTERN',\r\n        name: 'Trial Abuse Pattern',\r\n        description: 'Common pattern for trial abuse scenarios',\r\n        pattern: 'multiple_trials + rapid_creation + suspicious_usage',\r\n        category: 'TRIAL_ABUSE',\r\n        indicators: ['multiple_trials_same_email', 'rapid_trial_creation', 'suspicious_usage_pattern'],\r\n        confidence: 0.85,\r\n        severity: 'HIGH',\r\n        mitigation: 'Require verification and limit trial creation',\r\n        detectionCount: 0,\r\n        isActive: true\r\n      },\r\n      {\r\n        id: 'API_ABUSE_PATTERN',\r\n        name: 'API Abuse Pattern',\r\n        description: 'Pattern for API abuse and automation',\r\n        pattern: 'high_api_usage + automated_behavior + data_export',\r\n        category: 'API_ABUSE',\r\n        indicators: ['suspicious_usage_pattern', 'data_scraping_detection'],\r\n        confidence: 0.9,\r\n        severity: 'CRITICAL',\r\n        mitigation: 'Rate limit and require CAPTCHA',\r\n        detectionCount: 0,\r\n        isActive: true\r\n      }\r\n    ];\r\n\r\n    patterns.forEach(pattern => {\r\n      this.patterns.set(pattern.id, pattern);\r\n    });\r\n  }\r\n\r\n  public async analyzeActivity(\r\n    activity: {\r\n      type: string;\r\n      tenantId?: string;\r\n      trialId?: string;\r\n      userId?: string;\r\n      email?: string;\r\n      ipAddress: string;\r\n      userAgent: string;\r\n      timestamp: Date;\r\n      metadata?: { [key: string]: any };\r\n    }\r\n  ): Promise<void> {\r\n    try {\r\n      // Check all enabled rules\r\n      for (const rule of this.rules.values()) {\r\n        if (!rule.enabled) continue;\r\n\r\n        // Check cooldown period\r\n        if (rule.lastTriggered && \r\n            Date.now() - rule.lastTriggered.getTime() < rule.cooldownPeriod * 60 * 60 * 1000) {\r\n          continue;\r\n        }\r\n\r\n        // Evaluate rule conditions\r\n        const isTriggered = await this.evaluateRule(rule, activity);\r\n        \r\n        if (isTriggered) {\r\n          await this.triggerRule(rule, activity);\r\n        }\r\n      }\r\n\r\n      // Update risk scores\r\n      await this.updateRiskScores(activity);\r\n\r\n      // Check for patterns\r\n      await this.checkPatterns(activity);\r\n\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId: activity.tenantId || 'UNKNOWN',\r\n        userId: activity.userId || 'SYSTEM',\r\n        action: 'ANALYZE_ACTIVITY_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          activityType: activity.type,\r\n          ipAddress: activity.ipAddress\r\n        },\r\n        ipAddress: activity.ipAddress,\r\n        userAgent: activity.userAgent,\r\n        timestamp: new Date(),\r\n        category: 'ABUSE_DETECTION',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async evaluateRule(\r\n    rule: AbuseDetectionRule,\r\n    activity: any\r\n  ): Promise<boolean> {\r\n    let totalScore = 0;\r\n    let metConditions = 0;\r\n\r\n    for (const condition of rule.conditions) {\r\n      const isMet = await this.evaluateCondition(condition, activity);\r\n      if (isMet) {\r\n        totalScore += condition.weight;\r\n        metConditions++;\r\n      }\r\n    }\r\n\r\n    // Rule is triggered if enough conditions are met with sufficient weight\r\n    const threshold = 0.7; // 70% of total weight needed\r\n    const totalWeight = rule.conditions.reduce((sum, c) => sum + c.weight, 0);\r\n    const score = totalWeight > 0 ? totalScore / totalWeight : 0;\r\n\r\n    return score >= threshold;\r\n  }\r\n\r\n  private async evaluateCondition(\r\n    condition: AbuseCondition,\r\n    activity: any\r\n  ): Promise<boolean> {\r\n    let value: any;\r\n\r\n    switch (condition.type) {\r\n      case 'IP_FREQUENCY':\r\n        value = await this.getIPFrequency(condition.field, activity.ipAddress, condition.timeWindow);\r\n        break;\r\n      case 'EMAIL_FREQUENCY':\r\n        value = await this.getEmailFrequency(condition.field, activity.email, condition.timeWindow);\r\n        break;\r\n      case 'DOMAIN_FREQUENCY':\r\n        value = await this.getDomainFrequency(condition.field, activity.email, condition.timeWindow);\r\n        break;\r\n      case 'USAGE_PATTERN':\r\n        value = await this.getUsageMetric(condition.field, activity.tenantId, condition.timeWindow);\r\n        break;\r\n      case 'BEHAVIORAL':\r\n        value = await this.getBehavioralMetric(condition.field, activity, condition.timeWindow);\r\n        break;\r\n      case 'TECHNICAL':\r\n        value = await this.getTechnicalMetric(condition.field, activity);\r\n        break;\r\n      default:\r\n        return false;\r\n    }\r\n\r\n    return this.compareValues(value, condition.operator, condition.value);\r\n  }\r\n\r\n  private async getIPFrequency(\r\n    field: string,\r\n    ipAddress: string,\r\n    timeWindow?: number\r\n  ): Promise<number> {\r\n    // Simplified implementation - would query actual data\r\n    const reputation = this.ipReputation.get(ipAddress);\r\n    if (reputation) {\r\n      switch (field) {\r\n        case 'trial_creation_count':\r\n          return reputation.trialCreations || 0;\r\n        case 'failed_login_attempts':\r\n          return reputation.failedLogins || 0;\r\n        default:\r\n          return 0;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private async getEmailFrequency(\r\n    field: string,\r\n    email?: string,\r\n    timeWindow?: number\r\n  ): Promise<number> {\r\n    if (!email) return 0;\r\n    \r\n    // Simplified implementation - would query actual data\r\n    const trials = await this.trialManager.getTrialsByStatus('ACTIVE');\r\n    return trials.filter(t => t.contactInfo.email === email).length;\r\n  }\r\n\r\n  private async getDomainFrequency(\r\n    field: string,\r\n    email?: string,\r\n    timeWindow?: number\r\n  ): Promise<number> {\r\n    if (!email) return 0;\r\n    \r\n    const domain = email.split('@')[1];\r\n    const reputation = this.domainReputation.get(domain);\r\n    if (reputation) {\r\n      return reputation.trialCount || 0;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private async getUsageMetric(\r\n    field: string,\r\n    tenantId?: string,\r\n    timeWindow?: number\r\n  ): Promise<number> {\r\n    // Simplified implementation - would query actual usage data\r\n    switch (field) {\r\n      case 'api_calls_per_minute':\r\n        return Math.floor(Math.random() * 2000); // Placeholder\r\n      case 'data_export_requests':\r\n        return Math.floor(Math.random() * 100); // Placeholder\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  private async getBehavioralMetric(\r\n    field: string,\r\n    activity: any,\r\n    timeWindow?: number\r\n  ): Promise<number> {\r\n    // Simplified implementation - would query behavioral data\r\n    switch (field) {\r\n      case 'failed_login_attempts':\r\n        return Math.floor(Math.random() * 20); // Placeholder\r\n      case 'unique_ip_addresses':\r\n        return Math.floor(Math.random() * 10); // Placeholder\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  private async getTechnicalMetric(\r\n    field: string,\r\n    activity: any\r\n  ): Promise<boolean> {\r\n    switch (field) {\r\n      case 'user_agent':\r\n        if (!activity.userAgent) return false;\r\n        const regex = new RegExp(condition.value as string, 'i');\r\n        return regex.test(activity.userAgent);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private compareValues(actual: any, operator: string, expected: any): boolean {\r\n    switch (operator) {\r\n      case 'EQUALS':\r\n        return actual === expected;\r\n      case 'GREATER_THAN':\r\n        return Number(actual) > Number(expected);\r\n      case 'LESS_THAN':\r\n        return Number(actual) < Number(expected);\r\n      case 'BETWEEN':\r\n        const [min, max] = expected;\r\n        return Number(actual) >= Number(min) && Number(actual) <= Number(max);\r\n      case 'CONTAINS':\r\n        return String(actual).includes(String(expected));\r\n      case 'REGEX':\r\n        const regex = new RegExp(expected, 'i');\r\n        return regex.test(String(actual));\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private async triggerRule(\r\n    rule: AbuseDetectionRule,\r\n    activity: any\r\n  ): Promise<void> {\r\n    // Update rule trigger info\r\n    rule.lastTriggered = new Date();\r\n    rule.triggerCount++;\r\n\r\n    // Create alert\r\n    const alert = await this.createAlert(rule, activity);\r\n\r\n    // Execute actions\r\n    for (const action of rule.actions) {\r\n      await this.executeAction(action, alert, activity);\r\n    }\r\n\r\n    // Log the rule trigger\r\n    await this.auditLog.logOperation({\r\n      tenantId: activity.tenantId || 'UNKNOWN',\r\n      userId: activity.userId || 'SYSTEM',\r\n      action: 'ABUSE_RULE_TRIGGERED',\r\n      details: {\r\n        ruleId: rule.id,\r\n        ruleName: rule.name,\r\n        severity: rule.severity,\r\n        alertId: alert.id\r\n      },\r\n      ipAddress: activity.ipAddress,\r\n      userAgent: activity.userAgent,\r\n      timestamp: new Date(),\r\n      category: 'ABUSE_DETECTION',\r\n      severity: 'WARNING'\r\n    });\r\n  }\r\n\r\n  private async createAlert(\r\n    rule: AbuseDetectionRule,\r\n    activity: any\r\n  ): Promise<AbuseAlert> {\r\n    const alertId = this.generateAlertId();\r\n\r\n    const evidence: AbuseEvidence[] = [\r\n      {\r\n        type: 'USER_ACTION',\r\n        description: 'Triggering activity',\r\n        value: activity,\r\n        timestamp: activity.timestamp,\r\n        source: 'ABUSE_DETECTION',\r\n        confidence: 0.9\r\n      }\r\n    ];\r\n\r\n    const alert: AbuseAlert = {\r\n      id: alertId,\r\n      ruleId: rule.id,\r\n      tenantId: activity.tenantId,\r\n      trialId: activity.trialId,\r\n      userId: activity.userId,\r\n      severity: rule.severity,\r\n      category: rule.category,\r\n      title: rule.name,\r\n      description: rule.description,\r\n      evidence,\r\n      ipAddress: activity.ipAddress,\r\n      userAgent: activity.userAgent,\r\n      timestamp: new Date(),\r\n      status: 'OPEN',\r\n      actions: []\r\n    };\r\n\r\n    this.alerts.set(alertId, alert);\r\n    return alert;\r\n  }\r\n\r\n  private async executeAction(\r\n    action: AbuseAction,\r\n    alert: AbuseAlert,\r\n    activity: any\r\n  ): Promise<void> {\r\n    // Apply delay if specified\r\n    if (action.delay && action.delay > 0) {\r\n      await new Promise(resolve => setTimeout(resolve, action.delay * 60 * 1000));\r\n    }\r\n\r\n    let result: 'SUCCESS' | 'FAILED' | 'PARTIAL' = 'SUCCESS';\r\n    let description = '';\r\n\r\n    try {\r\n      switch (action.type) {\r\n        case 'ALERT':\r\n          await this.sendAlert(alert, action.parameters);\r\n          description = `Alert sent: ${action.parameters.message}`;\r\n          break;\r\n        case 'BLOCK':\r\n          await this.blockAccess(activity, action.parameters);\r\n          description = `Access blocked: ${action.parameters.reason}`;\r\n          break;\r\n        case 'SUSPEND':\r\n          await this.suspendAccount(activity, action.parameters);\r\n          description = `Account suspended: ${action.parameters.reason}`;\r\n          break;\r\n        case 'TERMINATE':\r\n          await this.terminateAccount(activity, action.parameters);\r\n          description = `Account terminated: ${action.parameters.reason}`;\r\n          break;\r\n        case 'RATE_LIMIT':\r\n          await this.applyRateLimit(activity, action.parameters);\r\n          description = `Rate limit applied: ${action.parameters.limit} per ${action.parameters.window}s`;\r\n          break;\r\n        case 'REQUIRE_VERIFICATION':\r\n          await this.requireVerification(activity, action.parameters);\r\n          description = `Verification required: ${action.parameters.method}`;\r\n          break;\r\n        default:\r\n          result = 'FAILED';\r\n          description = `Unknown action type: ${action.type}`;\r\n      }\r\n    } catch (error) {\r\n      result = 'FAILED';\r\n      description = `Action failed: ${(error as Error).message}`;\r\n    }\r\n\r\n    // Record action\r\n    const alertAction: AbuseAlertAction = {\r\n      type: action.type as any,\r\n      description,\r\n      timestamp: new Date(),\r\n      performedBy: 'SYSTEM',\r\n      result\r\n    };\r\n    alert.actions.push(alertAction);\r\n  }\r\n\r\n  private async sendAlert(alert: AbuseAlert, parameters: any): Promise<void> {\r\n    // Send alert to security team\r\n    // This would integrate with notification systems\r\n    console.log(`ALERT: ${parameters.message} - ${alert.id}`);\r\n  }\r\n\r\n  private async blockAccess(activity: any, parameters: any): Promise<void> {\r\n    // Block access from IP address or user\r\n    // This would integrate with access control systems\r\n    console.log(`BLOCKING access: ${parameters.reason}`);\r\n  }\r\n\r\n  private async suspendAccount(activity: any, parameters: any): Promise<void> {\r\n    // Suspend trial or account\r\n    if (activity.trialId) {\r\n      await this.trialManager.suspendTrial(\r\n        activity.trialId,\r\n        'ABUSE_DETECTION',\r\n        parameters.reason\r\n      );\r\n    }\r\n  }\r\n\r\n  private async terminateAccount(activity: any, parameters: any): Promise<void> {\r\n    // Terminate trial or account\r\n    if (activity.trialId) {\r\n      await this.trialManager.cancelTrial(\r\n        activity.trialId,\r\n        'ABUSE_DETECTION',\r\n        parameters.reason\r\n      );\r\n    }\r\n  }\r\n\r\n  private async applyRateLimit(activity: any, parameters: any): Promise<void> {\r\n    // Apply rate limiting\r\n    console.log(`RATE LIMIT: ${parameters.limit} per ${parameters.window}s`);\r\n  }\r\n\r\n  private async requireVerification(activity: any, parameters: any): Promise<void> {\r\n    // Require additional verification\r\n    console.log(`VERIFICATION REQUIRED: ${parameters.method}`);\r\n  }\r\n\r\n  private async updateRiskScores(activity: any): Promise<void> {\r\n    // Update risk scores for various entities\r\n    await this.updateIPRiskScore(activity.ipAddress, activity);\r\n    if (activity.email) {\r\n      await this.updateEmailRiskScore(activity.email, activity);\r\n    }\r\n    if (activity.tenantId) {\r\n      await this.updateTenantRiskScore(activity.tenantId, activity);\r\n    }\r\n  }\r\n\r\n  private async updateIPRiskScore(ipAddress: string, activity: any): Promise<void> {\r\n    const existing = this.riskScores.get(ipAddress);\r\n    const factors: RiskFactor[] = [\r\n      {\r\n        name: 'Recent Activity',\r\n        value: 1,\r\n        weight: 0.3,\r\n        description: 'Recent activity from this IP',\r\n        threshold: 5,\r\n        status: 'NORMAL'\r\n      }\r\n    ];\r\n\r\n    const score = this.calculateRiskScore(factors);\r\n    const riskScore: RiskScore = {\r\n      ipAddress,\r\n      overallScore: score,\r\n      factors,\r\n      category: 'TRIAL_ABUSE',\r\n      timestamp: new Date(),\r\n      trend: existing ? this.calculateTrend(existing.overallScore, score) : 'STABLE',\r\n      recommendation: score > 70 ? 'Monitor closely' : 'Normal activity'\r\n    };\r\n\r\n    this.riskScores.set(ipAddress, riskScore);\r\n  }\r\n\r\n  private async updateEmailRiskScore(email: string, activity: any): Promise<void> {\r\n    const existing = this.riskScores.get(email);\r\n    const factors: RiskFactor[] = [\r\n      {\r\n        name: 'Email Activity',\r\n        value: 1,\r\n        weight: 0.4,\r\n        description: 'Recent activity from this email',\r\n        threshold: 3,\r\n        status: 'NORMAL'\r\n      }\r\n    ];\r\n\r\n    const score = this.calculateRiskScore(factors);\r\n    const riskScore: RiskScore = {\r\n      email,\r\n      overallScore: score,\r\n      factors,\r\n      category: 'TRIAL_ABUSE',\r\n      timestamp: new Date(),\r\n      trend: existing ? this.calculateTrend(existing.overallScore, score) : 'STABLE',\r\n      recommendation: score > 60 ? 'Verify identity' : 'Normal activity'\r\n    };\r\n\r\n    this.riskScores.set(email, riskScore);\r\n  }\r\n\r\n  private async updateTenantRiskScore(tenantId: string, activity: any): Promise<void> {\r\n    const existing = this.riskScores.get(tenantId);\r\n    const factors: RiskFactor[] = [\r\n      {\r\n        name: 'Tenant Activity',\r\n        value: 1,\r\n        weight: 0.5,\r\n        description: 'Recent activity in this tenant',\r\n        threshold: 10,\r\n        status: 'NORMAL'\r\n      }\r\n    ];\r\n\r\n    const score = this.calculateRiskScore(factors);\r\n    const riskScore: RiskScore = {\r\n      tenantId,\r\n      overallScore: score,\r\n      factors,\r\n      category: 'API_ABUSE',\r\n      timestamp: new Date(),\r\n      trend: existing ? this.calculateTrend(existing.overallScore, score) : 'STABLE',\r\n      recommendation: score > 80 ? 'Investigate immediately' : 'Monitor'\r\n    };\r\n\r\n    this.riskScores.set(tenantId, riskScore);\r\n  }\r\n\r\n  private calculateRiskScore(factors: RiskFactor[]): number {\r\n    let totalScore = 0;\r\n    let totalWeight = 0;\r\n\r\n    for (const factor of factors) {\r\n      totalScore += factor.value * factor.weight;\r\n      totalWeight += factor.weight;\r\n    }\r\n\r\n    return totalWeight > 0 ? (totalScore / totalWeight) * 100 : 0;\r\n  }\r\n\r\n  private calculateTrend(oldScore: number, newScore: number): 'INCREASING' | 'DECREASING' | 'STABLE' {\r\n    const diff = newScore - oldScore;\r\n    if (diff > 10) return 'INCREASING';\r\n    if (diff < -10) return 'DECREASING';\r\n    return 'STABLE';\r\n  }\r\n\r\n  private async checkPatterns(activity: any): Promise<void> {\r\n    // Check if activity matches known abuse patterns\r\n    for (const pattern of this.patterns.values()) {\r\n      if (!pattern.isActive) continue;\r\n\r\n      const matches = await this.evaluatePattern(pattern, activity);\r\n      if (matches) {\r\n        pattern.detectionCount++;\r\n        pattern.detectedAt = new Date();\r\n        \r\n        // Create high-priority alert for pattern match\r\n        await this.createPatternAlert(pattern, activity);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async evaluatePattern(pattern: AbusePattern, activity: any): Promise<boolean> {\r\n    // Simplified pattern evaluation\r\n    // In production, this would use more sophisticated pattern matching\r\n    return Math.random() > 0.8; // Placeholder\r\n  }\r\n\r\n  private async createPatternAlert(pattern: AbusePattern, activity: any): Promise<void> {\r\n    const alertId = this.generateAlertId();\r\n\r\n    const evidence: AbuseEvidence[] = [\r\n      {\r\n        type: 'SYSTEM_EVENT',\r\n        description: 'Pattern match detected',\r\n        value: { patternId: pattern.id, patternName: pattern.name },\r\n        timestamp: new Date(),\r\n        source: 'PATTERN_DETECTION',\r\n        confidence: pattern.confidence\r\n      }\r\n    ];\r\n\r\n    const alert: AbuseAlert = {\r\n      id: alertId,\r\n      ruleId: pattern.id,\r\n      tenantId: activity.tenantId,\r\n      trialId: activity.trialId,\r\n      userId: activity.userId,\r\n      severity: pattern.severity,\r\n      category: pattern.category,\r\n      title: `Pattern Detected: ${pattern.name}`,\r\n      description: pattern.description,\r\n      evidence,\r\n      ipAddress: activity.ipAddress,\r\n      userAgent: activity.userAgent,\r\n      timestamp: new Date(),\r\n      status: 'OPEN',\r\n      actions: []\r\n    };\r\n\r\n    this.alerts.set(alertId, alert);\r\n  }\r\n\r\n  public async getAlert(alertId: string): Promise<AbuseAlert | null> {\r\n    return this.alerts.get(alertId) || null;\r\n  }\r\n\r\n  public async getAlertsByStatus(status: AbuseAlert['status']): Promise<AbuseAlert[]> {\r\n    return Array.from(this.alerts.values()).filter(alert => alert.status === status);\r\n  }\r\n\r\n  public async getRiskScore(entityId: string): Promise<RiskScore | null> {\r\n    return this.riskScores.get(entityId) || null;\r\n  }\r\n\r\n  public async getAbuseMetrics(\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<AbuseMetrics> {\r\n    const alerts = Array.from(this.alerts.values())\r\n      .filter(alert => alert.timestamp >= startDate && alert.timestamp <= endDate);\r\n\r\n    const alertsBySeverity: { [key: string]: number } = {};\r\n    const alertsByCategory: { [key: string]: number } = {};\r\n    const alertsByStatus: { [key: string]: number } = {};\r\n\r\n    alerts.forEach(alert => {\r\n      alertsBySeverity[alert.severity] = (alertsBySeverity[alert.severity] || 0) + 1;\r\n      alertsByCategory[alert.category] = (alertsByCategory[alert.category] || 0) + 1;\r\n      alertsByStatus[alert.status] = (alertsByStatus[alert.status] || 0) + 1;\r\n    });\r\n\r\n    const resolvedAlerts = alerts.filter(a => a.status === 'RESOLVED');\r\n    const falsePositives = alerts.filter(a => a.status === 'FALSE_POSITIVE');\r\n    \r\n    const truePositiveRate = alerts.length > 0 ? ((resolvedAlerts.length - falsePositives.length) / alerts.length) * 100 : 0;\r\n    const falsePositiveRate = alerts.length > 0 ? (falsePositives.length / alerts.length) * 100 : 0;\r\n\r\n    const averageResolutionTime = resolvedAlerts.length > 0\r\n      ? resolvedAlerts.reduce((sum, a) => {\r\n          const time = a.resolvedAt ? a.resolvedAt.getTime() - a.timestamp.getTime() : 0;\r\n          return sum + time;\r\n        }, 0) / resolvedAlerts.length / (24 * 60 * 60 * 1000)\r\n      : 0;\r\n\r\n    return {\r\n      totalAlerts: alerts.length,\r\n      alertsBySeverity,\r\n      alertsByCategory,\r\n      alertsByStatus,\r\n      truePositiveRate,\r\n      falsePositiveRate,\r\n      averageResolutionTime,\r\n      blockedAttempts: 0, // Placeholder\r\n      preventedLoss: 0, // Placeholder\r\n      topTriggeredRules: [], // Placeholder\r\n      riskTrends: [], // Placeholder\r\n      periodStart: startDate,\r\n      periodEnd: endDate\r\n    };\r\n  }\r\n\r\n  private generateAlertId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `ALERT${timestamp}${random}`;\r\n  }\r\n}\r\n\r\ninterface IPReputation {\r\n  ipAddress: string;\r\n  trialCreations: number;\r\n  failedLogins: number;\r\n  suspiciousActivity: number;\r\n  lastSeen: Date;\r\n  reputation: 'GOOD' | 'SUSPICIOUS' | 'MALICIOUS';\r\n}\r\n\r\ninterface DomainReputation {\r\n  domain: string;\r\n  trialCount: number;\r\n  bounceRate: number;\r\n  spamComplaints: number;\r\n  lastSeen: Date;\r\n  reputation: 'GOOD' | 'SUSPICIOUS' | 'MALICIOUS';\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\billing-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\contract-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\conversion-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\deal-desk.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":590,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":590,"endColumn":46},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":605,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":606,"endColumn":71}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ProductTier } from './product-tiers';\r\nimport { ContractEngine, Contract } from './contract-engine';\r\nimport { ImmutableAuditLogger } from '../compliance/immutable-audit-log';\r\n\r\nexport interface Deal {\r\n  id: string;\r\n  tenantId: string;\r\n  dealNumber: string;\r\n  dealName: string;\r\n  status: 'PROSPECT' | 'QUALIFIED' | 'PROPOSAL' | 'NEGOTIATION' | 'APPROVED' | 'WON' | 'LOST' | 'CLOSED';\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  dealType: 'NEW_BUSINESS' | 'RENEWAL' | 'EXPANSION' | 'UPGRADE' | 'DOWNGRADE';\r\n  estimatedValue: number;\r\n  currency: string;\r\n  probability: number;\r\n  expectedCloseDate: Date;\r\n  actualCloseDate?: Date;\r\n  salesRep: string;\r\n  accountManager: string;\r\n  customer: CustomerInfo;\r\n  requirements: DealRequirement[];\r\n  pricing: DealPricing;\r\n  terms: DealTerms;\r\n  approvals: DealApproval[];\r\n  contracts: string[]; // Contract IDs\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  createdBy: string;\r\n  notes: DealNote[];\r\n  activities: DealActivity[];\r\n  competitors: CompetitorInfo[];\r\n  riskFactors: RiskFactor[];\r\n}\r\n\r\nexport interface CustomerInfo {\r\n  name: string;\r\n  industry: string;\r\n  size: 'SMALL' | 'MEDIUM' | 'LARGE' | 'ENTERPRISE';\r\n  website: string;\r\n  phone: string;\r\n  email: string;\r\n  address: {\r\n    street: string;\r\n    city: string;\r\n    state: string;\r\n    country: string;\r\n    zipCode: string;\r\n  };\r\n  contacts: ContactInfo[];\r\n  currentProvider?: string;\r\n  currentContractValue?: number;\r\n  decisionMaker: string;\r\n  technicalContact: string;\r\n  billingContact: string;\r\n}\r\n\r\nexport interface ContactInfo {\r\n  name: string;\r\n  title: string;\r\n  email: string;\r\n  phone: string;\r\n  role: 'DECISION_MAKER' | 'TECHNICAL' | 'BILLING' | 'USER' | 'INFLUENCER';\r\n  influence: 'HIGH' | 'MEDIUM' | 'LOW';\r\n}\r\n\r\nexport interface DealRequirement {\r\n  id: string;\r\n  category: 'FUNCTIONAL' | 'TECHNICAL' | 'COMPLIANCE' | 'INTEGRATION' | 'SUPPORT';\r\n  description: string;\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  mandatory: boolean;\r\n  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'BLOCKED';\r\n  assignedTo?: string;\r\n  dueDate?: Date;\r\n  estimatedEffort?: number;\r\n  actualEffort?: number;\r\n  dependencies: string[];\r\n}\r\n\r\nexport interface DealPricing {\r\n  basePrice: number;\r\n  currency: string;\r\n  billingCycle: 'MONTHLY' | 'QUARTERLY' | 'ANNUALLY';\r\n  contractLength: number; // in months\r\n  tier: ProductTier;\r\n  users: number;\r\n  companies: number;\r\n  expectedUsage: ExpectedUsage[];\r\n  discounts: PricingDiscount[];\r\n  overageRates: OverageRate[];\r\n  setupFee: number;\r\n  implementationFee: number;\r\n  trainingFee: number;\r\n  supportFee: number;\r\n  totalContractValue: number;\r\n  monthlyRecurringRevenue: number;\r\n  annualRecurringRevenue: number;\r\n}\r\n\r\nexport interface ExpectedUsage {\r\n  metric: string;\r\n  estimatedMonthly: number;\r\n  estimatedAnnual: number;\r\n  unit: string;\r\n  growthRate: number; // percentage\r\n}\r\n\r\nexport interface PricingDiscount {\r\n  type: 'VOLUME' | 'ANNUAL' | 'STARTUP' | 'NONPROFIT' | 'EDUCATIONAL' | 'CUSTOM' | 'EARLY_BIRD';\r\n  value: number;\r\n  reason: string;\r\n  approvedBy: string;\r\n  approvedAt: Date;\r\n  expiresAt?: Date;\r\n}\r\n\r\nexport interface OverageRate {\r\n  metric: string;\r\n  unit: string;\r\n  rate: number;\r\n  tieredRates?: {\r\n    minQuantity: number;\r\n    rate: number;\r\n  }[];\r\n}\r\n\r\nexport interface DealTerms {\r\n  paymentTerms: {\r\n    netDays: number;\r\n    lateFeePercentage: number;\r\n    earlyPaymentDiscount?: {\r\n      percentage: number;\r\n      days: number;\r\n    };\r\n  };\r\n  renewalTerms: {\r\n    autoRenew: boolean;\r\n    noticePeriod: number; // days\r\n    priceIncrease: {\r\n      type: 'PERCENTAGE' | 'FIXED';\r\n      value: number;\r\n      cap?: number;\r\n    };\r\n  };\r\n  terminationTerms: {\r\n    noticePeriod: number; // days\r\n    penalty?: {\r\n      type: 'PERCENTAGE' | 'FIXED';\r\n      value: number;\r\n    };\r\n    dataExportPeriod: number; // days\r\n  };\r\n  serviceLevels: ServiceLevelTerm[];\r\n  customTerms: CustomTerm[];\r\n  complianceRequirements: ComplianceTerm[];\r\n}\r\n\r\nexport interface ServiceLevelTerm {\r\n  metric: string;\r\n  target: number;\r\n  unit: string;\r\n  credits: {\r\n    type: 'PERCENTAGE' | 'FIXED_AMOUNT';\r\n    value: number;\r\n    threshold: number;\r\n  };\r\n  exclusions: string[];\r\n}\r\n\r\nexport interface CustomTerm {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  category: 'LEGAL' | 'TECHNICAL' | 'FINANCIAL' | 'OPERATIONAL';\r\n  mandatory: boolean;\r\n  customerRequested: boolean;\r\n  status: 'PENDING' | 'APPROVED' | 'REJECTED';\r\n  reviewedBy?: string;\r\n  reviewedAt?: Date;\r\n}\r\n\r\nexport interface ComplianceTerm {\r\n  type: 'SOX' | 'GDPR' | 'CCPA' | 'HIPAA' | 'SOC2' | 'ISO27001' | 'CUSTOM';\r\n  description: string;\r\n  mandatory: boolean;\r\n  implementationRequired: boolean;\r\n  dueDate?: Date;\r\n  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';\r\n  assignedTo: string;\r\n}\r\n\r\nexport interface DealApproval {\r\n  id: string;\r\n  type: 'PRICING' | 'TERMS' | 'COMPLIANCE' | 'LEGAL' | 'EXECUTIVE';\r\n  approver: string;\r\n  approverTitle: string;\r\n  status: 'PENDING' | 'APPROVED' | 'REJECTED';\r\n  requestedAt: Date;\r\n  reviewedAt?: Date;\r\n  comments?: string;\r\n  conditions?: string[];\r\n  level: number; // Approval level (1, 2, 3...)\r\n}\r\n\r\nexport interface DealNote {\r\n  id: string;\r\n  content: string;\r\n  author: string;\r\n  createdAt: Date;\r\n  category: 'GENERAL' | 'PRICING' | 'TECHNICAL' | 'LEGAL' | 'COMPLIANCE';\r\n  visibility: 'INTERNAL' | 'TEAM' | 'ALL';\r\n  attachments: string[];\r\n}\r\n\r\nexport interface DealActivity {\r\n  id: string;\r\n  type: 'CALL' | 'MEETING' | 'EMAIL' | 'DEMO' | 'PROPOSAL' | 'SITE_VISIT' | 'FOLLOW_UP';\r\n  title: string;\r\n  description: string;\r\n  date: Date;\r\n  duration: number; // in minutes\r\n  participants: string[];\r\n  outcome: string;\r\n  nextSteps: string[];\r\n  createdBy: string;\r\n}\r\n\r\nexport interface CompetitorInfo {\r\n  name: string;\r\n  strengths: string[];\r\n  weaknesses: string[];\r\n  pricing: {\r\n    estimated: number;\r\n    currency: string;\r\n    notes: string;\r\n  };\r\n  marketPosition: 'LEADER' | 'CHALLENGER' | 'FOLLOWER' | 'NICHE';\r\n  winProbability: number;\r\n}\r\n\r\nexport interface RiskFactor {\r\n  id: string;\r\n  category: 'TECHNICAL' | 'FINANCIAL' | 'LEGAL' | 'COMPETITIVE' | 'TIMING' | 'RESOURCE';\r\n  description: string;\r\n  impact: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  probability: 'LOW' | 'MEDIUM' | 'HIGH';\r\n  mitigation: string;\r\n  owner: string;\r\n  status: 'OPEN' | 'MITIGATED' | 'CLOSED';\r\n}\r\n\r\nexport interface DealMetrics {\r\n  totalDeals: number;\r\n  dealsByStatus: { [key: string]: number };\r\n  dealsByPriority: { [key: string]: number };\r\n  totalPipelineValue: number;\r\n  weightedPipelineValue: number;\r\n  averageDealSize: number;\r\n  averageSalesCycle: number;\r\n  winRate: number;\r\n  conversionRate: number;\r\n  averageDiscount: number;\r\n  topCompetitors: { name: string; deals: number; winRate: number }[];\r\n  revenueByMonth: { month: string; revenue: number }[];\r\n  periodStart: Date;\r\n  periodEnd: Date;\r\n}\r\n\r\nexport interface ApprovalRule {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  conditions: ApprovalCondition[];\r\n  requiredApprovers: ApproverRequirement[];\r\n  enabled: boolean;\r\n  priority: number;\r\n}\r\n\r\nexport interface ApprovalCondition {\r\n  field: string;\r\n  operator: 'EQUALS' | 'GREATER_THAN' | 'LESS_THAN' | 'CONTAINS' | 'BETWEEN';\r\n  value: any;\r\n  logicalOperator?: 'AND' | 'OR';\r\n}\r\n\r\nexport interface ApproverRequirement {\r\n  role: string;\r\n  level: number;\r\n  required: boolean;\r\n  parallel: boolean;\r\n}\r\n\r\nexport class DealDesk {\r\n  private static instance: DealDesk;\r\n  private auditLog: ImmutableAuditLogger;\r\n  private contractEngine: ContractEngine;\r\n  private deals: Map<string, Deal> = new Map();\r\n  private approvalRules: Map<string, ApprovalRule> = new Map();\r\n  private templates: Map<string, DealTemplate> = new Map();\r\n\r\n  private constructor() {\r\n    this.auditLog = new ImmutableAuditLogger();\r\n    this.contractEngine = ContractEngine.getInstance();\r\n    this.initializeApprovalRules();\r\n    this.initializeTemplates();\r\n  }\r\n\r\n  public static getInstance(): DealDesk {\r\n    if (!DealDesk.instance) {\r\n      DealDesk.instance = new DealDesk();\r\n    }\r\n    return DealDesk.instance;\r\n  }\r\n\r\n  private initializeApprovalRules(): void {\r\n    const rules: ApprovalRule[] = [\r\n      {\r\n        id: 'ENTERPRISE_PRICING',\r\n        name: 'Enterprise Pricing Approval',\r\n        description: 'Approval required for deals over $100,000',\r\n        conditions: [\r\n          { field: 'estimatedValue', operator: 'GREATER_THAN', value: 100000 }\r\n        ],\r\n        requiredApprovers: [\r\n          { role: 'SALES_DIRECTOR', level: 1, required: true, parallel: false },\r\n          { role: 'FINANCE_DIRECTOR', level: 2, required: true, parallel: false }\r\n        ],\r\n        enabled: true,\r\n        priority: 1\r\n      },\r\n      {\r\n        id: 'CUSTOM_TERMS',\r\n        name: 'Custom Terms Approval',\r\n        description: 'Approval required for deals with custom terms',\r\n        conditions: [\r\n          { field: 'hasCustomTerms', operator: 'EQUALS', value: true }\r\n        ],\r\n        requiredApprovers: [\r\n          { role: 'LEGAL_COUNSEL', level: 1, required: true, parallel: false }\r\n        ],\r\n        enabled: true,\r\n        priority: 2\r\n      },\r\n      {\r\n        id: 'COMPLIANCE_RISK',\r\n        name: 'Compliance Risk Approval',\r\n        description: 'Approval required for high compliance risk deals',\r\n        conditions: [\r\n          { field: 'complianceRisk', operator: 'EQUALS', value: 'HIGH' }\r\n        ],\r\n        requiredApprovers: [\r\n          { role: 'COMPLIANCE_OFFICER', level: 1, required: true, parallel: false },\r\n          { role: 'RISK_MANAGER', level: 2, required: true, parallel: false }\r\n        ],\r\n        enabled: true,\r\n        priority: 3\r\n      }\r\n    ];\r\n\r\n    rules.forEach(rule => {\r\n      this.approvalRules.set(rule.id, rule);\r\n    });\r\n  }\r\n\r\n  private initializeTemplates(): void {\r\n    // Initialize deal templates\r\n    const templates: DealTemplate[] = [\r\n      {\r\n        id: 'ENTERPRISE_TEMPLATE',\r\n        name: 'Enterprise Deal Template',\r\n        description: 'Standard template for enterprise deals',\r\n        dealType: 'NEW_BUSINESS',\r\n        customerSize: 'ENTERPRISE',\r\n        pricing: {\r\n          basePrice: 50000,\r\n          billingCycle: 'ANNUAL',\r\n          contractLength: 36,\r\n          tier: 'ENTERPRISE'\r\n        },\r\n        terms: {\r\n          paymentTerms: { netDays: 30, lateFeePercentage: 1.5 },\r\n          renewalTerms: { autoRenew: true, noticePeriod: 90, priceIncrease: { type: 'PERCENTAGE', value: 5 } },\r\n          terminationTerms: { noticePeriod: 90, dataExportPeriod: 30 }\r\n        },\r\n        requirements: [\r\n          { category: 'COMPLIANCE', description: 'SOX compliance', mandatory: true, priority: 'HIGH' }\r\n        ]\r\n      }\r\n    ];\r\n\r\n    templates.forEach(template => {\r\n      this.templates.set(template.id, template);\r\n    });\r\n  }\r\n\r\n  public async createDeal(\r\n    tenantId: string,\r\n    dealName: string,\r\n    customer: CustomerInfo,\r\n    dealType: Deal['dealType'],\r\n    estimatedValue: number,\r\n    createdBy: string\r\n  ): Promise<Deal> {\r\n    try {\r\n      // Generate deal ID\r\n      const dealId = this.generateDealId();\r\n      const dealNumber = this.generateDealNumber(tenantId);\r\n\r\n      // Create deal\r\n      const deal: Deal = {\r\n        id: dealId,\r\n        tenantId,\r\n        dealNumber,\r\n        dealName,\r\n        status: 'PROSPECT',\r\n        priority: this.calculatePriority(estimatedValue, dealType),\r\n        dealType,\r\n        estimatedValue,\r\n        currency: 'USD',\r\n        probability: this.calculateInitialProbability(dealType),\r\n        expectedCloseDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days\r\n        salesRep: createdBy,\r\n        accountManager: createdBy,\r\n        customer,\r\n        requirements: [],\r\n        pricing: this.getDefaultPricing(dealType, estimatedValue),\r\n        terms: this.getDefaultTerms(),\r\n        approvals: [],\r\n        contracts: [],\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n        createdBy,\r\n        notes: [],\r\n        activities: [],\r\n        competitors: [],\r\n        riskFactors: []\r\n      };\r\n\r\n      // Store deal\r\n      this.deals.set(dealId, deal);\r\n\r\n      // Check if approvals are needed\r\n      await this.checkRequiredApprovals(deal);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: createdBy,\r\n        action: 'CREATE_DEAL',\r\n        details: {\r\n          dealId,\r\n          dealName,\r\n          dealType,\r\n          estimatedValue\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'INFO'\r\n      });\r\n\r\n      return deal;\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: createdBy,\r\n        action: 'CREATE_DEAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          dealName,\r\n          dealType\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private calculatePriority(estimatedValue: number, dealType: Deal['dealType']): Deal['priority'] {\r\n    if (estimatedValue > 100000) return 'HIGH';\r\n    if (estimatedValue > 50000) return 'MEDIUM';\r\n    if (dealType === 'RENEWAL' || dealType === 'EXPANSION') return 'HIGH';\r\n    return 'LOW';\r\n  }\r\n\r\n  private calculateInitialProbability(dealType: Deal['dealType']): number {\r\n    switch (dealType) {\r\n      case 'NEW_BUSINESS': return 25;\r\n      case 'RENEWAL': return 75;\r\n      case 'EXPANSION': return 50;\r\n      case 'UPGRADE': return 60;\r\n      case 'DOWNGRADE': return 40;\r\n      default: return 25;\r\n    }\r\n  }\r\n\r\n  private getDefaultPricing(dealType: Deal['dealType'], estimatedValue: number): DealPricing {\r\n    const monthlyValue = estimatedValue / 12;\r\n\r\n    return {\r\n      basePrice: monthlyValue,\r\n      currency: 'USD',\r\n      billingCycle: 'MONTHLY',\r\n      contractLength: 12,\r\n      tier: 'PRO',\r\n      users: 10,\r\n      companies: 2,\r\n      expectedUsage: [],\r\n      discounts: [],\r\n      overageRates: [],\r\n      setupFee: 0,\r\n      implementationFee: estimatedValue * 0.1,\r\n      trainingFee: estimatedValue * 0.05,\r\n      supportFee: monthlyValue * 0.2,\r\n      totalContractValue: estimatedValue,\r\n      monthlyRecurringRevenue: monthlyValue,\r\n      annualRecurringRevenue: estimatedValue\r\n    };\r\n  }\r\n\r\n  private getDefaultTerms(): DealTerms {\r\n    return {\r\n      paymentTerms: {\r\n        netDays: 30,\r\n        lateFeePercentage: 1.5\r\n      },\r\n      renewalTerms: {\r\n        autoRenew: true,\r\n        noticePeriod: 90,\r\n        priceIncrease: {\r\n          type: 'PERCENTAGE',\r\n          value: 5,\r\n          cap: 10\r\n        }\r\n      },\r\n      terminationTerms: {\r\n        noticePeriod: 90,\r\n        dataExportPeriod: 30\r\n      },\r\n      serviceLevels: [],\r\n      customTerms: [],\r\n      complianceRequirements: []\r\n    };\r\n  }\r\n\r\n  private async checkRequiredApprovals(deal: Deal): Promise<void> {\r\n    const requiredApprovals: DealApproval[] = [];\r\n\r\n    for (const rule of this.approvalRules.values()) {\r\n      if (!rule.enabled) continue;\r\n\r\n      if (this.evaluateConditions(rule.conditions, deal)) {\r\n        for (const approver of rule.requiredApprovers) {\r\n          const approval: DealApproval = {\r\n            id: this.generateApprovalId(),\r\n            type: this.getApprovalType(approver.role),\r\n            approver: approver.role,\r\n            approverTitle: approver.role,\r\n            status: 'PENDING',\r\n            requestedAt: new Date(),\r\n            level: approver.level\r\n          };\r\n          requiredApprovals.push(approval);\r\n        }\r\n      }\r\n    }\r\n\r\n    deal.approvals = requiredApprovals;\r\n  }\r\n\r\n  private evaluateConditions(conditions: ApprovalCondition[], deal: Deal): boolean {\r\n    return conditions.every(condition => {\r\n      const fieldValue = this.getFieldValue(deal, condition.field);\r\n      \r\n      switch (condition.operator) {\r\n        case 'EQUALS':\r\n          return fieldValue === condition.value;\r\n        case 'GREATER_THAN':\r\n          return Number(fieldValue) > Number(condition.value);\r\n        case 'LESS_THAN':\r\n          return Number(fieldValue) < Number(condition.value);\r\n        case 'CONTAINS':\r\n          return String(fieldValue).includes(String(condition.value));\r\n        case 'BETWEEN':\r\n          const [min, max] = condition.value;\r\n          return Number(fieldValue) >= Number(min) && Number(fieldValue) <= Number(max);\r\n        default:\r\n          return false;\r\n      }\r\n    });\r\n  }\r\n\r\n  private getFieldValue(deal: Deal, field: string): any {\r\n    switch (field) {\r\n      case 'estimatedValue':\r\n        return deal.estimatedValue;\r\n      case 'hasCustomTerms':\r\n        return deal.terms.customTerms.length > 0;\r\n      case 'complianceRisk':\r\n        const highRiskCompliance = deal.terms.complianceRequirements\r\n          .filter(req => req.mandatory && req.status !== 'COMPLETED');\r\n        return highRiskCompliance.length > 0 ? 'HIGH' : 'LOW';\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  private getApprovalType(role: string): DealApproval['type'] {\r\n    if (role.includes('SALES')) return 'PRICING';\r\n    if (role.includes('FINANCE')) return 'PRICING';\r\n    if (role.includes('LEGAL')) return 'LEGAL';\r\n    if (role.includes('COMPLIANCE')) return 'COMPLIANCE';\r\n    if (role.includes('RISK')) return 'COMPLIANCE';\r\n    if (role.includes('EXECUTIVE')) return 'EXECUTIVE';\r\n    return 'PRICING';\r\n  }\r\n\r\n  public async updateDeal(\r\n    dealId: string,\r\n    updates: Partial<Deal>,\r\n    updatedBy: string\r\n  ): Promise<Deal> {\r\n    try {\r\n      const deal = this.deals.get(dealId);\r\n      if (!deal) {\r\n        throw new Error(`Deal ${dealId} not found`);\r\n      }\r\n\r\n      // Update deal\r\n      const updatedDeal = { ...deal, ...updates, updatedAt: new Date() };\r\n      this.deals.set(dealId, updatedDeal);\r\n\r\n      // Recheck approvals if pricing or terms changed\r\n      if (updates.pricing || updates.terms) {\r\n        await this.checkRequiredApprovals(updatedDeal);\r\n      }\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: deal.tenantId,\r\n        userId: updatedBy,\r\n        action: 'UPDATE_DEAL',\r\n        details: {\r\n          dealId,\r\n          updates: Object.keys(updates)\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'INFO'\r\n      });\r\n\r\n      return updatedDeal;\r\n    } catch (error) {\r\n      const deal = this.deals.get(dealId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: deal?.tenantId || 'UNKNOWN',\r\n        userId: updatedBy,\r\n        action: 'UPDATE_DEAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          dealId\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async approveDeal(\r\n    dealId: string,\r\n    approvalId: string,\r\n    approvedBy: string,\r\n    comments?: string\r\n  ): Promise<void> {\r\n    try {\r\n      const deal = this.deals.get(dealId);\r\n      if (!deal) {\r\n        throw new Error(`Deal ${dealId} not found`);\r\n      }\r\n\r\n      const approval = deal.approvals.find(a => a.id === approvalId);\r\n      if (!approval) {\r\n        throw new Error(`Approval ${approvalId} not found`);\r\n      }\r\n\r\n      // Update approval\r\n      approval.status = 'APPROVED';\r\n      approval.reviewedAt = new Date();\r\n      approval.comments = comments;\r\n\r\n      // Check if all required approvals are complete\r\n      const pendingApprovals = deal.approvals.filter(a => a.status === 'PENDING');\r\n      if (pendingApprovals.length === 0) {\r\n        deal.status = 'APPROVED';\r\n      }\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: deal.tenantId,\r\n        userId: approvedBy,\r\n        action: 'APPROVE_DEAL',\r\n        details: {\r\n          dealId,\r\n          approvalId,\r\n          approverRole: approval.approver,\r\n          comments\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'INFO'\r\n      });\r\n    } catch (error) {\r\n      const deal = this.deals.get(dealId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: deal?.tenantId || 'UNKNOWN',\r\n        userId: approvedBy,\r\n        action: 'APPROVE_DEAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          dealId,\r\n          approvalId\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async closeDeal(\r\n    dealId: string,\r\n    status: 'WON' | 'LOST',\r\n    closedBy: string,\r\n    reason?: string,\r\n    actualValue?: number\r\n  ): Promise<void> {\r\n    try {\r\n      const deal = this.deals.get(dealId);\r\n      if (!deal) {\r\n        throw new Error(`Deal ${dealId} not found`);\r\n      }\r\n\r\n      // Update deal status\r\n      deal.status = status;\r\n      deal.actualCloseDate = new Date();\r\n      \r\n      if (actualValue) {\r\n        deal.estimatedValue = actualValue;\r\n      }\r\n\r\n      // Add closing note\r\n      const note: DealNote = {\r\n        id: this.generateNoteId(),\r\n        content: `Deal ${status.toLowerCase()}. ${reason || ''}`,\r\n        author: closedBy,\r\n        createdAt: new Date(),\r\n        category: 'GENERAL',\r\n        visibility: 'ALL',\r\n        attachments: []\r\n      };\r\n      deal.notes.push(note);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: deal.tenantId,\r\n        userId: closedBy,\r\n        action: 'CLOSE_DEAL',\r\n        details: {\r\n          dealId,\r\n          status,\r\n          reason,\r\n          actualValue\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'INFO'\r\n      });\r\n    } catch (error) {\r\n      const deal = this.deals.get(dealId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: deal?.tenantId || 'UNKNOWN',\r\n        userId: closedBy,\r\n        action: 'CLOSE_DEAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          dealId,\r\n          status\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'DEAL_DESK',\r\n        timestamp: new Date(),\r\n        category: 'SALES',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getDeal(dealId: string): Promise<Deal | null> {\r\n    return this.deals.get(dealId) || null;\r\n  }\r\n\r\n  public async getDealsByTenant(tenantId: string): Promise<Deal[]> {\r\n    return Array.from(this.deals.values()).filter(deal => deal.tenantId === tenantId);\r\n  }\r\n\r\n  public async getDealsByStatus(status: Deal['status']): Promise<Deal[]> {\r\n    return Array.from(this.deals.values()).filter(deal => deal.status === status);\r\n  }\r\n\r\n  public async getDealMetrics(\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<DealMetrics> {\r\n    const deals = Array.from(this.deals.values())\r\n      .filter(deal => deal.createdAt >= startDate && deal.createdAt <= endDate);\r\n\r\n    const dealsByStatus: { [key: string]: number } = {};\r\n    const dealsByPriority: { [key: string]: number } = {};\r\n\r\n    deals.forEach(deal => {\r\n      dealsByStatus[deal.status] = (dealsByStatus[deal.status] || 0) + 1;\r\n      dealsByPriority[deal.priority] = (dealsByPriority[deal.priority] || 0) + 1;\r\n    });\r\n\r\n    const totalPipelineValue = deals\r\n      .filter(d => d.status !== 'LOST' && d.status !== 'CLOSED')\r\n      .reduce((sum, d) => sum + d.estimatedValue, 0);\r\n\r\n    const weightedPipelineValue = deals\r\n      .filter(d => d.status !== 'LOST' && d.status !== 'CLOSED')\r\n      .reduce((sum, d) => sum + (d.estimatedValue * d.probability / 100), 0);\r\n\r\n    const averageDealSize = deals.length > 0 ? totalPipelineValue / deals.length : 0;\r\n\r\n    const wonDeals = deals.filter(d => d.status === 'WON');\r\n    const winRate = deals.length > 0 ? (wonDeals.length / deals.length) * 100 : 0;\r\n\r\n    return {\r\n      totalDeals: deals.length,\r\n      dealsByStatus,\r\n      dealsByPriority,\r\n      totalPipelineValue,\r\n      weightedPipelineValue,\r\n      averageDealSize,\r\n      averageSalesCycle: 45, // Placeholder\r\n      winRate,\r\n      conversionRate: 25, // Placeholder\r\n      averageDiscount: 10, // Placeholder\r\n      topCompetitors: [], // Placeholder\r\n      revenueByMonth: [], // Placeholder\r\n      periodStart: startDate,\r\n      periodEnd: endDate\r\n    };\r\n  }\r\n\r\n  private generateDealId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `DEAL${timestamp}${random}`;\r\n  }\r\n\r\n  private generateDealNumber(tenantId: string): string {\r\n    const year = new Date().getFullYear();\r\n    const sequence = Math.floor(Math.random() * 99999) + 1;\r\n    return `DL-${tenantId.toUpperCase()}-${year}-${sequence.toString().padStart(5, '0')}`;\r\n  }\r\n\r\n  private generateApprovalId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `APPR${timestamp}${random}`;\r\n  }\r\n\r\n  private generateNoteId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `NOTE${timestamp}${random}`;\r\n  }\r\n}\r\n\r\ninterface DealTemplate {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  dealType: Deal['dealType'];\r\n  customerSize: CustomerInfo['size'];\r\n  pricing: Partial<DealPricing>;\r\n  terms: Partial<DealTerms>;\r\n  requirements: Partial<DealRequirement>[];\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\entitlement-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\expansion-signals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\growth-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\product-tiers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\retention-automation.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":783,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":783,"endColumn":52}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ProductTier } from './product-tiers';\r\nimport { UsageMeter } from './usage-meter';\r\nimport { BillingEngine } from './billing-engine';\r\nimport { ImmutableAuditLogger } from '../compliance/immutable-audit-log';\r\n\r\nexport interface RetentionCampaign {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  type: 'PROACTIVE' | 'REACTIVE' | 'PREVENTIVE';\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  status: 'PLANNING' | 'ACTIVE' | 'PAUSED' | 'COMPLETED' | 'CANCELLED';\r\n  targetSegments: RetentionSegment[];\r\n  triggers: RetentionTrigger[];\r\n  actions: RetentionAction[];\r\n  budget: RetentionBudget;\r\n  timeline: RetentionTimeline;\r\n  kpis: RetentionKPI[];\r\n  owner: string;\r\n  team: string[];\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  startedAt?: Date;\r\n  completedAt?: Date;\r\n}\r\n\r\nexport interface RetentionSegment {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  criteria: SegmentCriteria;\r\n  size: number;\r\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  churnProbability: number;\r\n  ltv: number;\r\n  status: 'TARGETED' | 'ACTIVE' | 'RESOLVED' | 'CHURNED';\r\n}\r\n\r\nexport interface SegmentCriteria {\r\n  tier: ProductTier[];\r\n  usageLevel: string[];\r\n  engagement: string[];\r\n  paymentHistory: string[];\r\n  supportHistory: string[];\r\n  tenureRange: { min: number; max: number }; // in months\r\n  lastLogin: { min: number; max: number }; // in days\r\n  riskFactors: string[];\r\n}\r\n\r\nexport interface RetentionTrigger {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  type: 'USAGE_DECLINE' | 'PAYMENT_ISSUE' | 'SUPPORT_TICKET' | 'COMPETITOR_THREAT' | 'FEATURE_REQUEST' | 'PRICING_FEEDBACK';\r\n  condition: TriggerCondition;\r\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  confidence: number;\r\n  timeframe: 'IMMEDIATE' | 'URGENT' | 'SHORT_TERM' | 'MEDIUM_TERM';\r\n  isActive: boolean;\r\n}\r\n\r\nexport interface TriggerCondition {\r\n  field: string;\r\n  operator: 'GREATER_THAN' | 'LESS_THAN' | 'EQUALS' | 'BETWEEN' | 'CONTAINS';\r\n  value: any;\r\n  timeWindow?: number; // in days\r\n}\r\n\r\nexport interface RetentionAction {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  type: 'EMAIL' | 'CALL' | 'OFFER' | 'FEATURE_GRANT' | 'TRAINING' | 'SUPPORT' | 'SURVEY';\r\n  priority: number;\r\n  delay: number; // in hours\r\n  conditions: string[];\r\n  template?: string;\r\n  parameters: { [key: string]: any };\r\n  owner: string;\r\n  status: 'PENDING' | 'SENT' | 'DELIVERED' | 'OPENED' | 'CLICKED' | 'COMPLETED' | 'FAILED';\r\n  results: ActionResult[];\r\n}\r\n\r\nexport interface ActionResult {\r\n  metric: string;\r\n  value: any;\r\n  timestamp: Date;\r\n  success: boolean;\r\n}\r\n\r\nexport interface RetentionBudget {\r\n  total: number;\r\n  allocated: number;\r\n  spent: number;\r\n  remaining: number;\r\n  currency: string;\r\n  categories: BudgetCategory[];\r\n  period: 'MONTHLY' | 'QUARTERLY' | 'ANNUALLY';\r\n}\r\n\r\nexport interface BudgetCategory {\r\n  name: string;\r\n  allocated: number;\r\n  spent: number;\r\n  remaining: number;\r\n  description: string;\r\n}\r\n\r\nexport interface RetentionTimeline {\r\n  startDate: Date;\r\n  endDate: Date;\r\n  phases: TimelinePhase[];\r\n  milestones: TimelineMilestone[];\r\n}\r\n\r\nexport interface TimelinePhase {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  startDate: Date;\r\n  endDate: Date;\r\n  status: 'PLANNED' | 'ACTIVE' | 'COMPLETED' | 'DELAYED';\r\n  deliverables: string[];\r\n}\r\n\r\nexport interface TimelineMilestone {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  dueDate: Date;\r\n  status: 'PENDING' | 'ACHIEVED' | 'MISSED';\r\n  importance: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n}\r\n\r\nexport interface RetentionKPI {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  target: number;\r\n  current: number;\r\n  unit: string;\r\n  frequency: 'DAILY' | 'WEEKLY' | 'MONTHLY';\r\n  trend: 'IMPROVING' | 'DECLINING' | 'STABLE';\r\n  status: 'ON_TRACK' | 'AT_RISK' | 'BEHIND' | 'ACHIEVED';\r\n}\r\n\r\nexport interface ChurnRisk {\r\n  id: string;\r\n  tenantId: string;\r\n  riskScore: number; // 0-100\r\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  factors: RiskFactor[];\r\n  signals: RiskSignal[];\r\n  predictedChurnDate?: Date;\r\n  confidence: number;\r\n  recommendedActions: string[];\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  acknowledged: boolean;\r\n  acknowledgedBy?: string;\r\n  acknowledgedAt?: Date;\r\n  status: 'ACTIVE' | 'ADDRESSED' | 'CHURNED' | 'FALSE_POSITIVE';\r\n}\r\n\r\nexport interface RiskFactor {\r\n  name: string;\r\n  value: number;\r\n  weight: number;\r\n  description: string;\r\n  threshold: number;\r\n  impact: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  status: 'NORMAL' | 'WARNING' | 'CRITICAL';\r\n}\r\n\r\nexport interface RiskSignal {\r\n  type: 'USAGE_DECLINE' | 'LOGIN_INACTIVITY' | 'SUPPORT_VOLUME' | 'PAYMENT_LATE' | 'FEATURE_ABANDONMENT' | 'COMPETITOR_ACTIVITY';\r\n  description: string;\r\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  timestamp: Date;\r\n  value: number;\r\n  threshold: number;\r\n}\r\n\r\nexport interface RetentionMetrics {\r\n  totalCustomers: number;\r\n  churnRate: number;\r\n  retentionRate: number;\r\n  netRevenueRetention: number;\r\n  grossRevenueRetention: number;\r\n  customerLifetimeValue: number;\r\n  averageTenure: number;\r\n  riskDistribution: { [key: string]: number };\r\n  campaignEffectiveness: { [key: string]: number };\r\n  interventionSuccess: number;\r\n  earlyWarningAccuracy: number;\r\n  revenueAtRisk: number;\r\n  savedRevenue: number;\r\n  periodStart: Date;\r\n  periodEnd: Date;\r\n}\r\n\r\nexport interface RetentionIntervention {\r\n  id: string;\r\n  tenantId: string;\r\n  campaignId: string;\r\n  type: RetentionAction['type'];\r\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';\r\n  scheduledAt: Date;\r\n  completedAt?: Date;\r\n  assignedTo: string;\r\n  actions: InterventionAction[];\r\n  results: InterventionResult[];\r\n  outcome: 'SUCCESS' | 'PARTIAL' | 'FAILED' | 'UNKNOWN';\r\n  revenueImpact: number;\r\n  cost: number;\r\n  roi: number;\r\n}\r\n\r\nexport interface InterventionAction {\r\n  id: string;\r\n  type: string;\r\n  description: string;\r\n  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';\r\n  scheduledAt: Date;\r\n  completedAt?: Date;\r\n  assignee: string;\r\n  result?: string;\r\n  metadata?: { [key: string]: any };\r\n}\r\n\r\nexport interface InterventionResult {\r\n  metric: string;\r\n  value: any;\r\n  baseline: any;\r\n  change: number;\r\n  significance: boolean;\r\n  timestamp: Date;\r\n}\r\n\r\nexport class RetentionAutomationEngine {\r\n  private static instance: RetentionAutomationEngine;\r\n  private auditLog: ImmutableAuditLogger;\r\n  private usageMeter: UsageMeter;\r\n  private billingEngine: BillingEngine;\r\n  private campaigns: Map<string, RetentionCampaign> = new Map();\r\n  private risks: Map<string, ChurnRisk> = new Map();\r\n  private interventions: Map<string, RetentionIntervention> = new Map();\r\n  private triggers: Map<string, RetentionTrigger> = new Map();\r\n\r\n  private constructor() {\r\n    this.auditLog = new ImmutableAuditLogger();\r\n    this.usageMeter = UsageMeter.getInstance();\r\n    this.billingEngine = BillingEngine.getInstance();\r\n    this.initializeDefaultCampaigns();\r\n    this.initializeDefaultTriggers();\r\n  }\r\n\r\n  public static getInstance(): RetentionAutomationEngine {\r\n    if (!RetentionAutomationEngine.instance) {\r\n      RetentionAutomationEngine.instance = new RetentionAutomationEngine();\r\n    }\r\n    return RetentionAutomationEngine.instance;\r\n  }\r\n\r\n  private initializeDefaultCampaigns(): void {\r\n    const campaigns: RetentionCampaign[] = [\r\n      {\r\n        id: 'HIGH_RISK_INTERVENTION',\r\n        name: 'High Risk Customer Intervention',\r\n        description: 'Proactive outreach to customers at high risk of churn',\r\n        type: 'PROACTIVE',\r\n        priority: 'HIGH',\r\n        status: 'ACTIVE',\r\n        targetSegments: [\r\n          {\r\n            id: 'high_risk_customers',\r\n            name: 'High Risk Customers',\r\n            description: 'Customers with churn probability > 70%',\r\n            criteria: {\r\n              tier: ['STARTER', 'PRO'],\r\n              usageLevel: ['LOW', 'DECLINING'],\r\n              engagement: ['LOW'],\r\n              paymentHistory: ['LATE', 'MISSED'],\r\n              supportHistory: ['HIGH_VOLUME'],\r\n              tenureRange: { min: 3, max: 24 },\r\n              lastLogin: { min: 7, max: 30 },\r\n              riskFactors: ['usage_decline', 'payment_issues', 'support_tickets']\r\n            },\r\n            size: 150,\r\n            riskLevel: 'HIGH',\r\n            churnProbability: 75,\r\n            ltv: 8500,\r\n            status: 'TARGETED'\r\n          }\r\n        ],\r\n        triggers: [\r\n          {\r\n            id: 'usage_decline_trigger',\r\n            name: 'Usage Decline Trigger',\r\n            description: 'Detect significant decline in usage',\r\n            type: 'USAGE_DECLINE',\r\n            condition: {\r\n              field: 'usage_change_percentage',\r\n              operator: 'LESS_THAN',\r\n              value: -30,\r\n              timeWindow: 14\r\n            },\r\n            severity: 'HIGH',\r\n            confidence: 0.8,\r\n            timeframe: 'URGENT',\r\n            isActive: true\r\n          },\r\n          {\r\n            id: 'payment_issue_trigger',\r\n            name: 'Payment Issue Trigger',\r\n            description: 'Detect payment failures or delays',\r\n            type: 'PAYMENT_ISSUE',\r\n            condition: {\r\n              field: 'payment_status',\r\n              operator: 'CONTAINS',\r\n              value: 'FAILED|LATE',\r\n              timeWindow: 7\r\n            },\r\n            severity: 'CRITICAL',\r\n            confidence: 0.9,\r\n            timeframe: 'IMMEDIATE',\r\n            isActive: true\r\n          }\r\n        ],\r\n        actions: [\r\n          {\r\n            id: 'high_risk_email',\r\n            name: 'High Risk Email Outreach',\r\n            description: 'Personalized email to high risk customers',\r\n            type: 'EMAIL',\r\n            priority: 1,\r\n            delay: 2,\r\n            conditions: ['risk_score > 70'],\r\n            template: 'high_risk_retention_template',\r\n            parameters: {\r\n              subject: 'We want to help you succeed',\r\n              personalization: 'HIGH',\r\n              offer_type: 'SUPPORT'\r\n            },\r\n            owner: 'RETENTION_TEAM',\r\n            status: 'PENDING',\r\n            results: []\r\n          },\r\n          {\r\n            id: 'account_manager_call',\r\n            name: 'Account Manager Call',\r\n            description: 'Personal call from account manager',\r\n            type: 'CALL',\r\n            priority: 2,\r\n            delay: 24,\r\n            conditions: ['risk_score > 80'],\r\n            parameters: {\r\n              script: 'high_risk_call_script',\r\n              objective: 'IDENTIFY_ISSUES_AND_SOLUTIONS'\r\n            },\r\n            owner: 'ACCOUNT_MANAGER',\r\n            status: 'PENDING',\r\n            results: []\r\n          },\r\n          {\r\n            id: 'retention_offer',\r\n            name: 'Retention Offer',\r\n            description: 'Special offer to prevent churn',\r\n            type: 'OFFER',\r\n            priority: 3,\r\n            delay: 48,\r\n            conditions: ['risk_score > 75'],\r\n            parameters: {\r\n              discount_percentage: 20,\r\n              duration_months: 3,\r\n              type: 'TEMPORARY_DISCOUNT'\r\n            },\r\n            owner: 'SALES_TEAM',\r\n            status: 'PENDING',\r\n            results: []\r\n          }\r\n        ],\r\n        budget: {\r\n          total: 50000,\r\n          allocated: 35000,\r\n          spent: 12000,\r\n          remaining: 23000,\r\n          currency: 'USD',\r\n          categories: [\r\n            {\r\n              name: 'Personnel',\r\n              allocated: 25000,\r\n              spent: 8000,\r\n              remaining: 17000,\r\n              description: 'Account manager and support time'\r\n            },\r\n            {\r\n              name: 'Offers',\r\n              allocated: 10000,\r\n              spent: 4000,\r\n              remaining: 6000,\r\n              description: 'Discounts and special offers'\r\n            }\r\n          ],\r\n          period: 'QUARTERLY'\r\n        },\r\n        timeline: {\r\n          startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),\r\n          endDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000),\r\n          phases: [\r\n            {\r\n              id: 'identification_phase',\r\n              name: 'Risk Identification',\r\n              description: 'Identify high risk customers',\r\n              startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),\r\n              endDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000),\r\n              status: 'COMPLETED',\r\n              deliverables: ['Risk assessment report', 'Customer list']\r\n            },\r\n            {\r\n              id: 'intervention_phase',\r\n              name: 'Customer Intervention',\r\n              description: 'Execute retention actions',\r\n              startDate: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000),\r\n              endDate: new Date(Date.now() + 45 * 24 * 60 * 60 * 1000),\r\n              status: 'ACTIVE',\r\n              deliverables: ['Customer contacts', 'Offers sent', 'Follow-ups completed']\r\n            }\r\n          ],\r\n          milestones: [\r\n            {\r\n              id: 'first_contact_milestone',\r\n              name: 'First Contact Complete',\r\n              description: 'Initial contact with all high risk customers',\r\n              dueDate: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000),\r\n              status: 'ACHIEVED',\r\n              importance: 'HIGH'\r\n            },\r\n            {\r\n              id: 'retention_target_milestone',\r\n              name: 'Retention Target Achieved',\r\n              description: 'Achieve 80% retention rate for target segment',\r\n              dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\r\n              status: 'PENDING',\r\n              importance: 'CRITICAL'\r\n            }\r\n          ]\r\n        },\r\n        kpis: [\r\n          {\r\n            id: 'retention_rate',\r\n            name: 'Target Segment Retention Rate',\r\n            description: 'Retention rate for high risk customers',\r\n            target: 80,\r\n            current: 72,\r\n            unit: '%',\r\n            frequency: 'WEEKLY',\r\n            trend: 'IMPROVING',\r\n            status: 'ON_TRACK'\r\n          },\r\n          {\r\n            id: 'intervention_success',\r\n            name: 'Intervention Success Rate',\r\n            description: 'Percentage of successful interventions',\r\n            target: 70,\r\n            current: 65,\r\n            unit: '%',\r\n            frequency: 'WEEKLY',\r\n            trend: 'STABLE',\r\n            status: 'ON_TRACK'\r\n          }\r\n        ],\r\n        owner: 'RETENTION_MANAGER',\r\n        team: ['RETENTION_TEAM', 'ACCOUNT_MANAGERS', 'SUPPORT_TEAM', 'SALES_TEAM'],\r\n        createdAt: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000),\r\n        updatedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),\r\n        startedAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)\r\n      }\r\n    ];\r\n\r\n    campaigns.forEach(campaign => {\r\n      this.campaigns.set(campaign.id, campaign);\r\n    });\r\n  }\r\n\r\n  private initializeDefaultTriggers(): void {\r\n    const triggers: RetentionTrigger[] = [\r\n      {\r\n        id: 'usage_decline_trigger',\r\n        name: 'Usage Decline Trigger',\r\n        description: 'Detect significant decline in customer usage',\r\n        type: 'USAGE_DECLINE',\r\n        condition: {\r\n          field: 'usage_change_percentage',\r\n          operator: 'LESS_THAN',\r\n          value: -25,\r\n          timeWindow: 14\r\n        },\r\n        severity: 'HIGH',\r\n        confidence: 0.8,\r\n        timeframe: 'URGENT',\r\n        isActive: true\r\n      },\r\n      {\r\n        id: 'login_inactivity_trigger',\r\n        name: 'Login Inactivity Trigger',\r\n        description: 'Detect extended period of no login activity',\r\n        type: 'USAGE_DECLINE',\r\n        condition: {\r\n          field: 'days_since_last_login',\r\n          operator: 'GREATER_THAN',\r\n          value: 14,\r\n          timeWindow: 1\r\n        },\r\n        severity: 'MEDIUM',\r\n        confidence: 0.7,\r\n        timeframe: 'SHORT_TERM',\r\n        isActive: true\r\n      },\r\n      {\r\n        id: 'support_volume_trigger',\r\n        name: 'Support Volume Trigger',\r\n        description: 'Detect unusual increase in support tickets',\r\n        type: 'SUPPORT_TICKET',\r\n        condition: {\r\n          field: 'support_tickets_last_30_days',\r\n          operator: 'GREATER_THAN',\r\n          value: 5,\r\n          timeWindow: 30\r\n        },\r\n        severity: 'MEDIUM',\r\n        confidence: 0.6,\r\n        timeframe: 'SHORT_TERM',\r\n        isActive: true\r\n      },\r\n      {\r\n        id: 'payment_late_trigger',\r\n        name: 'Payment Late Trigger',\r\n        description: 'Detect late or failed payments',\r\n        type: 'PAYMENT_ISSUE',\r\n        condition: {\r\n          field: 'payment_days_overdue',\r\n          operator: 'GREATER_THAN',\r\n          value: 7,\r\n          timeWindow: 1\r\n        },\r\n        severity: 'HIGH',\r\n        confidence: 0.9,\r\n        timeframe: 'IMMEDIATE',\r\n        isActive: true\r\n      },\r\n      {\r\n        id: 'feature_abandonment_trigger',\r\n        name: 'Feature Abandonment Trigger',\r\n        description: 'Detect abandonment of previously used features',\r\n        type: 'FEATURE_REQUEST',\r\n        condition: {\r\n          field: 'feature_usage_decline',\r\n          operator: 'GREATER_THAN',\r\n          value: 50,\r\n          timeWindow: 30\r\n        },\r\n        severity: 'MEDIUM',\r\n        confidence: 0.5,\r\n        timeframe: 'MEDIUM_TERM',\r\n        isActive: true\r\n      }\r\n    ];\r\n\r\n    triggers.forEach(trigger => {\r\n      this.triggers.set(trigger.id, trigger);\r\n    });\r\n  }\r\n\r\n  public async analyzeChurnRisk(tenantId: string): Promise<ChurnRisk> {\r\n    try {\r\n      // Get tenant data\r\n      const usageMetrics = await this.usageMeter.getAllUsageMetrics(tenantId);\r\n      const billingData = await this.billingEngine.getAccount(tenantId);\r\n      \r\n      // Analyze risk factors\r\n      const factors = await this.calculateRiskFactors(tenantId, usageMetrics, billingData);\r\n      \r\n      // Detect risk signals\r\n      const signals = await this.detectRiskSignals(tenantId, usageMetrics, billingData);\r\n      \r\n      // Calculate overall risk score\r\n      const riskScore = this.calculateRiskScore(factors, signals);\r\n      const riskLevel = this.getRiskLevel(riskScore);\r\n      \r\n      // Predict churn date if high risk\r\n      const predictedChurnDate = riskScore > 70 ? this.predictChurnDate(riskScore) : undefined;\r\n      \r\n      // Generate recommendations\r\n      const recommendedActions = this.generateRecommendations(factors, signals, riskLevel);\r\n      \r\n      const churnRisk: ChurnRisk = {\r\n        id: this.generateRiskId(),\r\n        tenantId,\r\n        riskScore,\r\n        riskLevel,\r\n        factors,\r\n        signals,\r\n        predictedChurnDate,\r\n        confidence: this.calculateConfidence(factors, signals),\r\n        recommendedActions,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n        acknowledged: false,\r\n        status: 'ACTIVE'\r\n      };\r\n\r\n      this.risks.set(churnRisk.id, churnRisk);\r\n\r\n      // Trigger retention actions if needed\r\n      if (riskScore > 60) {\r\n        await this.triggerRetentionActions(tenantId, churnRisk);\r\n      }\r\n\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: 'SYSTEM',\r\n        action: 'ANALYZE_CHURN_RISK',\r\n        details: {\r\n          tenantId,\r\n          riskScore,\r\n          riskLevel,\r\n          factorsCount: factors.length,\r\n          signalsCount: signals.length\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'RETENTION_ENGINE',\r\n        timestamp: new Date(),\r\n        category: 'RETENTION',\r\n        severity: riskLevel === 'CRITICAL' ? 'CRITICAL' : riskLevel === 'HIGH' ? 'WARNING' : 'INFO'\r\n      });\r\n\r\n      return churnRisk;\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: 'SYSTEM',\r\n        action: 'ANALYZE_CHURN_RISK_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          tenantId\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'RETENTION_ENGINE',\r\n        timestamp: new Date(),\r\n        category: 'RETENTION',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async calculateRiskFactors(\r\n    tenantId: string,\r\n    usageMetrics: any[],\r\n    billingData: any\r\n  ): Promise<RiskFactor[]> {\r\n    const factors: RiskFactor[] = [];\r\n\r\n    // Usage decline factor\r\n    const usageFactor: RiskFactor = {\r\n      name: 'Usage Decline',\r\n      value: await this.calculateUsageDecline(tenantId),\r\n      weight: 0.3,\r\n      description: 'Percentage decline in usage over last 30 days',\r\n      threshold: 25,\r\n      impact: 'HIGH',\r\n      status: 'NORMAL'\r\n    };\r\n    factors.push(usageFactor);\r\n\r\n    // Login frequency factor\r\n    const loginFactor: RiskFactor = {\r\n      name: 'Login Frequency',\r\n      value: await this.calculateLoginFrequency(tenantId),\r\n      weight: 0.2,\r\n      description: 'Days since last login',\r\n      threshold: 14,\r\n      impact: 'MEDIUM',\r\n      status: 'NORMAL'\r\n    };\r\n    factors.push(loginFactor);\r\n\r\n    // Support tickets factor\r\n    const supportFactor: RiskFactor = {\r\n      name: 'Support Volume',\r\n      value: await this.calculateSupportVolume(tenantId),\r\n      weight: 0.15,\r\n      description: 'Number of support tickets in last 30 days',\r\n      threshold: 5,\r\n      impact: 'MEDIUM',\r\n      status: 'NORMAL'\r\n    };\r\n    factors.push(supportFactor);\r\n\r\n    // Payment history factor\r\n    const paymentFactor: RiskFactor = {\r\n      name: 'Payment History',\r\n      value: await this.calculatePaymentRisk(billingData),\r\n      weight: 0.25,\r\n      description: 'Payment risk score based on history',\r\n      threshold: 30,\r\n      impact: 'HIGH',\r\n      status: 'NORMAL'\r\n    };\r\n    factors.push(paymentFactor);\r\n\r\n    // Feature adoption factor\r\n    const featureFactor: RiskFactor = {\r\n      name: 'Feature Adoption',\r\n      value: await this.calculateFeatureAdoption(tenantId),\r\n      weight: 0.1,\r\n      description: 'Percentage of core features actively used',\r\n      threshold: 40,\r\n      impact: 'LOW',\r\n      status: 'NORMAL'\r\n    };\r\n    factors.push(featureFactor);\r\n\r\n    // Update factor statuses\r\n    factors.forEach(factor => {\r\n      if (factor.value >= factor.threshold * 1.5) {\r\n        factor.status = 'CRITICAL';\r\n      } else if (factor.value >= factor.threshold) {\r\n        factor.status = 'WARNING';\r\n      }\r\n    });\r\n\r\n    return factors;\r\n  }\r\n\r\n  private async detectRiskSignals(\r\n    tenantId: string,\r\n    usageMetrics: any[],\r\n    billingData: any\r\n  ): Promise<RiskSignal[]> {\r\n    const signals: RiskSignal[] = [];\r\n\r\n    // Check all active triggers\r\n    for (const trigger of this.triggers.values()) {\r\n      if (!trigger.isActive) continue;\r\n\r\n      const isTriggered = await this.evaluateTrigger(trigger, tenantId, usageMetrics, billingData);\r\n      \r\n      if (isTriggered) {\r\n        const signal: RiskSignal = {\r\n          type: trigger.type,\r\n          description: trigger.description,\r\n          severity: trigger.severity,\r\n          timestamp: new Date(),\r\n          value: await this.getTriggerValue(trigger, tenantId),\r\n          threshold: trigger.condition.value\r\n        };\r\n        signals.push(signal);\r\n      }\r\n    }\r\n\r\n    return signals;\r\n  }\r\n\r\n  private async evaluateTrigger(\r\n    trigger: RetentionTrigger,\r\n    tenantId: string,\r\n    usageMetrics: any[],\r\n    billingData: any\r\n  ): Promise<boolean> {\r\n    const value = await this.getTriggerValue(trigger, tenantId);\r\n    \r\n    switch (trigger.condition.operator) {\r\n      case 'GREATER_THAN':\r\n        return value > trigger.condition.value;\r\n      case 'LESS_THAN':\r\n        return value < trigger.condition.value;\r\n      case 'EQUALS':\r\n        return value === trigger.condition.value;\r\n      case 'BETWEEN':\r\n        const [min, max] = trigger.condition.value;\r\n        return value >= min && value <= max;\r\n      case 'CONTAINS':\r\n        return String(value).includes(String(trigger.condition.value));\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private async getTriggerValue(trigger: RetentionTrigger, tenantId: string): Promise<any> {\r\n    switch (trigger.condition.field) {\r\n      case 'usage_change_percentage':\r\n        return await this.calculateUsageDecline(tenantId);\r\n      case 'days_since_last_login':\r\n        return await this.calculateLoginFrequency(tenantId);\r\n      case 'support_tickets_last_30_days':\r\n        return await this.calculateSupportVolume(tenantId);\r\n      case 'payment_days_overdue':\r\n        return await this.calculatePaymentDaysOverdue(tenantId);\r\n      case 'feature_usage_decline':\r\n        return await this.calculateFeatureUsageDecline(tenantId);\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  private calculateRiskScore(factors: RiskFactor[], signals: RiskSignal[]): number {\r\n    let factorScore = 0;\r\n    let signalScore = 0;\r\n\r\n    // Calculate factor contribution\r\n    factors.forEach(factor => {\r\n      const normalizedValue = Math.min(factor.value / factor.threshold, 2);\r\n      factorScore += normalizedValue * factor.weight;\r\n    });\r\n\r\n    // Calculate signal contribution\r\n    signals.forEach(signal => {\r\n      const signalWeight = {\r\n        'LOW': 0.1,\r\n        'MEDIUM': 0.2,\r\n        'HIGH': 0.3,\r\n        'CRITICAL': 0.4\r\n      }[signal.severity];\r\n      signalScore += signalWeight;\r\n    });\r\n\r\n    // Combine scores\r\n    const totalScore = (factorScore * 0.7) + (signalScore * 0.3);\r\n    return Math.min(totalScore * 100, 100);\r\n  }\r\n\r\n  private getRiskLevel(score: number): ChurnRisk['riskLevel'] {\r\n    if (score >= 80) return 'CRITICAL';\r\n    if (score >= 60) return 'HIGH';\r\n    if (score >= 40) return 'MEDIUM';\r\n    return 'LOW';\r\n  }\r\n\r\n  private predictChurnDate(riskScore: number): Date {\r\n    // Simple prediction based on risk score\r\n    const daysToChurn = Math.max(7, 90 - (riskScore * 0.8));\r\n    return new Date(Date.now() + daysToChurn * 24 * 60 * 60 * 1000);\r\n  }\r\n\r\n  private calculateConfidence(factors: RiskFactor[], signals: RiskSignal[]): number {\r\n    // Confidence based on data quality and signal strength\r\n    const factorConfidence = factors.length > 0 ? 0.8 : 0.5;\r\n    const signalConfidence = signals.length > 0 ? 0.9 : 0.6;\r\n    return (factorConfidence + signalConfidence) / 2;\r\n  }\r\n\r\n  private generateRecommendations(\r\n    factors: RiskFactor[],\r\n    signals: RiskSignal[],\r\n    riskLevel: ChurnRisk['riskLevel']\r\n  ): string[] {\r\n    const recommendations: string[] = [];\r\n\r\n    // Usage-related recommendations\r\n    const usageFactor = factors.find(f => f.name === 'Usage Decline');\r\n    if (usageFactor && usageFactor.status !== 'NORMAL') {\r\n      recommendations.push('Schedule usage review call to understand declining usage');\r\n      recommendations.push('Offer training on underutilized features');\r\n    }\r\n\r\n    // Payment-related recommendations\r\n    const paymentFactor = factors.find(f => f.name === 'Payment History');\r\n    if (paymentFactor && paymentFactor.status !== 'NORMAL') {\r\n      recommendations.push('Contact customer about payment issues');\r\n      recommendations.push('Offer flexible payment options');\r\n    }\r\n\r\n    // Support-related recommendations\r\n    const supportFactor = factors.find(f => f.name === 'Support Volume');\r\n    if (supportFactor && supportFactor.status !== 'NORMAL') {\r\n      recommendations.push('Review support tickets for underlying issues');\r\n      recommendations.push('Assign dedicated support representative');\r\n    }\r\n\r\n    // Risk level specific recommendations\r\n    if (riskLevel === 'CRITICAL') {\r\n      recommendations.push('Immediate executive outreach');\r\n      recommendations.push('Offer significant retention incentive');\r\n    } else if (riskLevel === 'HIGH') {\r\n      recommendations.push('Account manager outreach within 24 hours');\r\n      recommendations.push('Schedule success planning session');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  private async triggerRetentionActions(tenantId: string, churnRisk: ChurnRisk): Promise<void> {\r\n    // Find applicable campaigns\r\n    const applicableCampaigns = Array.from(this.campaigns.values())\r\n      .filter(campaign => campaign.status === 'ACTIVE');\r\n\r\n    for (const campaign of applicableCampaigns) {\r\n      // Check if tenant matches campaign criteria\r\n      const matches = await this.evaluateCampaignCriteria(campaign, tenantId, churnRisk);\r\n      \r\n      if (matches) {\r\n        await this.executeCampaignActions(campaign, tenantId, churnRisk);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async evaluateCampaignCriteria(\r\n    campaign: RetentionCampaign,\r\n    tenantId: string,\r\n    churnRisk: ChurnRisk\r\n  ): Promise<boolean> {\r\n    // Simplified criteria evaluation\r\n    // In production, this would be more sophisticated\r\n    return campaign.targetSegments.some(segment => \r\n      segment.riskLevel === churnRisk.riskLevel\r\n    );\r\n  }\r\n\r\n  private async executeCampaignActions(\r\n    campaign: RetentionCampaign,\r\n    tenantId: string,\r\n    churnRisk: ChurnRisk\r\n  ): Promise<void> {\r\n    for (const action of campaign.actions) {\r\n      if (action.status !== 'PENDING') continue;\r\n\r\n      // Check action conditions\r\n      const conditionsMet = await this.evaluateActionConditions(action, churnRisk);\r\n      \r\n      if (conditionsMet) {\r\n        await this.executeRetentionAction(action, tenantId, churnRisk);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async evaluateActionConditions(\r\n    action: RetentionAction,\r\n    churnRisk: ChurnRisk\r\n  ): Promise<boolean> {\r\n    // Simplified condition evaluation\r\n    // In production, this would support complex condition logic\r\n    return true;\r\n  }\r\n\r\n  private async executeRetentionAction(\r\n    action: RetentionAction,\r\n    tenantId: string,\r\n    churnRisk: ChurnRisk\r\n  ): Promise<void> {\r\n    const interventionId = this.generateInterventionId();\r\n\r\n    const intervention: RetentionIntervention = {\r\n      id: interventionId,\r\n      tenantId,\r\n      campaignId: 'HIGH_RISK_INTERVENTION', // Simplified\r\n      type: action.type,\r\n      priority: 'HIGH',\r\n      status: 'PENDING',\r\n      scheduledAt: new Date(Date.now() + action.delay * 60 * 60 * 1000),\r\n      assignedTo: action.owner,\r\n      actions: [],\r\n      results: [],\r\n      outcome: 'UNKNOWN',\r\n      revenueImpact: 0,\r\n      cost: 0,\r\n      roi: 0\r\n    };\r\n\r\n    this.interventions.set(interventionId, intervention);\r\n\r\n    // Update action status\r\n    action.status = 'SENT';\r\n\r\n    await this.auditLog.logOperation({\r\n      tenantId,\r\n      userId: 'SYSTEM',\r\n      action: 'EXECUTE_RETENTION_ACTION',\r\n      details: {\r\n        interventionId,\r\n        actionType: action.type,\r\n        actionName: action.name,\r\n        riskScore: churnRisk.riskScore\r\n      },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'RETENTION_ENGINE',\r\n      timestamp: new Date(),\r\n      category: 'RETENTION',\r\n      severity: 'INFO'\r\n    });\r\n  }\r\n\r\n  // Helper methods (simplified implementations)\r\n  private async calculateUsageDecline(tenantId: string): Promise<number> {\r\n    return Math.floor(Math.random() * 50); // Placeholder\r\n  }\r\n\r\n  private async calculateLoginFrequency(tenantId: string): Promise<number> {\r\n    return Math.floor(Math.random() * 30); // Placeholder\r\n  }\r\n\r\n  private async calculateSupportVolume(tenantId: string): Promise<number> {\r\n    return Math.floor(Math.random() * 10); // Placeholder\r\n  }\r\n\r\n  private async calculatePaymentRisk(billingData: any): Promise<number> {\r\n    return Math.floor(Math.random() * 40); // Placeholder\r\n  }\r\n\r\n  private async calculateFeatureAdoption(tenantId: string): Promise<number> {\r\n    return Math.floor(Math.random() * 60); // Placeholder\r\n  }\r\n\r\n  private async calculatePaymentDaysOverdue(tenantId: string): Promise<number> {\r\n    return Math.floor(Math.random() * 15); // Placeholder\r\n  }\r\n\r\n  private async calculateFeatureUsageDecline(tenantId: string): Promise<number> {\r\n    return Math.floor(Math.random() * 70); // Placeholder\r\n  }\r\n\r\n  public async getRetentionMetrics(\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<RetentionMetrics> {\r\n    try {\r\n      const metrics: RetentionMetrics = {\r\n        totalCustomers: 0, // Would calculate from customer data\r\n        churnRate: 0, // Would calculate from churn data\r\n        retentionRate: 0, // Would calculate from retention data\r\n        netRevenueRetention: 0, // Would calculate from billing data\r\n        grossRevenueRetention: 0, // Would calculate from billing data\r\n        customerLifetimeValue: 0, // Would calculate from customer data\r\n        averageTenure: 0, // Would calculate from customer data\r\n        riskDistribution: {}, // Would calculate from risk data\r\n        campaignEffectiveness: {}, // Would calculate from campaign data\r\n        interventionSuccess: 0, // Would calculate from intervention data\r\n        earlyWarningAccuracy: 0, // Would calculate from prediction accuracy\r\n        revenueAtRisk: 0, // Would calculate from risk data\r\n        savedRevenue: 0, // Would calculate from intervention results\r\n        periodStart: startDate,\r\n        periodEnd: endDate\r\n      };\r\n\r\n      return metrics;\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId: 'SYSTEM',\r\n        userId: 'SYSTEM',\r\n        action: 'GET_RETENTION_METRICS_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          startDate,\r\n          endDate\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'RETENTION_ENGINE',\r\n        timestamp: new Date(),\r\n        category: 'RETENTION',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getChurnRisk(tenantId: string): Promise<ChurnRisk | null> {\r\n    return Array.from(this.risks.values()).find(risk => risk.tenantId === tenantId) || null;\r\n  }\r\n\r\n  public async getInterventions(tenantId?: string): Promise<RetentionIntervention[]> {\r\n    const interventions = Array.from(this.interventions.values());\r\n    return tenantId ? interventions.filter(i => i.tenantId === tenantId) : interventions;\r\n  }\r\n\r\n  private generateRiskId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `RISK${timestamp}${random}`;\r\n  }\r\n\r\n  private generateInterventionId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `INT${timestamp}${random}`;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\trial-manager.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":740,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":740,"endColumn":77},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":746,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":746,"endColumn":107}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ProductTier } from './product-tiers';\r\nimport { ImmutableAuditLogger } from '../compliance/immutable-audit-log';\r\nimport { GovernanceModelManager } from '../governance/governance-model';\r\n\r\nexport interface Trial {\r\n  id: string;\r\n  tenantId: string;\r\n  trialType: 'FREE_TIER' | 'STARTER_TRIAL' | 'PRO_TRIAL' | 'ENTERPRISE_TRIAL' | 'CUSTOM_TRIAL';\r\n  status: 'PENDING' | 'ACTIVE' | 'SUSPENDED' | 'EXPIRED' | 'CONVERTED' | 'CANCELLED';\r\n  trialNumber: string;\r\n  startDate: Date;\r\n  endDate: Date;\r\n  duration: number; // in days\r\n  targetTier: ProductTier;\r\n  features: TrialFeature[];\r\n  limits: TrialLimit[];\r\n  usage: TrialUsage[];\r\n  conversionSettings: ConversionSettings;\r\n  abusePrevention: AbusePreventionSettings;\r\n  contactInfo: TrialContactInfo;\r\n  billingInfo: TrialBillingInfo;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  createdBy: string;\r\n  convertedAt?: Date;\r\n  convertedToTier?: ProductTier;\r\n  cancellationReason?: string;\r\n  suspensionReason?: string;\r\n  notes: TrialNote[];\r\n  activities: TrialActivity[];\r\n}\r\n\r\nexport interface TrialFeature {\r\n  featureId: string;\r\n  featureName: string;\r\n  enabled: boolean;\r\n  accessLevel: 'FULL' | 'LIMITED' | 'DEMO';\r\n  restrictions?: string[];\r\n  demoData?: boolean;\r\n}\r\n\r\nexport interface TrialLimit {\r\n  metric: string;\r\n  limit: number;\r\n  currentUsage: number;\r\n  unit: string;\r\n  hardLimit: boolean;\r\n  warningThreshold: number;\r\n  criticalThreshold: number;\r\n}\r\n\r\nexport interface TrialUsage {\r\n  metric: string;\r\n  value: number;\r\n  timestamp: Date;\r\n  source: string;\r\n  description: string;\r\n}\r\n\r\nexport interface ConversionSettings {\r\n  autoConvert: boolean;\r\n  conversionTier: ProductTier;\r\n  conversionDiscount: number;\r\n  gracePeriod: number; // days after trial end\r\n  paymentMethodRequired: boolean;\r\n  approvalRequired: boolean;\r\n  conversionTriggers: ConversionTrigger[];\r\n}\r\n\r\nexport interface ConversionTrigger {\r\n  type: 'USAGE_THRESHOLD' | 'FEATURE_USAGE' | 'TIME_BASED' | 'MANUAL';\r\n  condition: string;\r\n  value: number;\r\n  action: 'CONVERT' | 'NOTIFY' | 'EXTEND';\r\n}\r\n\r\nexport interface AbusePreventionSettings {\r\n  maxTrialsPerEmail: number;\r\n  maxTrialsPerIP: number;\r\n  maxTrialsPerDomain: number;\r\n  trialCooldownPeriod: number; // days\r\n  verificationRequired: boolean;\r\n  monitoringLevel: 'BASIC' | 'ENHANCED' | 'STRICT';\r\n  suspiciousActivityThresholds: SuspiciousActivityThreshold[];\r\n}\r\n\r\nexport interface SuspiciousActivityThreshold {\r\n  activity: string;\r\n  threshold: number;\r\n  timeWindow: number; // in hours\r\n  action: 'WARN' | 'SUSPEND' | 'TERMINATE';\r\n}\r\n\r\nexport interface TrialContactInfo {\r\n  firstName: string;\r\n  lastName: string;\r\n  email: string;\r\n  phone: string;\r\n  company: string;\r\n  industry: string;\r\n  companySize: '1-10' | '11-50' | '51-200' | '201-500' | '500+';\r\n  jobTitle: string;\r\n  country: string;\r\n  state: string;\r\n  useCase: string;\r\n  referralSource: string;\r\n}\r\n\r\nexport interface TrialBillingInfo {\r\n  billingAddress?: {\r\n    street: string;\r\n    city: string;\r\n    state: string;\r\n    zipCode: string;\r\n    country: string;\r\n  };\r\n  taxId?: string;\r\n  paymentMethod?: {\r\n    type: 'CREDIT_CARD' | 'BANK_TRANSFER';\r\n    lastFour?: string;\r\n    token?: string;\r\n  };\r\n  poNumber?: string;\r\n}\r\n\r\nexport interface TrialNote {\r\n  id: string;\r\n  content: string;\r\n  author: string;\r\n  createdAt: Date;\r\n  category: 'GENERAL' | 'SUPPORT' | 'ABUSE' | 'CONVERSION' | 'TECHNICAL';\r\n  visibility: 'INTERNAL' | 'TEAM' | 'ALL';\r\n}\r\n\r\nexport interface TrialActivity {\r\n  id: string;\r\n  type: 'LOGIN' | 'FEATURE_USE' | 'DATA_IMPORT' | 'EXPORT' | 'INVITE' | 'SUPPORT_REQUEST';\r\n  description: string;\r\n  timestamp: Date;\r\n  userId?: string;\r\n  ipAddress: string;\r\n  userAgent: string;\r\n  metadata?: { [key: string]: any };\r\n}\r\n\r\nexport interface TrialMetrics {\r\n  totalTrials: number;\r\n  activeTrials: number;\r\n  expiredTrials: number;\r\n  convertedTrials: number;\r\n  cancelledTrials: number;\r\n  conversionRate: number;\r\n  averageTrialDuration: number;\r\n  trialToConversionTime: number;\r\n  trialsByType: { [key: string]: number };\r\n  trialsByIndustry: { [key: string]: number };\r\n  trialsByCompanySize: { [key: string]: number };\r\n  topConversionFeatures: { feature: string; conversionRate: number }[];\r\n  abandonmentReasons: { reason: string; count: number }[];\r\n  periodStart: Date;\r\n  periodEnd: Date;\r\n}\r\n\r\nexport interface TrialTemplate {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  trialType: Trial['trialType'];\r\n  targetTier: ProductTier;\r\n  duration: number;\r\n  features: Omit<TrialFeature, 'featureId'>[];\r\n  limits: Omit<TrialLimit, 'currentUsage'>[];\r\n  conversionSettings: ConversionSettings;\r\n  abusePrevention: AbusePreventionSettings;\r\n  isActive: boolean;\r\n  createdFor: string; // industry or segment\r\n  createdBy: string;\r\n  createdAt: Date;\r\n}\r\n\r\nexport class TrialManager {\r\n  private static instance: TrialManager;\r\n  private auditLog: ImmutableAuditLogger;\r\n  private governanceManager: GovernanceModelManager;\r\n  private trials: Map<string, Trial> = new Map();\r\n  private templates: Map<string, TrialTemplate> = new Map();\r\n  private emailTrials: Map<string, number> = new Map();\r\n  private ipTrials: Map<string, number> = new Map();\r\n  private domainTrials: Map<string, number> = new Map();\r\n\r\n  private constructor() {\r\n    this.auditLog = new ImmutableAuditLogger();\r\n    this.governanceManager = new GovernanceModelManager();\r\n    this.initializeDefaultTemplates();\r\n  }\r\n\r\n  public static getInstance(): TrialManager {\r\n    if (!TrialManager.instance) {\r\n      TrialManager.instance = new TrialManager();\r\n    }\r\n    return TrialManager.instance;\r\n  }\r\n\r\n  private initializeDefaultTemplates(): void {\r\n    const templates: TrialTemplate[] = [\r\n      {\r\n        id: 'STARTER_TRIAL_TEMPLATE',\r\n        name: 'Starter Trial',\r\n        description: '14-day trial of Starter tier features',\r\n        trialType: 'STARTER_TRIAL',\r\n        targetTier: 'STARTER',\r\n        duration: 14,\r\n        features: [\r\n          {\r\n            featureName: 'Multi-User Access',\r\n            enabled: true,\r\n            accessLevel: 'LIMITED',\r\n            restrictions: ['max_3_users'],\r\n            demoData: false\r\n          },\r\n          {\r\n            featureName: 'Basic Compliance',\r\n            enabled: true,\r\n            accessLevel: 'FULL',\r\n            demoData: false\r\n          },\r\n          {\r\n            featureName: 'API Access',\r\n            enabled: true,\r\n            accessLevel: 'LIMITED',\r\n            restrictions: ['1000_calls_per_day'],\r\n            demoData: false\r\n          },\r\n          {\r\n            featureName: 'Email Support',\r\n            enabled: true,\r\n            accessLevel: 'FULL',\r\n            demoData: false\r\n          }\r\n        ],\r\n        limits: [\r\n          {\r\n            metric: 'users',\r\n            limit: 3,\r\n            unit: 'users',\r\n            hardLimit: true,\r\n            warningThreshold: 2,\r\n            criticalThreshold: 3\r\n          },\r\n          {\r\n            metric: 'transactions',\r\n            limit: 100,\r\n            unit: 'transactions',\r\n            hardLimit: false,\r\n            warningThreshold: 80,\r\n            criticalThreshold: 95\r\n          },\r\n          {\r\n            metric: 'api_calls',\r\n            limit: 1000,\r\n            unit: 'calls/day',\r\n            hardLimit: true,\r\n            warningThreshold: 800,\r\n            criticalThreshold: 950\r\n          }\r\n        ],\r\n        conversionSettings: {\r\n          autoConvert: false,\r\n          conversionTier: 'STARTER',\r\n          conversionDiscount: 20,\r\n          gracePeriod: 7,\r\n          paymentMethodRequired: true,\r\n          approvalRequired: false,\r\n          conversionTriggers: [\r\n            {\r\n              type: 'USAGE_THRESHOLD',\r\n              condition: 'transactions > 80',\r\n              value: 80,\r\n              action: 'NOTIFY'\r\n            },\r\n            {\r\n              type: 'TIME_BASED',\r\n              condition: 'trial_days_remaining <= 3',\r\n              value: 3,\r\n              action: 'NOTIFY'\r\n            }\r\n          ]\r\n        },\r\n        abusePrevention: {\r\n          maxTrialsPerEmail: 1,\r\n          maxTrialsPerIP: 3,\r\n          maxTrialsPerDomain: 5,\r\n          trialCooldownPeriod: 30,\r\n          verificationRequired: true,\r\n          monitoringLevel: 'ENHANCED',\r\n          suspiciousActivityThresholds: [\r\n            {\r\n              activity: 'rapid_feature_usage',\r\n              threshold: 100,\r\n              timeWindow: 1,\r\n              action: 'WARN'\r\n            },\r\n            {\r\n              activity: 'multiple_logins',\r\n              threshold: 10,\r\n              timeWindow: 24,\r\n              action: 'SUSPEND'\r\n            }\r\n          ]\r\n        },\r\n        isActive: true,\r\n        createdFor: 'GENERAL',\r\n        createdBy: 'SYSTEM',\r\n        createdAt: new Date()\r\n      },\r\n      {\r\n        id: 'PRO_TRIAL_TEMPLATE',\r\n        name: 'Pro Trial',\r\n        description: '21-day trial of Pro tier features',\r\n        trialType: 'PRO_TRIAL',\r\n        targetTier: 'PRO',\r\n        duration: 21,\r\n        features: [\r\n          {\r\n            featureName: 'Multi-User Access',\r\n            enabled: true,\r\n            accessLevel: 'LIMITED',\r\n            restrictions: ['max_10_users'],\r\n            demoData: false\r\n          },\r\n          {\r\n            featureName: 'Advanced Compliance',\r\n            enabled: true,\r\n            accessLevel: 'FULL',\r\n            demoData: false\r\n          },\r\n          {\r\n            featureName: 'Custom Integrations',\r\n            enabled: true,\r\n            accessLevel: 'LIMITED',\r\n            restrictions: ['max_5_integrations'],\r\n            demoData: false\r\n          },\r\n          {\r\n            featureName: 'Priority Support',\r\n            enabled: true,\r\n            accessLevel: 'FULL',\r\n            demoData: false\r\n          },\r\n          {\r\n            featureName: 'Advanced Analytics',\r\n            enabled: true,\r\n            accessLevel: 'FULL',\r\n            demoData: true\r\n          }\r\n        ],\r\n        limits: [\r\n          {\r\n            metric: 'users',\r\n            limit: 10,\r\n            unit: 'users',\r\n            hardLimit: true,\r\n            warningThreshold: 8,\r\n            criticalThreshold: 10\r\n          },\r\n          {\r\n            metric: 'transactions',\r\n            limit: 1000,\r\n            unit: 'transactions',\r\n            hardLimit: false,\r\n            warningThreshold: 800,\r\n            criticalThreshold: 950\r\n          },\r\n          {\r\n            metric: 'api_calls',\r\n            limit: 10000,\r\n            unit: 'calls/day',\r\n            hardLimit: true,\r\n            warningThreshold: 8000,\r\n            criticalThreshold: 9500\r\n          }\r\n        ],\r\n        conversionSettings: {\r\n          autoConvert: false,\r\n          conversionTier: 'PRO',\r\n          conversionDiscount: 15,\r\n          gracePeriod: 14,\r\n          paymentMethodRequired: true,\r\n          approvalRequired: false,\r\n          conversionTriggers: [\r\n            {\r\n              type: 'USAGE_THRESHOLD',\r\n              condition: 'transactions > 800',\r\n              value: 800,\r\n              action: 'NOTIFY'\r\n            },\r\n            {\r\n              type: 'FEATURE_USAGE',\r\n              condition: 'advanced_analytics_usage > 50',\r\n              value: 50,\r\n              action: 'NOTIFY'\r\n            }\r\n          ]\r\n        },\r\n        abusePrevention: {\r\n          maxTrialsPerEmail: 1,\r\n          maxTrialsPerIP: 2,\r\n          maxTrialsPerDomain: 3,\r\n          trialCooldownPeriod: 60,\r\n          verificationRequired: true,\r\n          monitoringLevel: 'STRICT',\r\n          suspiciousActivityThresholds: [\r\n            {\r\n              activity: 'data_export_volume',\r\n              threshold: 1000,\r\n              timeWindow: 24,\r\n              action: 'SUSPEND'\r\n            },\r\n            {\r\n              activity: 'concurrent_sessions',\r\n              threshold: 5,\r\n              timeWindow: 1,\r\n              action: 'WARN'\r\n            }\r\n          ]\r\n        },\r\n        isActive: true,\r\n        createdFor: 'ENTERPRISE',\r\n        createdBy: 'SYSTEM',\r\n        createdAt: new Date()\r\n      }\r\n    ];\r\n\r\n    templates.forEach(template => {\r\n      this.templates.set(template.id, template);\r\n    });\r\n  }\r\n\r\n  public async createTrial(\r\n    templateId: string,\r\n    contactInfo: TrialContactInfo,\r\n    billingInfo?: TrialBillingInfo,\r\n    createdBy: string\r\n  ): Promise<Trial> {\r\n    try {\r\n      const template = this.templates.get(templateId);\r\n      if (!template) {\r\n        throw new Error(`Template ${templateId} not found`);\r\n      }\r\n\r\n      // Check abuse prevention\r\n      await this.checkAbusePrevention(contactInfo.email, template.abusePrevention);\r\n\r\n      // Generate trial ID and number\r\n      const trialId = this.generateTrialId();\r\n      const trialNumber = this.generateTrialNumber();\r\n\r\n      // Create trial\r\n      const trial: Trial = {\r\n        id: trialId,\r\n        tenantId: trialId, // Use trial ID as tenant ID for isolation\r\n        trialType: template.trialType,\r\n        status: 'PENDING',\r\n        trialNumber,\r\n        startDate: new Date(),\r\n        endDate: new Date(Date.now() + template.duration * 24 * 60 * 60 * 1000),\r\n        duration: template.duration,\r\n        targetTier: template.targetTier,\r\n        features: template.features.map((f, index) => ({\r\n          ...f,\r\n          featureId: `feature_${index}`\r\n        })),\r\n        limits: template.limits.map(limit => ({\r\n          ...limit,\r\n          currentUsage: 0\r\n        })),\r\n        usage: [],\r\n        conversionSettings: template.conversionSettings,\r\n        abusePrevention: template.abusePrevention,\r\n        contactInfo,\r\n        billingInfo,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n        createdBy,\r\n        notes: [],\r\n        activities: []\r\n      };\r\n\r\n      // Store trial\r\n      this.trials.set(trialId, trial);\r\n\r\n      // Update abuse prevention counters\r\n      this.updateAbusePreventionCounters(contactInfo.email, template.abusePrevention);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: trialId,\r\n        userId: createdBy,\r\n        action: 'CREATE_TRIAL',\r\n        details: {\r\n          trialId,\r\n          trialType: template.trialType,\r\n          targetTier: template.targetTier,\r\n          contactEmail: contactInfo.email\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'INFO'\r\n      });\r\n\r\n      return trial;\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId: 'UNKNOWN',\r\n        userId: createdBy,\r\n        action: 'CREATE_TRIAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          templateId,\r\n          contactEmail: contactInfo.email\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async checkAbusePrevention(\r\n    email: string,\r\n    settings: AbusePreventionSettings\r\n  ): Promise<void> {\r\n    const domain = email.split('@')[1];\r\n    const now = new Date();\r\n\r\n    // Check email trials\r\n    const emailCount = this.emailTrials.get(email) || 0;\r\n    if (emailCount >= settings.maxTrialsPerEmail) {\r\n      throw new Error(`Maximum trials per email (${settings.maxTrialsPerEmail}) exceeded`);\r\n    }\r\n\r\n    // Check domain trials\r\n    const domainCount = this.domainTrials.get(domain) || 0;\r\n    if (domainCount >= settings.maxTrialsPerDomain) {\r\n      throw new Error(`Maximum trials per domain (${settings.maxTrialsPerDomain}) exceeded`);\r\n    }\r\n\r\n    // Check cooldown period\r\n    // This would require checking trial history - simplified for now\r\n  }\r\n\r\n  private updateAbusePreventionCounters(\r\n    email: string,\r\n    settings: AbusePreventionSettings\r\n  ): void {\r\n    const domain = email.split('@')[1];\r\n\r\n    // Update counters\r\n    this.emailTrials.set(email, (this.emailTrials.get(email) || 0) + 1);\r\n    this.domainTrials.set(domain, (this.domainTrials.get(domain) || 0) + 1);\r\n  }\r\n\r\n  public async activateTrial(trialId: string, activatedBy: string): Promise<void> {\r\n    try {\r\n      const trial = this.trials.get(trialId);\r\n      if (!trial) {\r\n        throw new Error(`Trial ${trialId} not found`);\r\n      }\r\n\r\n      if (trial.status !== 'PENDING') {\r\n        throw new Error(`Trial ${trialId} is not in PENDING status`);\r\n      }\r\n\r\n      // Activate trial\r\n      trial.status = 'ACTIVE';\r\n      trial.startDate = new Date();\r\n      trial.endDate = new Date(Date.now() + trial.duration * 24 * 60 * 60 * 1000);\r\n      trial.updatedAt = new Date();\r\n\r\n      // Add activity\r\n      const activity: TrialActivity = {\r\n        id: this.generateActivityId(),\r\n        type: 'LOGIN',\r\n        description: 'Trial activated',\r\n        timestamp: new Date(),\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER'\r\n      };\r\n      trial.activities.push(activity);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: trialId,\r\n        userId: activatedBy,\r\n        action: 'ACTIVATE_TRIAL',\r\n        details: {\r\n          trialId,\r\n          startDate: trial.startDate,\r\n          endDate: trial.endDate\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'INFO'\r\n      });\r\n    } catch (error) {\r\n      const trial = this.trials.get(trialId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: trial?.tenantId || 'UNKNOWN',\r\n        userId: activatedBy,\r\n        action: 'ACTIVATE_TRIAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          trialId\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async recordTrialUsage(\r\n    trialId: string,\r\n    metric: string,\r\n    value: number,\r\n    source: string,\r\n    description: string,\r\n    ipAddress: string,\r\n    userAgent: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      const trial = this.trials.get(trialId);\r\n      if (!trial) {\r\n        throw new Error(`Trial ${trialId} not found`);\r\n      }\r\n\r\n      if (trial.status !== 'ACTIVE') {\r\n        return false;\r\n      }\r\n\r\n      // Check if trial has expired\r\n      if (new Date() > trial.endDate) {\r\n        await this.expireTrial(trialId, 'SYSTEM');\r\n        return false;\r\n      }\r\n\r\n      // Find the limit for this metric\r\n      const limit = trial.limits.find(l => l.metric === metric);\r\n      if (limit) {\r\n        const newUsage = limit.currentUsage + value;\r\n\r\n        // Check hard limit\r\n        if (limit.hardLimit && newUsage > limit.limit) {\r\n          await this.suspendTrial(trialId, 'USAGE_LIMIT_EXCEEDED', `Hard limit exceeded for ${metric}`);\r\n          return false;\r\n        }\r\n\r\n        // Update current usage\r\n        limit.currentUsage = newUsage;\r\n\r\n        // Check thresholds\r\n        const percentage = (newUsage / limit.limit) * 100;\r\n        if (percentage >= limit.criticalThreshold) {\r\n          await this.createUsageAlert(trialId, metric, 'CRITICAL', newUsage, limit.limit);\r\n        } else if (percentage >= limit.warningThreshold) {\r\n          await this.createUsageAlert(trialId, metric, 'WARNING', newUsage, limit.limit);\r\n        }\r\n      }\r\n\r\n      // Record usage\r\n      const usage: TrialUsage = {\r\n        metric,\r\n        value,\r\n        timestamp: new Date(),\r\n        source,\r\n        description\r\n      };\r\n      trial.usage.push(usage);\r\n\r\n      // Add activity\r\n      const activity: TrialActivity = {\r\n        id: this.generateActivityId(),\r\n        type: 'FEATURE_USE',\r\n        description: `${metric}: ${value} ${limit?.unit || ''}`,\r\n        timestamp: new Date(),\r\n        ipAddress,\r\n        userAgent,\r\n        metadata: { metric, value }\r\n      };\r\n      trial.activities.push(activity);\r\n\r\n      // Check conversion triggers\r\n      await this.checkConversionTriggers(trialId);\r\n\r\n      // Check for suspicious activity\r\n      await this.checkSuspiciousActivity(trialId, activity);\r\n\r\n      return true;\r\n    } catch (error) {\r\n      const trial = this.trials.get(trialId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: trial?.tenantId || 'UNKNOWN',\r\n        userId: 'SYSTEM',\r\n        action: 'RECORD_TRIAL_USAGE_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          trialId,\r\n          metric,\r\n          value\r\n        },\r\n        ipAddress,\r\n        userAgent,\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async checkConversionTriggers(trialId: string): Promise<void> {\r\n    const trial = this.trials.get(trialId);\r\n    if (!trial) return;\r\n\r\n    for (const trigger of trial.conversionSettings.conversionTriggers) {\r\n      let conditionMet = false;\r\n\r\n      switch (trigger.type) {\r\n        case 'USAGE_THRESHOLD':\r\n          const limit = trial.limits.find(l => l.metric === 'transactions');\r\n          if (limit && limit.currentUsage >= trigger.value) {\r\n            conditionMet = true;\r\n          }\r\n          break;\r\n        case 'TIME_BASED':\r\n          const daysRemaining = Math.ceil((trial.endDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000));\r\n          if (daysRemaining <= trigger.value) {\r\n            conditionMet = true;\r\n          }\r\n          break;\r\n        // Add other trigger types as needed\r\n      }\r\n\r\n      if (conditionMet) {\r\n        if (trigger.action === 'CONVERT' && trial.conversionSettings.autoConvert) {\r\n          await this.convertTrial(trialId, trial.conversionSettings.conversionTier, 'SYSTEM');\r\n        } else if (trigger.action === 'NOTIFY') {\r\n          await this.sendConversionNotification(trialId, trigger);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async checkSuspiciousActivity(trialId: string, activity: TrialActivity): Promise<void> {\r\n    const trial = this.trials.get(trialId);\r\n    if (!trial) return;\r\n\r\n    for (const threshold of trial.abusePrevention.suspiciousActivityThresholds) {\r\n      const recentActivities = trial.activities.filter(a => \r\n        a.type === activity.type &&\r\n        a.timestamp >= new Date(Date.now() - threshold.timeWindow * 60 * 60 * 1000)\r\n      );\r\n\r\n      if (recentActivities.length >= threshold.threshold) {\r\n        if (threshold.action === 'SUSPEND') {\r\n          await this.suspendTrial(trialId, 'SUSPICIOUS_ACTIVITY', `Suspicious activity detected: ${threshold.activity}`);\r\n        } else if (threshold.action === 'TERMINATE') {\r\n          await this.cancelTrial(trialId, 'SUSPICIOUS_ACTIVITY', `Suspicious activity detected: ${threshold.activity}`);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private async createUsageAlert(\r\n    trialId: string,\r\n    metric: string,\r\n    level: 'WARNING' | 'CRITICAL',\r\n    currentUsage: number,\r\n    limit: number\r\n  ): Promise<void> {\r\n    const trial = this.trials.get(trialId);\r\n    if (!trial) return;\r\n\r\n    const note: TrialNote = {\r\n      id: this.generateNoteId(),\r\n      content: `${level} usage alert for ${metric}: ${currentUsage}/${limit} (${((currentUsage/limit)*100).toFixed(1)}%)`,\r\n      author: 'SYSTEM',\r\n      createdAt: new Date(),\r\n      category: 'SUPPORT',\r\n      visibility: 'TEAM'\r\n    };\r\n    trial.notes.push(note);\r\n  }\r\n\r\n  private async sendConversionNotification(trialId: string, trigger: ConversionTrigger): Promise<void> {\r\n    const trial = this.trials.get(trialId);\r\n    if (!trial) return;\r\n\r\n    const note: TrialNote = {\r\n      id: this.generateNoteId(),\r\n      content: `Conversion trigger met: ${trigger.condition}`,\r\n      author: 'SYSTEM',\r\n      createdAt: new Date(),\r\n      category: 'CONVERSION',\r\n      visibility: 'TEAM'\r\n    };\r\n    trial.notes.push(note);\r\n  }\r\n\r\n  public async convertTrial(\r\n    trialId: string,\r\n    targetTier: ProductTier,\r\n    convertedBy: string\r\n  ): Promise<void> {\r\n    try {\r\n      const trial = this.trials.get(trialId);\r\n      if (!trial) {\r\n        throw new Error(`Trial ${trialId} not found`);\r\n      }\r\n\r\n      if (trial.status !== 'ACTIVE') {\r\n        throw new Error(`Trial ${trialId} is not active`);\r\n      }\r\n\r\n      // Convert trial\r\n      trial.status = 'CONVERTED';\r\n      trial.convertedAt = new Date();\r\n      trial.convertedToTier = targetTier;\r\n      trial.updatedAt = new Date();\r\n\r\n      // Add conversion note\r\n      const note: TrialNote = {\r\n        id: this.generateNoteId(),\r\n        content: `Trial converted to ${targetTier} tier`,\r\n        author: convertedBy,\r\n        createdAt: new Date(),\r\n        category: 'CONVERSION',\r\n        visibility: 'ALL'\r\n      };\r\n      trial.notes.push(note);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: trialId,\r\n        userId: convertedBy,\r\n        action: 'CONVERT_TRIAL',\r\n        details: {\r\n          trialId,\r\n          fromTier: trial.targetTier,\r\n          toTier: targetTier,\r\n          trialDuration: Math.ceil((Date.now() - trial.startDate.getTime()) / (24 * 60 * 60 * 1000))\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'INFO'\r\n      });\r\n    } catch (error) {\r\n      const trial = this.trials.get(trialId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: trial?.tenantId || 'UNKNOWN',\r\n        userId: convertedBy,\r\n        action: 'CONVERT_TRIAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          trialId,\r\n          targetTier\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async expireTrial(trialId: string, expiredBy: string): Promise<void> {\r\n    try {\r\n      const trial = this.trials.get(trialId);\r\n      if (!trial) {\r\n        throw new Error(`Trial ${trialId} not found`);\r\n      }\r\n\r\n      if (trial.status === 'EXPIRED' || trial.status === 'CONVERTED') {\r\n        return;\r\n      }\r\n\r\n      // Expire trial\r\n      trial.status = 'EXPIRED';\r\n      trial.updatedAt = new Date();\r\n\r\n      // Add expiration note\r\n      const note: TrialNote = {\r\n        id: this.generateNoteId(),\r\n        content: 'Trial expired',\r\n        author: expiredBy,\r\n        createdAt: new Date(),\r\n        category: 'GENERAL',\r\n        visibility: 'ALL'\r\n      };\r\n      trial.notes.push(note);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: trialId,\r\n        userId: expiredBy,\r\n        action: 'EXPIRE_TRIAL',\r\n        details: {\r\n          trialId,\r\n          trialDuration: trial.duration,\r\n          actualDuration: Math.ceil((Date.now() - trial.startDate.getTime()) / (24 * 60 * 60 * 1000))\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'INFO'\r\n      });\r\n    } catch (error) {\r\n      const trial = this.trials.get(trialId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: trial?.tenantId || 'UNKNOWN',\r\n        userId: expiredBy,\r\n        action: 'EXPIRE_TRIAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          trialId\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async suspendTrial(\r\n    trialId: string,\r\n    reason: string,\r\n    description: string\r\n  ): Promise<void> {\r\n    try {\r\n      const trial = this.trials.get(trialId);\r\n      if (!trial) {\r\n        throw new Error(`Trial ${trialId} not found`);\r\n      }\r\n\r\n      // Suspend trial\r\n      trial.status = 'SUSPENDED';\r\n      trial.suspensionReason = reason;\r\n      trial.updatedAt = new Date();\r\n\r\n      // Add suspension note\r\n      const note: TrialNote = {\r\n        id: this.generateNoteId(),\r\n        content: `Trial suspended: ${description}`,\r\n        author: 'SYSTEM',\r\n        createdAt: new Date(),\r\n        category: 'ABUSE',\r\n        visibility: 'TEAM'\r\n      };\r\n      trial.notes.push(note);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: trialId,\r\n        userId: 'SYSTEM',\r\n        action: 'SUSPEND_TRIAL',\r\n        details: {\r\n          trialId,\r\n          reason,\r\n          description\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'WARNING'\r\n      });\r\n    } catch (error) {\r\n      const trial = this.trials.get(trialId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: trial?.tenantId || 'UNKNOWN',\r\n        userId: 'SYSTEM',\r\n        action: 'SUSPEND_TRIAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          trialId,\r\n          reason\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async cancelTrial(\r\n    trialId: string,\r\n    reason: string,\r\n    description: string\r\n  ): Promise<void> {\r\n    try {\r\n      const trial = this.trials.get(trialId);\r\n      if (!trial) {\r\n        throw new Error(`Trial ${trialId} not found`);\r\n      }\r\n\r\n      // Cancel trial\r\n      trial.status = 'CANCELLED';\r\n      trial.cancellationReason = reason;\r\n      trial.updatedAt = new Date();\r\n\r\n      // Add cancellation note\r\n      const note: TrialNote = {\r\n        id: this.generateNoteId(),\r\n        content: `Trial cancelled: ${description}`,\r\n        author: 'SYSTEM',\r\n        createdAt: new Date(),\r\n        category: 'GENERAL',\r\n        visibility: 'ALL'\r\n      };\r\n      trial.notes.push(note);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId: trialId,\r\n        userId: 'SYSTEM',\r\n        action: 'CANCEL_TRIAL',\r\n        details: {\r\n          trialId,\r\n          reason,\r\n          description\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'WARNING'\r\n      });\r\n    } catch (error) {\r\n      const trial = this.trials.get(trialId);\r\n      await this.auditLog.logOperation({\r\n        tenantId: trial?.tenantId || 'UNKNOWN',\r\n        userId: 'SYSTEM',\r\n        action: 'CANCEL_TRIAL_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          trialId,\r\n          reason\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'TRIAL_MANAGER',\r\n        timestamp: new Date(),\r\n        category: 'TRIAL',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getTrial(trialId: string): Promise<Trial | null> {\r\n    return this.trials.get(trialId) || null;\r\n  }\r\n\r\n  public async getTrialsByStatus(status: Trial['status']): Promise<Trial[]> {\r\n    return Array.from(this.trials.values()).filter(trial => trial.status === status);\r\n  }\r\n\r\n  public async getTrialMetrics(\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<TrialMetrics> {\r\n    const trials = Array.from(this.trials.values())\r\n      .filter(trial => trial.createdAt >= startDate && trial.createdAt <= endDate);\r\n\r\n    const activeTrials = trials.filter(t => t.status === 'ACTIVE');\r\n    const expiredTrials = trials.filter(t => t.status === 'EXPIRED');\r\n    const convertedTrials = trials.filter(t => t.status === 'CONVERTED');\r\n    const cancelledTrials = trials.filter(t => t.status === 'CANCELLED');\r\n\r\n    const conversionRate = trials.length > 0 ? (convertedTrials.length / trials.length) * 100 : 0;\r\n    const averageTrialDuration = trials.length > 0 \r\n      ? trials.reduce((sum, t) => sum + t.duration, 0) / trials.length \r\n      : 0;\r\n\r\n    const trialToConversionTime = convertedTrials.length > 0\r\n      ? convertedTrials.reduce((sum, t) => {\r\n          const duration = t.convertedAt ? t.convertedAt.getTime() - t.startDate.getTime() : 0;\r\n          return sum + duration;\r\n        }, 0) / convertedTrials.length / (24 * 60 * 60 * 1000)\r\n      : 0;\r\n\r\n    const trialsByType: { [key: string]: number } = {};\r\n    const trialsByIndustry: { [key: string]: number } = {};\r\n    const trialsByCompanySize: { [key: string]: number } = {};\r\n\r\n    trials.forEach(trial => {\r\n      trialsByType[trial.trialType] = (trialsByType[trial.trialType] || 0) + 1;\r\n      trialsByIndustry[trial.contactInfo.industry] = (trialsByIndustry[trial.contactInfo.industry] || 0) + 1;\r\n      trialsByCompanySize[trial.contactInfo.companySize] = (trialsByCompanySize[trial.contactInfo.companySize] || 0) + 1;\r\n    });\r\n\r\n    return {\r\n      totalTrials: trials.length,\r\n      activeTrials: activeTrials.length,\r\n      expiredTrials: expiredTrials.length,\r\n      convertedTrials: convertedTrials.length,\r\n      cancelledTrials: cancelledTrials.length,\r\n      conversionRate,\r\n      averageTrialDuration,\r\n      trialToConversionTime,\r\n      trialsByType,\r\n      trialsByIndustry,\r\n      trialsByCompanySize,\r\n      topConversionFeatures: [], // Placeholder\r\n      abandonmentReasons: [], // Placeholder\r\n      periodStart: startDate,\r\n      periodEnd: endDate\r\n    };\r\n  }\r\n\r\n  private generateTrialId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `TRIAL${timestamp}${random}`;\r\n  }\r\n\r\n  private generateTrialNumber(): string {\r\n    const year = new Date().getFullYear();\r\n    const sequence = Math.floor(Math.random() * 99999) + 1;\r\n    return `TRL-${year}-${sequence.toString().padStart(5, '0')}`;\r\n  }\r\n\r\n  private generateActivityId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `ACT${timestamp}${random}`;\r\n  }\r\n\r\n  private generateNoteId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `NOTE${timestamp}${random}`;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\monetization\\usage-meter.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":680,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":680,"endColumn":40},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":685,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":685,"endColumn":78},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":689,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":689,"endColumn":64},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":693,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":693,"endColumn":67}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ProductTier } from './product-tiers';\r\nimport { ImmutableAuditLogger } from '../compliance/immutable-audit-log';\r\nimport { GovernanceModelManager } from '../governance/governance-model';\r\n\r\nexport interface UsageMetric {\r\n  id: string;\r\n  tenantId: string;\r\n  metricType: 'TRANSACTIONS' | 'API_CALLS' | 'STORAGE' | 'USERS' | 'COMPANIES' | 'REPORTS' | 'INTEGRATIONS';\r\n  currentValue: number;\r\n  limit: number;\r\n  periodStart: Date;\r\n  periodEnd: Date;\r\n  resetFrequency: 'DAILY' | 'MONTHLY' | 'ANNUALLY' | 'NEVER';\r\n  lastUpdated: Date;\r\n}\r\n\r\nexport interface UsageEvent {\r\n  id: string;\r\n  tenantId: string;\r\n  metricType: UsageMetric['metricType'];\r\n  value: number;\r\n  timestamp: Date;\r\n  description: string;\r\n  source: string;\r\n  userId?: string;\r\n  sessionId?: string;\r\n}\r\n\r\nexport interface UsageAlert {\r\n  id: string;\r\n  tenantId: string;\r\n  metricType: UsageMetric['metricType'];\r\n  alertType: 'WARNING' | 'CRITICAL' | 'LIMIT_REACHED' | 'OVERAGE';\r\n  currentUsage: number;\r\n  limit: number;\r\n  percentage: number;\r\n  message: string;\r\n  createdAt: Date;\r\n  acknowledged: boolean;\r\n  acknowledgedAt?: Date;\r\n  acknowledgedBy?: string;\r\n}\r\n\r\nexport interface UsageReport {\r\n  id: string;\r\n  tenantId: string;\r\n  reportPeriod: {\r\n    startDate: Date;\r\n    endDate: Date;\r\n  };\r\n  metrics: UsageMetricSummary[];\r\n  totalUsage: number;\r\n  totalLimit: number;\r\n  utilizationPercentage: number;\r\n  overageCharges: number;\r\n  generatedAt: Date;\r\n}\r\n\r\nexport interface UsageMetricSummary {\r\n  metricType: UsageMetric['metricType'];\r\n  currentUsage: number;\r\n  limit: number;\r\n  utilizationPercentage: number;\r\n  overageAmount: number;\r\n  overageCharges: number;\r\n}\r\n\r\nexport interface UsageThreshold {\r\n  metricType: UsageMetric['metricType'];\r\n  warningThreshold: number; // percentage (e.g., 80 for 80%)\r\n  criticalThreshold: number; // percentage (e.g., 95 for 95%)\r\n  overageRate: number; // cost per unit over limit\r\n  hardLimit: boolean; // whether to block when limit reached\r\n}\r\n\r\nexport class UsageMeter {\r\n  private static instance: UsageMeter;\r\n  private auditLog: ImmutableAuditLogger;\r\n  private governanceManager: GovernanceModelManager;\r\n  private usageMetrics: Map<string, UsageMetric> = new Map();\r\n  private usageEvents: Map<string, UsageEvent[]> = new Map();\r\n  private usageAlerts: Map<string, UsageAlert[]> = new Map();\r\n  private thresholds: Map<string, UsageThreshold> = new Map();\r\n\r\n  private constructor() {\r\n    this.auditLog = ImmutableAuditLogger.getInstance();\r\n    this.governanceManager = GovernanceModelManager.getInstance();\r\n    this.initializeDefaultThresholds();\r\n  }\r\n\r\n  public static getInstance(): UsageMeter {\r\n    if (!UsageMeter.instance) {\r\n      UsageMeter.instance = new UsageMeter();\r\n    }\r\n    return UsageMeter.instance;\r\n  }\r\n\r\n  private initializeDefaultThresholds(): void {\r\n    const defaultThresholds: UsageThreshold[] = [\r\n      {\r\n        metricType: 'TRANSACTIONS',\r\n        warningThreshold: 80,\r\n        criticalThreshold: 95,\r\n        overageRate: 0.10, // $0.10 per transaction over limit\r\n        hardLimit: false\r\n      },\r\n      {\r\n        metricType: 'API_CALLS',\r\n        warningThreshold: 80,\r\n        criticalThreshold: 95,\r\n        overageRate: 0.001, // $0.001 per API call over limit\r\n        hardLimit: true\r\n      },\r\n      {\r\n        metricType: 'STORAGE',\r\n        warningThreshold: 85,\r\n        criticalThreshold: 98,\r\n        overageRate: 0.50, // $0.50 per GB over limit\r\n        hardLimit: false\r\n      },\r\n      {\r\n        metricType: 'USERS',\r\n        warningThreshold: 90,\r\n        criticalThreshold: 100,\r\n        overageRate: 10.00, // $10.00 per user over limit\r\n        hardLimit: true\r\n      },\r\n      {\r\n        metricType: 'COMPANIES',\r\n        warningThreshold: 90,\r\n        criticalThreshold: 100,\r\n        overageRate: 25.00, // $25.00 per company over limit\r\n        hardLimit: true\r\n      },\r\n      {\r\n        metricType: 'REPORTS',\r\n        warningThreshold: 80,\r\n        criticalThreshold: 95,\r\n        overageRate: 2.00, // $2.00 per report over limit\r\n        hardLimit: false\r\n      },\r\n      {\r\n        metricType: 'INTEGRATIONS',\r\n        warningThreshold: 80,\r\n        criticalThreshold: 95,\r\n        overageRate: 5.00, // $5.00 per integration over limit\r\n        hardLimit: false\r\n      }\r\n    ];\r\n\r\n    defaultThresholds.forEach(threshold => {\r\n      this.thresholds.set(threshold.metricType, threshold);\r\n    });\r\n  }\r\n\r\n  public async initializeTenantUsage(\r\n    tenantId: string,\r\n    tier: ProductTier,\r\n    limits: { [key in UsageMetric['metricType']]?: number }\r\n  ): Promise<void> {\r\n    try {\r\n      const metricTypes: UsageMetric['metricType'][] = [\r\n        'TRANSACTIONS', 'API_CALLS', 'STORAGE', 'USERS', 'COMPANIES', 'REPORTS', 'INTEGRATIONS'\r\n      ];\r\n\r\n      for (const metricType of metricTypes) {\r\n        const limit = limits[metricType] || this.getDefaultLimit(metricType, tier);\r\n        const metricId = `${tenantId}_${metricType}`;\r\n\r\n        const usageMetric: UsageMetric = {\r\n          id: metricId,\r\n          tenantId,\r\n          metricType,\r\n          currentValue: 0,\r\n          limit,\r\n          periodStart: new Date(),\r\n          periodEnd: this.calculatePeriodEnd(metricType),\r\n          resetFrequency: this.getResetFrequency(metricType),\r\n          lastUpdated: new Date()\r\n        };\r\n\r\n        this.usageMetrics.set(metricId, usageMetric);\r\n      }\r\n\r\n      // Initialize usage events array for tenant\r\n      this.usageEvents.set(tenantId, []);\r\n\r\n      // Initialize usage alerts array for tenant\r\n      this.usageAlerts.set(tenantId, []);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: 'SYSTEM',\r\n        action: 'INITIALIZE_TENANT_USAGE',\r\n        details: {\r\n          tier,\r\n          limits\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'USAGE_METER',\r\n        timestamp: new Date(),\r\n        category: 'BILLING',\r\n        severity: 'INFO'\r\n      });\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: 'SYSTEM',\r\n        action: 'INITIALIZE_TENANT_USAGE_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          tier\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'USAGE_METER',\r\n        timestamp: new Date(),\r\n        category: 'BILLING',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async recordUsage(\r\n    tenantId: string,\r\n    metricType: UsageMetric['metricType'],\r\n    value: number,\r\n    description: string,\r\n    source: string,\r\n    userId?: string,\r\n    sessionId?: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      const metricId = `${tenantId}_${metricType}`;\r\n      const usageMetric = this.usageMetrics.get(metricId);\r\n\r\n      if (!usageMetric) {\r\n        throw new Error(`Usage metric not found for tenant ${tenantId} and metric ${metricType}`);\r\n      }\r\n\r\n      // Check if metric needs reset\r\n      if (new Date() > usageMetric.periodEnd) {\r\n        await this.resetUsageMetric(tenantId, metricType);\r\n      }\r\n\r\n      // Get threshold for this metric type\r\n      const threshold = this.thresholds.get(metricType);\r\n      if (!threshold) {\r\n        throw new Error(`Threshold not configured for metric type ${metricType}`);\r\n      }\r\n\r\n      // Check hard limit\r\n      if (threshold.hardLimit && usageMetric.currentValue + value > usageMetric.limit) {\r\n        await this.createUsageAlert(\r\n          tenantId,\r\n          metricType,\r\n          'LIMIT_REACHED',\r\n          usageMetric.currentValue + value,\r\n          usageMetric.limit,\r\n          `Hard limit reached for ${metricType}. Operation blocked.`\r\n        );\r\n\r\n        // Log the blocked operation\r\n        await this.auditLog.logOperation({\r\n          tenantId,\r\n          userId: userId || 'SYSTEM',\r\n          action: 'USAGE_LIMIT_BLOCKED',\r\n          details: {\r\n            metricType,\r\n            attemptedValue: value,\r\n            currentUsage: usageMetric.currentValue,\r\n            limit: usageMetric.limit\r\n          },\r\n          ipAddress: 'SYSTEM',\r\n          userAgent: source,\r\n          timestamp: new Date(),\r\n          category: 'BILLING',\r\n          severity: 'WARNING'\r\n        });\r\n\r\n        return false;\r\n      }\r\n\r\n      // Update usage metric\r\n      usageMetric.currentValue += value;\r\n      usageMetric.lastUpdated = new Date();\r\n\r\n      // Record usage event\r\n      const usageEvent: UsageEvent = {\r\n        id: this.generateUsageId(),\r\n        tenantId,\r\n        metricType,\r\n        value,\r\n        timestamp: new Date(),\r\n        description,\r\n        source,\r\n        userId,\r\n        sessionId\r\n      };\r\n\r\n      const tenantEvents = this.usageEvents.get(tenantId) || [];\r\n      tenantEvents.push(usageEvent);\r\n      this.usageEvents.set(tenantId, tenantEvents);\r\n\r\n      // Check thresholds and create alerts if necessary\r\n      await this.checkUsageThresholds(tenantId, metricType, usageMetric);\r\n\r\n      // Log the operation\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: userId || 'SYSTEM',\r\n        action: 'RECORD_USAGE',\r\n        details: {\r\n          metricType,\r\n          value,\r\n          newTotal: usageMetric.currentValue,\r\n          limit: usageMetric.limit\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: source,\r\n        timestamp: new Date(),\r\n        category: 'BILLING',\r\n        severity: 'INFO'\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: userId || 'SYSTEM',\r\n        action: 'RECORD_USAGE_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          metricType,\r\n          value\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: source,\r\n        timestamp: new Date(),\r\n        category: 'BILLING',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async checkUsageThresholds(\r\n    tenantId: string,\r\n    metricType: UsageMetric['metricType'],\r\n    usageMetric: UsageMetric\r\n  ): Promise<void> {\r\n    const threshold = this.thresholds.get(metricType);\r\n    if (!threshold) return;\r\n\r\n    const percentage = (usageMetric.currentValue / usageMetric.limit) * 100;\r\n\r\n    // Check critical threshold\r\n    if (percentage >= threshold.criticalThreshold) {\r\n      await this.createUsageAlert(\r\n        tenantId,\r\n        metricType,\r\n        'CRITICAL',\r\n        usageMetric.currentValue,\r\n        usageMetric.limit,\r\n        `Critical usage threshold reached for ${metricType}: ${percentage.toFixed(1)}%`\r\n      );\r\n    }\r\n    // Check warning threshold\r\n    else if (percentage >= threshold.warningThreshold) {\r\n      await this.createUsageAlert(\r\n        tenantId,\r\n        metricType,\r\n        'WARNING',\r\n        usageMetric.currentValue,\r\n        usageMetric.limit,\r\n        `Warning threshold reached for ${metricType}: ${percentage.toFixed(1)}%`\r\n      );\r\n    }\r\n  }\r\n\r\n  private async createUsageAlert(\r\n    tenantId: string,\r\n    metricType: UsageMetric['metricType'],\r\n    alertType: UsageAlert['alertType'],\r\n    currentUsage: number,\r\n    limit: number,\r\n    message: string\r\n  ): Promise<void> {\r\n    const alert: UsageAlert = {\r\n      id: this.generateUsageId(),\r\n      tenantId,\r\n      metricType,\r\n      alertType,\r\n      currentUsage,\r\n      limit,\r\n      percentage: (currentUsage / limit) * 100,\r\n      message,\r\n      createdAt: new Date(),\r\n      acknowledged: false\r\n    };\r\n\r\n    const tenantAlerts = this.usageAlerts.get(tenantId) || [];\r\n    tenantAlerts.push(alert);\r\n    this.usageAlerts.set(tenantId, tenantAlerts);\r\n  }\r\n\r\n  private async resetUsageMetric(tenantId: string, metricType: UsageMetric['metricType']): Promise<void> {\r\n    const metricId = `${tenantId}_${metricType}`;\r\n    const usageMetric = this.usageMetrics.get(metricId);\r\n\r\n    if (!usageMetric) return;\r\n\r\n    usageMetric.currentValue = 0;\r\n    usageMetric.periodStart = new Date();\r\n    usageMetric.periodEnd = this.calculatePeriodEnd(metricType);\r\n    usageMetric.lastUpdated = new Date();\r\n\r\n    // Log the reset\r\n    await this.auditLog.logOperation({\r\n      tenantId,\r\n      userId: 'SYSTEM',\r\n      action: 'RESET_USAGE_METRIC',\r\n      details: {\r\n        metricType,\r\n        newPeriodStart: usageMetric.periodStart,\r\n        newPeriodEnd: usageMetric.periodEnd\r\n      },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'USAGE_METER',\r\n      timestamp: new Date(),\r\n      category: 'BILLING',\r\n      severity: 'INFO'\r\n    });\r\n  }\r\n\r\n  public async getUsageMetric(\r\n    tenantId: string,\r\n    metricType: UsageMetric['metricType']\r\n  ): Promise<UsageMetric | null> {\r\n    const metricId = `${tenantId}_${metricType}`;\r\n    return this.usageMetrics.get(metricId) || null;\r\n  }\r\n\r\n  public async getAllUsageMetrics(tenantId: string): Promise<UsageMetric[]> {\r\n    const metrics: UsageMetric[] = [];\r\n    const metricTypes: UsageMetric['metricType'][] = [\r\n      'TRANSACTIONS', 'API_CALLS', 'STORAGE', 'USERS', 'COMPANIES', 'REPORTS', 'INTEGRATIONS'\r\n    ];\r\n\r\n    for (const metricType of metricTypes) {\r\n      const metric = await this.getUsageMetric(tenantId, metricType);\r\n      if (metric) {\r\n        metrics.push(metric);\r\n      }\r\n    }\r\n\r\n    return metrics;\r\n  }\r\n\r\n  public async getUsageEvents(\r\n    tenantId: string,\r\n    startDate?: Date,\r\n    endDate?: Date,\r\n    metricType?: UsageMetric['metricType']\r\n  ): Promise<UsageEvent[]> {\r\n    const events = this.usageEvents.get(tenantId) || [];\r\n\r\n    return events.filter(event => {\r\n      if (startDate && event.timestamp < startDate) return false;\r\n      if (endDate && event.timestamp > endDate) return false;\r\n      if (metricType && event.metricType !== metricType) return false;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  public async getUsageAlerts(\r\n    tenantId: string,\r\n    acknowledged?: boolean,\r\n    alertType?: UsageAlert['alertType']\r\n  ): Promise<UsageAlert[]> {\r\n    const alerts = this.usageAlerts.get(tenantId) || [];\r\n\r\n    return alerts.filter(alert => {\r\n      if (acknowledged !== undefined && alert.acknowledged !== acknowledged) return false;\r\n      if (alertType && alert.alertType !== alertType) return false;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  public async acknowledgeAlert(\r\n    tenantId: string,\r\n    alertId: string,\r\n    acknowledgedBy: string\r\n  ): Promise<void> {\r\n    const alerts = this.usageAlerts.get(tenantId) || [];\r\n    const alert = alerts.find(a => a.id === alertId);\r\n\r\n    if (!alert) {\r\n      throw new Error(`Alert ${alertId} not found for tenant ${tenantId}`);\r\n    }\r\n\r\n    alert.acknowledged = true;\r\n    alert.acknowledgedAt = new Date();\r\n    alert.acknowledgedBy = acknowledgedBy;\r\n\r\n    // Log the acknowledgment\r\n    await this.auditLog.logOperation({\r\n      tenantId,\r\n      userId: acknowledgedBy,\r\n      action: 'ACKNOWLEDGE_USAGE_ALERT',\r\n      details: {\r\n        alertId,\r\n        alertType: alert.alertType,\r\n        metricType: alert.metricType\r\n      },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'USAGE_METER',\r\n      timestamp: new Date(),\r\n      category: 'BILLING',\r\n      severity: 'INFO'\r\n    });\r\n  }\r\n\r\n  public async generateUsageReport(\r\n    tenantId: string,\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<UsageReport> {\r\n    try {\r\n      const metrics = await this.getAllUsageMetrics(tenantId);\r\n      const events = await this.getUsageEvents(tenantId, startDate, endDate);\r\n\r\n      const metricSummaries: UsageMetricSummary[] = [];\r\n      let totalUsage = 0;\r\n      let totalLimit = 0;\r\n      let totalOverageCharges = 0;\r\n\r\n      for (const metric of metrics) {\r\n        const threshold = this.thresholds.get(metric.metricType);\r\n        if (!threshold) continue;\r\n\r\n        const overageAmount = Math.max(0, metric.currentValue - metric.limit);\r\n        const overageCharges = overageAmount * threshold.overageRate;\r\n\r\n        const summary: UsageMetricSummary = {\r\n          metricType: metric.metricType,\r\n          currentUsage: metric.currentValue,\r\n          limit: metric.limit,\r\n          utilizationPercentage: (metric.currentValue / metric.limit) * 100,\r\n          overageAmount,\r\n          overageCharges\r\n        };\r\n\r\n        metricSummaries.push(summary);\r\n        totalUsage += metric.currentValue;\r\n        totalLimit += metric.limit;\r\n        totalOverageCharges += overageCharges;\r\n      }\r\n\r\n      const utilizationPercentage = totalLimit > 0 ? (totalUsage / totalLimit) * 100 : 0;\r\n\r\n      const report: UsageReport = {\r\n        id: this.generateUsageId(),\r\n        tenantId,\r\n        reportPeriod: { startDate, endDate },\r\n        metrics: metricSummaries,\r\n        totalUsage,\r\n        totalLimit,\r\n        utilizationPercentage,\r\n        overageCharges: totalOverageCharges,\r\n        generatedAt: new Date()\r\n      };\r\n\r\n      // Log the report generation\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: 'SYSTEM',\r\n        action: 'GENERATE_USAGE_REPORT',\r\n        details: {\r\n          reportId: report.id,\r\n          startDate,\r\n          endDate,\r\n          totalOverageCharges\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'USAGE_METER',\r\n        timestamp: new Date(),\r\n        category: 'BILLING',\r\n        severity: 'INFO'\r\n      });\r\n\r\n      return report;\r\n    } catch (error) {\r\n      await this.auditLog.logOperation({\r\n        tenantId,\r\n        userId: 'SYSTEM',\r\n        action: 'GENERATE_USAGE_REPORT_ERROR',\r\n        details: {\r\n          error: (error as Error).message,\r\n          startDate,\r\n          endDate\r\n        },\r\n        ipAddress: 'SYSTEM',\r\n        userAgent: 'USAGE_METER',\r\n        timestamp: new Date(),\r\n        category: 'BILLING',\r\n        severity: 'ERROR'\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private getDefaultLimit(metricType: UsageMetric['metricType'], tier: ProductTier): number {\r\n    const limits: { [key in ProductTier]: { [key in UsageMetric['metricType']]: number } } = {\r\n      'FREE': {\r\n        'TRANSACTIONS': 50,\r\n        'API_CALLS': 100,\r\n        'STORAGE': 1, // GB\r\n        'USERS': 1,\r\n        'COMPANIES': 1,\r\n        'REPORTS': 5,\r\n        'INTEGRATIONS': 0\r\n      },\r\n      'STARTER': {\r\n        'TRANSACTIONS': 500,\r\n        'API_CALLS': 1000,\r\n        'STORAGE': 10, // GB\r\n        'USERS': 3,\r\n        'COMPANIES': 2,\r\n        'REPORTS': 10,\r\n        'INTEGRATIONS': 2\r\n      },\r\n      'PRO': {\r\n        'TRANSACTIONS': 5000,\r\n        'API_CALLS': 10000,\r\n        'STORAGE': 100, // GB\r\n        'USERS': 10,\r\n        'COMPANIES': 5,\r\n        'REPORTS': 25,\r\n        'INTEGRATIONS': 15\r\n      },\r\n      'ENTERPRISE': {\r\n        'TRANSACTIONS': -1, // Unlimited\r\n        'API_CALLS': -1, // Unlimited\r\n        'STORAGE': -1, // Unlimited\r\n        'USERS': -1, // Unlimited\r\n        'COMPANIES': -1, // Unlimited\r\n        'REPORTS': -1, // Unlimited\r\n        'INTEGRATIONS': -1 // Unlimited\r\n      }\r\n    };\r\n\r\n    return limits[tier][metricType];\r\n  }\r\n\r\n  private getResetFrequency(metricType: UsageMetric['metricType']): UsageMetric['resetFrequency'] {\r\n    switch (metricType) {\r\n      case 'API_CALLS':\r\n        return 'DAILY';\r\n      case 'TRANSACTIONS':\r\n      case 'REPORTS':\r\n        return 'MONTHLY';\r\n      case 'STORAGE':\r\n      case 'USERS':\r\n      case 'COMPANIES':\r\n      case 'INTEGRATIONS':\r\n        return 'NEVER';\r\n      default:\r\n        return 'MONTHLY';\r\n    }\r\n  }\r\n\r\n  private calculatePeriodEnd(metricType: UsageMetric['metricType']): Date {\r\n    const now = new Date();\r\n    const resetFrequency = this.getResetFrequency(metricType);\r\n\r\n    switch (resetFrequency) {\r\n      case 'DAILY':\r\n        const tomorrow = new Date(now);\r\n        tomorrow.setDate(tomorrow.getDate() + 1);\r\n        tomorrow.setHours(0, 0, 0, 0);\r\n        return tomorrow;\r\n      case 'MONTHLY':\r\n        const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);\r\n        nextMonth.setHours(23, 59, 59, 999);\r\n        return nextMonth;\r\n      case 'ANNUALLY':\r\n        const nextYear = new Date(now.getFullYear() + 1, 0, 0);\r\n        nextYear.setHours(23, 59, 59, 999);\r\n        return nextYear;\r\n      case 'NEVER':\r\n        const farFuture = new Date(now.getFullYear() + 100, 0, 0);\r\n        return farFuture;\r\n      default:\r\n        return new Date(now.getFullYear(), now.getMonth() + 1, 0);\r\n    }\r\n  }\r\n\r\n  private generateUsageId(): string {\r\n    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').substring(0, 14);\r\n    const random = Math.random().toString(36).substring(2, 8).toUpperCase();\r\n    return `USAGE${timestamp}${random}`;\r\n  }\r\n\r\n  public async updateUsageThreshold(\r\n    metricType: UsageMetric['metricType'],\r\n    threshold: Partial<UsageThreshold>\r\n  ): Promise<void> {\r\n    const existingThreshold = this.thresholds.get(metricType);\r\n    if (!existingThreshold) {\r\n      throw new Error(`Threshold not found for metric type ${metricType}`);\r\n    }\r\n\r\n    const updatedThreshold = { ...existingThreshold, ...threshold };\r\n    this.thresholds.set(metricType, updatedThreshold);\r\n\r\n    // Log the update\r\n    await this.auditLog.logOperation({\r\n      tenantId: 'SYSTEM',\r\n      userId: 'SYSTEM',\r\n      action: 'UPDATE_USAGE_THRESHOLD',\r\n      details: {\r\n        metricType,\r\n        oldThreshold: existingThreshold,\r\n        newThreshold: updatedThreshold\r\n      },\r\n      ipAddress: 'SYSTEM',\r\n      userAgent: 'USAGE_METER',\r\n      timestamp: new Date(),\r\n      category: 'BILLING',\r\n      severity: 'INFO'\r\n    });\r\n  }\r\n\r\n  public async checkUsageLimit(\r\n    tenantId: string,\r\n    metricType: UsageMetric['metricType'],\r\n    requiredValue: number\r\n  ): Promise<{ allowed: boolean; currentUsage: number; limit: number; percentage: number }> {\r\n    const metric = await this.getUsageMetric(tenantId, metricType);\r\n    if (!metric) {\r\n      throw new Error(`Usage metric not found for tenant ${tenantId} and metric ${metricType}`);\r\n    }\r\n\r\n    const percentage = (metric.currentValue / metric.limit) * 100;\r\n    const threshold = this.thresholds.get(metricType);\r\n    const hardLimit = threshold?.hardLimit || false;\r\n\r\n    const allowed = !hardLimit || (metric.currentValue + requiredValue <= metric.limit);\r\n\r\n    return {\r\n      allowed,\r\n      currentUsage: metric.currentValue,\r\n      limit: metric.limit,\r\n      percentage\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\observability\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\observability\\metrics-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\observability\\observability-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\observability\\structured-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\observability\\tracing-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\onboarding\\onboarding-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\onboarding\\onboarding-state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\onboarding\\onboarding-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\onboarding\\templates\\default-coa.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\backup-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\chaos-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\degradation-wrapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\disaster-recovery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\health-checks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\kill-switch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\rbac.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\readiness-gates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\restore-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\ops\\slo-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\performance\\admission-controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\performance\\capacity-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\performance\\concurrency-limiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\performance\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\performance\\load-shedder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\performance\\request-priority.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\prisma.ts","messages":[],"suppressedMessages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":7,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":7,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\reliability\\idempotency-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\audit-immutability.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":544,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":544,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":569,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":569,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":597,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":597,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":606,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":606,"endColumn":37}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Audit Immutability Enforcement\r\n// MANDATORY: Immutable audit logs with cryptographic integrity verification\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport type AuditEventType = 'AUTHENTICATION' | 'AUTHORIZATION' | 'DATA_MUTATION' | 'SECURITY' | 'SYSTEM';\r\nexport type AuditSeverity = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n\r\nexport interface AuditEvent {\r\n  id: string;\r\n  tenantId: string;\r\n  actorId: string;\r\n  action: string;\r\n  resourceType: string;\r\n  resourceId: string;\r\n  outcome: 'SUCCESS' | 'FAILURE';\r\n  timestamp: Date;\r\n  correlationId: string;\r\n  severity: AuditSeverity;\r\n  metadata: Record<string, any>;\r\n  previousHash?: string;\r\n  currentHash: string;\r\n  sequence: number;\r\n  immutable: boolean;\r\n}\r\n\r\nexport interface AuditChain {\r\n  events: AuditEvent[];\r\n  headHash: string;\r\n  tailHash: string;\r\n  totalEvents: number;\r\n  createdAt: Date;\r\n  lastModified: Date;\r\n  integrityVerified: boolean;\r\n  lastVerification: Date;\r\n}\r\n\r\nexport interface ImmutabilityViolation {\r\n  id: string;\r\n  timestamp: Date;\r\n  type: 'HASH_MISMATCH' | 'SEQUENCE_BREAK' | 'EVENT_MODIFICATION' | 'CHAIN_BREAK';\r\n  severity: 'HIGH' | 'CRITICAL';\r\n  description: string;\r\n  eventId: string;\r\n  expectedValue: string;\r\n  actualValue: string;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Audit Immutability Manager\r\n * \r\n * This class enforces immutable audit logs with cryptographic integrity\r\n * verification and comprehensive violation detection.\r\n */\r\nexport class AuditImmutabilityManager {\r\n  private static instance: AuditImmutabilityManager;\r\n  private auditLogger: any;\r\n  private auditChains: Map<string, AuditChain> = new Map();\r\n  private violations: ImmutabilityViolation[] = [];\r\n  private verificationInterval!: NodeJS.Timeout;\r\n  private appendQueues: Map<string, Promise<void>> = new Map();\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.startImmutabilityMonitoring();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): AuditImmutabilityManager {\r\n    if (!AuditImmutabilityManager.instance) {\r\n      AuditImmutabilityManager.instance = new AuditImmutabilityManager();\r\n    }\r\n    return AuditImmutabilityManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Add audit event with immutability protection\r\n   */\r\n  async addAuditEvent(event: Omit<AuditEvent, 'id' | 'previousHash' | 'currentHash' | 'sequence' | 'immutable'>): Promise<AuditEvent> {\r\n    const tenantId = event.tenantId;\r\n    const chainKey = this.getChainKey(tenantId);\r\n\r\n    if (!tenantId) {\r\n      throw new Error('tenantId is required');\r\n    }\r\n    if (!event.actorId) {\r\n      throw new Error('actorId is required');\r\n    }\r\n    if (!event.action) {\r\n      throw new Error('action is required');\r\n    }\r\n    if (!event.resourceType) {\r\n      throw new Error('resourceType is required');\r\n    }\r\n    if (!event.resourceId) {\r\n      throw new Error('resourceId is required');\r\n    }\r\n    if (!event.correlationId) {\r\n      throw new Error('correlationId is required');\r\n    }\r\n    if (!(event.timestamp instanceof Date) || Number.isNaN(event.timestamp.getTime())) {\r\n      throw new Error('timestamp is required');\r\n    }\r\n\r\n    const previous = this.appendQueues.get(chainKey) ?? Promise.resolve();\r\n\r\n    const appendPromise = (async () => {\r\n      await previous;\r\n      // CRITICAL: Get or create audit chain\r\n      let chain = this.auditChains.get(chainKey);\r\n      if (!chain) {\r\n        chain = await this.createAuditChain(tenantId);\r\n        this.auditChains.set(chainKey, chain);\r\n      }\r\n\r\n      // CRITICAL: Calculate sequence number\r\n      const sequence = chain.totalEvents + 1;\r\n      const previousHash = chain.totalEvents > 0 ? chain.tailHash : undefined;\r\n\r\n      // CRITICAL: Create immutable audit event\r\n      const immutableEvent: AuditEvent = {\r\n        ...event,\r\n        id: this.generateEventId(),\r\n        sequence,\r\n        previousHash,\r\n        currentHash: '',\r\n        immutable: true\r\n      };\r\n\r\n      // CRITICAL: Calculate current hash\r\n      immutableEvent.currentHash = this.calculateEventHash(immutableEvent);\r\n\r\n      // CRITICAL: Validate event immutability\r\n      await this.validateEventImmutability(immutableEvent, chain);\r\n\r\n      // CRITICAL: Add to chain\r\n      chain.events.push(immutableEvent);\r\n      chain.tailHash = immutableEvent.currentHash;\r\n      chain.totalEvents++;\r\n      chain.lastModified = new Date();\r\n\r\n      // CRITICAL: Update head hash\r\n      chain.headHash = this.calculateChainHash(chain);\r\n\r\n      // CRITICAL: Store chain\r\n      this.auditChains.set(chainKey, chain);\r\n\r\n      // CRITICAL: Log event addition\r\n      this.auditLogger.logAuthorizationDecision({\r\n        tenantId,\r\n        actorId: event.actorId,\r\n        action: 'AUDIT_EVENT_ADDED',\r\n        resourceType: 'AUDIT_CHAIN',\r\n        resourceId: immutableEvent.id,\r\n        outcome: 'SUCCESS',\r\n        correlationId: event.correlationId,\r\n        severity: event.severity,\r\n        metadata: {\r\n          originalAction: event.action,\r\n          sequence,\r\n          hash: immutableEvent.currentHash,\r\n          chainSize: chain.totalEvents\r\n        }\r\n      });\r\n\r\n      logger.debug('Audit event added to immutable chain', {\r\n        eventId: immutableEvent.id,\r\n        tenantId,\r\n        action: event.action,\r\n        sequence,\r\n        chainSize: chain.totalEvents\r\n      });\r\n\r\n      return immutableEvent;\r\n    })();\r\n\r\n    this.appendQueues.set(chainKey, appendPromise.then(() => undefined, () => undefined));\r\n\r\n    return appendPromise;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get audit chain\r\n   */\r\n  getAuditChain(tenantId: string): AuditChain | null {\r\n    const chainKey = this.getChainKey(tenantId);\r\n    return this.auditChains.get(chainKey) || null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get audit events\r\n   */\r\n  getAuditEvents(\r\n    tenantId: string,\r\n    limit?: number,\r\n    offset?: number\r\n  ): AuditEvent[] {\r\n    const chain = this.getAuditChain(tenantId);\r\n    if (!chain) {\r\n      return [];\r\n    }\r\n\r\n    let events = chain.events;\r\n    \r\n    if (offset) {\r\n      events = events.slice(offset);\r\n    }\r\n    \r\n    if (limit) {\r\n      events = events.slice(0, limit);\r\n    }\r\n\r\n    return events;\r\n  }\r\n\r\n  resetForTests(): void {\r\n    this.auditChains.clear();\r\n    this.violations = [];\r\n    this.appendQueues.clear();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Verify audit chain integrity\r\n   */\r\n  async verifyAuditChainIntegrity(tenantId: string): Promise<{\r\n    valid: boolean;\r\n    violations: ImmutabilityViolation[];\r\n    chainHash: string;\r\n    verifiedAt: Date;\r\n  }> {\r\n    const chain = this.getAuditChain(tenantId);\r\n    if (!chain) {\r\n      return {\r\n        valid: false,\r\n        violations: [{\r\n          id: this.generateViolationId(),\r\n        timestamp: new Date(),\r\n        type: 'CHAIN_BREAK',\r\n        severity: 'CRITICAL',\r\n        description: `Audit chain not found for tenant ${tenantId}`,\r\n        eventId: '',\r\n        expectedValue: 'existing_chain',\r\n        actualValue: 'no_chain',\r\n        metadata: { tenantId }\r\n        }],\r\n        chainHash: '',\r\n        verifiedAt: new Date()\r\n      };\r\n    }\r\n\r\n    const violations: ImmutabilityViolation[] = [];\r\n    let isValid = true;\r\n\r\n    // CRITICAL: Verify chain structure\r\n    if (chain.events.length === 0) {\r\n      violations.push({\r\n        id: this.generateViolationId(),\r\n        timestamp: new Date(),\r\n        type: 'CHAIN_BREAK',\r\n        severity: 'CRITICAL',\r\n        description: 'Empty audit chain',\r\n        eventId: '',\r\n        expectedValue: 'non_empty_chain',\r\n        actualValue: 'empty_chain',\r\n        metadata: { tenantId }\r\n      });\r\n      isValid = false;\r\n    }\r\n\r\n    // CRITICAL: Verify sequence continuity\r\n    for (let i = 0; i < chain.events.length; i++) {\r\n      const event = chain.events[i];\r\n      \r\n      if (event.sequence !== i + 1) {\r\n        violations.push({\r\n          id: this.generateViolationId(),\r\n          timestamp: new Date(),\r\n          type: 'SEQUENCE_BREAK',\r\n          severity: 'HIGH',\r\n          description: `Sequence break at position ${i}`,\r\n          eventId: event.id,\r\n          expectedValue: `${i + 1}`,\r\n          actualValue: `${event.sequence}`,\r\n          metadata: { tenantId, position: i }\r\n        });\r\n        isValid = false;\r\n      }\r\n\r\n      // CRITICAL: Verify hash continuity\r\n      if (i > 0) {\r\n        const previousEvent = chain.events[i - 1];\r\n        if (event.previousHash !== previousEvent.currentHash) {\r\n          violations.push({\r\n            id: this.generateViolationId(),\r\n            timestamp: new Date(),\r\n            type: 'HASH_MISMATCH',\r\n            severity: 'CRITICAL',\r\n            description: `Hash mismatch at position ${i}`,\r\n            eventId: event.id,\r\n            expectedValue: previousEvent.currentHash,\r\n            actualValue: event.previousHash ?? '',\r\n            metadata: { tenantId, position: i }\r\n          });\r\n          isValid = false;\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Verify current hash\r\n      const calculatedHash = this.calculateEventHash(event);\r\n      if (event.currentHash !== calculatedHash) {\r\n        violations.push({\r\n          id: this.generateViolationId(),\r\n          timestamp: new Date(),\r\n          type: 'HASH_MISMATCH',\r\n          severity: 'CRITICAL',\r\n          description: `Current hash mismatch at position ${i}`,\r\n          eventId: event.id,\r\n          expectedValue: calculatedHash,\r\n          actualValue: event.currentHash,\r\n          metadata: { tenantId, position: i }\r\n        });\r\n        isValid = false;\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Verify chain hash\r\n    const calculatedChainHash = this.calculateChainHash(chain);\r\n    if (chain.headHash !== calculatedChainHash) {\r\n      violations.push({\r\n        id: this.generateViolationId(),\r\n        timestamp: new Date(),\r\n        type: 'CHAIN_BREAK',\r\n        severity: 'CRITICAL',\r\n        description: 'Chain head hash mismatch',\r\n        eventId: '',\r\n        expectedValue: calculatedChainHash,\r\n        actualValue: chain.headHash,\r\n        metadata: { tenantId }\r\n      });\r\n      isValid = false;\r\n    }\r\n\r\n    // CRITICAL: Update chain verification status\r\n    chain.integrityVerified = isValid;\r\n    chain.lastVerification = new Date();\r\n\r\n    // CRITICAL: Store violations\r\n    this.violations.push(...violations);\r\n\r\n    // CRITICAL: Log verification results\r\n    if (!isValid) {\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId,\r\n        actorId: 'immutability-system',\r\n        action: 'AUDIT_INTEGRITY_VIOLATION',\r\n        resourceType: 'AUDIT_CHAIN',\r\n        resourceId: tenantId,\r\n        outcome: 'FAILURE',\r\n        correlationId: `integrity_violation_${tenantId}_${Date.now()}`,\r\n        severity: 'CRITICAL',\r\n        metadata: {\r\n          violations: violations.length,\r\n          chainSize: chain.totalEvents,\r\n          chainHash: calculatedChainHash\r\n        }\r\n      });\r\n\r\n      logger.error(\r\n        'Audit chain integrity violations detected',\r\n        new Error('AUDIT_INTEGRITY_VIOLATIONS'),\r\n        {\r\n          tenantId,\r\n          violations: violations.length,\r\n          chainSize: chain.totalEvents\r\n        }\r\n      );\r\n    } else {\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId,\r\n        actorId: 'immutability-system',\r\n        action: 'AUDIT_INTEGRITY_VERIFIED',\r\n        resourceType: 'AUDIT_CHAIN',\r\n        resourceId: tenantId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: `integrity_verified_${tenantId}_${Date.now()}`,\r\n        severity: 'LOW',\r\n        metadata: {\r\n          chainSize: chain.totalEvents,\r\n          chainHash: calculatedChainHash\r\n        }\r\n      });\r\n\r\n      logger.info('Audit chain integrity verified', {\r\n        tenantId,\r\n        chainSize: chain.totalEvents\r\n      });\r\n    }\r\n\r\n    return {\r\n      valid: isValid,\r\n      violations,\r\n      chainHash: calculatedChainHash,\r\n      verifiedAt: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get immutability violations\r\n   */\r\n  getImmutabilityViolations(\r\n    tenantId?: string,\r\n    type?: string,\r\n    severity?: string,\r\n    limit?: number\r\n  ): ImmutabilityViolation[] {\r\n    let violations = this.violations;\r\n\r\n    // CRITICAL: Filter violations\r\n    if (tenantId) {\r\n      violations = violations.filter(v => \r\n        v.metadata.tenantId === tenantId || v.metadata.tenantId === 'system'\r\n      );\r\n    }\r\n\r\n    if (type) {\r\n      violations = violations.filter(v => v.type === type);\r\n    }\r\n\r\n    if (severity) {\r\n      violations = violations.filter(v => v.severity === severity);\r\n    }\r\n\r\n    if (limit) {\r\n      violations = violations.slice(0, limit);\r\n    }\r\n\r\n    return violations;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Clear immutability violations\r\n   */\r\n  clearImmutabilityViolations(tenantId?: string): number {\r\n    let clearedCount = 0;\r\n    \r\n    if (tenantId) {\r\n      const originalCount = this.violations.length;\r\n      this.violations = this.violations.filter(v => \r\n        v.metadata.tenantId !== tenantId && v.metadata.tenantId !== 'system'\r\n      );\r\n      clearedCount = originalCount - this.violations.length;\r\n    } else {\r\n      clearedCount = this.violations.length;\r\n      this.violations = [];\r\n    }\r\n\r\n    if (clearedCount > 0) {\r\n      logger.info('Cleared immutability violations', { clearedCount, tenantId });\r\n    }\r\n\r\n    return clearedCount;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create audit chain\r\n   */\r\n  private async createAuditChain(tenantId: string): Promise<AuditChain> {\r\n    const chain: AuditChain = {\r\n      events: [],\r\n      headHash: '',\r\n      tailHash: '',\r\n      totalEvents: 0,\r\n      createdAt: new Date(),\r\n      lastModified: new Date(),\r\n      integrityVerified: false,\r\n      lastVerification: new Date()\r\n    };\r\n\r\n    // CRITICAL: Calculate initial hash\r\n    chain.headHash = this.calculateChainHash(chain);\r\n\r\n    // CRITICAL: Store chain\r\n    this.auditChains.set(this.getChainKey(tenantId), chain);\r\n\r\n    // CRITICAL: Log chain creation\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId,\r\n      actorId: 'immutability-system',\r\n      action: 'AUDIT_CHAIN_CREATED',\r\n      resourceType: 'AUDIT_CHAIN',\r\n      resourceId: tenantId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: `chain_created_${tenantId}_${Date.now()}`,\r\n      severity: 'LOW',\r\n      metadata: {\r\n        chainHash: chain.headHash,\r\n        createdAt: chain.createdAt\r\n      }\r\n    });\r\n\r\n    logger.info('Audit chain created', {\r\n      tenantId,\r\n      chainHash: chain.headHash\r\n    });\r\n\r\n    return chain;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate event immutability\r\n   */\r\n  private async validateEventImmutability(event: AuditEvent, chain: AuditChain): Promise<void> {\r\n    // CRITICAL: Check if event already exists\r\n    const existingEvent = chain.events.find(e => e.id === event.id);\r\n    if (existingEvent) {\r\n      throw new Error(`Audit event ${event.id} already exists in chain`);\r\n    }\r\n\r\n    // CRITICAL: Verify sequence\r\n    if (event.sequence !== chain.totalEvents + 1) {\r\n      throw new Error(`Invalid sequence number for event ${event.id}: expected ${chain.totalEvents + 1}, got ${event.sequence}`);\r\n    }\r\n\r\n    // CRITICAL: Verify previous hash\r\n    if (chain.totalEvents > 0 && event.previousHash !== chain.tailHash) {\r\n      throw new Error(`Previous hash mismatch for event ${event.id}: expected ${chain.tailHash}, got ${event.previousHash}`);\r\n    }\r\n\r\n    // CRITICAL: Verify immutability flag\r\n    if (!event.immutable) {\r\n      throw new Error(`Event ${event.id} is not marked as immutable`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate event hash\r\n   */\r\n  private calculateEventHash(event: AuditEvent): string {\r\n    const crypto = require('crypto');\r\n    const eventString = JSON.stringify({\r\n      id: event.id,\r\n      tenantId: event.tenantId,\r\n      actorId: event.actorId,\r\n      action: event.action,\r\n      resourceType: event.resourceType,\r\n      resourceId: event.resourceId,\r\n      outcome: event.outcome,\r\n      timestamp: event.timestamp.toISOString(),\r\n      correlationId: event.correlationId,\r\n      severity: event.severity,\r\n      metadata: event.metadata,\r\n      previousHash: event.previousHash,\r\n      sequence: event.sequence,\r\n      immutable: event.immutable\r\n    });\r\n\r\n    return crypto.createHash('sha256').update(eventString).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate chain hash\r\n   */\r\n  private calculateChainHash(chain: AuditChain): string {\r\n    const crypto = require('crypto');\r\n    \r\n    // CRITICAL: Create chain string for hashing\r\n    const chainString = JSON.stringify({\r\n      tailHash: chain.tailHash,\r\n      totalEvents: chain.totalEvents,\r\n      createdAt: chain.createdAt.toISOString(),\r\n      events: chain.events.map(event => ({\r\n        id: event.id,\r\n        hash: event.currentHash,\r\n        sequence: event.sequence\r\n      }))\r\n    });\r\n\r\n    return crypto.createHash('sha256').update(chainString).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get chain key\r\n   */\r\n  private getChainKey(tenantId: string): string {\r\n    return `audit_chain_${tenantId}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate event ID\r\n   */\r\n  private generateEventId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `event_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate violation ID\r\n   */\r\n  private generateViolationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `violation_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * Start immutability monitoring\r\n   */\r\n  private startImmutabilityMonitoring(): void {\r\n    // CRITICAL: Periodic integrity verification\r\n    this.verificationInterval = setInterval(async () => {\r\n      const chains = Array.from(this.auditChains.keys());\r\n      \r\n      for (const chainKey of chains) {\r\n        const tenantId = chainKey.replace('audit_chain_', '');\r\n        try {\r\n          await this.verifyAuditChainIntegrity(tenantId);\r\n        } catch (error) {\r\n          logger.error('Failed to verify audit chain integrity', error as Error, { tenantId });\r\n        }\r\n      }\r\n    }, 300000); // Every 5 minutes\r\n\r\n    // CRITICAL: Periodic cleanup of old violations\r\n    setInterval(() => {\r\n      this.cleanupOldViolations();\r\n    }, 3600000); // Every hour\r\n  }\r\n\r\n  /**\r\n   * Cleanup old violations\r\n   */\r\n  private cleanupOldViolations(): void {\r\n    const cutoffTime = new Date();\r\n    cutoffTime.setMonth(cutoffTime.getMonth() - 1); // 1 month ago\r\n\r\n    const originalCount = this.violations.length;\r\n    this.violations = this.violations.filter(v => v.timestamp > cutoffTime);\r\n    const cleanedCount = originalCount - this.violations.length;\r\n\r\n    if (cleanedCount > 0) {\r\n      logger.info('Cleaned up old immutability violations', { cleanedCount });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop immutability monitoring\r\n   */\r\n  stopImmutabilityMonitoring(): void {\r\n    if (this.verificationInterval) {\r\n      clearInterval(this.verificationInterval);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global audit immutability manager instance\r\n */\r\nexport const auditImmutabilityManager = AuditImmutabilityManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const addAuditEvent = async (\r\n  event: Omit<AuditEvent, 'previousHash' | 'currentHash' | 'sequence' | 'immutable'>\r\n): Promise<AuditEvent> => {\r\n  return await auditImmutabilityManager.addAuditEvent(event);\r\n};\r\n\r\nexport const verifyAuditChainIntegrity = async (\r\n  tenantId: string\r\n): Promise<{\r\n  valid: boolean;\r\n  violations: ImmutabilityViolation[];\r\n  chainHash: string;\r\n  verifiedAt: Date;\r\n}> => {\r\n  return await auditImmutabilityManager.verifyAuditChainIntegrity(tenantId);\r\n};\r\n\r\nexport const getAuditChain = (tenantId: string): AuditChain | null => {\r\n  return auditImmutabilityManager.getAuditChain(tenantId);\r\n};\r\n\r\nexport const getAuditEvents = (\r\n  tenantId: string,\r\n  limit?: number,\r\n  offset?: number\r\n): AuditEvent[] => {\r\n  return auditImmutabilityManager.getAuditEvents(tenantId, limit, offset);\r\n};\r\n\r\nexport const getImmutabilityViolations = (\r\n  tenantId?: string,\r\n  type?: string,\r\n  severity?: string,\r\n  limit?: number\r\n): ImmutabilityViolation[] => {\r\n  return auditImmutabilityManager.getImmutabilityViolations(tenantId, type, severity, limit);\r\n};\r\n\r\nexport const clearImmutabilityViolations = (tenantId?: string): number => {\r\n  return auditImmutabilityManager.clearImmutabilityViolations(tenantId);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\automated-resilience-validation.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":1150,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":1150,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":1159,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":1159,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Automated Resilience Validation\r\n// MANDATORY: Continuous automated validation of resilience capabilities\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { recoveryStrategyManager } from './recovery-strategy.js';\r\nimport { auditImmutabilityManager } from './audit-immutability.js';\r\nimport { chaosEngineeringManager } from './chaos-hooks.js';\r\nimport { resilienceMetricsManager } from './resilience-metrics.js';\r\n\r\nexport type ValidationType = 'AVAILABILITY' | 'PERFORMANCE' | 'SECURITY' | 'COMPLIANCE' | 'RECOVERY' | 'RESILIENCE';\r\nexport type ValidationStatus = 'PASS' | 'FAIL' | 'WARNING' | 'SKIP';\r\nexport type ValidationSeverity = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n\r\nexport interface ValidationRule {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  type: ValidationType;\r\n  severity: ValidationSeverity;\r\n  enabled: boolean;\r\n  schedule: string; // Cron expression\r\n  timeout: number; // Timeout in seconds\r\n  retryCount: number;\r\n  retryDelay: number; // Retry delay in seconds\r\n  conditions: Array<{\r\n    metric: string;\r\n    operator: 'GT' | 'LT' | 'EQ' | 'NE' | 'GTE' | 'LTE';\r\n    threshold: number;\r\n    aggregation?: string;\r\n  }>;\r\n  actions: Array<{\r\n    type: 'ALERT' | 'ESCALATE' | 'REMEDIATE' | 'REPORT';\r\n    parameters: Record<string, any>;\r\n  }>;\r\n}\r\n\r\nexport interface ValidationResult {\r\n  ruleId: string;\r\n  ruleName: string;\r\n  type: ValidationType;\r\n  status: ValidationStatus;\r\n  severity: ValidationSeverity;\r\n  executedAt: Date;\r\n  duration: number;\r\n  message: string;\r\n  details: Record<string, any>;\r\n  metrics: Record<string, number>;\r\n  violations: Array<{\r\n    condition: string;\r\n    actual: number;\r\n    expected: number;\r\n    severity: ValidationSeverity;\r\n  }>;\r\n  actions: Array<{\r\n    type: string;\r\n    executed: boolean;\r\n    result: string;\r\n    error?: string;\r\n  }>;\r\n}\r\n\r\nexport interface ValidationReport {\r\n  id: string;\r\n  timestamp: Date;\r\n  totalRules: number;\r\n  executedRules: number;\r\n  passedRules: number;\r\n  failedRules: number;\r\n  warningRules: number;\r\n  skippedRules: number;\r\n  overallStatus: ValidationStatus;\r\n  results: ValidationResult[];\r\n  summary: {\r\n    availability: { pass: number; fail: number; warning: number };\r\n    performance: { pass: number; fail: number; warning: number };\r\n    security: { pass: number; fail: number; warning: number };\r\n    compliance: { pass: number; fail: number; warning: number };\r\n    recovery: { pass: number; fail: number; warning: number };\r\n    resilience: { pass: number; fail: number; warning: number };\r\n  };\r\n  recommendations: string[];\r\n  correlationId: string;\r\n}\r\n\r\n/**\r\n * CRITICAL: Automated Resilience Validation Manager\r\n * \r\n * This class implements continuous automated validation of all resilience\r\n * capabilities with comprehensive rule-based validation, alerting, and reporting.\r\n */\r\nexport class AutomatedResilienceValidator {\r\n  private static instance: AutomatedResilienceValidator;\r\n  private auditLogger: any;\r\n  private validationRules: Map<string, ValidationRule> = new Map();\r\n  private validationHistory: ValidationResult[] = [];\r\n  private validationTimer: NodeJS.Timeout;\r\n  private cleanupTimer: NodeJS.Timeout;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.initializeValidationRules();\r\n    this.startAutomatedValidation();\r\n    this.startHistoryCleanup();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): AutomatedResilienceValidator {\r\n    if (!AutomatedResilienceValidator.instance) {\r\n      AutomatedResilienceValidator.instance = new AutomatedResilienceValidator();\r\n    }\r\n    return AutomatedResilienceValidator.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute validation rule\r\n   */\r\n  async executeValidation(ruleId: string): Promise<ValidationResult> {\r\n    const rule = this.validationRules.get(ruleId);\r\n    if (!rule) {\r\n      throw new Error(`Validation rule ${ruleId} not found`);\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const correlationId = this.generateCorrelationId();\r\n\r\n    logger.info('Executing validation rule', {\r\n      ruleId,\r\n      ruleName: rule.name,\r\n      type: rule.type,\r\n      severity: rule.severity\r\n    });\r\n\r\n    try {\r\n      // CRITICAL: Execute validation with timeout\r\n      const result = await this.executeValidationWithTimeout(rule, correlationId);\r\n      \r\n      // CRITICAL: Store result\r\n      this.validationHistory.push(result);\r\n\r\n      // CRITICAL: Log validation execution\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId: 'system',\r\n        actorId: 'validation-system',\r\n        action: 'VALIDATION_EXECUTED',\r\n        resourceType: 'VALIDATION_RULE',\r\n        resourceId: ruleId,\r\n        outcome: result.status === 'PASS' ? 'SUCCESS' : 'FAILURE',\r\n        correlationId,\r\n        severity: this.mapSeverityToAuditLevel(result.severity),\r\n        metadata: {\r\n          ruleName: rule.name,\r\n          type: rule.type,\r\n          duration: result.duration,\r\n          violations: result.violations.length,\r\n          actions: result.actions.length\r\n        }\r\n      });\r\n\r\n      logger.info('Validation rule executed', {\r\n        ruleId,\r\n        status: result.status,\r\n        duration: result.duration,\r\n        violations: result.violations.length\r\n      });\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const duration = Date.now() - startTime;\r\n      \r\n      // CRITICAL: Create failure result\r\n      const failureResult: ValidationResult = {\r\n        ruleId,\r\n        ruleName: rule.name,\r\n        type: rule.type,\r\n        status: 'FAIL',\r\n        severity: 'CRITICAL',\r\n        executedAt: new Date(),\r\n        duration,\r\n        message: `Validation execution failed: ${(error as Error).message}`,\r\n        details: { error: (error as Error).message },\r\n        metrics: {},\r\n        violations: [],\r\n        actions: []\r\n      };\r\n\r\n      // CRITICAL: Store failure result\r\n      this.validationHistory.push(failureResult);\r\n\r\n      // CRITICAL: Log validation failure\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId: 'system',\r\n        actorId: 'validation-system',\r\n        action: 'VALIDATION_FAILED',\r\n        resourceType: 'VALIDATION_RULE',\r\n        resourceId: ruleId,\r\n        outcome: 'FAILURE',\r\n        correlationId,\r\n        severity: 'CRITICAL',\r\n        metadata: {\r\n          ruleName: rule.name,\r\n          type: rule.type,\r\n          error: (error as Error).message,\r\n          duration\r\n        }\r\n      });\r\n\r\n      logger.error('Validation rule execution failed', error as Error, {\r\n        ruleId,\r\n        ruleName: rule.name,\r\n        duration\r\n      });\r\n\r\n      return failureResult;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute all validation rules\r\n   */\r\n  async executeAllValidations(): Promise<ValidationReport> {\r\n    const reportId = this.generateReportId();\r\n    const correlationId = this.generateCorrelationId();\r\n    const startTime = Date.now();\r\n\r\n    logger.info('Executing all validation rules', {\r\n      reportId,\r\n      totalRules: this.validationRules.size\r\n    });\r\n\r\n    const results: ValidationResult[] = [];\r\n    const summary = {\r\n      availability: { pass: 0, fail: 0, warning: 0 },\r\n      performance: { pass: 0, fail: 0, warning: 0 },\r\n      security: { pass: 0, fail: 0, warning: 0 },\r\n      compliance: { pass: 0, fail: 0, warning: 0 },\r\n      recovery: { pass: 0, fail: 0, warning: 0 },\r\n      resilience: { pass: 0, fail: 0, warning: 0 }\r\n    };\r\n\r\n    // CRITICAL: Execute all enabled rules\r\n    for (const [ruleId, rule] of this.validationRules.entries()) {\r\n      if (!rule.enabled) {\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        const result = await this.executeValidation(ruleId);\r\n        results.push(result);\r\n\r\n        // CRITICAL: Update summary\r\n        if (result.status === 'PASS') {\r\n          summary[rule.type.toLowerCase() as keyof typeof summary].pass++;\r\n        } else if (result.status === 'FAIL') {\r\n          summary[rule.type.toLowerCase() as keyof typeof summary].fail++;\r\n        } else if (result.status === 'WARNING') {\r\n          summary[rule.type.toLowerCase() as keyof typeof summary].warning++;\r\n        }\r\n\r\n      } catch (error) {\r\n        logger.error('Failed to execute validation rule', error as Error, {\r\n          ruleId,\r\n          ruleName: rule.name\r\n        });\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Calculate overall status\r\n    const totalPassed = Object.values(summary).reduce((sum, cat) => sum + cat.pass, 0);\r\n    const totalFailed = Object.values(summary).reduce((sum, cat) => sum + cat.fail, 0);\r\n    const totalWarning = Object.values(summary).reduce((sum, cat) => sum + cat.warning, 0);\r\n\r\n    let overallStatus: ValidationStatus = 'PASS';\r\n    if (totalFailed > 0) {\r\n      overallStatus = 'FAIL';\r\n    } else if (totalWarning > 0) {\r\n      overallStatus = 'WARNING';\r\n    }\r\n\r\n    // CRITICAL: Generate recommendations\r\n    const recommendations = this.generateRecommendations(results);\r\n\r\n    // CRITICAL: Create report\r\n    const report: ValidationReport = {\r\n      id: reportId,\r\n      timestamp: new Date(),\r\n      totalRules: this.validationRules.size,\r\n      executedRules: results.length,\r\n      passedRules: totalPassed,\r\n      failedRules: totalFailed,\r\n      warningRules: totalWarning,\r\n      skippedRules: this.validationRules.size - results.length,\r\n      overallStatus,\r\n      results,\r\n      summary,\r\n      recommendations,\r\n      correlationId\r\n    };\r\n\r\n    // CRITICAL: Log validation report\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_REPORT_GENERATED',\r\n      resourceType: 'VALIDATION_REPORT',\r\n      resourceId: reportId,\r\n      outcome: overallStatus === 'PASS' ? 'SUCCESS' : 'FAILURE',\r\n      correlationId,\r\n      severity: overallStatus === 'FAIL' ? 'HIGH' : overallStatus === 'WARNING' ? 'MEDIUM' : 'LOW',\r\n      metadata: {\r\n        totalRules: report.totalRules,\r\n        executedRules: report.executedRules,\r\n        passedRules: report.passedRules,\r\n        failedRules: report.failedRules,\r\n        warningRules: report.warningRules,\r\n        overallStatus,\r\n        recommendations: recommendations.length\r\n      }\r\n    });\r\n\r\n    logger.info('Validation report generated', {\r\n      reportId,\r\n      overallStatus,\r\n      totalRules: report.totalRules,\r\n      executedRules: report.executedRules,\r\n      passedRules: report.passedRules,\r\n      failedRules: report.failedRules,\r\n      warningRules: report.warningRules\r\n    });\r\n\r\n    return report;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get validation history\r\n   */\r\n  getValidationHistory(\r\n    type?: ValidationType,\r\n    status?: ValidationStatus,\r\n    limit?: number\r\n  ): ValidationResult[] {\r\n    let history = this.validationHistory;\r\n\r\n    // CRITICAL: Filter by type\r\n    if (type) {\r\n      history = history.filter(result => result.type === type);\r\n    }\r\n\r\n    // CRITICAL: Filter by status\r\n    if (status) {\r\n      history = history.filter(result => result.status === status);\r\n    }\r\n\r\n    // CRITICAL: Sort by execution time (newest first)\r\n    history = history.sort((a, b) => b.executedAt.getTime() - a.executedAt.getTime());\r\n\r\n    // CRITICAL: Apply limit\r\n    if (limit) {\r\n      history = history.slice(0, limit);\r\n    }\r\n\r\n    return history;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get validation rules\r\n   */\r\n  getValidationRules(type?: ValidationType, enabled?: boolean): ValidationRule[] {\r\n    const rules = Array.from(this.validationRules.values());\r\n\r\n    let filtered = rules;\r\n\r\n    // CRITICAL: Filter by type\r\n    if (type) {\r\n      filtered = filtered.filter(rule => rule.type === type);\r\n    }\r\n\r\n    // CRITICAL: Filter by enabled status\r\n    if (enabled !== undefined) {\r\n      filtered = filtered.filter(rule => rule.enabled === enabled);\r\n    }\r\n\r\n    return filtered;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Add validation rule\r\n   */\r\n  addValidationRule(rule: ValidationRule): void {\r\n    this.validationRules.set(rule.id, rule);\r\n\r\n    // CRITICAL: Log rule addition\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_RULE_ADDED',\r\n      resourceType: 'VALIDATION_RULE',\r\n      resourceId: rule.id,\r\n      outcome: 'SUCCESS',\r\n      correlationId: this.generateCorrelationId(),\r\n      severity: 'LOW',\r\n      metadata: {\r\n        ruleName: rule.name,\r\n        type: rule.type,\r\n        severity: rule.severity,\r\n        enabled: rule.enabled,\r\n        conditions: rule.conditions.length\r\n      }\r\n    });\r\n\r\n    logger.info('Validation rule added', {\r\n      ruleId: rule.id,\r\n      ruleName: rule.name,\r\n      type: rule.type,\r\n      severity: rule.severity\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update validation rule\r\n   */\r\n  updateValidationRule(ruleId: string, updates: Partial<ValidationRule>): void {\r\n    const existingRule = this.validationRules.get(ruleId);\r\n    if (!existingRule) {\r\n      throw new Error(`Validation rule ${ruleId} not found`);\r\n    }\r\n\r\n    const updatedRule = { ...existingRule, ...updates };\r\n    this.validationRules.set(ruleId, updatedRule);\r\n\r\n    // CRITICAL: Log rule update\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_RULE_UPDATED',\r\n      resourceType: 'VALIDATION_RULE',\r\n      resourceId: ruleId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: this.generateCorrelationId(),\r\n      severity: 'LOW',\r\n      metadata: {\r\n        ruleName: updatedRule.name,\r\n        type: updatedRule.type,\r\n        severity: updatedRule.severity,\r\n        enabled: updatedRule.enabled,\r\n        updatedFields: Object.keys(updates)\r\n      }\r\n    });\r\n\r\n    logger.info('Validation rule updated', {\r\n      ruleId,\r\n      ruleName: updatedRule.name,\r\n      updatedFields: Object.keys(updates)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Delete validation rule\r\n   */\r\n  deleteValidationRule(ruleId: string): void {\r\n    const rule = this.validationRules.get(ruleId);\r\n    if (!rule) {\r\n      throw new Error(`Validation rule ${ruleId} not found`);\r\n    }\r\n\r\n    this.validationRules.delete(ruleId);\r\n\r\n    // CRITICAL: Log rule deletion\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_RULE_DELETED',\r\n      resourceType: 'VALIDATION_RULE',\r\n      resourceId: ruleId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: this.generateCorrelationId(),\r\n      severity: 'LOW',\r\n      metadata: {\r\n        ruleName: rule.name,\r\n        type: rule.type,\r\n        severity: rule.severity\r\n      }\r\n    });\r\n\r\n    logger.info('Validation rule deleted', {\r\n      ruleId,\r\n      ruleName: rule.name\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute validation with timeout\r\n   */\r\n  private async executeValidationWithTimeout(\r\n    rule: ValidationRule,\r\n    correlationId: string\r\n  ): Promise<ValidationResult> {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => {\r\n        reject(new Error(`Validation timeout after ${rule.timeout} seconds`));\r\n      }, rule.timeout * 1000);\r\n\r\n      this.executeValidationInternal(rule, correlationId)\r\n        .then(result => {\r\n          clearTimeout(timeout);\r\n          resolve(result);\r\n        })\r\n        .catch(error => {\r\n          clearTimeout(timeout);\r\n          reject(error);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute validation internal\r\n   */\r\n  private async executeValidationInternal(\r\n    rule: ValidationRule,\r\n    correlationId: string\r\n  ): Promise<ValidationResult> {\r\n    const startTime = Date.now();\r\n    const metrics: Record<string, number> = {};\r\n    const violations: any[] = [];\r\n    const actions: any[] = [];\r\n\r\n    // CRITICAL: Evaluate all conditions\r\n    for (const condition of rule.conditions) {\r\n      try {\r\n        // CRITICAL: Get metric value\r\n        const metricValue = resilienceMetricsManager.getMetric(\r\n          condition.metric,\r\n          condition.aggregation\r\n        );\r\n\r\n        if (metricValue === null) {\r\n          violations.push({\r\n            condition: `${condition.metric} ${condition.operator} ${condition.threshold}`,\r\n            actual: 'N/A',\r\n            expected: condition.threshold,\r\n            severity: 'MEDIUM'\r\n          });\r\n          continue;\r\n        }\r\n\r\n        metrics[condition.metric] = metricValue;\r\n\r\n        // CRITICAL: Evaluate condition\r\n        const conditionMet = this.evaluateCondition(metricValue, condition.operator, condition.threshold);\r\n\r\n        if (!conditionMet) {\r\n          violations.push({\r\n            condition: `${condition.metric} ${condition.operator} ${condition.threshold}`,\r\n            actual: metricValue,\r\n            expected: condition.threshold,\r\n            severity: rule.severity\r\n          });\r\n        }\r\n\r\n      } catch (error) {\r\n        violations.push({\r\n          condition: `${condition.metric} ${condition.operator} ${condition.threshold}`,\r\n          actual: 'ERROR',\r\n          expected: condition.threshold,\r\n          severity: 'HIGH'\r\n        });\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Determine status\r\n    let status: ValidationStatus = 'PASS';\r\n    if (violations.some(v => v.severity === 'CRITICAL')) {\r\n      status = 'FAIL';\r\n    } else if (violations.some(v => v.severity === 'HIGH')) {\r\n      status = 'FAIL';\r\n    } else if (violations.length > 0) {\r\n      status = 'WARNING';\r\n    }\r\n\r\n    // CRITICAL: Execute actions\r\n    for (const action of rule.actions) {\r\n      try {\r\n        const actionResult = await this.executeAction(action, violations, correlationId);\r\n        actions.push({\r\n          type: action.type,\r\n          executed: true,\r\n          result: actionResult\r\n        });\r\n      } catch (error) {\r\n        actions.push({\r\n          type: action.type,\r\n          executed: false,\r\n          result: 'FAILED',\r\n          error: (error as Error).message\r\n        });\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Create result\r\n    const result: ValidationResult = {\r\n      ruleId: rule.id,\r\n      ruleName: rule.name,\r\n      type: rule.type,\r\n      status,\r\n      severity: violations.length > 0 ? Math.max(...violations.map(v => this.getSeverityLevel(v.severity))) : rule.severity,\r\n      executedAt: new Date(),\r\n      duration: Date.now() - startTime,\r\n      message: this.generateValidationMessage(status, violations),\r\n      details: {\r\n        ruleDescription: rule.description,\r\n        conditionsEvaluated: rule.conditions.length,\r\n        actionsExecuted: actions.length\r\n      },\r\n      metrics,\r\n      violations,\r\n      actions\r\n    };\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Evaluate condition\r\n   */\r\n  private evaluateCondition(actual: number, operator: string, expected: number): boolean {\r\n    switch (operator) {\r\n      case 'GT': return actual > expected;\r\n      case 'LT': return actual < expected;\r\n      case 'EQ': return actual === expected;\r\n      case 'NE': return actual !== expected;\r\n      case 'GTE': return actual >= expected;\r\n      case 'LTE': return actual <= expected;\r\n      default: return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute action\r\n   */\r\n  private async executeAction(\r\n    action: any,\r\n    violations: any[],\r\n    correlationId: string\r\n  ): Promise<string> {\r\n    switch (action.type) {\r\n      case 'ALERT':\r\n        return await this.executeAlertAction(action, violations, correlationId);\r\n      case 'ESCALATE':\r\n        return await this.executeEscalateAction(action, violations, correlationId);\r\n      case 'REMEDIATE':\r\n        return await this.executeRemediateAction(action, violations, correlationId);\r\n      case 'REPORT':\r\n        return await this.executeReportAction(action, violations, correlationId);\r\n      default:\r\n        throw new Error(`Unknown action type: ${action.type}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute alert action\r\n   */\r\n  private async executeAlertAction(\r\n    action: any,\r\n    violations: any[],\r\n    correlationId: string\r\n  ): Promise<string> {\r\n    // CRITICAL: Send alert\r\n    logger.warn('Validation alert triggered', {\r\n      action,\r\n      violations: violations.length,\r\n      correlationId\r\n    });\r\n\r\n    // CRITICAL: Log alert\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_ALERT',\r\n      resourceType: 'VALIDATION_ALERT',\r\n      resourceId: correlationId,\r\n      outcome: 'SUCCESS',\r\n      correlationId,\r\n      severity: 'HIGH',\r\n      metadata: {\r\n        violations: violations.length,\r\n        actionParameters: action.parameters\r\n      }\r\n    });\r\n\r\n    return 'ALERT_SENT';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute escalate action\r\n   */\r\n  private async executeEscalateAction(\r\n    action: any,\r\n    violations: any[],\r\n    correlationId: string\r\n  ): Promise<string> {\r\n    // CRITICAL: Escalate to management\r\n    logger.error('Validation escalation triggered', {\r\n      action,\r\n      violations: violations.length,\r\n      correlationId\r\n    });\r\n\r\n    // CRITICAL: Log escalation\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_ESCALATION',\r\n      resourceType: 'VALIDATION_ESCALATION',\r\n      resourceId: correlationId,\r\n      outcome: 'SUCCESS',\r\n      correlationId,\r\n      severity: 'CRITICAL',\r\n      metadata: {\r\n        violations: violations.length,\r\n        actionParameters: action.parameters\r\n      }\r\n    });\r\n\r\n    return 'ESCALATED';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute remediate action\r\n   */\r\n  private async executeRemediateAction(\r\n    action: any,\r\n    violations: any[],\r\n    correlationId: string\r\n  ): Promise<string> {\r\n    // CRITICAL: Execute remediation\r\n    logger.info('Validation remediation triggered', {\r\n      action,\r\n      violations: violations.length,\r\n      correlationId\r\n    });\r\n\r\n    // CRITICAL: Log remediation\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_REMEDIATION',\r\n      resourceType: 'VALIDATION_REMEDIATION',\r\n      resourceId: correlationId,\r\n      outcome: 'SUCCESS',\r\n      correlationId,\r\n      severity: 'MEDIUM',\r\n      metadata: {\r\n        violations: violations.length,\r\n        actionParameters: action.parameters\r\n      }\r\n    });\r\n\r\n    return 'REMEDIATED';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute report action\r\n   */\r\n  private async executeReportAction(\r\n    action: any,\r\n    violations: any[],\r\n    correlationId: string\r\n  ): Promise<string> {\r\n    // CRITICAL: Generate report\r\n    logger.info('Validation report generated', {\r\n      action,\r\n      violations: violations.length,\r\n      correlationId\r\n    });\r\n\r\n    // CRITICAL: Log report\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'validation-system',\r\n      action: 'VALIDATION_REPORT',\r\n      resourceType: 'VALIDATION_REPORT',\r\n      resourceId: correlationId,\r\n      outcome: 'SUCCESS',\r\n      correlationId,\r\n      severity: 'LOW',\r\n      metadata: {\r\n        violations: violations.length,\r\n        actionParameters: action.parameters\r\n      }\r\n    });\r\n\r\n    return 'REPORT_GENERATED';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate validation message\r\n   */\r\n  private generateValidationMessage(status: ValidationStatus, violations: any[]): string {\r\n    switch (status) {\r\n      case 'PASS':\r\n        return 'All validation conditions passed';\r\n      case 'WARNING':\r\n        return `${violations.length} validation condition(s) triggered warnings`;\r\n      case 'FAIL':\r\n        return `${violations.length} validation condition(s) failed`;\r\n      case 'SKIP':\r\n        return 'Validation skipped';\r\n      default:\r\n        return 'Validation completed';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate recommendations\r\n   */\r\n  private generateRecommendations(results: ValidationResult[]): string[] {\r\n    const recommendations: string[] = [];\r\n    const failureTypes = new Set<string>();\r\n\r\n    // CRITICAL: Analyze failures\r\n    for (const result of results) {\r\n      if (result.status === 'FAIL') {\r\n        failureTypes.add(result.type);\r\n        \r\n        for (const violation of result.violations) {\r\n          if (violation.severity === 'CRITICAL') {\r\n            recommendations.push(`Critical issue detected in ${result.type}: ${violation.condition}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Add general recommendations\r\n    if (failureTypes.has('AVAILABILITY')) {\r\n      recommendations.push('Review service availability and implement additional redundancy');\r\n    }\r\n\r\n    if (failureTypes.has('PERFORMANCE')) {\r\n      recommendations.push('Optimize system performance and consider scaling resources');\r\n    }\r\n\r\n    if (failureTypes.has('SECURITY')) {\r\n      recommendations.push('Strengthen security controls and review access policies');\r\n    }\r\n\r\n    if (failureTypes.has('COMPLIANCE')) {\r\n      recommendations.push('Address compliance gaps and update documentation');\r\n    }\r\n\r\n    if (failureTypes.has('RECOVERY')) {\r\n      recommendations.push('Improve recovery procedures and test backup systems');\r\n    }\r\n\r\n    if (failureTypes.has('RESILIENCE')) {\r\n      recommendations.push('Enhance resilience mechanisms and conduct chaos testing');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get severity level\r\n   */\r\n  private getSeverityLevel(severity: string): number {\r\n    switch (severity) {\r\n      case 'LOW': return 1;\r\n      case 'MEDIUM': return 2;\r\n      case 'HIGH': return 3;\r\n      case 'CRITICAL': return 4;\r\n      default: return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Map severity to audit level\r\n   */\r\n  private mapSeverityToAuditLevel(severity: ValidationSeverity): string {\r\n    switch (severity) {\r\n      case 'LOW': return 'LOW';\r\n      case 'MEDIUM': return 'MEDIUM';\r\n      case 'HIGH': return 'HIGH';\r\n      case 'CRITICAL': return 'CRITICAL';\r\n      default: return 'MEDIUM';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize validation rules\r\n   */\r\n  private initializeValidationRules(): void {\r\n    // Availability validation rules\r\n    this.addValidationRule({\r\n      id: 'availability_uptime',\r\n      name: 'System Uptime Check',\r\n      description: 'Validate system uptime is above 99%',\r\n      type: 'AVAILABILITY',\r\n      severity: 'HIGH',\r\n      enabled: true,\r\n      schedule: '*/5 * * * *', // Every 5 minutes\r\n      timeout: 60,\r\n      retryCount: 3,\r\n      retryDelay: 10,\r\n      conditions: [\r\n        {\r\n          metric: 'system_uptime',\r\n          operator: 'GTE',\r\n          threshold: 99,\r\n          aggregation: 'AVG'\r\n        }\r\n      ],\r\n      actions: [\r\n        {\r\n          type: 'ALERT',\r\n          parameters: { channel: 'slack', severity: 'HIGH' }\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Performance validation rules\r\n    this.addValidationRule({\r\n      id: 'performance_response_time',\r\n      name: 'Response Time Check',\r\n      description: 'Validate P95 response time is below 2 seconds',\r\n      type: 'PERFORMANCE',\r\n      severity: 'MEDIUM',\r\n      enabled: true,\r\n      schedule: '*/2 * * * *', // Every 2 minutes\r\n      timeout: 30,\r\n      retryCount: 2,\r\n      retryDelay: 5,\r\n      conditions: [\r\n        {\r\n          metric: 'response_time_p95',\r\n          operator: 'LTE',\r\n          threshold: 2000,\r\n          aggregation: 'P95'\r\n        }\r\n      ],\r\n      actions: [\r\n        {\r\n          type: 'ALERT',\r\n          parameters: { channel: 'email', severity: 'MEDIUM' }\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Security validation rules\r\n    this.addValidationRule({\r\n      id: 'security_audit_integrity',\r\n      name: 'Audit Integrity Check',\r\n      description: 'Validate audit log integrity is maintained',\r\n      type: 'SECURITY',\r\n      severity: 'CRITICAL',\r\n      enabled: true,\r\n      schedule: '*/10 * * * *', // Every 10 minutes\r\n      timeout: 120,\r\n      retryCount: 3,\r\n      retryDelay: 15,\r\n      conditions: [\r\n        {\r\n          metric: 'audit_integrity_valid',\r\n          operator: 'EQ',\r\n          threshold: 1,\r\n          aggregation: 'AVG'\r\n        }\r\n      ],\r\n      actions: [\r\n        {\r\n          type: 'ESCALATE',\r\n          parameters: { level: 'management', urgency: 'HIGH' }\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Compliance validation rules\r\n    this.addValidationRule({\r\n      id: 'compliance_soc2',\r\n      name: 'SOC 2 Compliance Check',\r\n      description: 'Validate SOC 2 compliance status',\r\n      type: 'COMPLIANCE',\r\n      severity: 'HIGH',\r\n      enabled: true,\r\n      schedule: '0 */6 * * *', // Every 6 hours\r\n      timeout: 300,\r\n      retryCount: 2,\r\n      retryDelay: 30,\r\n      conditions: [\r\n        {\r\n          metric: 'soc2_compliance',\r\n          operator: 'EQ',\r\n          threshold: 1,\r\n          aggregation: 'AVG'\r\n        }\r\n      ],\r\n      actions: [\r\n        {\r\n          type: 'REPORT',\r\n          parameters: { format: 'pdf', recipients: ['compliance@accubooks.com'] }\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Recovery validation rules\r\n    this.addValidationRule({\r\n      id: 'recovery_rpo_rto',\r\n      name: 'RPO/RTO Compliance Check',\r\n      description: 'Validate RPO/RTO compliance',\r\n      type: 'RECOVERY',\r\n      severity: 'HIGH',\r\n      enabled: true,\r\n      schedule: '0 */4 * * *', // Every 4 hours\r\n      timeout: 180,\r\n      retryCount: 2,\r\n      retryDelay: 20,\r\n      conditions: [\r\n        {\r\n          metric: 'rpo_rto_compliance',\r\n          operator: 'EQ',\r\n          threshold: 1,\r\n          aggregation: 'AVG'\r\n        }\r\n      ],\r\n      actions: [\r\n        {\r\n          type: 'REMEDIATE',\r\n          parameters: { action: 'create_recovery_point', priority: 'HIGH' }\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Resilience validation rules\r\n    this.addValidationRule({\r\n      id: 'resilience_circuit_breaker',\r\n      name: 'Circuit Breaker Health Check',\r\n      description: 'Validate circuit breakers are not open',\r\n      type: 'RESILIENCE',\r\n      severity: 'MEDIUM',\r\n      enabled: true,\r\n      schedule: '*/3 * * * *', // Every 3 minutes\r\n      timeout: 60,\r\n      retryCount: 2,\r\n      retryDelay: 10,\r\n      conditions: [\r\n        {\r\n          metric: 'circuit_breaker_state',\r\n          operator: 'LTE',\r\n          threshold: 1,\r\n          aggregation: 'AVG'\r\n        }\r\n      ],\r\n      actions: [\r\n        {\r\n          type: 'ALERT',\r\n          parameters: { channel: 'slack', severity: 'MEDIUM' }\r\n        }\r\n      ]\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start automated validation\r\n   */\r\n  private startAutomatedValidation(): void {\r\n    // CRITICAL: Execute validation rules based on schedule\r\n    this.validationTimer = setInterval(async () => {\r\n      const now = new Date();\r\n      const minute = now.getMinutes();\r\n      const hour = now.getHours();\r\n\r\n      // CRITICAL: Check which rules should run now\r\n      for (const [ruleId, rule] of this.validationRules.entries()) {\r\n        if (!rule.enabled) {\r\n          continue;\r\n        }\r\n\r\n        // CRITICAL: Simple schedule check (in production, use a proper cron parser)\r\n        if (this.shouldRunRule(rule, minute, hour)) {\r\n          try {\r\n            await this.executeValidation(ruleId);\r\n          } catch (error) {\r\n            logger.error('Failed to execute scheduled validation', error as Error, {\r\n              ruleId,\r\n              ruleName: rule.name\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }, 60000); // Check every minute\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if rule should run\r\n   */\r\n  private shouldRunRule(rule: ValidationRule, minute: number, hour: number): boolean {\r\n    // CRITICAL: Simple schedule implementation\r\n    // In production, use a proper cron parser library\r\n    const schedule = rule.schedule;\r\n    \r\n    if (schedule === '*/5 * * * *') {\r\n      return minute % 5 === 0;\r\n    } else if (schedule === '*/2 * * * *') {\r\n      return minute % 2 === 0;\r\n    } else if (schedule === '*/10 * * * *') {\r\n      return minute % 10 === 0;\r\n    } else if (schedule === '*/3 * * * *') {\r\n      return minute % 3 === 0;\r\n    } else if (schedule === '0 */6 * * *') {\r\n      return minute === 0 && hour % 6 === 0;\r\n    } else if (schedule === '0 */4 * * *') {\r\n      return minute === 0 && hour % 4 === 0;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start history cleanup\r\n   */\r\n  private startHistoryCleanup(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanupHistory();\r\n    }, 3600000); // Every hour\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup history\r\n   */\r\n  private cleanupHistory(): void {\r\n    const cutoffTime = new Date();\r\n    cutoffTime.setDate(cutoffTime.getDate() - 7); // Keep 7 days\r\n\r\n    const originalCount = this.validationHistory.length;\r\n    this.validationHistory = this.validationHistory.filter(\r\n      result => result.executedAt > cutoffTime\r\n    );\r\n    const cleanedCount = originalCount - this.validationHistory.length;\r\n\r\n    if (cleanedCount > 0) {\r\n      logger.info('Cleaned up validation history', { cleanedCount });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate report ID\r\n   */\r\n  private generateReportId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `report_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Stop automated validation\r\n   */\r\n  stopAutomatedValidation(): void {\r\n    if (this.validationTimer) {\r\n      clearInterval(this.validationTimer);\r\n      this.validationTimer = null;\r\n    }\r\n\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n\r\n    logger.info('Automated validation stopped');\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global automated resilience validator instance\r\n */\r\nexport const automatedResilienceValidator = AutomatedResilienceValidator.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const executeValidation = async (ruleId: string): Promise<ValidationResult> => {\r\n  return await automatedResilienceValidator.executeValidation(ruleId);\r\n};\r\n\r\nexport const executeAllValidations = async (): Promise<ValidationReport> => {\r\n  return await automatedResilienceValidator.executeAllValidations();\r\n};\r\n\r\nexport const getValidationHistory = (\r\n  type?: ValidationType,\r\n  status?: ValidationStatus,\r\n  limit?: number\r\n): ValidationResult[] => {\r\n  return automatedResilienceValidator.getValidationHistory(type, status, limit);\r\n};\r\n\r\nexport const getValidationRules = (\r\n  type?: ValidationType,\r\n  enabled?: boolean\r\n): ValidationRule[] => {\r\n  return automatedResilienceValidator.getValidationRules(type, enabled);\r\n};\r\n\r\nexport const addValidationRule = (rule: ValidationRule): void => {\r\n  automatedResilienceValidator.addValidationRule(rule);\r\n};\r\n\r\nexport const updateValidationRule = (ruleId: string, updates: Partial<ValidationRule>): void => {\r\n  automatedResilienceValidator.updateValidationRule(ruleId, updates);\r\n};\r\n\r\nexport const deleteValidationRule = (ruleId: string): void => {\r\n  automatedResilienceValidator.deleteValidationRule(ruleId);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\bulkhead.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\chaos-hooks.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":724,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":724,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":733,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":733,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":743,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":743,"endColumn":37}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Chaos Engineering & Resilience Testing\r\n// MANDATORY: Fault injection and resilience validation with comprehensive testing\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport type FaultType = 'DATABASE_DOWN' | 'QUEUE_LAG' | 'CACHE_LOSS' | 'NETWORK_FAILURE' | 'SERVICE_CRASH' | 'RESOURCE_EXHAUSTION' | 'MEMORY_EXHAUSTION';\r\nexport type FaultSeverity = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n\r\nexport interface FaultInjection {\r\n  id: string;\r\n  type: FaultType;\r\n  severity: FaultSeverity;\r\n  description: string;\r\n  component: string;\r\n  parameters: Record<string, any>;\r\n  duration: number;\r\n  impact: string;\r\n  correlationId: string;\r\n  timestamp: Date;\r\n  active: boolean;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface ResilienceTest {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  scenario: string;\r\n  type: 'FAULT_INJECTION' | 'LOAD_TEST' | 'RECOVERY_TEST' | 'RESILIENCE_VALIDATION';\r\n  preconditions: string[];\r\n  steps: Array<{\r\n    step: number;\r\n    description: string;\r\n    action: string;\r\n    expectedOutcome: string;\r\n    timeout: number;\r\n  }>;\r\n  validation: Array<{\r\n    step: number;\r\n    description: string;\r\n    action: string;\r\n    expectedOutcome: string;\r\n    timeout: number;\r\n  }>;\r\n  metrics: {\r\n    success: boolean;\r\n    duration: number;\r\n    errors: string[];\r\n    warnings: string[];\r\n    performance_metrics: Record<string, number>;\r\n  };\r\n  correlationId: string;\r\n  createdAt: Date;\r\n  completedAt?: Date;\r\n}\r\n\r\nexport interface ChaosTestResult {\r\n  testId: string;\r\n  testName: string;\r\n  scenario: string;\r\n  success: boolean;\r\n  duration: number;\r\n  errors: string[];\r\n  warnings: string[];\r\n  metrics: Record<string, any>;\r\n  correlationId: string;\r\n  timestamp: Date;\r\n}\r\n\r\n/**\r\n * CRITICAL: Chaos Engineering Manager\r\n * \r\n * This class implements fault injection and resilience testing with comprehensive\r\n * validation of system resilience under various failure scenarios.\r\n */\r\nexport class ChaosEngineeringManager {\r\n  private static instance: ChaosEngineeringManager;\r\n  private auditLogger: any;\r\n  private activeFaults: Map<string, FaultInjection> = new Map();\r\n  private resilienceTests: Map<string, ResilienceTest> = new Map();\r\n  private chaosTestResults: ChaosTestResult[] = [];\r\n  private chaosTestTimer: NodeJS.Timeout | null = null;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.startChaosTesting();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): ChaosEngineeringManager {\r\n    if (!ChaosEngineeringManager.instance) {\r\n      ChaosEngineeringManager.instance = new ChaosEngineeringManager();\r\n    }\r\n    return ChaosEngineeringManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Inject fault into system\r\n   */\r\n  async injectFault(\r\n    type: FaultType,\r\n    component: string,\r\n    severity: FaultSeverity,\r\n    description: string,\r\n    parameters: Record<string, any> = {},\r\n    duration: number = 30000 // 30 seconds default\r\n  ): Promise<string> {\r\n    const faultId = this.generateFaultId();\r\n    const correlationId = this.generateCorrelationId();\r\n\r\n    const fault: FaultInjection = {\r\n      id: faultId,\r\n      type,\r\n      severity,\r\n      description,\r\n      component,\r\n      parameters,\r\n      duration,\r\n      impact: `Injected ${type} fault into ${component}`,\r\n      correlationId,\r\n      timestamp: new Date(),\r\n      active: true,\r\n      metadata: {\r\n        systemLoad: await this.getSystemLoad(),\r\n        componentState: await this.getComponentState(component),\r\n        activeFaults: this.getActiveFaults().length\r\n      }\r\n    };\r\n\r\n    // CRITICAL: Validate fault injection preconditions\r\n    await this.validateFaultInjectionPreconditions(fault);\r\n\r\n    // CRITICAL: Store active fault\r\n    this.activeFaults.set(faultId, fault);\r\n\r\n    // CRITICAL: Inject fault (background)\r\n    this.executeFaultInjection(fault).catch((error) => {\r\n      logger.error('Fault injection simulation failed', error as Error, {\r\n        faultId: fault.id,\r\n        type: fault.type,\r\n        component: fault.component\r\n      });\r\n    });\r\n\r\n    // CRITICAL: Log fault injection\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'chaos-engineering',\r\n      action: 'FAULT_INJECTED',\r\n      resourceType: 'CHAOS_TEST',\r\n      resourceId: faultId,\r\n      outcome: 'SUCCESS',\r\n      correlationId,\r\n      severity: this.mapSeverityToAuditLevel(severity),\r\n      metadata: {\r\n        type,\r\n        component,\r\n        severity,\r\n        description,\r\n        parameters,\r\n        duration,\r\n        impact: fault.impact\r\n      }\r\n    });\r\n\r\n    logger.warn('Fault injected', {\r\n      faultId,\r\n      type,\r\n      component,\r\n      severity,\r\n      description,\r\n      duration\r\n    });\r\n\r\n    return faultId;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Stop fault injection\r\n   */\r\n  stopFault(faultId: string): void {\r\n    const fault = this.activeFaults.get(faultId);\r\n    if (fault) {\r\n      fault.active = false;\r\n      this.activeFaults.delete(faultId);\r\n\r\n      // CRITICAL: Log fault stop\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId: 'system',\r\n        actorId: 'chaos-engineering',\r\n        action: 'FAULT_STOPPED',\r\n        resourceType: 'CHAOS_TEST',\r\n        resourceId: faultId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: fault.correlationId,\r\n        severity: 'LOW',\r\n        metadata: {\r\n          type: fault.type,\r\n          component: fault.component,\r\n          severity: fault.severity,\r\n          duration: Date.now() - fault.timestamp.getTime()\r\n        }\r\n      });\r\n\r\n      logger.info('Fault stopped', {\r\n        faultId,\r\n        type: fault.type,\r\n        component: fault.component,\r\n        duration: Date.now() - fault.timestamp.getTime()\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create resilience test\r\n   */\r\n  createResilienceTest(\r\n    name: string,\r\n    description: string,\r\n    scenario: string,\r\n    preconditions: string[],\r\n    steps: Array<{\r\n      step: number;\r\n      description: string;\r\n      action: string;\r\n      expectedOutcome: string;\r\n      timeout: number;\r\n    }>,\r\n    validation: Array<{\r\n      step: number;\r\n      description: string;\r\n      action: string;\r\n      expectedOutcome: string;\r\n      timeout: number;\r\n    }>,\r\n    correlationId?: string\r\n  ): string {\r\n    const testId = this.generateTestId();\r\n    const corrId = correlationId || this.generateCorrelationId();\r\n\r\n    const test: ResilienceTest = {\r\n      id: testId,\r\n      name,\r\n      description,\r\n      scenario,\r\n      type: 'RESILIENCE_VALIDATION',\r\n      preconditions,\r\n      steps,\r\n      validation,\r\n      metrics: {\r\n        success: false,\r\n        duration: 0,\r\n        errors: [],\r\n        warnings: [],\r\n        performance_metrics: {}\r\n      },\r\n      correlationId: corrId,\r\n      createdAt: new Date()\r\n    };\r\n\r\n    this.resilienceTests.set(testId, test);\r\n\r\n    logger.info('Resilience test created', {\r\n      testId,\r\n      name,\r\n      description,\r\n      scenario\r\n    });\r\n\r\n    return testId;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute resilience test\r\n   */\r\n  async executeResilienceTest(testId: string): Promise<ChaosTestResult> {\r\n    const test = this.resilienceTests.get(testId);\r\n    if (!test) {\r\n      throw new Error(`Resilience test ${testId} not found`);\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n    const performance_metrics: Record<string, number> = {};\r\n\r\n    try {\r\n      // CRITICAL: Execute test steps\r\n      for (const step of test.steps) {\r\n        const stepStartTime = Date.now();\r\n        \r\n        logger.info(`Executing test step ${step.step}: ${step.description}`, {\r\n          testId,\r\n          step: step.step,\r\n          description: step.description\r\n        });\r\n\r\n        // CRITICAL: Execute step action\r\n        const result = await this.executeTestStep(step, test);\r\n        \r\n        const stepDuration = Date.now() - stepStartTime;\r\n        performance_metrics[`step_${step.step}`] = stepDuration;\r\n\r\n        // CRITICAL: Validate expected outcome\r\n        if (result !== step.expectedOutcome) {\r\n          errors.push(`Step ${step.step} failed: expected ${step.expectedOutcome}, got ${result}`);\r\n        }\r\n\r\n        // CRITICAL: Check timeout\r\n        if (stepDuration > step.timeout) {\r\n          warnings.push(`Step ${step.step} exceeded timeout of ${step.timeout}ms`);\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Execute validation steps\r\n      for (const validation of test.validation) {\r\n        const validationStartTime = Date.now();\r\n        \r\n        logger.info(`Executing validation step ${validation.step}: ${validation.description}`, {\r\n          testId,\r\n          step: validation.step,\r\n          description: validation.description\r\n        });\r\n\r\n        const result = await this.executeTestStep(validation, test);\r\n        \r\n        const validationDuration = Date.now() - validationStartTime;\r\n        performance_metrics[`validation_${validation.step}`] = validationDuration;\r\n\r\n        // CRITICAL: Validate expected outcome\r\n        if (result !== validation.expectedOutcome) {\r\n          errors.push(`Validation ${validation.step} failed: expected ${validation.expectedOutcome}, got ${result}`);\r\n        }\r\n\r\n        // CRITICAL: Check timeout\r\n        if (validationDuration > validation.timeout) {\r\n          warnings.push(`Validation ${validation.step} exceeded timeout of ${validation.timeout}ms`);\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Mark test as successful\r\n      test.metrics.success = errors.length === 0 && warnings.length === 0;\r\n      test.metrics.duration = Date.now() - startTime;\r\n      test.metrics.errors = errors;\r\n      test.metrics.warnings = warnings;\r\n      test.metrics.performance_metrics = performance_metrics;\r\n      test.completedAt = new Date();\r\n\r\n      // CRITICAL: Log test completion\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId: 'system',\r\n        actorId: 'chaos-engineering',\r\n        action: 'RESILIENCE_TEST_COMPLETED',\r\n        resourceType: 'CHAOS_TEST',\r\n        resourceId: testId,\r\n        outcome: test.metrics.success ? 'SUCCESS' : 'FAILURE',\r\n        correlationId: test.correlationId,\r\n        severity: test.metrics.success ? 'LOW' : 'HIGH',\r\n        metadata: {\r\n          testName: test.name,\r\n          scenario: test.scenario,\r\n          duration: test.metrics.duration,\r\n          errors: test.metrics.errors.length,\r\n          warnings: test.metrics.warnings.length\r\n        }\r\n      });\r\n\r\n      logger.info('Resilience test completed', {\r\n        testId,\r\n        name: test.name,\r\n        scenario: test.scenario,\r\n        success: test.metrics.success,\r\n        duration: test.metrics.duration,\r\n        errors: test.metrics.errors.length,\r\n        warnings: test.metrics.warnings.length\r\n      });\r\n\r\n      // CRITICAL: Store test result\r\n      this.chaosTestResults.push({\r\n        testId,\r\n        testName: test.name,\r\n        scenario: test.scenario,\r\n        success: test.metrics.success,\r\n        duration: test.metrics.duration,\r\n        errors: test.metrics.errors,\r\n        warnings: test.metrics.warnings,\r\n        metrics: test.metrics.performance_metrics,\r\n        correlationId: test.correlationId,\r\n        timestamp: test.completedAt || new Date()\r\n      });\r\n\r\n      return {\r\n        testId,\r\n        testName: test.name,\r\n        scenario: test.scenario,\r\n        success: test.metrics.success,\r\n        duration: test.metrics.duration,\r\n        errors: test.metrics.success ? [] : test.metrics.errors,\r\n        warnings: test.metrics.warnings,\r\n        metrics: test.metrics.performance_metrics,\r\n        correlationId: test.correlationId,\r\n        timestamp: test.completedAt || new Date()\r\n      };\r\n\r\n    } catch (error) {\r\n      const duration = Date.now() - startTime;\r\n      \r\n      // CRITICAL: Log test failure\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId: 'system',\r\n        actorId: 'chaos-engineering',\r\n        action: 'RESILIENCE_TEST_FAILED',\r\n        resourceType: 'CHAOS_TEST',\r\n        resourceId: testId,\r\n        outcome: 'FAILURE',\r\n        correlationId: test.correlationId,\r\n        severity: 'CRITICAL',\r\n        metadata: {\r\n          testName: test.name,\r\n          scenario: test.scenario,\r\n          error: (error as Error).message,\r\n          duration\r\n        }\r\n      });\r\n\r\n      logger.error('Resilience test failed', error as Error, {\r\n        testId,\r\n        name: test.name,\r\n        scenario: test.scenario,\r\n        duration\r\n      });\r\n\r\n      return {\r\n        testId,\r\n        testName: test.name,\r\n        scenario: test.scenario,\r\n        success: false,\r\n        duration,\r\n        errors: [(error as Error).message],\r\n        warnings: [],\r\n        metrics: {},\r\n        correlationId: test.correlationId,\r\n        timestamp: new Date()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get active faults\r\n   */\r\n  getActiveFaults(): FaultInjection[] {\r\n    return Array.from(this.activeFaults.values());\r\n  }\r\n\r\n  resetForTests(): void {\r\n    this.activeFaults.clear();\r\n    this.resilienceTests.clear();\r\n    this.chaosTestResults = [];\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get resilience test results\r\n   */\r\n  getResilienceTests(\r\n    type?: 'RESILIENCE_VALIDATION' | 'FAULT_INJECTION' | 'LOAD_TEST' | 'RECOVERY_TEST',\r\n    limit?: number\r\n  ): ResilienceTest[] {\r\n    const tests = Array.from(this.resilienceTests.values());\r\n    \r\n    if (type) {\r\n      const filtered = tests.filter(test => test.type === type);\r\n      return limit ? filtered.slice(-limit) : filtered;\r\n    }\r\n    \r\n    return limit ? tests.slice(-limit) : tests;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get chaos test results\r\n   */\r\n  getChaosTestResults(limit?: number): ChaosTestResult[] {\r\n    const results = this.chaosTestResults;\r\n    \r\n    if (limit) {\r\n      return results.slice(-limit);\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get system load\r\n   */\r\n  private async getSystemLoad(): Promise<number> {\r\n    // CRITICAL: Get current system load percentage\r\n    // In a real implementation, this would get actual system metrics\r\n    return 25; // Simulated 25% load\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get component state\r\n   */\r\n  private async getComponentState(component: string): Promise<string> {\r\n    // CRITICAL: Get current component state\r\n    // In a real implementation, this would get actual component state\r\n    return 'HEALTHY';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate fault injection preconditions\r\n   */\r\n  private async validateFaultInjectionPreconditions(fault: FaultInjection): Promise<void> {\r\n    const validTypes: FaultType[] = [\r\n      'DATABASE_DOWN',\r\n      'QUEUE_LAG',\r\n      'CACHE_LOSS',\r\n      'NETWORK_FAILURE',\r\n      'SERVICE_CRASH',\r\n      'RESOURCE_EXHAUSTION',\r\n      'MEMORY_EXHAUSTION'\r\n    ];\r\n\r\n    const validSeverities: FaultSeverity[] = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];\r\n\r\n    if (!validTypes.includes(fault.type)) {\r\n      throw new Error(`Invalid fault type: ${String(fault.type)}`);\r\n    }\r\n\r\n    if (!validSeverities.includes(fault.severity)) {\r\n      throw new Error(`Invalid fault severity: ${String(fault.severity)}`);\r\n    }\r\n\r\n    // CRITICAL: Check system load\r\n    const systemLoad = await this.getSystemLoad();\r\n    if (systemLoad > 80) {\r\n      throw new Error(`System load too high for fault injection: ${systemLoad}%`);\r\n    }\r\n\r\n    // CRITICAL: Check component state\r\n    const componentState = await this.getComponentState(fault.component);\r\n    if (componentState === 'UNHEALTHY') {\r\n      throw new Error(`Component ${fault.component} is unhealthy`);\r\n    }\r\n\r\n    // CRITICAL: Check active faults\r\n    const activeFaults = this.getActiveFaults();\r\n    const similarFaults = activeFaults.filter(f => \r\n      f.type === fault.type && f.component === fault.component\r\n    );\r\n    \r\n    if (similarFaults.length > 3) {\r\n      throw new Error(`Too many similar active faults for ${fault.type} in ${fault.component}`);\r\n    }\r\n\r\n    // CRITICAL: Check fault severity\r\n    if (fault.severity === 'CRITICAL' && systemLoad > 50) {\r\n      throw new Error(`Critical fault injection not allowed at current system load: ${systemLoad}%`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute fault injection\r\n   */\r\n  private async executeFaultInjection(fault: FaultInjection): Promise<void> {\r\n    logger.info('Executing fault injection', {\r\n      faultId: fault.id,\r\n      type: fault.type,\r\n      component: fault.component,\r\n      severity: fault.severity,\r\n      description: fault.description,\r\n      duration: fault.duration\r\n    });\r\n\r\n    // CRITICAL: Simulate fault injection\r\n    // In a real implementation, this would actually inject the fault\r\n    // For now, we'll simulate the fault\r\n    const delayMs = this.getSimulationDelayMs(fault.duration);\r\n    await new Promise(resolve => setTimeout(resolve, delayMs));\r\n\r\n    // CRITICAL: Log fault injection completion\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'chaos-engineering',\r\n      action: 'FAULT_INJECTION_COMPLETED',\r\n      resourceType: 'CHAOS_TEST',\r\n      resourceId: fault.id,\r\n      outcome: 'SUCCESS',\r\n      correlationId: fault.correlationId,\r\n      severity: this.mapSeverityToAuditLevel(fault.severity),\r\n      metadata: {\r\n        type: fault.type,\r\n        component: fault.component,\r\n        severity: fault.severity,\r\n        description: fault.description,\r\n        duration: fault.duration,\r\n        impact: fault.impact\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute test step\r\n   */\r\n  private async executeTestStep(\r\n    step: any,\r\n    test: ResilienceTest\r\n  ): Promise<string> {\r\n    logger.info(`Executing test step ${step.step}: ${step.description}`, {\r\n      testId: test.id,\r\n      testName: test.name,\r\n      scenario: test.scenario,\r\n      step: step.step\r\n    });\r\n\r\n    // CRITICAL: Simulate step execution\r\n    // In a real implementation, this would execute the actual test step\r\n    const delayMs = this.getSimulationDelayMs(step.timeout);\r\n    await new Promise(resolve => setTimeout(resolve, delayMs));\r\n\r\n    // CRITICAL: Return simulated result\r\n    return step.expectedOutcome;\r\n  }\r\n\r\n  private getSimulationDelayMs(requestedMs: number): number {\r\n    const isTest = process.env.NODE_ENV === 'test' || process.env.VITEST === 'true';\r\n    if (isTest) {\r\n      return 1;\r\n    }\r\n\r\n    return requestedMs;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start chaos testing\r\n   */\r\n  private startChaosTesting(): void {\r\n    // CRITICAL: Periodic chaos testing\r\n    this.chaosTestTimer = setInterval(async () => {\r\n      await this.runChaosTest();\r\n    }, 300000); // Every 5 minutes\r\n\r\n    // CRITICAL: Periodic cleanup\r\n    setInterval(() => {\r\n      this.cleanupOldFaults();\r\n    }, 60000); // Every 10 minutes\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Run chaos test\r\n   */\r\n  async runChaosTest(): Promise<void> {\r\n    // CRITICAL: Select random chaos test\r\n    const tests = this.getResilienceTests('RESILIENCE_VALIDATION');\r\n    if (tests.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const randomTest = tests[this.selectDeterministicIndex(tests.length)];\r\n    \r\n    try {\r\n      await this.executeResilienceTest(randomTest.id);\r\n    } catch (error) {\r\n      logger.error('Chaos test failed', error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup old faults\r\n   */\r\n  private cleanupOldFaults(): void {\r\n    const now = Date.now();\r\n    let cleanedCount = 0;\r\n\r\n    for (const [faultId, fault] of this.activeFaults.entries()) {\r\n      if (fault.timestamp.getTime() < (now - 3600000)) { // 1 hour\r\n        this.activeFaults.delete(faultId);\r\n        cleanedCount++;\r\n      }\r\n    }\r\n\r\n    if (cleanedCount > 0) {\r\n      logger.info('Cleaned up old faults', { cleanedCount });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Stop chaos testing\r\n   */\r\n  stopChaosTesting(): void {\r\n    if (this.chaosTestTimer) {\r\n      clearInterval(this.chaosTestTimer);\r\n      this.chaosTestTimer = null;\r\n    }\r\n\r\n    // CRITICAL: Stop all active faults\r\n    for (const faultId of this.activeFaults.keys()) {\r\n      this.stopFault(faultId);\r\n    }\r\n\r\n    logger.info('Chaos testing stopped');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Map severity to audit level\r\n   */\r\n  private mapSeverityToAuditLevel(severity: FaultSeverity): string {\r\n    switch (severity) {\r\n      case 'LOW': return 'LOW';\r\n      case 'MEDIUM': return 'MEDIUM';\r\n      case 'HIGH': return 'HIGH';\r\n      case 'CRITICAL': return 'CRITICAL';\r\n      default: return 'MEDIUM';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate fault ID\r\n   */\r\n  private generateFaultId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `fault_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  private generateTestId(): string {\r\n    if (process.env.DETERMINISTIC_TEST_IDS === 'true') {\r\n      return 'test_00000001';\r\n    }\r\n\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `test_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  private selectDeterministicIndex(length: number): number {\r\n    if (length <= 0) {\r\n      return 0;\r\n    }\r\n\r\n    if (process.env.DETERMINISTIC_TEST_IDS === 'true') {\r\n      return 0;\r\n    }\r\n\r\n    return Math.floor(Math.random() * length);\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global chaos engineering manager instance\r\n */\r\nexport const chaosEngineeringManager = ChaosEngineeringManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const injectFault = async (\r\n  type: FaultType,\r\n  component: string,\r\n  severity: FaultSeverity,\r\n  description: string,\r\n  parameters: Record<string, any> = {},\r\n  duration: number = 30000\r\n): Promise<string> => {\r\n  return await chaosEngineeringManager.injectFault(type, component, severity, description, parameters, duration);\r\n};\r\n\r\nexport const stopFault = (faultId: string): void => {\r\n  chaosEngineeringManager.stopFault(faultId);\r\n};\r\n\r\nexport const createResilienceTest = (\r\n  name: string,\r\n  description: string,\r\n  scenario: string,\r\n  preconditions: string[],\r\n  steps: Array<{\r\n    step: number;\r\n    description: string;\r\n    action: string;\r\n    expectedOutcome: string;\r\n    timeout: number;\r\n  }>,\r\n  validation: Array<{\r\n    step: number;\r\n    description: string;\r\n    action: string;\r\n    expectedOutcome: string;\r\n    timeout: number;\r\n  }>,\r\n  correlationId?: string\r\n): string => {\r\n  return chaosEngineeringManager.createResilienceTest(name, description, scenario, preconditions, steps, validation, correlationId);\r\n};\r\n\r\nexport const getActiveFaults = (): FaultInjection[] => {\r\n  return chaosEngineeringManager.getActiveFaults();\r\n};\r\n\r\nexport const getResilienceTests = (\r\n  type?: 'RESILIENCE_VALIDATION' | 'FAULT_INJECTION' | 'LOAD_TEST' | 'RECOVERY_TEST',\r\n  limit?: number\r\n): ResilienceTest[] => {\r\n  return chaosEngineeringManager.getResilienceTests(type, limit);\r\n};\r\n\r\nexport const getChaosTestResults = (limit?: number): ChaosTestResult[] => {\r\n  return chaosEngineeringManager.getChaosTestResults(limit);\r\n};\r\n\r\nexport const runChaosTest = async (): Promise<void> => {\r\n  return await chaosEngineeringManager.runChaosTest();\r\n};\r\n\r\nexport const stopChaosTesting = (): void => {\r\n  chaosEngineeringManager.stopChaosTesting();\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\circuit-breaker.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":491,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":491,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":505,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":505,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Circuit Breaker Implementation\r\n// MANDATORY: Service circuit breakers with trip thresholds and automatic recovery\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\n\r\nexport type CircuitState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';\r\nexport type TripStrategy = 'FAILURE_COUNT' | 'FAILURE_RATE' | 'RESPONSE_TIME';\r\n\r\nexport interface CircuitBreakerConfig {\r\n  failureThreshold: number;\r\n  resetTimeout: number; // Time in OPEN state before attempting HALF_OPEN\r\n  monitoringPeriod: number; // Time window for failure counting\r\n  halfOpenMaxCalls: number; // Max calls in HALF_OPEN state\r\n  tripStrategy: TripStrategy;\r\n  failureRateThreshold: number; // Percentage (0-100)\r\n  responseTimeThreshold: number; // Milliseconds\r\n  minimumThroughput: number; // Minimum calls to consider for rate-based tripping\r\n}\r\n\r\nexport interface CircuitBreakerMetrics {\r\n  totalCalls: number;\r\n  successfulCalls: number;\r\n  failedCalls: number;\r\n  currentFailureRate: number;\r\n  averageResponseTime: number;\r\n  lastFailureTime?: Date;\r\n  lastSuccessTime?: Date;\r\n  stateTransitions: Array<{\r\n    from: CircuitState;\r\n    to: CircuitState;\r\n    timestamp: Date;\r\n    reason: string;\r\n  }>;\r\n}\r\n\r\nexport interface CircuitBreakerEvent {\r\n  id: string;\r\n  serviceName: string;\r\n  timestamp: Date;\r\n  state: CircuitState;\r\n  eventType: 'STATE_CHANGE' | 'CALL_SUCCESS' | 'CALL_FAILURE' | 'TRIP' | 'RESET';\r\n  metadata: Record<string, any>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Circuit Breaker Implementation\r\n * \r\n * This class implements circuit breakers with configurable trip strategies\r\n * and automatic recovery to prevent cascade failures.\r\n */\r\nexport class CircuitBreaker {\r\n  private serviceName: string;\r\n  private config: CircuitBreakerConfig;\r\n  private state: CircuitState = 'CLOSED';\r\n  private metrics: CircuitBreakerMetrics;\r\n  private failureWindow: Array<{ timestamp: Date; success: boolean; responseTime: number }> = [];\r\n  private lastStateChange: Date = new Date();\r\n  private halfOpenCalls: number = 0;\r\n  private auditLogger: any;\r\n  private events: CircuitBreakerEvent[] = [];\r\n  private deterministicCounter: number = 0;\r\n\r\n  constructor(serviceName: string, config: Partial<CircuitBreakerConfig> = {}) {\r\n    this.serviceName = serviceName;\r\n    this.config = this.mergeConfig(config);\r\n    this.metrics = this.initializeMetrics();\r\n    this.auditLogger = getImmutableAuditLogger();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute operation with circuit breaker protection\r\n   */\r\n  async execute<T>(operation: () => Promise<T>, fallback?: () => Promise<T>): Promise<T> {\r\n    const callId = this.generateCallId();\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // CRITICAL: Check if circuit is open\r\n      if (this.state === 'OPEN') {\r\n        if (this.shouldAttemptReset()) {\r\n          this.transitionTo('HALF_OPEN', 'Reset timeout elapsed');\r\n        } else {\r\n          throw new Error(`Circuit breaker OPEN for ${this.serviceName}`);\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Check half-open call limit\r\n      if (this.state === 'HALF_OPEN' && this.halfOpenCalls >= this.config.halfOpenMaxCalls) {\r\n        throw new Error(`Circuit breaker HALF_OPEN call limit exceeded for ${this.serviceName}`);\r\n      }\r\n\r\n      // CRITICAL: Execute the operation\r\n      const result = await operation();\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      // CRITICAL: Record successful call\r\n      this.recordSuccess(responseTime, callId);\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const responseTime = Date.now() - startTime;\r\n      \r\n      // CRITICAL: Record failed call\r\n      this.recordFailure(error as Error, responseTime, callId);\r\n\r\n      // CRITICAL: Use fallback if available\r\n      if (fallback && this.state === 'OPEN') {\r\n        try {\r\n          const fallbackResult = await fallback();\r\n          \r\n          this.auditLogger.logAuthorizationDecision({\r\n            tenantId: 'system',\r\n            actorId: 'circuit-breaker',\r\n            action: 'FALLBACK_SUCCESS',\r\n            resourceType: 'CIRCUIT_BREAKER',\r\n            resourceId: this.serviceName,\r\n            outcome: 'SUCCESS',\r\n            correlationId: `cb_fallback_${callId}`,\r\n            metadata: {\r\n              serviceName: this.serviceName,\r\n              state: this.state,\r\n              originalError: (error as Error).message,\r\n              fallbackResponseTime: Date.now() - startTime\r\n            }\r\n          });\r\n\r\n          return fallbackResult;\r\n\r\n        } catch (fallbackError) {\r\n          this.auditLogger.logAuthorizationDecision({\r\n            tenantId: 'system',\r\n            actorId: 'circuit-breaker',\r\n            action: 'FALLBACK_FAILURE',\r\n            resourceType: 'CIRCUIT_BREAKER',\r\n            resourceId: this.serviceName,\r\n            outcome: 'FAILURE',\r\n            correlationId: `cb_fallback_${callId}`,\r\n            metadata: {\r\n              serviceName: this.serviceName,\r\n              state: this.state,\r\n              originalError: (error as Error).message,\r\n              fallbackError: (fallbackError as Error).message\r\n            }\r\n          });\r\n\r\n          throw fallbackError;\r\n        }\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get current circuit state\r\n   */\r\n  getState(): CircuitState {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get circuit metrics\r\n   */\r\n  getMetrics(): CircuitBreakerMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get circuit configuration\r\n   */\r\n  getConfig(): CircuitBreakerConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Force circuit state (for testing/admin)\r\n   */\r\n  forceState(state: CircuitState, reason: string = 'Manual override'): void {\r\n    this.transitionTo(state, reason);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Reset circuit breaker\r\n   */\r\n  reset(): void {\r\n    this.transitionTo('CLOSED', 'Manual reset');\r\n    this.halfOpenCalls = 0;\r\n    this.failureWindow = [];\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Record successful call\r\n   */\r\n  private recordSuccess(responseTime: number, callId: string): void {\r\n    const now = new Date();\r\n    \r\n    // CRITICAL: Update metrics\r\n    this.metrics.totalCalls++;\r\n    this.metrics.successfulCalls++;\r\n    this.metrics.lastSuccessTime = now;\r\n\r\n    // CRITICAL: Add to failure window\r\n    this.failureWindow.push({\r\n      timestamp: now,\r\n      success: true,\r\n      responseTime\r\n    });\r\n\r\n    // CRITICAL: Log event\r\n    this.logEvent('CALL_SUCCESS', {\r\n      callId,\r\n      responseTime,\r\n      totalCalls: this.metrics.totalCalls\r\n    });\r\n\r\n    // CRITICAL: Handle half-open state\r\n    if (this.state === 'HALF_OPEN') {\r\n      this.halfOpenCalls++;\r\n      \r\n      // CRITICAL: If enough successful calls in half-open, close the circuit\r\n      if (this.halfOpenCalls >= this.config.halfOpenMaxCalls) {\r\n        this.transitionTo('CLOSED', 'Half-open calls succeeded');\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Cleanup old failures\r\n    this.cleanupFailureWindow();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Record failed call\r\n   */\r\n  private recordFailure(error: Error, responseTime: number, callId: string): void {\r\n    const now = new Date();\r\n    \r\n    // CRITICAL: Update metrics\r\n    this.metrics.totalCalls++;\r\n    this.metrics.failedCalls++;\r\n    this.metrics.lastFailureTime = now;\r\n\r\n    // CRITICAL: Add to failure window\r\n    this.failureWindow.push({\r\n      timestamp: now,\r\n      success: false,\r\n      responseTime\r\n    });\r\n\r\n    // CRITICAL: Log event\r\n    this.logEvent('CALL_FAILURE', {\r\n      callId,\r\n      responseTime,\r\n      error: error.message,\r\n      totalCalls: this.metrics.totalCalls\r\n    });\r\n\r\n    // CRITICAL: Check if circuit should trip\r\n    if (this.shouldTrip()) {\r\n      this.transitionTo('OPEN', 'Failure threshold exceeded');\r\n    }\r\n\r\n    // CRITICAL: Cleanup old failures\r\n    this.cleanupFailureWindow();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if circuit should trip\r\n   */\r\n  private shouldTrip(): boolean {\r\n    if (this.state === 'OPEN') {\r\n      return false;\r\n    }\r\n\r\n    const recentCalls = this.getRecentCalls();\r\n    \r\n    // CRITICAL: Check minimum throughput\r\n    if (recentCalls.length < this.config.minimumThroughput) {\r\n      return false;\r\n    }\r\n\r\n    switch (this.config.tripStrategy) {\r\n      case 'FAILURE_COUNT':\r\n        return this.shouldTripByCount(recentCalls);\r\n      case 'FAILURE_RATE':\r\n        return this.shouldTripByRate(recentCalls);\r\n      case 'RESPONSE_TIME':\r\n        return this.shouldTripByResponseTime(recentCalls);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if should trip by failure count\r\n   */\r\n  private shouldTripByCount(recentCalls: Array<{ success: boolean; responseTime: number }>): boolean {\r\n    const failures = recentCalls.filter(call => !call.success);\r\n    return failures.length >= this.config.failureThreshold;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if should trip by failure rate\r\n   */\r\n  private shouldTripByRate(recentCalls: Array<{ success: boolean; responseTime: number }>): boolean {\r\n    const failures = recentCalls.filter(call => !call.success);\r\n    const failureRate = (failures.length / recentCalls.length) * 100;\r\n    \r\n    this.metrics.currentFailureRate = failureRate;\r\n    \r\n    return failureRate >= this.config.failureRateThreshold;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if should trip by response time\r\n   */\r\n  private shouldTripByResponseTime(recentCalls: Array<{ success: boolean; responseTime: number }>): boolean {\r\n    const averageResponseTime = recentCalls.reduce((sum, call) => sum + call.responseTime, 0) / recentCalls.length;\r\n    \r\n    this.metrics.averageResponseTime = averageResponseTime;\r\n    \r\n    return averageResponseTime >= this.config.responseTimeThreshold;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if should attempt reset\r\n   */\r\n  private shouldAttemptReset(): boolean {\r\n    return Date.now() - this.lastStateChange.getTime() >= this.config.resetTimeout;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Transition to new state\r\n   */\r\n  private transitionTo(newState: CircuitState, reason: string): void {\r\n    const oldState = this.state;\r\n    const timestamp = new Date();\r\n\r\n    // CRITICAL: Record state transition\r\n    this.metrics.stateTransitions.push({\r\n      from: oldState,\r\n      to: newState,\r\n      timestamp,\r\n      reason\r\n    });\r\n\r\n    // CRITICAL: Update state\r\n    this.state = newState;\r\n    this.lastStateChange = timestamp;\r\n\r\n    // CRITICAL: Reset half-open calls if leaving half-open\r\n    if (oldState === 'HALF_OPEN') {\r\n      this.halfOpenCalls = 0;\r\n    }\r\n\r\n    // CRITICAL: Log event\r\n    this.logEvent('STATE_CHANGE', {\r\n      from: oldState,\r\n      to: newState,\r\n      reason\r\n    });\r\n\r\n    // CRITICAL: Log audit event\r\n    this.auditLogger.logAuthorizationDecision({\r\n      tenantId: 'system',\r\n      actorId: 'circuit-breaker',\r\n      action: 'CIRCUIT_STATE_CHANGE',\r\n      resourceType: 'CIRCUIT_BREAKER',\r\n      resourceId: this.serviceName,\r\n      outcome: 'SUCCESS',\r\n      correlationId: `cb_state_${timestamp.getTime()}`,\r\n      metadata: {\r\n        serviceName: this.serviceName,\r\n        from: oldState,\r\n        to: newState,\r\n        reason,\r\n        totalCalls: this.metrics.totalCalls,\r\n        failureRate: this.metrics.currentFailureRate\r\n      }\r\n    });\r\n\r\n    logger.warn('Circuit breaker state changed', {\r\n      serviceName: this.serviceName,\r\n      from: oldState,\r\n      to: newState,\r\n      reason\r\n    });\r\n\r\n    // CRITICAL: Log trip event specifically\r\n    if (newState === 'OPEN') {\r\n      this.logEvent('TRIP', {\r\n        reason,\r\n        failureRate: this.metrics.currentFailureRate,\r\n        totalFailures: this.metrics.failedCalls\r\n      });\r\n    }\r\n\r\n    // CRITICAL: Log reset event specifically\r\n    if (newState === 'CLOSED' && oldState !== 'HALF_OPEN') {\r\n      this.logEvent('RESET', {\r\n        reason,\r\n        totalCalls: this.metrics.totalCalls\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get recent calls within monitoring period\r\n   */\r\n  private getRecentCalls(): Array<{ success: boolean; responseTime: number }> {\r\n    const cutoffTime = new Date();\r\n    cutoffTime.setMilliseconds(cutoffTime.getMilliseconds() - this.config.monitoringPeriod);\r\n\r\n    return this.failureWindow\r\n      .filter(call => call.timestamp >= cutoffTime)\r\n      .map(call => ({ success: call.success, responseTime: call.responseTime }));\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup old failure window entries\r\n   */\r\n  private cleanupFailureWindow(): void {\r\n    const cutoffTime = new Date();\r\n    cutoffTime.setMilliseconds(cutoffTime.getMilliseconds() - this.config.monitoringPeriod);\r\n\r\n    this.failureWindow = this.failureWindow.filter(call => call.timestamp >= cutoffTime);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Log circuit breaker event\r\n   */\r\n  private logEvent(eventType: CircuitBreakerEvent['eventType'], metadata: Record<string, any>): void {\r\n    const event: CircuitBreakerEvent = {\r\n      id: this.generateEventId(),\r\n      serviceName: this.serviceName,\r\n      timestamp: new Date(),\r\n      state: this.state,\r\n      eventType,\r\n      metadata\r\n    };\r\n\r\n    this.events.push(event);\r\n\r\n    // CRITICAL: Keep only recent events (last 1000)\r\n    if (this.events.length > 1000) {\r\n      this.events = this.events.slice(-1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Merge configuration with defaults\r\n   */\r\n  private mergeConfig(config: Partial<CircuitBreakerConfig>): CircuitBreakerConfig {\r\n    const defaults: CircuitBreakerConfig = {\r\n      failureThreshold: 5,\r\n      resetTimeout: 60000, // 1 minute\r\n      monitoringPeriod: 10000, // 10 seconds\r\n      halfOpenMaxCalls: 3,\r\n      tripStrategy: 'FAILURE_COUNT',\r\n      failureRateThreshold: 50, // 50%\r\n      responseTimeThreshold: 1000, // 1 second\r\n      minimumThroughput: 10\r\n    };\r\n\r\n    return { ...defaults, ...config };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize metrics\r\n   */\r\n  private initializeMetrics(): CircuitBreakerMetrics {\r\n    return {\r\n      totalCalls: 0,\r\n      successfulCalls: 0,\r\n      failedCalls: 0,\r\n      currentFailureRate: 0,\r\n      averageResponseTime: 0,\r\n      stateTransitions: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate call ID\r\n   */\r\n  private generateCallId(): string {\r\n    if (process.env.DETERMINISTIC_TEST_IDS === 'true') {\r\n      this.deterministicCounter += 1;\r\n      return `call_${String(this.deterministicCounter).padStart(8, '0')}`;\r\n    }\r\n\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(4);\r\n    return `call_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate event ID\r\n   */\r\n  private generateEventId(): string {\r\n    if (process.env.DETERMINISTIC_TEST_IDS === 'true') {\r\n      this.deterministicCounter += 1;\r\n      return `event_${String(this.deterministicCounter).padStart(8, '0')}`;\r\n    }\r\n\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(4);\r\n    return `event_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get recent events\r\n   */\r\n  getRecentEvents(limit: number = 100): CircuitBreakerEvent[] {\r\n    return this.events.slice(-limit);\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Circuit Breaker Registry\r\n * \r\n * This class manages multiple circuit breakers and provides centralized monitoring.\r\n */\r\nexport class CircuitBreakerRegistry {\r\n  private static instance: CircuitBreakerRegistry;\r\n  private circuitBreakers: Map<string, CircuitBreaker> = new Map();\r\n  private globalMetrics: {\r\n    totalCircuits: number;\r\n    openCircuits: number;\r\n    halfOpenCircuits: number;\r\n    closedCircuits: number;\r\n    totalCalls: number;\r\n    totalFailures: number;\r\n  };\r\n\r\n  private constructor() {\r\n    this.globalMetrics = this.initializeGlobalMetrics();\r\n    this.startMonitoring();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): CircuitBreakerRegistry {\r\n    if (!CircuitBreakerRegistry.instance) {\r\n      CircuitBreakerRegistry.instance = new CircuitBreakerRegistry();\r\n    }\r\n    return CircuitBreakerRegistry.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get or create circuit breaker\r\n   */\r\n  getCircuitBreaker(serviceName: string, config?: Partial<CircuitBreakerConfig>): CircuitBreaker {\r\n    let circuitBreaker = this.circuitBreakers.get(serviceName);\r\n    \r\n    if (!circuitBreaker) {\r\n      circuitBreaker = new CircuitBreaker(serviceName, config);\r\n      this.circuitBreakers.set(serviceName, circuitBreaker);\r\n    }\r\n\r\n    return circuitBreaker;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get all circuit breakers\r\n   */\r\n  getAllCircuitBreakers(): Map<string, CircuitBreaker> {\r\n    return new Map(this.circuitBreakers);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get global metrics\r\n   */\r\n  getGlobalMetrics(): typeof this.globalMetrics {\r\n    this.updateGlobalMetrics();\r\n    return { ...this.globalMetrics };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Reset all circuit breakers\r\n   */\r\n  resetAll(): void {\r\n    for (const circuitBreaker of this.circuitBreakers.values()) {\r\n      circuitBreaker.reset();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get circuit breakers by state\r\n   */\r\n  getCircuitBreakersByState(state: CircuitState): CircuitBreaker[] {\r\n    return Array.from(this.circuitBreakers.values())\r\n      .filter(cb => cb.getState() === state);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update global metrics\r\n   */\r\n  private updateGlobalMetrics(): void {\r\n    let openCircuits = 0;\r\n    let halfOpenCircuits = 0;\r\n    let closedCircuits = 0;\r\n    let totalCalls = 0;\r\n    let totalFailures = 0;\r\n\r\n    for (const circuitBreaker of this.circuitBreakers.values()) {\r\n      const metrics = circuitBreaker.getMetrics();\r\n      const state = circuitBreaker.getState();\r\n\r\n      switch (state) {\r\n        case 'OPEN':\r\n          openCircuits++;\r\n          break;\r\n        case 'HALF_OPEN':\r\n          halfOpenCircuits++;\r\n          break;\r\n        case 'CLOSED':\r\n          closedCircuits++;\r\n          break;\r\n      }\r\n\r\n      totalCalls += metrics.totalCalls;\r\n      totalFailures += metrics.failedCalls;\r\n    }\r\n\r\n    this.globalMetrics = {\r\n      totalCircuits: this.circuitBreakers.size,\r\n      openCircuits,\r\n      halfOpenCircuits,\r\n      closedCircuits,\r\n      totalCalls,\r\n      totalFailures\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize global metrics\r\n   */\r\n  private initializeGlobalMetrics(): typeof this.globalMetrics {\r\n    return {\r\n      totalCircuits: 0,\r\n      openCircuits: 0,\r\n      halfOpenCircuits: 0,\r\n      closedCircuits: 0,\r\n      totalCalls: 0,\r\n      totalFailures: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start monitoring\r\n   */\r\n  private startMonitoring(): void {\r\n    // CRITICAL: Periodic metrics update\r\n    setInterval(() => {\r\n      this.updateGlobalMetrics();\r\n    }, 10000); // Every 10 seconds\r\n\r\n    // CRITICAL: Periodic cleanup of old circuit breakers\r\n    setInterval(() => {\r\n      this.cleanupInactiveCircuits();\r\n    }, 300000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup inactive circuit breakers\r\n   */\r\n  private cleanupInactiveCircuits(): void {\r\n    const cutoffTime = new Date();\r\n    cutoffTime.setHours(cutoffTime.getHours() - 1); // 1 hour ago\r\n\r\n    for (const [serviceName, circuitBreaker] of this.circuitBreakers.entries()) {\r\n      const metrics = circuitBreaker.getMetrics();\r\n      \r\n      // CRITICAL: Remove circuit breakers that haven't been used recently\r\n      if (metrics.totalCalls === 0 || \r\n          (metrics.lastSuccessTime && metrics.lastSuccessTime < cutoffTime && \r\n           metrics.lastFailureTime && metrics.lastFailureTime < cutoffTime)) {\r\n        this.circuitBreakers.delete(serviceName);\r\n        logger.info('Cleaned up inactive circuit breaker', { serviceName });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global circuit breaker registry instance\r\n */\r\nexport const circuitBreakerRegistry = CircuitBreakerRegistry.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const getCircuitBreaker = (serviceName: string, config?: Partial<CircuitBreakerConfig>): CircuitBreaker => {\r\n  return circuitBreakerRegistry.getCircuitBreaker(serviceName, config);\r\n};\r\n\r\nexport const executeWithCircuitBreaker = async <T>(\r\n  serviceName: string,\r\n  operation: () => Promise<T>,\r\n  fallback?: () => Promise<T>,\r\n  config?: Partial<CircuitBreakerConfig>\r\n): Promise<T> => {\r\n  const circuitBreaker = getCircuitBreaker(serviceName, config);\r\n  return await circuitBreaker.execute(operation, fallback);\r\n};\r\n\r\nexport const getCircuitBreakerMetrics = (serviceName: string): CircuitBreakerMetrics | null => {\r\n  const circuitBreaker = circuitBreakerRegistry.getAllCircuitBreakers().get(serviceName);\r\n  return circuitBreaker ? circuitBreaker.getMetrics() : null;\r\n};\r\n\r\nexport const getAllCircuitBreakerMetrics = (): ReturnType<typeof circuitBreakerRegistry.getGlobalMetrics> => {\r\n  return circuitBreakerRegistry.getGlobalMetrics();\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\degradation-modes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\failure-domains.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":890,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":890,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":899,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":899,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Failure Domains & Blast Radius Control\r\n// MANDATORY: Tenant-level failure isolation with zero cascade propagation\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport type FailureSeverity = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\nexport type FailureDomain = 'TENANT' | 'SERVICE' | 'DATABASE' | 'QUEUE' | 'CACHE' | 'EXTERNAL';\r\nexport type ContainmentStrategy = 'ISOLATE' | 'DEGRADE' | 'FAIL_FAST' | 'CIRCUIT_BREAK';\r\n\r\nexport interface FailureEvent {\r\n  id: string;\r\n  domain: FailureDomain;\r\n  severity: FailureSeverity;\r\n  tenantId?: string;\r\n  service?: string;\r\n  component?: string;\r\n  timestamp: Date;\r\n  message: string;\r\n  error?: Error;\r\n  metadata: Record<string, any>;\r\n  containmentStrategy: ContainmentStrategy;\r\n  blastRadius: {\r\n    affectedTenants: string[];\r\n    affectedServices: string[];\r\n    estimatedImpact: 'MINIMAL' | 'MODERATE' | 'EXTENSIVE';\r\n  };\r\n}\r\n\r\nexport interface FailureDomainConfig {\r\n  maxConcurrentFailures: number;\r\n  failureWindowMs: number;\r\n  recoveryTimeoutMs: number;\r\n  cascadePrevention: boolean;\r\n  tenantIsolation: boolean;\r\n  circuitBreakerThreshold: number;\r\n  fallbackEnabled: boolean;\r\n}\r\n\r\nexport interface TenantFailureState {\r\n  tenantId: string;\r\n  failureCount: number;\r\n  lastFailure: Date;\r\n  isolationStatus: 'NORMAL' | 'DEGRADED' | 'ISOLATED' | 'QUARANTINED';\r\n  affectedServices: string[];\r\n  recoveryAttempts: number;\r\n  maxRecoveryAttempts: number;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Failure Domain Manager\r\n * \r\n * This class manages failure domains with strict containment strategies\r\n * to prevent cascade failures and maintain tenant isolation.\r\n */\r\nexport class FailureDomainManager {\r\n  private static instance: FailureDomainManager;\r\n  private auditLogger: any;\r\n  private failureEvents: Map<string, FailureEvent> = new Map();\r\n  private tenantFailureStates: Map<string, TenantFailureState> = new Map();\r\n  private serviceFailureStates: Map<string, { count: number; lastFailure: Date; status: string }> = new Map();\r\n  private domainConfigs: Map<FailureDomain, FailureDomainConfig>;\r\n  private activeContainments: Map<string, { strategy: ContainmentStrategy; startTime: Date }> = new Map();\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.domainConfigs = this.initializeDomainConfigs();\r\n    this.startFailureMonitoring();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): FailureDomainManager {\r\n    if (!FailureDomainManager.instance) {\r\n      FailureDomainManager.instance = new FailureDomainManager();\r\n    }\r\n    return FailureDomainManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Report failure event\r\n   */\r\n  async reportFailure(\r\n    domain: FailureDomain,\r\n    severity: FailureSeverity,\r\n    message: string,\r\n    tenantId?: string,\r\n    service?: string,\r\n    component?: string,\r\n    error?: Error,\r\n    metadata: Record<string, any> = {}\r\n  ): Promise<FailureEvent> {\r\n    const eventId = this.generateFailureId();\r\n    const timestamp = new Date();\r\n\r\n    // CRITICAL: Determine containment strategy\r\n    const containmentStrategy = this.determineContainmentStrategy(domain, severity, tenantId);\r\n\r\n    // CRITICAL: Calculate blast radius\r\n    const blastRadius = await this.calculateBlastRadius(domain, tenantId, service);\r\n\r\n    const failureEvent: FailureEvent = {\r\n      id: eventId,\r\n      domain,\r\n      severity,\r\n      tenantId,\r\n      service,\r\n      component,\r\n      timestamp,\r\n      message,\r\n      error,\r\n      metadata,\r\n      containmentStrategy,\r\n      blastRadius\r\n    };\r\n\r\n    // CRITICAL: Store failure event\r\n    this.failureEvents.set(eventId, failureEvent);\r\n\r\n    // CRITICAL: Apply containment strategy\r\n    await this.applyContainmentStrategy(failureEvent);\r\n\r\n    // CRITICAL: Update failure states\r\n    this.updateFailureStates(failureEvent);\r\n\r\n    // CRITICAL: Log failure event\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: tenantId || 'system',\r\n      actorId: 'system',\r\n      action: 'FAILURE_DETECTED',\r\n      resourceType: 'FAILURE_DOMAIN',\r\n      resourceId: eventId,\r\n      outcome: 'FAILURE',\r\n      correlationId: `failure_${eventId}`,\r\n      severity: this.mapSeverityToAuditLevel(severity),\r\n      metadata: {\r\n        domain,\r\n        severity,\r\n        containmentStrategy,\r\n        blastRadius,\r\n        affectedTenants: blastRadius.affectedTenants.length,\r\n        affectedServices: blastRadius.affectedServices.length\r\n      }\r\n    });\r\n\r\n    logger.error('Failure event reported', {\r\n      eventId,\r\n      domain,\r\n      severity,\r\n      tenantId,\r\n      service,\r\n      containmentStrategy,\r\n      blastRadius: blastRadius.estimatedImpact\r\n    });\r\n\r\n    return failureEvent;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check tenant isolation status\r\n   */\r\n  getTenantIsolationStatus(tenantId: string): TenantFailureState {\r\n    const state = this.tenantFailureStates.get(tenantId);\r\n    \r\n    if (!state) {\r\n      return {\r\n        tenantId,\r\n        failureCount: 0,\r\n        lastFailure: new Date(),\r\n        isolationStatus: 'NORMAL',\r\n        affectedServices: [],\r\n        recoveryAttempts: 0,\r\n        maxRecoveryAttempts: 3,\r\n        metadata: {}\r\n      };\r\n    }\r\n\r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if tenant is quarantined\r\n   */\r\n  isTenantQuarantined(tenantId: string): boolean {\r\n    const state = this.getTenantIsolationStatus(tenantId);\r\n    return state.isolationStatus === 'QUARANTINED';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if service is circuit broken\r\n   */\r\n  isServiceCircuitBroken(service: string): boolean {\r\n    const state = this.serviceFailureStates.get(service);\r\n    return state?.status === 'CIRCUIT_BROKEN' || false;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute operation with failure domain protection\r\n   */\r\n  async executeWithFailureProtection<T>(\r\n    domain: FailureDomain,\r\n    tenantId: string,\r\n    operation: () => Promise<T>,\r\n    fallback?: () => Promise<T>,\r\n    timeoutMs: number = 30000\r\n  ): Promise<T> {\r\n    const startTime = Date.now();\r\n    const operationId = this.generateOperationId();\r\n\r\n    try {\r\n      // CRITICAL: Pre-execution checks\r\n      this.validateExecutionPreconditions(domain, tenantId);\r\n\r\n      // CRITICAL: Execute with timeout\r\n      const result = await this.executeWithTimeout(operation, timeoutMs);\r\n\r\n      // CRITICAL: Log successful execution\r\n      this.auditLogger.logAuthorizationDecision({\r\n        tenantId,\r\n        actorId: 'system',\r\n        action: 'OPERATION_SUCCESS',\r\n        resourceType: 'FAILURE_DOMAIN_OPERATION',\r\n        resourceId: operationId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: `operation_${operationId}`,\r\n        metadata: {\r\n          domain,\r\n          duration: Date.now() - startTime\r\n        }\r\n      });\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      // CRITICAL: Handle failure with containment\r\n      const failureEvent = await this.reportFailure(\r\n        domain,\r\n        this.classifyErrorSeverity(error as Error),\r\n        `Operation failed: ${(error as Error).message}`,\r\n        tenantId,\r\n        undefined,\r\n        undefined,\r\n        error as Error,\r\n        { operationId, duration: Date.now() - startTime }\r\n      );\r\n\r\n      // CRITICAL: Apply fallback if available\r\n      if (fallback && this.shouldUseFallback(failureEvent)) {\r\n        try {\r\n          const fallbackResult = await fallback();\r\n          \r\n          this.auditLogger.logAuthorizationDecision({\r\n            tenantId,\r\n            actorId: 'system',\r\n            action: 'FALLBACK_SUCCESS',\r\n            resourceType: 'FAILURE_DOMAIN_OPERATION',\r\n            resourceId: operationId,\r\n            outcome: 'SUCCESS',\r\n            correlationId: `operation_${operationId}`,\r\n            metadata: {\r\n              domain,\r\n              failureEventId: failureEvent.id,\r\n              fallbackDuration: Date.now() - startTime\r\n            }\r\n          });\r\n\r\n          return fallbackResult;\r\n\r\n        } catch (fallbackError) {\r\n          await this.reportFailure(\r\n            domain,\r\n            'CRITICAL',\r\n            `Fallback failed: ${(fallbackError as Error).message}`,\r\n            tenantId,\r\n            undefined,\r\n            undefined,\r\n            fallbackError as Error,\r\n            { operationId, originalFailureId: failureEvent.id }\r\n          );\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Re-throw original error\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Recover tenant from failure state\r\n   */\r\n  async recoverTenant(tenantId: string, force: boolean = false): Promise<boolean> {\r\n    const state = this.getTenantIsolationStatus(tenantId);\r\n    \r\n    if (state.isolationStatus === 'NORMAL') {\r\n      return true; // Already recovered\r\n    }\r\n\r\n    if (!force && state.recoveryAttempts >= state.maxRecoveryAttempts) {\r\n      logger.warn('Tenant recovery attempts exceeded', { tenantId, attempts: state.recoveryAttempts });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // CRITICAL: Validate tenant is safe to recover\r\n      const safeToRecover = await this.validateTenantRecovery(tenantId);\r\n      \r\n      if (!safeToRecover && !force) {\r\n        logger.warn('Tenant not safe to recover', { tenantId });\r\n        return false;\r\n      }\r\n\r\n      // CRITICAL: Reset tenant failure state\r\n      this.tenantFailureStates.set(tenantId, {\r\n        ...state,\r\n        failureCount: 0,\r\n        lastFailure: new Date(),\r\n        isolationStatus: 'NORMAL',\r\n        affectedServices: [],\r\n        recoveryAttempts: state.recoveryAttempts + 1\r\n      });\r\n\r\n      // CRITICAL: Clear active containments for tenant\r\n      this.clearTenantContainments(tenantId);\r\n\r\n      // CRITICAL: Log recovery\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId,\r\n        actorId: 'system',\r\n        action: 'TENANT_RECOVERED',\r\n        resourceType: 'FAILURE_DOMAIN',\r\n        resourceId: tenantId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: `recovery_${tenantId}`,\r\n        severity: 'LOW',\r\n        metadata: {\r\n          previousStatus: state.isolationStatus,\r\n          recoveryAttempts: state.recoveryAttempts + 1,\r\n          forced: force\r\n        }\r\n      });\r\n\r\n      logger.info('Tenant recovered successfully', { tenantId, forced });\r\n      return true;\r\n\r\n    } catch (error) {\r\n      logger.error('Failed to recover tenant', error as Error, { tenantId });\r\n      \r\n      await this.reportFailure(\r\n        'TENANT',\r\n        'HIGH',\r\n        `Recovery failed: ${(error as Error).message}`,\r\n        tenantId,\r\n        undefined,\r\n        undefined,\r\n        error as Error,\r\n        { recoveryAttempt: state.recoveryAttempts + 1 }\r\n      );\r\n\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get failure domain statistics\r\n   */\r\n  getFailureDomainStatistics(): {\r\n    totalFailures: number;\r\n    failuresByDomain: Record<FailureDomain, number>;\r\n    failuresBySeverity: Record<FailureSeverity, number>;\r\n    quarantinedTenants: number;\r\n    circuitBrokenServices: number;\r\n    activeContainments: number;\r\n    averageRecoveryTime: number;\r\n  } {\r\n    const totalFailures = this.failureEvents.size;\r\n    const failuresByDomain: Record<FailureDomain, number> = {\r\n      TENANT: 0,\r\n      SERVICE: 0,\r\n      DATABASE: 0,\r\n      QUEUE: 0,\r\n      CACHE: 0,\r\n      EXTERNAL: 0\r\n    };\r\n    const failuresBySeverity: Record<FailureSeverity, number> = {\r\n      LOW: 0,\r\n      MEDIUM: 0,\r\n      HIGH: 0,\r\n      CRITICAL: 0\r\n    };\r\n\r\n    let quarantinedTenants = 0;\r\n    let circuitBrokenServices = 0;\r\n\r\n    // CRITICAL: Count failures by domain and severity\r\n    for (const failure of this.failureEvents.values()) {\r\n      failuresByDomain[failure.domain]++;\r\n      failuresBySeverity[failure.severity]++;\r\n    }\r\n\r\n    // CRITICAL: Count quarantined tenants and circuit broken services\r\n    for (const state of this.tenantFailureStates.values()) {\r\n      if (state.isolationStatus === 'QUARANTINED') {\r\n        quarantinedTenants++;\r\n      }\r\n    }\r\n\r\n    for (const state of this.serviceFailureStates.values()) {\r\n      if (state.status === 'CIRCUIT_BROKEN') {\r\n        circuitBrokenServices++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalFailures,\r\n      failuresByDomain,\r\n      failuresBySeverity,\r\n      quarantinedTenants,\r\n      circuitBrokenServices,\r\n      activeContainments: this.activeContainments.size,\r\n      averageRecoveryTime: this.calculateAverageRecoveryTime()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Determine containment strategy\r\n   */\r\n  private determineContainmentStrategy(\r\n    domain: FailureDomain,\r\n    severity: FailureSeverity,\r\n    tenantId?: string\r\n  ): ContainmentStrategy {\r\n    const config = this.domainConfigs.get(domain);\r\n    \r\n    if (!config) {\r\n      return 'FAIL_FAST';\r\n    }\r\n\r\n    // CRITICAL: Tenant-specific failures should be isolated\r\n    if (tenantId && config.tenantIsolation) {\r\n      return 'ISOLATE';\r\n    }\r\n\r\n    // CRITICAL: High severity failures should fail fast\r\n    if (severity === 'CRITICAL') {\r\n      return 'FAIL_FAST';\r\n    }\r\n\r\n    // CRITICAL: Service failures should use circuit breaker\r\n    if (domain === 'SERVICE' && config.circuitBreakerThreshold > 0) {\r\n      return 'CIRCUIT_BREAK';\r\n    }\r\n\r\n    // CRITICAL: Database and queue failures should degrade\r\n    if (domain === 'DATABASE' || domain === 'QUEUE') {\r\n      return 'DEGRADE';\r\n    }\r\n\r\n    return 'FAIL_FAST';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate blast radius\r\n   */\r\n  private async calculateBlastRadius(\r\n    domain: FailureDomain,\r\n    tenantId?: string,\r\n    service?: string\r\n  ): Promise<FailureEvent['blastRadius']> {\r\n    const affectedTenants: string[] = [];\r\n    const affectedServices: string[] = [];\r\n\r\n    // CRITICAL: Tenant-specific failures have limited blast radius\r\n    if (tenantId) {\r\n      affectedTenants.push(tenantId);\r\n      \r\n      // CRITICAL: Check if tenant failure affects other services\r\n      const tenantState = this.getTenantIsolationStatus(tenantId);\r\n      affectedServices.push(...tenantState.affectedServices);\r\n    }\r\n\r\n    // CRITICAL: Service failures affect all tenants using that service\r\n    if (service) {\r\n      affectedServices.push(service);\r\n      \r\n      // CRITICAL: In a real implementation, you'd query which tenants use this service\r\n      // For now, we'll estimate based on failure patterns\r\n      const estimatedTenantCount = this.estimateTenantCountForService(service);\r\n      if (estimatedTenantCount > 0) {\r\n        // CRITICAL: Service failures have extensive blast radius\r\n        return {\r\n          affectedTenants: Array.from({ length: Math.min(estimatedTenantCount, 100) }, (_, i) => `tenant-${i}`),\r\n          affectedServices: [service],\r\n          estimatedImpact: estimatedTenantCount > 50 ? 'EXTENSIVE' : 'MODERATE'\r\n        };\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Database and queue failures have extensive impact\r\n    if (domain === 'DATABASE' || domain === 'QUEUE') {\r\n      return {\r\n        affectedTenants: ['ALL_TENANTS'],\r\n        affectedServices: ['ALL_SERVICES'],\r\n        estimatedImpact: 'EXTENSIVE'\r\n      };\r\n    }\r\n\r\n    // CRITICAL: Cache and external failures have moderate impact\r\n    if (domain === 'CACHE' || domain === 'EXTERNAL') {\r\n      return {\r\n        affectedTenants: ['AFFECTED_TENANTS'],\r\n        affectedServices: affectedServices.length > 0 ? affectedServices : ['DEPENDENT_SERVICES'],\r\n        estimatedImpact: 'MODERATE'\r\n      };\r\n    }\r\n\r\n    return {\r\n      affectedTenants,\r\n      affectedServices,\r\n      estimatedImpact: affectedTenants.length > 10 || affectedServices.length > 5 ? 'MODERATE' : 'MINIMAL'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Apply containment strategy\r\n   */\r\n  private async applyContainmentStrategy(failureEvent: FailureEvent): Promise<void> {\r\n    const { domain, severity, tenantId, service, containmentStrategy } = failureEvent;\r\n\r\n    switch (containmentStrategy) {\r\n      case 'ISOLATE':\r\n        await this.isolateTenant(tenantId!);\r\n        break;\r\n      case 'DEGRADE':\r\n        await this.degradeService(service || domain);\r\n        break;\r\n      case 'FAIL_FAST':\r\n        await this.failFast(domain, tenantId);\r\n        break;\r\n      case 'CIRCUIT_BREAK':\r\n        await this.circuitBreakService(service!);\r\n        break;\r\n    }\r\n\r\n    // CRITICAL: Track active containment\r\n    this.activeContainments.set(failureEvent.id, {\r\n      strategy: containmentStrategy,\r\n      startTime: new Date()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Isolate tenant\r\n   */\r\n  private async isolateTenant(tenantId: string): Promise<void> {\r\n    const state = this.getTenantIsolationStatus(tenantId);\r\n    \r\n    this.tenantFailureStates.set(tenantId, {\r\n      ...state,\r\n      failureCount: state.failureCount + 1,\r\n      lastFailure: new Date(),\r\n      isolationStatus: state.failureCount >= 3 ? 'QUARANTINED' : 'ISOLATED',\r\n      affectedServices: [...state.affectedServices, 'ALL_SERVICES']\r\n    });\r\n\r\n    logger.warn('Tenant isolated due to failure', { tenantId, status: state.isolationStatus });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Degrade service\r\n   */\r\n  private async degradeService(service: string): Promise<void> {\r\n    const currentState = this.serviceFailureStates.get(service) || { count: 0, lastFailure: new Date(), status: 'NORMAL' };\r\n    \r\n    this.serviceFailureStates.set(service, {\r\n      count: currentState.count + 1,\r\n      lastFailure: new Date(),\r\n      status: currentState.count >= 5 ? 'DEGRADED' : 'WARNING'\r\n    });\r\n\r\n    logger.warn('Service degraded due to failure', { service, status: currentState.status });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Fail fast\r\n   */\r\n  private async failFast(domain: FailureDomain, tenantId?: string): Promise<void> {\r\n    // CRITICAL: Immediate rejection of all operations in this domain\r\n    logger.error('Fail fast activated', { domain, tenantId });\r\n    \r\n    // CRITICAL: In a real implementation, this would trigger immediate circuit breaking\r\n    // and rejection of all operations in the affected domain\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Circuit break service\r\n   */\r\n  private async circuitBreakService(service: string): Promise<void> {\r\n    const currentState = this.serviceFailureStates.get(service) || { count: 0, lastFailure: new Date(), status: 'NORMAL' };\r\n    \r\n    this.serviceFailureStates.set(service, {\r\n      count: currentState.count + 1,\r\n      lastFailure: new Date(),\r\n      status: 'CIRCUIT_BROKEN'\r\n    });\r\n\r\n    logger.error('Service circuit broken', { service });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update failure states\r\n   */\r\n  private updateFailureStates(failureEvent: FailureEvent): void {\r\n    const { domain, tenantId, service } = failureEvent;\r\n\r\n    // CRITICAL: Update tenant state\r\n    if (tenantId) {\r\n      const tenantState = this.getTenantIsolationStatus(tenantId);\r\n      this.tenantFailureStates.set(tenantId, {\r\n        ...tenantState,\r\n        failureCount: tenantState.failureCount + 1,\r\n        lastFailure: failureEvent.timestamp,\r\n        affectedServices: service ? [...new Set([...tenantState.affectedServices, service])] : tenantState.affectedServices\r\n      });\r\n    }\r\n\r\n    // CRITICAL: Update service state\r\n    if (service) {\r\n      const serviceState = this.serviceFailureStates.get(service) || { count: 0, lastFailure: new Date(), status: 'NORMAL' };\r\n      this.serviceFailureStates.set(service, {\r\n        count: serviceState.count + 1,\r\n        lastFailure: failureEvent.timestamp,\r\n        status: serviceState.status\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate execution preconditions\r\n   */\r\n  private validateExecutionPreconditions(domain: FailureDomain, tenantId: string): void {\r\n    // CRITICAL: Check tenant isolation status\r\n    const tenantState = this.getTenantIsolationStatus(tenantId);\r\n    if (tenantState.isolationStatus === 'QUARANTINED') {\r\n      throw new Error(`Tenant ${tenantId} is quarantined and cannot execute operations`);\r\n    }\r\n\r\n    // CRITICAL: Check domain-specific preconditions\r\n    const config = this.domainConfigs.get(domain);\r\n    if (config && config.cascadePrevention) {\r\n      // CRITICAL: Additional domain-specific validations would go here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute with timeout\r\n   */\r\n  private async executeWithTimeout<T>(operation: () => Promise<T>, timeoutMs: number): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => {\r\n        reject(new Error(`Operation timed out after ${timeoutMs}ms`));\r\n      }, timeoutMs);\r\n\r\n      operation()\r\n        .then(result => {\r\n          clearTimeout(timeout);\r\n          resolve(result);\r\n        })\r\n        .catch(error => {\r\n          clearTimeout(timeout);\r\n          reject(error);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Classify error severity\r\n   */\r\n  private classifyErrorSeverity(error: Error): FailureSeverity {\r\n    const message = error.message.toLowerCase();\r\n    \r\n    if (message.includes('timeout') || message.includes('network')) {\r\n      return 'MEDIUM';\r\n    }\r\n    \r\n    if (message.includes('database') || message.includes('connection')) {\r\n      return 'HIGH';\r\n    }\r\n    \r\n    if (message.includes('critical') || message.includes('fatal')) {\r\n      return 'CRITICAL';\r\n    }\r\n    \r\n    return 'LOW';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Map severity to audit level\r\n   */\r\n  private mapSeverityToAuditLevel(severity: FailureSeverity): string {\r\n    switch (severity) {\r\n      case 'LOW': return 'LOW';\r\n      case 'MEDIUM': return 'MEDIUM';\r\n      case 'HIGH': return 'HIGH';\r\n      case 'CRITICAL': return 'CRITICAL';\r\n      default: return 'MEDIUM';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Should use fallback\r\n   */\r\n  private shouldUseFallback(failureEvent: FailureEvent): boolean {\r\n    const config = this.domainConfigs.get(failureEvent.domain);\r\n    return config?.fallbackEnabled || false;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate tenant recovery\r\n   */\r\n  private async validateTenantRecovery(tenantId: string): Promise<boolean> {\r\n    // CRITICAL: Check if tenant has active failures\r\n    const state = this.getTenantIsolationStatus(tenantId);\r\n    \r\n    // CRITICAL: Don't recover if recent failures occurred\r\n    const timeSinceLastFailure = Date.now() - state.lastFailure.getTime();\r\n    if (timeSinceLastFailure < 300000) { // 5 minutes\r\n      return false;\r\n    }\r\n\r\n    // CRITICAL: Additional validation logic would go here\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Clear tenant containments\r\n   */\r\n  private clearTenantContainments(tenantId: string): void {\r\n    for (const [eventId, containment] of this.activeContainments.entries()) {\r\n      // CRITICAL: In a real implementation, you'd check if this containment is for the tenant\r\n      // For now, we'll clear all containments for simplicity\r\n      this.activeContainments.delete(eventId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Estimate tenant count for service\r\n   */\r\n  private estimateTenantCountForService(service: string): number {\r\n    // CRITICAL: This would query the database to get actual tenant count\r\n    // For now, return reasonable estimates\r\n    const serviceEstimates: Record<string, number> = {\r\n      'auth': 1000,\r\n      'billing': 1000,\r\n      'audit': 1000,\r\n      'data': 800,\r\n      'cache': 600,\r\n      'queue': 400,\r\n      'external': 200\r\n    };\r\n\r\n    return serviceEstimates[service] || 100;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate average recovery time\r\n   */\r\n  private calculateAverageRecoveryTime(): number {\r\n    // CRITICAL: This would calculate actual recovery times from historical data\r\n    // For now, return a reasonable estimate\r\n    return 300000; // 5 minutes\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize domain configurations\r\n   */\r\n  private initializeDomainConfigs(): Map<FailureDomain, FailureDomainConfig> {\r\n    return new Map([\r\n      ['TENANT', {\r\n        maxConcurrentFailures: 5,\r\n        failureWindowMs: 300000, // 5 minutes\r\n        recoveryTimeoutMs: 600000, // 10 minutes\r\n        cascadePrevention: true,\r\n        tenantIsolation: true,\r\n        circuitBreakerThreshold: 3,\r\n        fallbackEnabled: false\r\n      }],\r\n      ['SERVICE', {\r\n        maxConcurrentFailures: 10,\r\n        failureWindowMs: 60000, // 1 minute\r\n        recoveryTimeoutMs: 300000, // 5 minutes\r\n        cascadePrevention: true,\r\n        tenantIsolation: false,\r\n        circuitBreakerThreshold: 5,\r\n        fallbackEnabled: true\r\n      }],\r\n      ['DATABASE', {\r\n        maxConcurrentFailures: 3,\r\n        failureWindowMs: 30000, // 30 seconds\r\n        recoveryTimeoutMs: 120000, // 2 minutes\r\n        cascadePrevention: true,\r\n        tenantIsolation: false,\r\n        circuitBreakerThreshold: 2,\r\n        fallbackEnabled: true\r\n      }],\r\n      ['QUEUE', {\r\n        maxConcurrentFailures: 5,\r\n        failureWindowMs: 60000, // 1 minute\r\n        recoveryTimeoutMs: 180000, // 3 minutes\r\n        cascadePrevention: true,\r\n        tenantIsolation: false,\r\n        circuitBreakerThreshold: 3,\r\n        fallbackEnabled: true\r\n      }],\r\n      ['CACHE', {\r\n        maxConcurrentFailures: 15,\r\n        failureWindowMs: 30000, // 30 seconds\r\n        recoveryTimeoutMs: 60000, // 1 minute\r\n        cascadePrevention: false,\r\n        tenantIsolation: false,\r\n        circuitBreakerThreshold: 10,\r\n        fallbackEnabled: true\r\n      }],\r\n      ['EXTERNAL', {\r\n        maxConcurrentFailures: 8,\r\n        failureWindowMs: 120000, // 2 minutes\r\n        recoveryTimeoutMs: 300000, // 5 minutes\r\n        cascadePrevention: true,\r\n        tenantIsolation: false,\r\n        circuitBreakerThreshold: 5,\r\n        fallbackEnabled: true\r\n      }]\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start failure monitoring\r\n   */\r\n  private startFailureMonitoring(): void {\r\n    // CRITICAL: Periodic cleanup of old failure events\r\n    setInterval(() => {\r\n      this.cleanupOldFailures();\r\n    }, 300000); // Every 5 minutes\r\n\r\n    // CRITICAL: Periodic recovery attempts\r\n    setInterval(() => {\r\n      this.attemptRecoveries();\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup old failures\r\n   */\r\n  private cleanupOldFailures(): void {\r\n    const cutoffTime = new Date();\r\n    cutoffTime.setHours(cutoffTime.getHours() - 24); // 24 hours ago\r\n\r\n    let cleanedCount = 0;\r\n    for (const [eventId, failure] of this.failureEvents.entries()) {\r\n      if (failure.timestamp < cutoffTime) {\r\n        this.failureEvents.delete(eventId);\r\n        cleanedCount++;\r\n      }\r\n    }\r\n\r\n    if (cleanedCount > 0) {\r\n      logger.info('Cleaned up old failure events', { cleanedCount });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Attempt recoveries\r\n   */\r\n  private attemptRecoveries(): void {\r\n    for (const [tenantId, state] of this.tenantFailureStates.entries()) {\r\n      if (state.isolationStatus !== 'NORMAL' && state.recoveryAttempts < state.maxRecoveryAttempts) {\r\n        this.recoverTenant(tenantId).catch(error => {\r\n          logger.error('Failed recovery attempt', error, { tenantId });\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate failure ID\r\n   */\r\n  private generateFailureId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `failure_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate operation ID\r\n   */\r\n  private generateOperationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `op_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global failure domain manager instance\r\n */\r\nexport const failureDomainManager = FailureDomainManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const reportFailure = async (\r\n  domain: FailureDomain,\r\n  severity: FailureSeverity,\r\n  message: string,\r\n  tenantId?: string,\r\n  service?: string,\r\n  component?: string,\r\n  error?: Error,\r\n  metadata: Record<string, any> = {}\r\n): Promise<FailureEvent> => {\r\n  return await failureDomainManager.reportFailure(domain, severity, message, tenantId, service, component, error, metadata);\r\n};\r\n\r\nexport const executeWithFailureProtection = async <T>(\r\n  domain: FailureDomain,\r\n  tenantId: string,\r\n  operation: () => Promise<T>,\r\n  fallback?: () => Promise<T>,\r\n  timeoutMs: number = 30000\r\n): Promise<T> => {\r\n  return await failureDomainManager.executeWithFailureProtection(domain, tenantId, operation, fallback, timeoutMs);\r\n};\r\n\r\nexport const getTenantIsolationStatus = (tenantId: string): TenantFailureState => {\r\n  return failureDomainManager.getTenantIsolationStatus(tenantId);\r\n};\r\n\r\nexport const isTenantQuarantined = (tenantId: string): boolean => {\r\n  return failureDomainManager.isTenantQuarantined(tenantId);\r\n};\r\n\r\nexport const isServiceCircuitBroken = (service: string): boolean => {\r\n  return failureDomainManager.isServiceCircuitBroken(service);\r\n};\r\n\r\nexport const recoverTenant = async (tenantId: string, force: boolean = false): Promise<boolean> => {\r\n  return await failureDomainManager.recoverTenant(tenantId, force);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\idempotency-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":153,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":153,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":163,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":163,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Idempotency Manager\n// MANDATORY: Global idempotency key system with exactly-once semantics\n\nimport { logger } from '../utils/structured-logger.js';\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\nimport { TenantContext } from '../tenant/tenant-isolation.js';\nimport { devInvariant } from '../runtime/dev-invariants.js';\n\nexport type IdempotencyScope = 'GLOBAL' | 'TENANT' | 'USER' | 'SESSION' | 'OPERATION';\nexport type ExecutionStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED' | 'EXPIRED';\n\nexport interface IdempotencyKey {\n  id: string;\n  key: string;\n  scope: IdempotencyScope;\n  tenantId?: string;\n  userId?: string;\n  sessionId?: string;\n  operationType: string;\n  status: ExecutionStatus;\n  result?: any;\n  error?: string;\n  createdAt: Date;\n  expiresAt: Date;\n  lastExecutedAt?: Date;\n  executionCount: number;\n  maxExecutions: number;\n  metadata: Record<string, any>;\n}\n\nexport interface IdempotencyConfig {\n  defaultTtl: number; // Time to live in milliseconds\n  maxExecutionCount: number;\n  cleanupInterval: number; // Cleanup interval in milliseconds\n  enableReplayProtection: boolean;\n  enableCrossRequestProtection: boolean;\n  enablePersistence: boolean;\n}\n\nexport interface IdempotencyResult {\n  isDuplicate: boolean;\n  status: ExecutionStatus;\n  result?: any;\n  error?: string;\n  key: IdempotencyKey;\n  shouldExecute: boolean;\n}\n\n/**\n * CRITICAL: Idempotency Manager\n * \n * This class manages global idempotency keys with exactly-once execution guarantees\n * across API requests and background jobs with database-level enforcement.\n */\nexport class IdempotencyManager {\n  private static instance: IdempotencyManager;\n  private static keyStore: Map<string, IdempotencyKey> = new Map(); // CRITICAL: Static key store\n  private config: IdempotencyConfig;\n  private auditLogger: any;\n  private cleanupTimer?: NodeJS.Timeout;\n\n  private constructor() {\n    this.auditLogger = getImmutableAuditLogger();\n    this.config = this.initializeConfig();\n    this.startCleanupTimer();\n  }\n\n  /**\n   * CRITICAL: Get singleton instance\n   */\n  static getInstance(): IdempotencyManager {\n    if (!IdempotencyManager.instance) {\n      IdempotencyManager.instance = new IdempotencyManager();\n    }\n    return IdempotencyManager.instance;\n  }\n\n  /**\n   * CRITICAL: Initialize configuration\n   */\n  private initializeConfig(): IdempotencyConfig {\n    return {\n      defaultTtl: 300000, // 5 minutes\n      maxExecutionCount: 3,\n      cleanupInterval: 60000, // 1 minute\n      enableReplayProtection: true,\n      enableCrossRequestProtection: true,\n      enablePersistence: false // In-memory only for now\n    };\n  }\n\n  /**\n   * CRITICAL: Start cleanup timer\n   */\n  private startCleanupTimer(): void {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupExpiredKeys();\n    }, this.config.cleanupInterval);\n  }\n\n  /**\n   * CRITICAL: Stop cleanup timer\n   */\n  private stopCleanupTimer(): void {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = undefined;\n    }\n  }\n\n  /**\n   * CRITICAL: Generate idempotency key\n   */\n  generateKey(\n    operationType: string,\n    scope: IdempotencyScope,\n    tenantContext?: TenantContext,\n    userId?: string,\n    sessionId?: string,\n    additionalContext?: Record<string, any>\n  ): string {\n    const keyParts = [operationType, scope];\n    \n    if (scope === 'TENANT' && tenantContext) {\n      keyParts.push(tenantContext.tenantId);\n    }\n    \n    if (userId) {\n      keyParts.push(userId);\n    }\n    \n    if (sessionId) {\n      keyParts.push(`session:${sessionId}`);\n    }\n    \n    // CRITICAL: Only include hash if there's actual additional context\n    if (additionalContext && Object.keys(additionalContext).length > 0) {\n      const contextHash = this.hashObject(additionalContext);\n      keyParts.push(contextHash);\n    }\n    \n    return keyParts.join(':');\n  }\n\n  /**\n   * CRITICAL: Hash object for consistent key generation\n   */\n  private hashObject(obj: Record<string, any>): string {\n    const crypto = require('crypto');\n    const hash = crypto.createHash('sha256');\n    hash.update(JSON.stringify(obj, Object.keys(obj).sort()));\n    return hash.digest('hex').substring(0, 32); // Increased from 16 to 32 characters\n  }\n\n  /**\n   * CRITICAL: Generate unique key ID\n   */\n  private generateKeyId(): string {\n    const crypto = require('crypto');\n    return crypto.randomUUID();\n  }\n\n  /**\n   * CRITICAL: Check idempotency and prepare for execution\n   */\n  async checkIdempotency(\n    key: string,\n    operationType: string,\n    scope: IdempotencyScope,\n    tenantContext?: TenantContext,\n    userId?: string,\n    sessionId?: string,\n    ttl?: number,\n    maxExecutions?: number,\n    metadata: Record<string, any> = {}\n  ): Promise<IdempotencyResult> {\n    devInvariant(!!key && key.length > 0, 'IDEMPOTENCY_LIFECYCLE_INVALID', 'Idempotency key must be a non-empty string.', { key });\n    devInvariant(!!operationType && operationType.length > 0, 'IDEMPOTENCY_LIFECYCLE_INVALID', 'Idempotency operationType must be a non-empty string.', { operationType });\n\n    const now = new Date();\n    const effectiveTtl = ttl || this.config.defaultTtl;\n    const effectiveMaxExecutions = maxExecutions || this.config.maxExecutionCount;\n\n    logger.debug('checkIdempotency start', { key, operationType, scope });\n\n    // CRITICAL: Check if key exists\n    let idempotencyKey = IdempotencyManager.keyStore.get(key);\n    devInvariant(!idempotencyKey || idempotencyKey.key === key, 'IDEMPOTENCY_LIFECYCLE_INVALID', 'Idempotency keystore corruption: stored key mismatch.', {\n      requestedKey: key,\n      storedKey: idempotencyKey?.key,\n    });\n    \n    logger.debug('keyStore lookup', { key, found: !!idempotencyKey, status: idempotencyKey?.status });\n\n    if (!idempotencyKey) {\n      // CRITICAL: Create new idempotency key\n      idempotencyKey = {\n        id: this.generateKeyId(),\n        key,\n        scope,\n        tenantId: tenantContext?.tenantId,\n        userId,\n        sessionId,\n        operationType,\n        status: 'PENDING',\n        createdAt: now,\n        expiresAt: new Date(now.getTime() + effectiveTtl),\n        executionCount: 0,\n        maxExecutions: effectiveMaxExecutions,\n        metadata\n      };\n\n      IdempotencyManager.keyStore.set(key, idempotencyKey);\n      \n      logger.debug('Created new idempotency key', { key, id: idempotencyKey.id });\n\n      // CRITICAL: Log key creation\n      this.auditLogger.logAuthorizationDecision({\n        tenantId: tenantContext?.tenantId || 'system',\n        actorId: userId || 'system',\n        action: 'IDEMPOTENCY_KEY_CREATED',\n        resourceType: 'IDEMPOTENCY_KEY',\n        resourceId: idempotencyKey.id,\n        outcome: 'SUCCESS',\n        correlationId: `idempotency_${idempotencyKey.id}`,\n        metadata: {\n          key,\n          operationType,\n          scope,\n          ttl: effectiveTtl,\n          maxExecutions: effectiveMaxExecutions\n        }\n      });\n\n      return {\n        isDuplicate: false,\n        status: 'PENDING',\n        key: idempotencyKey,\n        shouldExecute: true\n      };\n    }\n\n    // CRITICAL: Check if key has expired\n    if (idempotencyKey.expiresAt < now) {\n      idempotencyKey.status = 'EXPIRED';\n      IdempotencyManager.keyStore.set(key, idempotencyKey);\n\n      // CRITICAL: Log expiration\n      this.auditLogger.logAuthorizationDecision({\n        tenantId: idempotencyKey.tenantId || 'system',\n        actorId: idempotencyKey.userId || 'system',\n        action: 'IDEMPOTENCY_KEY_EXPIRED',\n        resourceType: 'IDEMPOTENCY_KEY',\n        resourceId: idempotencyKey.id,\n        outcome: 'SUCCESS',\n        correlationId: `idempotency_${idempotencyKey.id}`,\n        metadata: {\n          key,\n          operationType,\n          expiredAt: now\n        }\n      });\n\n      // CRITICAL: Create new key for expired one\n      // Remove the expired record so the next check can create a fresh key entry.\n      IdempotencyManager.keyStore.delete(key);\n      return await this.checkIdempotency(key, operationType, scope, tenantContext, userId, sessionId, ttl, maxExecutions, metadata);\n    }\n\n    // CRITICAL: Check execution count\n    if (idempotencyKey.executionCount >= idempotencyKey.maxExecutions) {\n      // CRITICAL: If we have a completed result, return it instead of throwing error\n      if (idempotencyKey.status === 'COMPLETED' && idempotencyKey.result !== undefined) {\n        return {\n          isDuplicate: true,\n          status: 'COMPLETED',\n          result: idempotencyKey.result,\n          key: idempotencyKey,\n          shouldExecute: false\n        };\n      }\n      \n      // CRITICAL: If we have a failed result, return the error\n      if (idempotencyKey.status === 'FAILED' && idempotencyKey.error) {\n        return {\n          isDuplicate: true,\n          status: 'FAILED',\n          error: idempotencyKey.error,\n          key: idempotencyKey,\n          shouldExecute: false\n        };\n      }\n      \n      // CRITICAL: Only throw error if no result available\n      return {\n        isDuplicate: true,\n        status: idempotencyKey.status,\n        error: `Maximum execution count (${idempotencyKey.maxExecutions}) exceeded`,\n        key: idempotencyKey,\n        shouldExecute: false\n      };\n    }\n\n    // CRITICAL: Check if currently executing (prevent concurrent execution)\n    if (idempotencyKey.status === 'IN_PROGRESS') {\n      const waitTime = Date.now() - idempotencyKey.lastExecutedAt!.getTime();\n      \n      logger.debug('Detected IN_PROGRESS key', { key, waitTime, status: idempotencyKey.status });\n      \n      // CRITICAL: If it's been executing too long, consider it failed\n      if (waitTime > 300000) { // 5 minutes\n        idempotencyKey.status = 'FAILED';\n        idempotencyKey.error = 'Execution timeout';\n        IdempotencyManager.keyStore.set(key, idempotencyKey);\n\n        return {\n          isDuplicate: true,\n          status: 'FAILED',\n          error: 'Previous execution timed out',\n          key: idempotencyKey,\n          shouldExecute: false\n        };\n      }\n\n      logger.debug('Returning IN_PROGRESS result', { key });\n      return {\n        isDuplicate: true,\n        status: 'IN_PROGRESS',\n        error: 'Operation currently in progress',\n        key: idempotencyKey,\n        shouldExecute: false\n      };\n    }\n\n    // CRITICAL: Return existing result if completed\n    if (idempotencyKey.status === 'COMPLETED') {\n      return {\n        isDuplicate: true,\n        status: 'COMPLETED',\n        result: idempotencyKey.result,\n        key: idempotencyKey,\n        shouldExecute: false\n      };\n    }\n\n    // CRITICAL: Return error if failed\n    if (idempotencyKey.status === 'FAILED') {\n      return {\n        isDuplicate: true,\n        status: 'FAILED',\n        error: idempotencyKey.error,\n        key: idempotencyKey,\n        shouldExecute: false\n      };\n    }\n\n    // CRITICAL: Existing pending key found - allow execution but mark as duplicate\n    return {\n      isDuplicate: true,\n      status: 'PENDING',\n      key: idempotencyKey,\n      shouldExecute: true\n    };\n  }\n\n  /**\n   * CRITICAL: Clear the key store (for testing)\n   */\n  clearKeyStore(): void {\n    IdempotencyManager.keyStore.clear();\n    logger.debug('Key store cleared');\n  }\n\n  /**\n   * CRITICAL: Start execution with idempotency protection\n   */\n  async startExecution(\n    key: string,\n    tenantContext?: TenantContext,\n    userId?: string\n  ): Promise<void> {\n    devInvariant(!!key && key.length > 0, 'IDEMPOTENCY_LIFECYCLE_INVALID', 'startExecution requires non-empty key.', { key });\n    const idempotencyKey = IdempotencyManager.keyStore.get(key);\n    \n    if (!idempotencyKey) {\n      throw new Error(`Idempotency key ${key} not found`);\n    }\n\n    devInvariant(\n      idempotencyKey.status === 'PENDING' || idempotencyKey.status === 'IN_PROGRESS',\n      'IDEMPOTENCY_LIFECYCLE_INVALID',\n      'startExecution called with unexpected key status.',\n      {\n        key,\n        status: idempotencyKey.status,\n        executionCount: idempotencyKey.executionCount,\n      },\n    );\n\n    if (idempotencyKey.status !== 'PENDING') {\n      throw new Error(`Cannot start execution for key ${key} with status ${idempotencyKey.status}`);\n    }\n\n    // CRITICAL: Update status to in progress\n    idempotencyKey.status = 'IN_PROGRESS';\n    idempotencyKey.lastExecutedAt = new Date();\n    idempotencyKey.executionCount++;\n    \n    IdempotencyManager.keyStore.set(key, idempotencyKey);\n\n    // CRITICAL: Log execution start\n    this.auditLogger.logAuthorizationDecision({\n      tenantId: idempotencyKey.tenantId || 'system',\n      actorId: userId || 'system',\n      action: 'EXECUTION_STARTED',\n      resourceType: 'IDEMPOTENCY_KEY',\n      resourceId: idempotencyKey.id,\n      outcome: 'SUCCESS',\n      correlationId: `idempotency_${idempotencyKey.id}`,\n      metadata: {\n        key,\n        operationType: idempotencyKey.operationType,\n        executionCount: idempotencyKey.executionCount\n      }\n    });\n\n    logger.info('Execution started', {\n      key,\n      operationType: idempotencyKey.operationType,\n      executionCount: idempotencyKey.executionCount\n    });\n  }\n\n  /**\n   * CRITICAL: Complete execution with result\n   */\n  async completeExecution<T>(\n    key: string,\n    result: T,\n    tenantContext?: TenantContext,\n    userId?: string\n  ): Promise<void> {\n    devInvariant(!!key && key.length > 0, 'IDEMPOTENCY_LIFECYCLE_INVALID', 'completeExecution requires non-empty key.', { key });\n    const idempotencyKey = IdempotencyManager.keyStore.get(key);\n    \n    if (!idempotencyKey) {\n      throw new Error(`Idempotency key ${key} not found`);\n    }\n\n    devInvariant(idempotencyKey.status === 'IN_PROGRESS', 'IDEMPOTENCY_LIFECYCLE_INVALID', 'completeExecution called when key is not IN_PROGRESS.', {\n      key,\n      status: idempotencyKey.status,\n      executionCount: idempotencyKey.executionCount,\n    });\n\n    if (idempotencyKey.status !== 'IN_PROGRESS') {\n      throw new Error(`Cannot complete execution for key ${key} with status ${idempotencyKey.status}`);\n    }\n\n    // CRITICAL: Update status to completed\n    idempotencyKey.status = 'COMPLETED';\n    idempotencyKey.result = result;\n    idempotencyKey.lastExecutedAt = new Date();\n    \n    IdempotencyManager.keyStore.set(key, idempotencyKey);\n\n    // CRITICAL: Log completion\n    this.auditLogger.logAuthorizationDecision({\n      tenantId: idempotencyKey.tenantId || 'system',\n      actorId: userId || 'system',\n      action: 'EXECUTION_COMPLETED',\n      resourceType: 'IDEMPOTENCY_KEY',\n      resourceId: idempotencyKey.id,\n      outcome: 'SUCCESS',\n      correlationId: `idempotency_${idempotencyKey.id}`,\n      metadata: {\n        key,\n        operationType: idempotencyKey.operationType,\n        executionCount: idempotencyKey.executionCount,\n        executionTime: Date.now() - idempotencyKey.createdAt.getTime()\n      }\n    });\n\n    logger.info('Execution completed', {\n      key,\n      operationType: idempotencyKey.operationType,\n      executionCount: idempotencyKey.executionCount\n    });\n  }\n\n  /**\n   * CRITICAL: Fail execution with error\n   */\n  async failExecution(\n    key: string,\n    error: Error,\n    tenantContext?: TenantContext,\n    userId?: string\n  ): Promise<void> {\n    devInvariant(!!key && key.length > 0, 'IDEMPOTENCY_LIFECYCLE_INVALID', 'failExecution requires non-empty key.', { key });\n    const idempotencyKey = IdempotencyManager.keyStore.get(key);\n    \n    if (!idempotencyKey) {\n      throw new Error(`Idempotency key ${key} not found`);\n    }\n\n    devInvariant(idempotencyKey.status === 'IN_PROGRESS', 'IDEMPOTENCY_LIFECYCLE_INVALID', 'failExecution called when key is not IN_PROGRESS.', {\n      key,\n      status: idempotencyKey.status,\n      executionCount: idempotencyKey.executionCount,\n    });\n\n    if (idempotencyKey.status !== 'IN_PROGRESS') {\n      throw new Error(`Cannot fail execution for key ${key} with status ${idempotencyKey.status}`);\n    }\n\n    // CRITICAL: Update status to failed\n    idempotencyKey.status = 'FAILED';\n    idempotencyKey.error = error.message;\n    idempotencyKey.lastExecutedAt = new Date();\n    \n    IdempotencyManager.keyStore.set(key, idempotencyKey);\n\n    // CRITICAL: Log failure\n    this.auditLogger.logAuthorizationDecision({\n      tenantId: idempotencyKey.tenantId || 'system',\n      actorId: userId || 'system',\n      action: 'EXECUTION_FAILED',\n      resourceType: 'IDEMPOTENCY_KEY',\n      resourceId: idempotencyKey.id,\n      outcome: 'FAILURE',\n      correlationId: `idempotency_${idempotencyKey.id}`,\n      metadata: {\n        key,\n        operationType: idempotencyKey.operationType,\n        executionCount: idempotencyKey.executionCount,\n        error: error.message,\n        executionTime: Date.now() - idempotencyKey.createdAt.getTime()\n      }\n    });\n\n    logger.error('Execution failed', error, {\n      key,\n      operationType: idempotencyKey.operationType,\n      executionCount: idempotencyKey.executionCount\n    });\n  }\n\n  /**\n   * CRITICAL: Execute operation with idempotency protection\n   */\n  async executeWithIdempotency<T>(\n    operationType: string,\n    scope: IdempotencyScope,\n    operation: () => Promise<T>,\n    tenantContext?: TenantContext,\n    userId?: string,\n    sessionId?: string,\n    additionalContext?: Record<string, any>,\n    ttl?: number,\n    maxExecutions?: number,\n    metadata: Record<string, any> = {},\n    preGeneratedKey?: string\n  ): Promise<T> {\n    // CRITICAL: Use pre-generated key or generate one\n    const key = preGeneratedKey || this.generateKey(operationType, scope, tenantContext, userId, sessionId, additionalContext);\n    \n    logger.debug('executeWithIdempotency', { key, operationType, scope, preGeneratedKey: !!preGeneratedKey });\n\n    // CRITICAL: Check idempotency\n    const idempotencyResult = await this.checkIdempotency(\n      key,\n      operationType,\n      scope,\n      tenantContext,\n      userId,\n      sessionId,\n      ttl,\n      maxExecutions,\n      metadata\n    );\n    \n    logger.debug('checkIdempotency result', { key, status: idempotencyResult.status, isDuplicate: idempotencyResult.isDuplicate, shouldExecute: idempotencyResult.shouldExecute });\n\n    // CRITICAL: Return existing result if duplicate\n    if (idempotencyResult.isDuplicate && idempotencyResult.status === 'COMPLETED') {\n      logger.debug('Returning cached result', { key });\n      return idempotencyResult.result;\n    }\n\n    // CRITICAL: Throw error if failed\n    if (idempotencyResult.isDuplicate && idempotencyResult.status === 'FAILED') {\n      logger.debug('Returning failed error', { key, error: idempotencyResult.error });\n      throw new Error(idempotencyResult.error || 'Previous execution failed');\n    }\n\n    // CRITICAL: Wait for in-progress execution and return result\n    if (idempotencyResult.isDuplicate && idempotencyResult.status === 'IN_PROGRESS') {\n      logger.debug('Waiting for in-progress execution', { key });\n      return await this.waitForCompletion(key, 30000, 500); // 30s timeout, 500ms poll\n    }\n\n    // CRITICAL: Execute operation (only when shouldExecute is true)\n    if (!idempotencyResult.shouldExecute) {\n      logger.error('Cannot execute operation: shouldExecute is false', undefined, { key, status: idempotencyResult.status });\n      throw new Error(`Cannot execute operation for key ${key} with status ${idempotencyResult.status}`);\n    }\n\n    logger.debug('Starting new execution', { key });\n    try {\n      await this.startExecution(key, tenantContext, userId);\n      \n      const result = await operation();\n      \n      await this.completeExecution(key, result, tenantContext, userId);\n      \n      logger.debug('Completed execution', { key });\n      return result;\n\n    } catch (error) {\n      // PRAGMATIC: If startExecution fails due to IN_PROGRESS, wait and return result\n      if (error instanceof Error && error.message.includes('Cannot start execution') && error.message.includes('IN_PROGRESS')) {\n        logger.debug('StartExecution failed with IN_PROGRESS, waiting for completion', { key });\n        return await this.waitForCompletion(key, 30000, 500);\n      }\n      await this.failExecution(key, error as Error, tenantContext, userId);\n      throw error;\n    }\n  }\n\n  /**\n   * CRITICAL: Wait for in-progress execution to complete\n   */\n  private async waitForCompletion<T>(\n    key: string,\n    timeoutMs: number = 30000,\n    pollIntervalMs: number = 500\n  ): Promise<T> {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeoutMs) {\n      const idempotencyKey = IdempotencyManager.keyStore.get(key);\n      \n      if (!idempotencyKey) {\n        throw new Error(`Idempotency key ${key} not found during wait`);\n      }\n      \n      if (idempotencyKey.status === 'COMPLETED') {\n        return idempotencyKey.result as T;\n      }\n      \n      if (idempotencyKey.status === 'FAILED') {\n        throw new Error(idempotencyKey.error || 'Execution failed');\n      }\n      \n      if (idempotencyKey.status === 'IN_PROGRESS') {\n        // Check for timeout\n        const waitTime = Date.now() - (idempotencyKey.lastExecutedAt?.getTime() || 0);\n        if (waitTime > 300000) { // 5 minutes\n          throw new Error('Execution timed out');\n        }\n        // Continue waiting\n        await new Promise(resolve => setTimeout(resolve, pollIntervalMs));\n        continue;\n      }\n      \n      // Unexpected status\n      throw new Error(`Unexpected status ${idempotencyKey.status} for key ${key}`);\n    }\n    \n    throw new Error(`Timeout waiting for execution of key ${key}`);\n  }\n\n  /**\n   * CRITICAL: Get idempotency key\n   */\n  async getKey(key: string): Promise<IdempotencyKey | null> {\n    return IdempotencyManager.keyStore.get(key) || null;\n  }\n\n  /**\n   * CRITICAL: Delete idempotency key\n   */\n  async deleteKey(key: string): Promise<boolean> {\n    const deleted = IdempotencyManager.keyStore.has(key);\n    IdempotencyManager.keyStore.delete(key);\n    return deleted;\n  }\n\n  /**\n   * CRITICAL: Get statistics\n   */\n  async getStatistics(): Promise<{\n    totalKeys: number;\n    keysByStatus: Record<ExecutionStatus, number>;\n    keysByScope: Record<IdempotencyScope, number>;\n    keysByOperation: Record<string, number>;\n  }> {\n    const stats = {\n      totalKeys: IdempotencyManager.keyStore.size,\n      keysByStatus: {} as Record<ExecutionStatus, number>,\n      keysByScope: {} as Record<IdempotencyScope, number>,\n      keysByOperation: {} as Record<string, number>\n    };\n\n    // Initialize counters\n    const statuses: ExecutionStatus[] = ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'EXPIRED'];\n    const scopes: IdempotencyScope[] = ['GLOBAL', 'TENANT', 'USER', 'SESSION', 'OPERATION'];\n    \n    statuses.forEach(status => {\n      stats.keysByStatus[status] = 0;\n    });\n    \n    scopes.forEach(scope => {\n      stats.keysByScope[scope] = 0;\n    });\n\n    // Count keys\n    for (const [key, idempotencyKey] of IdempotencyManager.keyStore.entries()) {\n      stats.keysByStatus[idempotencyKey.status]++;\n      stats.keysByScope[idempotencyKey.scope]++;\n      stats.keysByOperation[idempotencyKey.operationType] = (stats.keysByOperation[idempotencyKey.operationType] || 0) + 1;\n    }\n\n    return stats;\n  }\n\n  /**\n   * CRITICAL: Cleanup expired keys\n   */\n  async cleanupExpiredKeys(): Promise<number> {\n    const now = new Date();\n    let cleanedCount = 0;\n\n    for (const [key, idempotencyKey] of IdempotencyManager.keyStore.entries()) {\n      if (idempotencyKey.expiresAt < now) {\n        IdempotencyManager.keyStore.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    if (cleanedCount > 0) {\n      logger.info(`Cleaned up ${cleanedCount} expired idempotency keys`);\n    }\n\n    return cleanedCount;\n  }\n\n  /**\n   * CRITICAL: Clear all keys (for testing)\n   */\n  async clearAllKeys(): Promise<void> {\n    IdempotencyManager.keyStore.clear();\n  }\n}\n\n// CRITICAL: Export singleton instance and convenience functions for test compatibility\nexport const idempotencyManager = IdempotencyManager.getInstance();\n\n// CRITICAL: Export convenience functions for test compatibility\nexport const executeWithIdempotency = <T>(\n  operationType: string,\n  scope: IdempotencyScope,\n  operation: () => Promise<T>,\n  tenantContext?: TenantContext,\n  userId?: string,\n  sessionId?: string,\n  additionalContext?: Record<string, any>,\n  ttl?: number,\n  maxExecutions?: number,\n  metadata: Record<string, any> = {},\n  preGeneratedKey?: string\n): Promise<T> => {\n  return idempotencyManager.executeWithIdempotency(\n    operationType,\n    scope,\n    operation,\n    tenantContext,\n    userId,\n    sessionId,\n    additionalContext,\n    ttl,\n    maxExecutions,\n    metadata,\n    preGeneratedKey\n  );\n};\n\nexport const generateIdempotencyKey = (\n  operationType: string,\n  scope: IdempotencyScope,\n  tenantContext?: TenantContext,\n  userId?: string,\n  sessionId?: string,\n  additionalContext?: Record<string, any>\n): string => {\n  return idempotencyManager.generateKey(\n    operationType,\n    scope,\n    tenantContext,\n    userId,\n    sessionId,\n    additionalContext\n  );\n};\n\nexport const checkIdempotency = (\n  key: string,\n  operationType: string,\n  scope: IdempotencyScope,\n  tenantContext?: TenantContext,\n  userId?: string,\n  sessionId?: string,\n  ttl?: number,\n  maxExecutions?: number,\n  metadata: Record<string, any> = {}\n): Promise<IdempotencyResult> => {\n  return idempotencyManager.checkIdempotency(\n    key,\n    operationType,\n    scope,\n    tenantContext,\n    userId,\n    sessionId,\n    ttl,\n    maxExecutions,\n    metadata\n  );\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\idempotency-middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":243,"column":22,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":243,"endColumn":39},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":252,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":252,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":368,"column":24,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":368,"endColumn":41},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":412,"column":24,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":412,"endColumn":41},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":456,"column":24,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":456,"endColumn":41}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Idempotency Middleware\r\n// MANDATORY: Request and job protection with exactly-once semantics\r\n\r\nimport { Request, Response, NextFunction } from 'express';\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { idempotencyManager, IdempotencyScope, generateIdempotencyKey, checkIdempotency } from './idempotency-manager.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport interface IdempotencyMiddlewareOptions {\r\n  operationType: string;\r\n  scope: IdempotencyScope;\r\n  ttl?: number;\r\n  maxExecutions?: number;\r\n  keyGenerator?: (req: Request) => string;\r\n  additionalContext?: (req: Request) => Record<string, any>;\r\n  skipPaths?: string[];\r\n  skipMethods?: string[];\r\n}\r\n\r\n/**\r\n * CRITICAL: Idempotency Middleware for Express\r\n * \r\n * This middleware provides idempotency protection for API endpoints\r\n * with configurable scopes and automatic key generation.\r\n */\r\nexport function idempotencyMiddleware(options: IdempotencyMiddlewareOptions) {\r\n  const {\r\n    operationType,\r\n    scope,\r\n    ttl,\r\n    maxExecutions,\r\n    keyGenerator,\r\n    additionalContext,\r\n    skipPaths = [],\r\n    skipMethods = ['GET', 'HEAD', 'OPTIONS']\r\n  } = options;\r\n\r\n  return async (req: Request, res: Response, next: NextFunction) => {\r\n    const startTime = Date.now();\r\n    const correlationId = req.headers['x-correlation-id'] as string || `idempotency_${Date.now()}`;\r\n\r\n    try {\r\n      // CRITICAL: Skip idempotency for specified methods and paths\r\n      if (skipMethods.includes(req.method) || skipPaths.some(path => req.path.startsWith(path))) {\r\n        return next();\r\n      }\r\n\r\n      // CRITICAL: Extract tenant context\r\n      const tenantContext = (req as any).tenantContext;\r\n      if (!tenantContext && (scope === 'TENANT' || scope === 'USER')) {\r\n        return res.status(401).json({\r\n          error: 'Unauthorized',\r\n          message: 'Tenant context required for idempotency'\r\n        });\r\n      }\r\n\r\n      // CRITICAL: Generate idempotency key\r\n      let key: string;\r\n      if (keyGenerator) {\r\n        key = keyGenerator(req);\r\n      } else {\r\n        key = generateDefaultKey(req, operationType, scope, tenantContext, additionalContext);\r\n      }\r\n\r\n      // CRITICAL: Check idempotency\r\n      const idempotencyResult = await checkIdempotency(\r\n        key,\r\n        operationType,\r\n        scope,\r\n        tenantContext,\r\n        (req as any).user?.id,\r\n        req.session?.id,\r\n        ttl,\r\n        maxExecutions\r\n      );\r\n\r\n      // CRITICAL: Handle duplicate requests\r\n      if (idempotencyResult.isDuplicate) {\r\n        // CRITICAL: Log duplicate request\r\n        const auditLogger = getImmutableAuditLogger();\r\n        auditLogger.logAuthorizationDecision({\r\n          tenantId: tenantContext?.tenantId || 'system',\r\n          actorId: (req as any).user?.id || 'system',\r\n          action: 'DUPLICATE_REQUEST_BLOCKED',\r\n          resourceType: 'IDEMPOTENCY_KEY',\r\n          resourceId: idempotencyResult.key.id,\r\n          outcome: 'SUCCESS',\r\n          correlationId,\r\n          metadata: {\r\n            key,\r\n            operationType,\r\n            scope,\r\n            status: idempotencyResult.status,\r\n            duration: Date.now() - startTime\r\n          }\r\n        });\r\n\r\n        // CRITICAL: Return appropriate response based on status\r\n        if (idempotencyResult.status === 'COMPLETED') {\r\n          return res.status(200).json({\r\n            success: true,\r\n            duplicate: true,\r\n            status: 'completed',\r\n            result: idempotencyResult.result,\r\n            message: 'Request already completed'\r\n          });\r\n        } else if (idempotencyResult.status === 'FAILED') {\r\n          return res.status(400).json({\r\n            success: false,\r\n            duplicate: true,\r\n            status: 'failed',\r\n            error: idempotencyResult.error,\r\n            message: 'Request previously failed'\r\n          });\r\n        } else if (idempotencyResult.status === 'IN_PROGRESS') {\r\n          return res.status(409).json({\r\n            success: false,\r\n            duplicate: true,\r\n            status: 'in_progress',\r\n            error: idempotencyResult.error,\r\n            message: 'Request currently in progress'\r\n          });\r\n        } else {\r\n          return res.status(400).json({\r\n            success: false,\r\n            duplicate: true,\r\n            status: idempotencyResult.status,\r\n            error: idempotencyResult.error,\r\n            message: 'Request cannot be processed'\r\n          });\r\n        }\r\n      }\r\n\r\n      // CRITICAL: Add idempotency info to request\r\n      (req as any).idempotencyKey = idempotencyResult.key;\r\n      (req as any).idempotencyKeyString = key;\r\n\r\n      // CRITICAL: Start execution\r\n      await idempotencyManager.startExecution(\r\n        key,\r\n        tenantContext,\r\n        (req as any).user?.id\r\n      );\r\n\r\n      // CRITICAL: Override res.json to capture result\r\n      const originalJson = res.json;\r\n      res.json = function(data: any) {\r\n        // CRITICAL: Complete execution with result\r\n        idempotencyManager.completeExecution(\r\n          key,\r\n          data,\r\n          tenantContext,\r\n          (req as any).user?.id\r\n        ).catch(error => {\r\n          logger.error('Failed to complete idempotency execution', error, {\r\n            keyId: idempotencyResult.key.id,\r\n            operationType\r\n          });\r\n        });\r\n\r\n        // CRITICAL: Call original json\r\n        return originalJson.call(this, data);\r\n      };\r\n\r\n      // CRITICAL: Override res.status to handle errors\r\n      const originalStatus = res.status;\r\n      res.status = function(code: number) {\r\n        // CRITICAL: Handle error responses\r\n        if (code >= 400) {\r\n          const error = new Error(`HTTP ${code} response`);\r\n          idempotencyManager.failExecution(\r\n            key,\r\n            error,\r\n            tenantContext,\r\n            (req as any).user?.id\r\n          ).catch(err => {\r\n            logger.error('Failed to fail idempotency execution', err, {\r\n              keyId: idempotencyResult.key.id,\r\n              operationType,\r\n              statusCode: code\r\n            });\r\n          });\r\n        }\r\n\r\n        return originalStatus.call(this, code);\r\n      };\r\n\r\n      next();\r\n\r\n    } catch (error) {\r\n      logger.error('Idempotency middleware error', error as Error, {\r\n        operationType,\r\n        scope,\r\n        path: req.path,\r\n        method: req.method\r\n      });\r\n\r\n      res.status(500).json({\r\n        error: 'Internal Server Error',\r\n        message: 'Idempotency check failed'\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * CRITICAL: Generate default idempotency key\r\n */\r\nfunction generateDefaultKey(\r\n  req: Request,\r\n  operationType: string,\r\n  scope: IdempotencyScope,\r\n  tenantContext?: TenantContext,\r\n  additionalContext?: (req: Request) => Record<string, any>\r\n): string {\r\n  const keyParts = [operationType, scope];\r\n  \r\n  // CRITICAL: Add tenant ID if tenant-scoped\r\n  if (scope === 'TENANT' && tenantContext) {\r\n    keyParts.push(tenantContext.tenantId);\r\n  }\r\n  \r\n  // CRITICAL: Add user ID if user-scoped\r\n  if (scope === 'USER' && (req as any).user?.id) {\r\n    keyParts.push(`user:${(req as any).user.id}`);\r\n  }\r\n  \r\n  // CRITICAL: Add session ID if session-scoped\r\n  if (scope === 'SESSION' && req.session?.id) {\r\n    keyParts.push(`session:${req.session.id}`);\r\n  }\r\n  \r\n  // CRITICAL: Add method and path for operation-scoped\r\n  if (scope === 'OPERATION') {\r\n    keyParts.push(`${req.method}:${req.path}`);\r\n  }\r\n  \r\n  // CRITICAL: Add additional context\r\n  if (additionalContext) {\r\n    const context = additionalContext(req);\r\n    if (context && Object.keys(context).length > 0) {\r\n      const crypto = require('crypto');\r\n      const hash = crypto.createHash('sha256');\r\n      hash.update(JSON.stringify(context, Object.keys(context).sort()));\r\n      keyParts.push(hash.digest('hex').substring(0, 16));\r\n    }\r\n  }\r\n  \r\n  // CRITICAL: Add request body hash for POST/PUT requests\r\n  if (['POST', 'PUT', 'PATCH'].includes(req.method) && req.body) {\r\n    const crypto = require('crypto');\r\n    const hash = crypto.createHash('sha256');\r\n    hash.update(JSON.stringify(req.body, Object.keys(req.body).sort()));\r\n    keyParts.push(hash.digest('hex').substring(0, 16));\r\n  }\r\n  \r\n  return keyParts.join(':');\r\n}\r\n\r\n/**\r\n * CRITICAL: Job Idempotency Wrapper\r\n * \r\n * This wrapper provides idempotency protection for background jobs\r\n * with automatic error handling and result caching.\r\n */\r\nexport function withJobIdempotency<T extends any[], R>(\r\n  operationType: string,\r\n  scope: IdempotencyScope,\r\n  jobFunction: (...args: T) => Promise<R>,\r\n  options: {\r\n    ttl?: number;\r\n    maxExecutions?: number;\r\n    keyExtractor?: (...args: T) => string;\r\n    contextExtractor?: (...args: T) => Record<string, any>;\r\n  } = {}\r\n) {\r\n  const {\r\n    ttl,\r\n    maxExecutions,\r\n    keyExtractor,\r\n    contextExtractor\r\n  } = options;\r\n\r\n  return async (...args: T): Promise<R> => {\r\n    // CRITICAL: Extract additional context first\r\n    let additionalContext: Record<string, any> = {};\r\n    if (contextExtractor) {\r\n      additionalContext = contextExtractor(...args);\r\n    }\r\n\r\n    // CRITICAL: Extract key components\r\n    let key: string;\r\n    let tenantContext: TenantContext | undefined;\r\n    let userId: string | undefined;\r\n    let sessionId: string | undefined;\r\n\r\n    // CRITICAL: Extract context from arguments for fallback key generation\r\n    if (args[0] && typeof args[0] === 'object') {\r\n      const firstArg = args[0];\r\n      if ('tenantId' in firstArg) {\r\n        tenantContext = firstArg as TenantContext;\r\n      }\r\n      if ('userId' in firstArg) {\r\n        userId = firstArg.userId;\r\n      }\r\n      if ('sessionId' in firstArg) {\r\n        sessionId = firstArg.sessionId;\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Generate key using keyExtractor or fallback\r\n    if (keyExtractor) {\r\n      key = keyExtractor(...args);\r\n    } else {\r\n      key = idempotencyManager.generateKey(operationType, scope, tenantContext, userId, sessionId, additionalContext);\r\n    }\r\n\r\n    // CRITICAL: Execute with idempotency protection\r\n    console.log('WRAPPER calling executeWithIdempotency with key:', key);\r\n    console.log('WRAPPER keyStore size before call:', (idempotencyManager as any).keyStore?.size || 'no store');\r\n    const result = await idempotencyManager.executeWithIdempotency(\r\n      operationType,\r\n      scope,\r\n      () => jobFunction(...args),\r\n      tenantContext,\r\n      userId,\r\n      sessionId,\r\n      additionalContext,\r\n      ttl,\r\n      maxExecutions,\r\n      {},\r\n      key // Pass the pre-generated key\r\n    );\r\n    console.log('WRAPPER result:', result);\r\n    console.log('WRAPPER keyStore size after call:', (idempotencyManager as any).keyStore?.size || 'no store');\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * CRITICAL: Billing Operation Idempotency\r\n * \r\n * Specialized wrapper for billing operations with exactly-once guarantees\r\n */\r\nexport function withBillingIdempotency<T extends any[], R>(\r\n  billingType: string,\r\n  billingFunction: (...args: T) => Promise<R>\r\n) {\r\n  return withJobIdempotency(\r\n    `BILLING_${billingType}`,\r\n    'TENANT',\r\n    billingFunction,\r\n    {\r\n      ttl: 86400000, // 24 hours\r\n      maxExecutions: 1, // Exactly-once\r\n      keyExtractor: (...args) => {\r\n        // CRITICAL: Extract billing ID from arguments\r\n        const billingData = args.find(arg => \r\n          typeof arg === 'object' && arg && 'billingId' in arg\r\n        ) as any;\r\n        \r\n        if (billingData?.billingId) {\r\n          return `BILLING_${billingType}_${billingData.billingId}`;\r\n        }\r\n        \r\n        // CRITICAL: Fallback to generated key with args hash\r\n        const crypto = require('crypto');\r\n        const hash = crypto.createHash('sha256');\r\n        hash.update(JSON.stringify(args, Object.keys(args).sort()));\r\n        return `BILLING_${billingType}_${hash.digest('hex').substring(0, 16)}`;\r\n      },\r\n      contextExtractor: (...args) => {\r\n        // CRITICAL: Extract billing context for consistent keys\r\n        const billingData = args.find(arg => \r\n          typeof arg === 'object' && arg && ('amount' in arg || 'subscriptionId' in arg)\r\n        ) as any;\r\n        \r\n        return billingData || {};\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * CRITICAL: Dangerous Operation Idempotency\r\n * \r\n * Specialized wrapper for dangerous operations with strict controls\r\n */\r\nexport function withDangerousOperationIdempotency<T extends any[], R>(\r\n  operationType: string,\r\n  dangerousFunction: (...args: T) => Promise<R>\r\n) {\r\n  return withJobIdempotency(\r\n    `DANGEROUS_${operationType}`,\r\n    'TENANT',\r\n    dangerousFunction,\r\n    {\r\n      ttl: 604800000, // 7 days\r\n      maxExecutions: 1, // Exactly-once\r\n      keyExtractor: (...args) => {\r\n        // CRITICAL: Extract operation ID from arguments\r\n        const operationData = args.find(arg => \r\n          typeof arg === 'object' && arg && 'operationId' in arg\r\n        ) as any;\r\n        \r\n        if (operationData?.operationId) {\r\n          return `DANGEROUS_${operationType}_${operationData.operationId}`;\r\n        }\r\n        \r\n        // CRITICAL: Fallback to generated key\r\n        const crypto = require('crypto');\r\n        const hash = crypto.createHash('sha256');\r\n        hash.update(JSON.stringify(args, Object.keys(args).sort()));\r\n        return `DANGEROUS_${operationType}_${hash.digest('hex').substring(0, 16)}`;\r\n      },\r\n      contextExtractor: (...args) => {\r\n        // CRITICAL: Extract operation context\r\n        const operationData = args.find(arg => \r\n          typeof arg === 'object' && arg && ('riskLevel' in arg || 'approvalId' in arg)\r\n        ) as any;\r\n        \r\n        return operationData || {};\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * CRITICAL: Approval Execution Idempotency\r\n * \r\n * Specialized wrapper for approval executions with tracking\r\n */\r\nexport function withApprovalIdempotency<T extends any[], R>(\r\n  approvalType: string,\r\n  approvalFunction: (...args: T) => Promise<R>\r\n) {\r\n  return withJobIdempotency(\r\n    `APPROVAL_${approvalType}`,\r\n    'TENANT',\r\n    approvalFunction,\r\n    {\r\n      ttl: 86400000, // 24 hours\r\n      maxExecutions: 1, // Exactly-once\r\n      keyExtractor: (...args) => {\r\n        // CRITICAL: Extract approval ID from arguments\r\n        const approvalData = args.find(arg => \r\n          typeof arg === 'object' && arg && 'approvalId' in arg\r\n        ) as any;\r\n        \r\n        if (approvalData?.approvalId) {\r\n          return `APPROVAL_${approvalType}_${approvalData.approvalId}`;\r\n        }\r\n        \r\n        // CRITICAL: Fallback to generated key\r\n        const crypto = require('crypto');\r\n        const hash = crypto.createHash('sha256');\r\n        hash.update(JSON.stringify(args, Object.keys(args).sort()));\r\n        return `APPROVAL_${approvalType}_${hash.digest('hex').substring(0, 16)}`;\r\n      },\r\n      contextExtractor: (...args) => {\r\n        // CRITICAL: Extract approval context\r\n        const approvalData = args.find(arg => \r\n          typeof arg === 'object' && arg && ('requestId' in arg || 'approverId' in arg)\r\n        ) as any;\r\n        \r\n        return approvalData || {};\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * CRITICAL: Express route decorator for idempotency\r\n */\r\nexport function Idempotent(options: IdempotencyMiddlewareOptions) {\r\n  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\r\n    const originalMethod = descriptor.value;\r\n\r\n    descriptor.value = async function (req: Request, res: Response, next: NextFunction) {\r\n      // CRITICAL: Apply idempotency middleware\r\n      const middleware = idempotencyMiddleware(options);\r\n      await middleware(req, res, () => {\r\n        // CRITICAL: Call original method\r\n        return originalMethod.call(this, req, res, next);\r\n      });\r\n    };\r\n\r\n    return descriptor;\r\n  };\r\n}\r\n\r\n/**\r\n * CRITICAL: Convenience middleware creators\r\n */\r\nexport const createTenantIdempotency = (operationType: string, options: Partial<IdempotencyMiddlewareOptions> = {}) => {\r\n  return idempotencyMiddleware({\r\n    operationType,\r\n    scope: 'TENANT',\r\n    ...options\r\n  });\r\n};\r\n\r\nexport const createUserIdempotency = (operationType: string, options: Partial<IdempotencyMiddlewareOptions> = {}) => {\r\n  return idempotencyMiddleware({\r\n    operationType,\r\n    scope: 'USER',\r\n    ...options\r\n  });\r\n};\r\n\r\nexport const createSessionIdempotency = (operationType: string, options: Partial<IdempotencyMiddlewareOptions> = {}) => {\r\n  return idempotencyMiddleware({\r\n    operationType,\r\n    scope: 'SESSION',\r\n    ...options\r\n  });\r\n};\r\n\r\nexport const createOperationIdempotency = (operationType: string, options: Partial<IdempotencyMiddlewareOptions> = {}) => {\r\n  return idempotencyMiddleware({\r\n    operationType,\r\n    scope: 'OPERATION',\r\n    ...options\r\n  });\r\n};\r\n\r\n/**\r\n * CRITICAL: Error handling for idempotency failures\r\n */\r\nexport class IdempotencyError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public keyId: string,\r\n    public operationType: string,\r\n    public originalError?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = 'IdempotencyError';\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Retry handler for idempotent operations\r\n */\r\nexport async function retryWithIdempotency<T>(\r\n  operationType: string,\r\n  scope: IdempotencyScope,\r\n  operation: () => Promise<T>,\r\n  maxRetries: number = 3,\r\n  retryDelay: number = 1000,\r\n  tenantContext?: TenantContext,\r\n  userId?: string,\r\n  sessionId?: string,\r\n  additionalContext?: Record<string, any>\r\n): Promise<T> {\r\n  let lastError: Error;\r\n  \r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      return await idempotencyManager.executeWithIdempotency(\r\n        operationType,\r\n        scope,\r\n        operation,\r\n        tenantContext,\r\n        userId,\r\n        sessionId,\r\n        additionalContext\r\n      );\r\n    } catch (error) {\r\n      lastError = error as Error;\r\n      \r\n      if (attempt === maxRetries) {\r\n        break;\r\n      }\r\n      \r\n      // CRITICAL: Wait before retry\r\n      await new Promise(resolve => setTimeout(resolve, retryDelay * Math.pow(2, attempt)));\r\n    }\r\n  }\r\n  \r\n  throw lastError!;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\priority-queue.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":863,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":863,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":872,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":872,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Priority Queue Implementation\r\n// MANDATORY: Priority-based request queues with fair scheduling\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport type QueuePriority = 'CRITICAL' | 'HIGH' | 'NORMAL' | 'LOW' | 'BACKGROUND';\r\nexport type QueueStatus = 'ACTIVE' | 'PAUSED' | 'DRAINING' | 'SHUTDOWN';\r\n\r\nexport interface PriorityQueueItem {\r\n  id: string;\r\n  tenantId: string;\r\n  priority: QueuePriority;\r\n  payload: Record<string, any>;\r\n  createdAt: Date;\r\n  scheduledAt: Date;\r\n  expiresAt?: Date;\r\n  attempts: number;\r\n  maxAttempts: number;\r\n  delayUntil?: Date;\r\n  correlationId: string;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface PriorityQueueConfig {\r\n  maxSize: number;\r\n  processingConcurrency: number;\r\n  priorities: QueuePriority[];\r\n  priorityWeights: Record<QueuePriority, number>;\r\n  fairScheduling: boolean;\r\n  tenantIsolation: boolean;\r\n  starvationPrevention: boolean;\r\n  maxWaitTime: number; // Maximum time in queue before priority boost\r\n}\r\n\r\nexport interface QueueMetrics {\r\n  totalItems: number;\r\n  itemsByPriority: Record<QueuePriority, number>;\r\n  itemsByTenant: Record<string, number>;\r\n  averageWaitTime: number;\r\n  processingRate: number;\r\n  errorRate: number;\r\n  oldestItemAge: number;\r\n  newestItemAge: number;\r\n}\r\n\r\n/**\r\n * CRITICAL: Priority Queue Manager\r\n * \r\n * This class implements priority-based queues with fair scheduling,\r\n * tenant isolation, and starvation prevention mechanisms.\r\n */\r\nexport class PriorityQueueManager {\r\n  private static instance: PriorityQueueManager;\r\n  private auditLogger: any;\r\n  private queues: Map<string, Map<QueuePriority, PriorityQueueItem[]>> = new Map();\r\n  private processing: Map<string, Set<string>> = new Map();\r\n  private configs: Map<string, PriorityQueueConfig> = new Map();\r\n  private globalConfig: PriorityQueueConfig;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.globalConfig = this.initializeGlobalConfig();\r\n    this.startQueueMonitoring();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): PriorityQueueManager {\r\n    if (!PriorityQueueManager.instance) {\r\n      PriorityQueueManager.instance = new PriorityQueueManager();\r\n    }\r\n    return PriorityQueueManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get or create priority queue\r\n   */\r\n  getPriorityQueue(queueName: string, config: Partial<PriorityQueueConfig> = {}): Map<QueuePriority, PriorityQueueItem[]> {\r\n    let queue = this.queues.get(queueName);\r\n    \r\n    if (!queue) {\r\n      const mergedConfig = { ...this.globalConfig, ...config };\r\n      queue = this.initializeQueue(queueName, mergedConfig);\r\n      this.queues.set(queueName, queue);\r\n      this.configs.set(queueName, mergedConfig);\r\n      this.processing.set(queueName, new Set());\r\n    }\r\n\r\n    return queue;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Enqueue item with priority\r\n   */\r\n  async enqueue(\r\n    queueName: string,\r\n    tenantId: string,\r\n    priority: QueuePriority,\r\n    payload: Record<string, any>,\r\n    delayUntil?: Date,\r\n    correlationId?: string,\r\n    metadata: Record<string, any> = {}\r\n  ): Promise<string> {\r\n    const queue = this.getPriorityQueue(queueName);\r\n    const config = this.configs.get(queueName)!;\r\n    const itemId = this.generateItemId();\r\n\r\n    // CRITICAL: Validate enqueue preconditions\r\n    this.validateEnqueuePreconditions(queue, config, tenantId, priority);\r\n\r\n    const item: PriorityQueueItem = {\r\n      id: itemId,\r\n      tenantId,\r\n      priority,\r\n      payload,\r\n      createdAt: new Date(),\r\n      scheduledAt: delayUntil || new Date(),\r\n      expiresAt: metadata.expiresAt ? new Date(metadata.expiresAt) : undefined,\r\n      attempts: 0,\r\n      maxAttempts: config.maxSize / 10, // 10% of max size\r\n      delayUntil,\r\n      correlationId: correlationId || this.generateCorrelationId(),\r\n      metadata\r\n    };\r\n\r\n    // CRITICAL: Add to appropriate priority queue\r\n    const priorityQueue = queue.get(priority);\r\n    if (!priorityQueue) {\r\n      queue.set(priority, []);\r\n    }\r\n    queue.get(priority)!.push(item);\r\n\r\n    // CRITICAL: Sort by priority and creation time\r\n    this.sortQueue(queue);\r\n\r\n    // CRITICAL: Log enqueue\r\n    this.auditLogger.logDataMutation({\r\n      tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'ITEM_ENQUEUED',\r\n      resourceType: 'PRIORITY_QUEUE',\r\n      resourceId: itemId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: item.correlationId,\r\n      metadata: {\r\n        queueName,\r\n        priority,\r\n        scheduledAt: item.scheduledAt,\r\n        payloadSize: JSON.stringify(payload).length\r\n      }\r\n    });\r\n\r\n    logger.info('Item enqueued', {\r\n      itemId,\r\n      queueName,\r\n      tenantId,\r\n      priority,\r\n      scheduledAt: item.scheduledAt\r\n    });\r\n\r\n    return itemId;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Dequeue item with priority\r\n   */\r\n  async dequeue(queueName: string, tenantId?: string): Promise<PriorityQueueItem | null> {\r\n    const queue = this.queues.get(queueName);\r\n    const config = this.configs.get(queueName);\r\n    \r\n    if (!queue || !config) {\r\n      throw new Error(`Queue ${queueName} not found`);\r\n    }\r\n\r\n    // CRITICAL: Check queue status\r\n    if (config.priorities.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // CRITICAL: Find next item to process\r\n    const item = this.findNextItem(queue, config, tenantId);\r\n    \r\n    if (!item) {\r\n      return null;\r\n    }\r\n\r\n    // CRITICAL: Mark as processing\r\n    const processingSet = this.processing.get(queueName);\r\n    if (!processingSet) {\r\n      this.processing.set(queueName, new Set());\r\n    }\r\n    this.processing.get(queueName)!.add(item.id);\r\n\r\n    // CRITICAL: Update item state\r\n    item.attempts++;\r\n    item.scheduledAt = new Date();\r\n\r\n    // CRITICAL: Remove from queue\r\n    const priorityQueue = queue.get(item.priority);\r\n    if (priorityQueue) {\r\n      const index = priorityQueue.findIndex(i => i.id === item.id);\r\n      if (index !== -1) {\r\n        priorityQueue.splice(index, 1);\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Log dequeue\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: item.tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'ITEM_DEQUEUED',\r\n      resourceType: 'PRIORITY_QUEUE',\r\n      resourceId: item.id,\r\n      outcome: 'SUCCESS',\r\n      correlationId: item.correlationId,\r\n      metadata: {\r\n        queueName,\r\n        priority: item.priority,\r\n        attempts: item.attempts,\r\n        waitTime: Date.now() - item.createdAt.getTime()\r\n      }\r\n    });\r\n\r\n    logger.info('Item dequeued', {\r\n      itemId: item.id,\r\n      queueName,\r\n      tenantId: item.tenantId,\r\n      priority: item.priority,\r\n      attempts: item.attempts\r\n    });\r\n\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Acknowledge item completion\r\n   */\r\n  async acknowledge(itemId: string, result?: any): Promise<void> {\r\n    // CRITICAL: Find item in processing\r\n    for (const [queueName, processingSet] of this.processing.entries()) {\r\n      if (processingSet.has(itemId)) {\r\n        processingSet.delete(itemId);\r\n\r\n        // CRITICAL: Log acknowledgment\r\n        this.auditLogger.logDataMutation({\r\n          tenantId: 'system',\r\n          actorId: 'queue-system',\r\n          action: 'ITEM_ACKNOWLEDGED',\r\n          resourceType: 'PRIORITY_QUEUE',\r\n          resourceId: itemId,\r\n          outcome: 'SUCCESS',\r\n          correlationId: `ack_${itemId}_${Date.now()}`,\r\n          metadata: {\r\n            queueName,\r\n            result: result ? 'SUCCESS' : 'NO_RESULT'\r\n          }\r\n        });\r\n\r\n        logger.info('Item acknowledged', {\r\n          itemId,\r\n          queueName\r\n        });\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    throw new Error(`Item ${itemId} not found in processing`);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Reject item (retry or dead letter)\r\n   */\r\n  async reject(itemId: string, error: Error, shouldRetry: boolean = true): Promise<void> {\r\n    // CRITICAL: Find item in processing\r\n    for (const [queueName, processingSet] of this.processing.entries()) {\r\n      if (processingSet.has(itemId)) {\r\n        const queue = this.queues.get(queueName);\r\n        const config = this.configs.get(queueName);\r\n        \r\n        // CRITICAL: Remove from processing\r\n        processingSet.delete(itemId);\r\n\r\n        // CRITICAL: Find item data\r\n        let item: PriorityQueueItem | null = null;\r\n        for (const priorityQueue of queue.values()) {\r\n          const found = priorityQueue.find(i => i.id === itemId);\r\n          if (found) {\r\n            item = found;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!item) {\r\n          throw new Error(`Item ${itemId} not found`);\r\n        }\r\n\r\n        // CRITICAL: Handle retry or dead letter\r\n        if (shouldRetry && item.attempts < item.maxAttempts) {\r\n          // CRITICAL: Schedule retry with exponential backoff\r\n          const retryDelay = this.calculateRetryDelay(item.attempts);\r\n          item.delayUntil = new Date(Date.now() + retryDelay);\r\n          item.scheduledAt = item.delayUntil;\r\n          \r\n          // CRITICAL: Re-enqueue\r\n          const priorityQueue = queue.get(item.priority);\r\n          if (priorityQueue) {\r\n            priorityQueue.push(item);\r\n            this.sortQueue(queue);\r\n          }\r\n\r\n          // CRITICAL: Log retry\r\n          this.auditLogger.logDataMutation({\r\n            tenantId: item.tenantId,\r\n            actorId: 'queue-system',\r\n            action: 'ITEM_RETRY',\r\n            resourceType: 'PRIORITY_QUEUE',\r\n            resourceId: itemId,\r\n            outcome: 'SUCCESS',\r\n            correlationId: item.correlationId,\r\n            metadata: {\r\n              queueName,\r\n              priority: item.priority,\r\n              attempts: item.attempts,\r\n              retryDelay,\r\n              error: error.message\r\n            }\r\n          });\r\n\r\n          logger.warn('Item scheduled for retry', {\r\n            itemId,\r\n            queueName,\r\n            priority: item.priority,\r\n            attempts: item.attempts,\r\n            retryDelay\r\n          });\r\n\r\n        } else {\r\n          // CRITICAL: Send to dead letter\r\n          await this.sendToDeadLetter(item, error, queueName);\r\n        }\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    throw new Error(`Item ${itemId} not found in processing`);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get queue metrics\r\n   */\r\n  getQueueMetrics(queueName: string): QueueMetrics | null {\r\n    const queue = this.queues.get(queueName);\r\n    const config = this.configs.get(queueName);\r\n    \r\n    if (!queue || !config) {\r\n      return null;\r\n    }\r\n\r\n    const now = Date.now();\r\n    const itemsByPriority: Record<QueuePriority, number> = {\r\n      CRITICAL: 0,\r\n      HIGH: 0,\r\n      NORMAL: 0,\r\n      LOW: 0,\r\n      BACKGROUND: 0\r\n    };\r\n    \r\n    const itemsByTenant: Record<string, number> = {};\r\n    let totalWaitTime = 0;\r\n    let itemCount = 0;\r\n    let oldestAge = 0;\r\n    let newestAge = 0;\r\n\r\n    // CRITICAL: Calculate metrics\r\n    for (const priority of config.priorities) {\r\n      const priorityQueue = queue.get(priority);\r\n      if (priorityQueue) {\r\n        itemsByPriority[priority] = priorityQueue.length;\r\n        \r\n        for (const item of priorityQueue) {\r\n          itemsByTenant[item.tenantId] = (itemsByTenant[item.tenantId] || 0) + 1;\r\n          \r\n          const waitTime = now - item.createdAt.getTime();\r\n          totalWaitTime += waitTime;\r\n          itemCount++;\r\n          \r\n          if (oldestAge === 0 || waitTime < oldestAge) {\r\n            oldestAge = waitTime;\r\n          }\r\n          if (newestAge === 0 || waitTime > newestAge) {\r\n            newestAge = waitTime;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalItems: itemCount,\r\n      itemsByPriority,\r\n      itemsByTenant,\r\n      averageWaitTime: itemCount > 0 ? totalWaitTime / itemCount : 0,\r\n      processingRate: this.processing.get(queueName)?.size || 0,\r\n      errorRate: 0, // Would be calculated from actual errors\r\n      oldestItemAge: oldestAge,\r\n      newestItemAge: newestAge\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get all queue metrics\r\n   */\r\n  getAllQueueMetrics(): Map<string, QueueMetrics> {\r\n    const metrics = new Map<string, QueueMetrics>();\r\n    \r\n    for (const queueName of this.queues.keys()) {\r\n      const queueMetrics = this.getQueueMetrics(queueName);\r\n      if (queueMetrics) {\r\n        metrics.set(queueName, queueMetrics);\r\n      }\r\n    }\r\n\r\n    return metrics;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Pause queue processing\r\n   */\r\n  pauseQueue(queueName: string, reason: string): void {\r\n    const config = this.configs.get(queueName);\r\n    if (config) {\r\n      // CRITICAL: This would be implemented to pause processing\r\n      logger.info('Queue paused', { queueName, reason });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Resume queue processing\r\n   */\r\n  resumeQueue(queueName: string): void {\r\n    const config = this.configs.get(queueName);\r\n    if (config) {\r\n      // CRITICAL: This would be implemented to resume processing\r\n      logger.info('Queue resumed', { queueName });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Drain queue (process all items then stop)\r\n   */\r\n  async drainQueue(queueName: string): Promise<void> {\r\n    const config = this.configs.get(queueName);\r\n    if (config) {\r\n      // CRITICAL: This would be implemented to drain the queue\r\n      logger.info('Queue draining started', { queueName });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Configure queue\r\n   */\r\n  configureQueue(queueName: string, config: Partial<PriorityQueueConfig>): void {\r\n    const existingConfig = this.configs.get(queueName);\r\n    const newConfig = existingConfig ? { ...existingConfig, ...config } : { ...this.globalConfig, ...config };\r\n    \r\n    this.configs.set(queueName, newConfig);\r\n\r\n    // CRITICAL: Update queue if it exists\r\n    const queue = this.queues.get(queueName);\r\n    if (queue) {\r\n      // CRITICAL: Re-sort queue with new configuration\r\n      this.sortQueue(queue);\r\n    }\r\n\r\n    // CRITICAL: Log configuration change\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'system',\r\n      action: 'QUEUE_CONFIGURED',\r\n      resourceType: 'PRIORITY_QUEUE',\r\n      resourceId: queueName,\r\n      outcome: 'SUCCESS',\r\n      correlationId: `queue_config_${queueName}_${Date.now()}`,\r\n      severity: 'LOW',\r\n      metadata: {\r\n        queueName,\r\n        maxSize: newConfig.maxSize,\r\n        priorities: newConfig.priorities,\r\n        fairScheduling: newConfig.fairScheduling\r\n      }\r\n    });\r\n\r\n    logger.info('Queue configuration updated', { queueName, config: newConfig });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate enqueue preconditions\r\n   */\r\n  private validateEnqueuePreconditions(\r\n    queue: Map<QueuePriority, PriorityQueueItem[]>,\r\n    config: PriorityQueueConfig,\r\n    tenantId: string,\r\n    priority: QueuePriority\r\n  ): void {\r\n    // CRITICAL: Check if priority is allowed\r\n    if (!config.priorities.includes(priority)) {\r\n      throw new Error(`Priority ${priority} not allowed for queue`);\r\n    }\r\n\r\n    // CRITICAL: Check queue size limit\r\n    const totalItems = Array.from(queue.values()).reduce((sum, items) => sum + items.length, 0);\r\n    if (totalItems >= config.maxSize) {\r\n      throw new Error(`Queue is full (${totalItems}/${config.maxSize})`);\r\n    }\r\n\r\n    // CRITICAL: Check tenant isolation\r\n    if (config.tenantIsolation) {\r\n      // CRITICAL: This would check tenant-specific limits\r\n      // For now, we'll allow all tenants\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Find next item to process\r\n   */\r\n  private findNextItem(\r\n    queue: Map<QueuePriority, PriorityQueueItem[]>,\r\n    config: PriorityQueueConfig,\r\n    tenantId?: string\r\n  ): PriorityQueueItem | null {\r\n    const now = Date.now();\r\n    let candidate: PriorityQueueItem | null = null;\r\n\r\n    if (config.fairScheduling) {\r\n      // CRITICAL: Fair scheduling - round-robin across priorities\r\n      candidate = this.findNextItemFair(queue, config, tenantId, now);\r\n    } else {\r\n      // CRITICAL: Priority-based scheduling\r\n      candidate = this.findNextItemPriority(queue, config, tenantId, now);\r\n    }\r\n\r\n    // CRITICAL: Check for starvation prevention\r\n    if (candidate && config.starvationPrevention) {\r\n      const waitTime = now - candidate.createdAt.getTime();\r\n      if (waitTime > config.maxWaitTime) {\r\n        // CRITICAL: Boost priority for starving items\r\n        return this.boostPriority(queue, candidate, config);\r\n      }\r\n    }\r\n\r\n    return candidate;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Find next item with fair scheduling\r\n   */\r\n  private findNextItemFair(\r\n    queue: Map<QueuePriority, PriorityQueueItem[]>,\r\n    config: PriorityQueueConfig,\r\n    tenantId?: string,\r\n    now: number\r\n  ): PriorityQueueItem | null {\r\n    let roundRobinIndex = 0;\r\n    const visitedTenants = new Set<string>();\r\n\r\n    // CRITICAL: Round-robin through priorities\r\n    for (const priority of config.priorities) {\r\n      const priorityQueue = queue.get(priority);\r\n      if (!priorityQueue || priorityQueue.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      // CRITICAL: Find eligible item for this priority\r\n      for (let i = 0; i < priorityQueue.length; i++) {\r\n        const item = priorityQueue[i];\r\n        \r\n        // CRITICAL: Check if item is ready\r\n        if (item.scheduledAt <= now && (!item.expiresAt || item.expiresAt > now)) {\r\n          // CRITICAL: Check tenant isolation\r\n          if (tenantId && item.tenantId !== tenantId) {\r\n            continue;\r\n          }\r\n\r\n          // CRITICAL: Fair scheduling - check if tenant has been served\r\n          if (config.tenantIsolation && visitedTenants.has(item.tenantId)) {\r\n            continue;\r\n          }\r\n\r\n          visitedTenants.add(item.tenantId);\r\n          roundRobinIndex = i;\r\n          return item;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Find next item with priority scheduling\r\n   */\r\n  private findNextItemPriority(\r\n    queue: Map<QueuePriority, PriorityQueueItem[]>,\r\n    config: PriorityQueueConfig,\r\n    tenantId?: string,\r\n    now: number\r\n  ): PriorityQueueItem | null {\r\n    // CRITICAL: Process priorities in order\r\n    for (const priority of config.priorities) {\r\n      const priorityQueue = queue.get(priority);\r\n      if (!priorityQueue || priorityQueue.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      // CRITICAL: Find first eligible item\r\n      for (const item of priorityQueue) {\r\n        // CRITICAL: Check if item is ready\r\n        if (item.scheduledAt <= now && (!item.expiresAt || item.expiresAt > now)) {\r\n          // CRITICAL: Check tenant isolation\r\n          if (tenantId && item.tenantId !== tenantId) {\r\n            continue;\r\n          }\r\n\r\n          return item;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Boost priority for starving items\r\n   */\r\n  private boostPriority(\r\n    queue: Map<QueuePriority, PriorityQueueItem[]>,\r\n    item: PriorityQueueItem,\r\n    config: PriorityQueueConfig\r\n  ): PriorityQueueItem {\r\n    // CRITICAL: Find higher priority\r\n    const currentIndex = config.priorities.indexOf(item.priority);\r\n    if (currentIndex <= 0) {\r\n      return item; // Already highest priority\r\n    }\r\n\r\n    const higherPriority = config.priorities[currentIndex - 1];\r\n    const higherPriorityQueue = queue.get(higherPriority);\r\n    \r\n    if (higherPriorityQueue) {\r\n      // CRITICAL: Move to higher priority queue\r\n      const currentQueue = queue.get(item.priority);\r\n      if (currentQueue) {\r\n        const index = currentQueue.findIndex(i => i.id === item.id);\r\n        if (index !== -1) {\r\n          currentQueue.splice(index, 1);\r\n        }\r\n      }\r\n      \r\n      higherPriorityQueue.push(item);\r\n      this.sortQueue(queue);\r\n      \r\n      // CRITICAL: Log priority boost\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: item.tenantId,\r\n        actorId: 'queue-system',\r\n        action: 'PRIORITY_BOOST',\r\n        resourceType: 'PRIORITY_QUEUE',\r\n        resourceId: item.id,\r\n        outcome: 'SUCCESS',\r\n        correlationId: `priority_boost_${item.id}_${Date.now()}`,\r\n        metadata: {\r\n          oldPriority: item.priority,\r\n          newPriority: higherPriority,\r\n          waitTime: Date.now() - item.createdAt.getTime()\r\n        }\r\n      });\r\n\r\n      logger.warn('Item priority boosted due to starvation', {\r\n        itemId: item.id,\r\n        oldPriority: item.priority,\r\n        newPriority: higherPriority,\r\n        waitTime: Date.now() - item.createdAt.getTime()\r\n      });\r\n\r\n      item.priority = higherPriority;\r\n    }\r\n\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Sort queue by priority and creation time\r\n   */\r\n  private sortQueue(queue: Map<QueuePriority, PriorityQueueItem[]>): void {\r\n    const priorityOrder: Record<QueuePriority, number> = {\r\n      CRITICAL: 0,\r\n      HIGH: 1,\r\n      NORMAL: 2,\r\n      LOW: 3,\r\n      BACKGROUND: 4\r\n    };\r\n\r\n    // CRITICAL: Sort each priority queue\r\n    for (const [priority, items] of queue.entries()) {\r\n      items.sort((a, b) => {\r\n        // CRITICAL: First by priority (already separated)\r\n        // Then by creation time (FIFO within same priority)\r\n        return a.createdAt.getTime() - b.createdAt.getTime();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate retry delay\r\n   */\r\n  private calculateRetryDelay(attempts: number): number {\r\n    // CRITICAL: Exponential backoff with jitter\r\n    const baseDelay = 1000; // 1 second\r\n    const maxDelay = 300000; // 5 minutes\r\n    const delay = baseDelay * Math.pow(2, attempts - 1);\r\n    const jitter = Math.random() * 1000; // Up to 1 second jitter\r\n    \r\n    return Math.min(delay + jitter, maxDelay);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Send to dead letter queue\r\n   */\r\n  private async sendToDeadLetter(item: PriorityQueueItem, error: Error, queueName: string): Promise<void> {\r\n    // CRITICAL: Log dead letter\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: item.tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'ITEM_DEAD_LETTER',\r\n      resourceType: 'PRIORITY_QUEUE',\r\n      resourceId: item.id,\r\n      outcome: 'FAILURE',\r\n      correlationId: item.correlationId,\r\n      metadata: {\r\n        queueName,\r\n        priority: item.priority,\r\n        attempts: item.attempts,\r\n        error: error.message,\r\n        waitTime: Date.now() - item.createdAt.getTime()\r\n      }\r\n    });\r\n\r\n    logger.error('Item sent to dead letter queue', {\r\n      itemId: item.id,\r\n      queueName,\r\n      priority: item.priority,\r\n      attempts: item.attempts,\r\n      error: error.message\r\n    });\r\n\r\n    // CRITICAL: In a real implementation, this would store the item in a dead letter queue\r\n    // For now, we just log it\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize queue\r\n   */\r\n  private initializeQueue(queueName: string, config: PriorityQueueConfig): Map<QueuePriority, PriorityQueueItem[]> {\r\n    const queue = new Map<QueuePriority, PriorityQueueItem[]>();\r\n    \r\n    // CRITICAL: Initialize priority queues\r\n    for (const priority of config.priorities) {\r\n      queue.set(priority, []);\r\n    }\r\n\r\n    return queue;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize global configuration\r\n   */\r\n  private initializeGlobalConfig(): PriorityQueueConfig {\r\n    return {\r\n      maxSize: 10000,\r\n      processingConcurrency: 10,\r\n      priorities: ['CRITICAL', 'HIGH', 'NORMAL', 'LOW', 'BACKGROUND'],\r\n      priorityWeights: {\r\n        CRITICAL: 100,\r\n        HIGH: 50,\r\n        NORMAL: 10,\r\n        LOW: 5,\r\n        BACKGROUND: 1\r\n      },\r\n      fairScheduling: true,\r\n      tenantIsolation: true,\r\n      starvationPrevention: true,\r\n      maxWaitTime: 300000 // 5 minutes\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start queue monitoring\r\n   */\r\n  private startQueueMonitoring(): void {\r\n    // CRITICAL: Periodic metrics update\r\n    setInterval(() => {\r\n      this.updateAllMetrics();\r\n    }, 10000); // Every 10 seconds\r\n\r\n    // CRITICAL: Periodic cleanup\r\n    setInterval(() => {\r\n      this.cleanupExpiredItems();\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update all metrics\r\n   */\r\n  private updateAllMetrics(): void {\r\n    // CRITICAL: This would update metrics for monitoring systems\r\n    // For now, we just log the statistics\r\n    const stats = {\r\n      totalQueues: this.queues.size,\r\n      totalProcessing: Array.from(this.processing.values()).reduce((sum, set) => sum + set.size, 0),\r\n      totalItems: Array.from(this.queues.values()).reduce((sum, queue) => \r\n        sum + Array.from(queue.values()).reduce((queueSum, items) => queueSum + items.length, 0), 0\r\n      )\r\n    };\r\n\r\n    logger.debug('Queue metrics updated', stats);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup expired items\r\n   */\r\n  private cleanupExpiredItems(): void {\r\n    const now = Date.now();\r\n    let cleanedCount = 0;\r\n\r\n    for (const [queueName, queue] of this.queues.entries()) {\r\n      for (const [priority, items] of queue.entries()) {\r\n        const filteredItems = items.filter(item => {\r\n          // CRITICAL: Remove expired items\r\n          if (item.expiresAt && item.expiresAt < now) {\r\n            cleanedCount++;\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n        \r\n        queue.set(priority, filteredItems);\r\n      }\r\n    }\r\n\r\n    if (cleanedCount > 0) {\r\n      logger.info('Cleaned up expired queue items', { cleanedCount });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate item ID\r\n   */\r\n  private generateItemId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `item_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global priority queue manager instance\r\n */\r\nexport const priorityQueueManager = PriorityQueueManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const enqueuePriorityItem = async (\r\n  queueName: string,\r\n  tenantId: string,\r\n  priority: QueuePriority,\r\n  payload: Record<string, any>,\r\n  delayUntil?: Date,\r\n  correlationId?: string,\r\n  metadata: Record<string, any> = {}\r\n): Promise<string> => {\r\n  return await priorityQueueManager.enqueue(queueName, tenantId, priority, payload, delayUntil, correlationId, metadata);\r\n};\r\n\r\nexport const dequeuePriorityItem = async (\r\n  queueName: string,\r\n  tenantId?: string\r\n): Promise<PriorityQueueItem | null> => {\r\n  return await priorityQueueManager.dequeue(queueName, tenantId);\r\n};\r\n\r\nexport const acknowledgePriorityItem = async (itemId: string, result?: any): Promise<void> => {\r\n  return await priorityQueueManager.acknowledge(itemId, result);\r\n};\r\n\r\nexport const rejectPriorityItem = async (itemId: string, error: Error, shouldRetry: boolean = true): Promise<void> => {\r\n  return await priorityQueueManager.reject(itemId, error, shouldRetry);\r\n};\r\n\r\nexport const getQueueMetrics = (queueName: string): QueueMetrics | null => {\r\n  return priorityQueueManager.getQueueMetrics(queueName);\r\n};\r\n\r\nexport const getAllQueueMetrics = (): Map<string, QueueMetrics> => {\r\n  return priorityQueueManager.getAllQueueMetrics();\r\n};\r\n\r\nexport const configurePriorityQueue = (queueName: string, config: Partial<PriorityQueueConfig>): void => {\r\n  priorityQueueManager.configureQueue(queueName, config);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\queue-boundaries.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'candidates' is never reassigned. Use 'const' instead.","line":530,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":530,"endColumn":35,"fix":{"range":[15438,15474],"text":"const candidates: QueueMessage[] = [];"}},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":837,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":837,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":846,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":846,"endColumn":37}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"// CRITICAL: Queue Boundaries & Decoupling\r\n// MANDATORY: Queue-based decoupling for critical workflows with blast radius control\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport type QueuePriority = 'CRITICAL' | 'HIGH' | 'NORMAL' | 'LOW' | 'BACKGROUND';\r\nexport type QueueStatus = 'ACTIVE' | 'DEGRADED' | 'ISOLATED' | 'CIRCUIT_BROKEN';\r\n\r\nexport interface QueueMessage {\r\n  id: string;\r\n  tenantId: string;\r\n  queueName: string;\r\n  priority: QueuePriority;\r\n  payload: Record<string, any>;\r\n  attempts: number;\r\n  maxAttempts: number;\r\n  delayUntil?: Date;\r\n  createdAt: Date;\r\n  scheduledAt: Date;\r\n  expiresAt: Date;\r\n  correlationId: string;\r\n  metadata: Record<string, any>;\r\n}\r\n\r\nexport interface QueueConfig {\r\n  maxSize: number;\r\n  processingConcurrency: number;\r\n  retryPolicy: {\r\n    maxAttempts: number;\r\n    backoffMultiplier: number;\r\n    initialDelay: number;\r\n    maxDelay: number;\r\n  };\r\n  deadLetterQueue: boolean;\r\n  priorityQueues: boolean;\r\n  tenantIsolation: boolean;\r\n  circuitBreaker: {\r\n    failureThreshold: number;\r\n    resetTimeout: number;\r\n  };\r\n}\r\n\r\nexport interface QueueMetrics {\r\n  totalMessages: number;\r\n  pendingMessages: number;\r\n  processingMessages: number;\r\n  completedMessages: number;\r\n  failedMessages: number;\r\n  deadLetterMessages: number;\r\n  averageProcessingTime: number;\r\n  throughputPerSecond: number;\r\n  errorRate: number;\r\n  tenantBacklog: Record<string, number>;\r\n  priorityBacklog: Record<QueuePriority, number>;\r\n}\r\n\r\nexport interface QueueBoundary {\r\n  queueName: string;\r\n  status: QueueStatus;\r\n  config: QueueConfig;\r\n  metrics: QueueMetrics;\r\n  lastActivity: Date;\r\n  circuitBreakerState: 'CLOSED' | 'OPEN' | 'HALF_OPEN';\r\n  tenantQuarantines: Set<string>;\r\n  rateLimits: Map<string, { count: number; resetTime: Date }>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Queue Boundary Manager\r\n * \r\n * This class manages queue boundaries with tenant isolation, priority processing,\r\n * and circuit breaker protection to prevent cascade failures.\r\n */\r\nexport class QueueBoundaryManager {\r\n  private static instance: QueueBoundaryManager;\r\n  private auditLogger: any;\r\n  private boundaries: Map<string, QueueBoundary> = new Map();\r\n  private messageStore: Map<string, QueueMessage> = new Map();\r\n  private processors: Map<string, NodeJS.Timeout> = new Map();\r\n  private defaultConfig: QueueConfig;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.defaultConfig = this.initializeDefaultConfig();\r\n    this.startQueueMonitoring();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): QueueBoundaryManager {\r\n    if (!QueueBoundaryManager.instance) {\r\n      QueueBoundaryManager.instance = new QueueBoundaryManager();\r\n    }\r\n    return QueueBoundaryManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create or get queue boundary\r\n   */\r\n  getQueueBoundary(queueName: string, config: Partial<QueueConfig> = {}): QueueBoundary {\r\n    let boundary = this.boundaries.get(queueName);\r\n    \r\n    if (!boundary) {\r\n      const mergedConfig = { ...this.defaultConfig, ...config };\r\n      boundary = this.initializeBoundary(queueName, mergedConfig);\r\n      this.boundaries.set(queueName, boundary);\r\n      this.startQueueProcessor(queueName);\r\n    }\r\n\r\n    return boundary;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Enqueue message with boundary protection\r\n   */\r\n  async enqueue(\r\n    queueName: string,\r\n    tenantId: string,\r\n    payload: Record<string, any>,\r\n    priority: QueuePriority = 'NORMAL',\r\n    delayUntil?: Date,\r\n    correlationId?: string,\r\n    metadata: Record<string, any> = {}\r\n  ): Promise<string> {\r\n    const boundary = this.getQueueBoundary(queueName);\r\n    const messageId = this.generateMessageId();\r\n\r\n    // CRITICAL: Validate enqueue preconditions\r\n    this.validateEnqueuePreconditions(boundary, tenantId, priority);\r\n\r\n    const message: QueueMessage = {\r\n      id: messageId,\r\n      tenantId,\r\n      queueName,\r\n      priority,\r\n      payload,\r\n      attempts: 0,\r\n      maxAttempts: boundary.config.retryPolicy.maxAttempts,\r\n      delayUntil,\r\n      createdAt: new Date(),\r\n      scheduledAt: delayUntil || new Date(),\r\n      expiresAt: new Date(Date.now() + 86400000), // 24 hours\r\n      correlationId: correlationId || this.generateCorrelationId(),\r\n      metadata\r\n    };\r\n\r\n    // CRITICAL: Store message\r\n    this.messageStore.set(messageId, message);\r\n\r\n    // CRITICAL: Update metrics\r\n    this.updateBoundaryMetrics(boundary, 'ENQUEUE', message);\r\n\r\n    // CRITICAL: Log enqueue\r\n    this.auditLogger.logDataMutation({\r\n      tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'MESSAGE_ENQUEUED',\r\n      resourceType: 'QUEUE_MESSAGE',\r\n      resourceId: messageId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: message.correlationId,\r\n      metadata: {\r\n        queueName,\r\n        priority,\r\n        scheduledAt: message.scheduledAt,\r\n        payloadSize: JSON.stringify(payload).length\r\n      }\r\n    });\r\n\r\n    logger.info('Message enqueued', {\r\n      messageId,\r\n      queueName,\r\n      tenantId,\r\n      priority,\r\n      scheduledAt: message.scheduledAt\r\n    });\r\n\r\n    return messageId;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Dequeue message with boundary protection\r\n   */\r\n  async dequeue(queueName: string, tenantId?: string): Promise<QueueMessage | null> {\r\n    const boundary = this.getQueueBoundary(queueName);\r\n\r\n    // CRITICAL: Check boundary status\r\n    if (boundary.status === 'CIRCUIT_BROKEN') {\r\n      throw new Error(`Queue ${queueName} is circuit broken`);\r\n    }\r\n\r\n    if (boundary.status === 'ISOLATED') {\r\n      throw new Error(`Queue ${queueName} is isolated`);\r\n    }\r\n\r\n    // CRITICAL: Find next message\r\n    const message = this.findNextMessage(boundary, tenantId);\r\n    \r\n    if (!message) {\r\n      return null;\r\n    }\r\n\r\n    // CRITICAL: Update message state\r\n    message.attempts++;\r\n    this.messageStore.set(message.id, message);\r\n\r\n    // CRITICAL: Update metrics\r\n    this.updateBoundaryMetrics(boundary, 'DEQUEUE', message);\r\n\r\n    // CRITICAL: Log dequeue\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: message.tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'MESSAGE_DEQUEUED',\r\n      resourceType: 'QUEUE_MESSAGE',\r\n      resourceId: message.id,\r\n      outcome: 'SUCCESS',\r\n      correlationId: message.correlationId,\r\n      metadata: {\r\n        queueName,\r\n        attempts: message.attempts,\r\n        processingTime: Date.now() - message.createdAt.getTime()\r\n      }\r\n    });\r\n\r\n    return message;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Acknowledge message completion\r\n   */\r\n  async acknowledge(messageId: string, result?: any): Promise<void> {\r\n    const message = this.messageStore.get(messageId);\r\n    \r\n    if (!message) {\r\n      throw new Error(`Message ${messageId} not found`);\r\n    }\r\n\r\n    const boundary = this.getQueueBoundary(message.queueName);\r\n\r\n    // CRITICAL: Remove message from store\r\n    this.messageStore.delete(messageId);\r\n\r\n    // CRITICAL: Update metrics\r\n    this.updateBoundaryMetrics(boundary, 'ACKNOWLEDGE', message);\r\n\r\n    // CRITICAL: Log acknowledgment\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: message.tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'MESSAGE_ACKNOWLEDGED',\r\n      resourceType: 'QUEUE_MESSAGE',\r\n      resourceId: messageId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: message.correlationId,\r\n      metadata: {\r\n        queueName: message.queueName,\r\n        attempts: message.attempts,\r\n        processingTime: Date.now() - message.createdAt.getTime(),\r\n        result: result ? 'SUCCESS' : 'NO_RESULT'\r\n      }\r\n    });\r\n\r\n    logger.info('Message acknowledged', {\r\n      messageId,\r\n      queueName: message.queueName,\r\n      tenantId: message.tenantId,\r\n      attempts: message.attempts\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Reject message (retry or dead letter)\r\n   */\r\n  async reject(messageId: string, error: Error, shouldRetry: boolean = true): Promise<void> {\r\n    const message = this.messageStore.get(messageId);\r\n    \r\n    if (!message) {\r\n      throw new Error(`Message ${messageId} not found`);\r\n    }\r\n\r\n    const boundary = this.getQueueBoundary(message.queueName);\r\n\r\n    // CRITICAL: Check if should retry\r\n    if (shouldRetry && message.attempts < message.maxAttempts) {\r\n      // CRITICAL: Schedule retry with exponential backoff\r\n      const retryDelay = this.calculateRetryDelay(message.attempts, boundary.config.retryPolicy);\r\n      message.delayUntil = new Date(Date.now() + retryDelay);\r\n      message.scheduledAt = message.delayUntil;\r\n      \r\n      this.messageStore.set(messageId, message);\r\n\r\n      // CRITICAL: Update metrics\r\n      this.updateBoundaryMetrics(boundary, 'RETRY', message);\r\n\r\n      // CRITICAL: Log retry\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: message.tenantId,\r\n        actorId: 'queue-system',\r\n        action: 'MESSAGE_RETRY',\r\n        resourceType: 'QUEUE_MESSAGE',\r\n        resourceId: messageId,\r\n        outcome: 'SUCCESS',\r\n        correlationId: message.correlationId,\r\n        metadata: {\r\n          queueName: message.queueName,\r\n          attempts: message.attempts,\r\n          retryDelay,\r\n          error: error.message\r\n        }\r\n      });\r\n\r\n      logger.warn('Message scheduled for retry', {\r\n        messageId,\r\n        queueName: message.queueName,\r\n        tenantId: message.tenantId,\r\n        attempts: message.attempts,\r\n        retryDelay\r\n      });\r\n\r\n    } else {\r\n      // CRITICAL: Send to dead letter queue\r\n      await this.sendToDeadLetterQueue(message, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get queue boundary metrics\r\n   */\r\n  getBoundaryMetrics(queueName: string): QueueMetrics | null {\r\n    const boundary = this.boundaries.get(queueName);\r\n    return boundary ? { ...boundary.metrics } : null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get all boundary metrics\r\n   */\r\n  getAllBoundaryMetrics(): Map<string, QueueMetrics> {\r\n    const metrics = new Map<string, QueueMetrics>();\r\n    \r\n    for (const [queueName, boundary] of this.boundaries.entries()) {\r\n      metrics.set(queueName, { ...boundary.metrics });\r\n    }\r\n\r\n    return metrics;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Quarantine tenant from queue\r\n   */\r\n  quarantineTenant(queueName: string, tenantId: string, reason: string): void {\r\n    const boundary = this.getQueueBoundary(queueName);\r\n    \r\n    boundary.tenantQuarantines.add(tenantId);\r\n\r\n    // CRITICAL: Log quarantine\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'TENANT_QUARANTINED',\r\n      resourceType: 'QUEUE_BOUNDARY',\r\n      resourceId: queueName,\r\n      outcome: 'SUCCESS',\r\n      correlationId: `quarantine_${tenantId}_${Date.now()}`,\r\n      severity: 'HIGH',\r\n      metadata: {\r\n        queueName,\r\n        reason,\r\n        quarantinedAt: new Date()\r\n      }\r\n    });\r\n\r\n    logger.warn('Tenant quarantined from queue', {\r\n      queueName,\r\n      tenantId,\r\n      reason\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Remove tenant quarantine\r\n   */\r\n  removeTenantQuarantine(queueName: string, tenantId: string): void {\r\n    const boundary = this.getQueueBoundary(queueName);\r\n    \r\n    if (boundary.tenantQuarantines.delete(tenantId)) {\r\n      // CRITICAL: Log quarantine removal\r\n      this.auditLogger.logSecurityEvent({\r\n        tenantId,\r\n        actorId: 'queue-system',\r\n        action: 'TENANT_QUARANTINE_REMOVED',\r\n        resourceType: 'QUEUE_BOUNDARY',\r\n        resourceId: queueName,\r\n        outcome: 'SUCCESS',\r\n        correlationId: `unquarantine_${tenantId}_${Date.now()}`,\r\n        severity: 'LOW',\r\n        metadata: {\r\n          queueName,\r\n          removedAt: new Date()\r\n        }\r\n      });\r\n\r\n      logger.info('Tenant quarantine removed', {\r\n        queueName,\r\n        tenantId\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Isolate queue boundary\r\n   */\r\n  isolateBoundary(queueName: string, reason: string): void {\r\n    const boundary = this.getQueueBoundary(queueName);\r\n    \r\n    boundary.status = 'ISOLATED';\r\n\r\n    // CRITICAL: Log isolation\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'queue-system',\r\n      action: 'QUEUE_ISOLATED',\r\n      resourceType: 'QUEUE_BOUNDARY',\r\n      resourceId: queueName,\r\n      outcome: 'SUCCESS',\r\n      correlationId: `isolate_${queueName}_${Date.now()}`,\r\n      severity: 'HIGH',\r\n      metadata: {\r\n        queueName,\r\n        reason,\r\n        isolatedAt: new Date()\r\n      }\r\n    });\r\n\r\n    logger.error('Queue boundary isolated', {\r\n      queueName,\r\n      reason\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Restore queue boundary\r\n   */\r\n  restoreBoundary(queueName: string): void {\r\n    const boundary = this.getQueueBoundary(queueName);\r\n    \r\n    boundary.status = 'ACTIVE';\r\n    boundary.circuitBreakerState = 'CLOSED';\r\n\r\n    // CRITICAL: Log restoration\r\n    this.auditLogger.logSecurityEvent({\r\n      tenantId: 'system',\r\n      actorId: 'queue-system',\r\n      action: 'QUEUE_RESTORED',\r\n      resourceType: 'QUEUE_BOUNDARY',\r\n      resourceId: queueName,\r\n      outcome: 'SUCCESS',\r\n      correlationId: `restore_${queueName}_${Date.now()}`,\r\n      severity: 'LOW',\r\n      metadata: {\r\n        queueName,\r\n        restoredAt: new Date()\r\n      }\r\n    });\r\n\r\n    logger.info('Queue boundary restored', {\r\n      queueName\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate enqueue preconditions\r\n   */\r\n  private validateEnqueuePreconditions(boundary: QueueBoundary, tenantId: string, priority: QueuePriority): void {\r\n    // CRITICAL: Check boundary status\r\n    if (boundary.status === 'CIRCUIT_BROKEN') {\r\n      throw new Error(`Queue ${boundary.queueName} is circuit broken`);\r\n    }\r\n\r\n    if (boundary.status === 'ISOLATED') {\r\n      throw new Error(`Queue ${boundary.queueName} is isolated`);\r\n    }\r\n\r\n    // CRITICAL: Check tenant quarantine\r\n    if (boundary.tenantQuarantines.has(tenantId)) {\r\n      throw new Error(`Tenant ${tenantId} is quarantined from queue ${boundary.queueName}`);\r\n    }\r\n\r\n    // CRITICAL: Check queue size limit\r\n    if (boundary.metrics.pendingMessages >= boundary.config.maxSize) {\r\n      throw new Error(`Queue ${boundary.queueName} is full (${boundary.metrics.pendingMessages}/${boundary.config.maxSize})`);\r\n    }\r\n\r\n    // CRITICAL: Check rate limits\r\n    this.checkRateLimits(boundary, tenantId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check rate limits\r\n   */\r\n  private checkRateLimits(boundary: QueueBoundary, tenantId: string): void {\r\n    const now = new Date();\r\n    const rateLimit = boundary.rateLimits.get(tenantId);\r\n\r\n    if (rateLimit && rateLimit.resetTime > now) {\r\n      if (rateLimit.count >= 100) { // 100 messages per minute per tenant\r\n        throw new Error(`Rate limit exceeded for tenant ${tenantId} in queue ${boundary.queueName}`);\r\n      }\r\n    } else {\r\n      // CRITICAL: Reset or create rate limit\r\n      boundary.rateLimits.set(tenantId, {\r\n        count: 0,\r\n        resetTime: new Date(now.getTime() + 60000) // 1 minute\r\n      });\r\n    }\r\n\r\n    // CRITICAL: Increment count\r\n    const currentRateLimit = boundary.rateLimits.get(tenantId)!;\r\n    currentRateLimit.count++;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Find next message to process\r\n   */\r\n  private findNextMessage(boundary: QueueBoundary, tenantId?: string): QueueMessage | null {\r\n    const now = new Date();\r\n    let candidates: QueueMessage[] = [];\r\n\r\n    // CRITICAL: Filter messages by criteria\r\n    for (const message of this.messageStore.values()) {\r\n      if (message.queueName !== boundary.queueName) continue;\r\n      if (message.scheduledAt > now) continue;\r\n      if (message.expiresAt < now) continue;\r\n      if (tenantId && message.tenantId !== tenantId) continue;\r\n      if (boundary.tenantQuarantines.has(message.tenantId)) continue;\r\n\r\n      candidates.push(message);\r\n    }\r\n\r\n    // CRITICAL: Sort by priority and creation time\r\n    candidates.sort((a, b) => {\r\n      const priorityOrder = { CRITICAL: 0, HIGH: 1, NORMAL: 2, LOW: 3, BACKGROUND: 4 };\r\n      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\r\n      \r\n      if (priorityDiff !== 0) {\r\n        return priorityDiff;\r\n      }\r\n\r\n      return a.createdAt.getTime() - b.createdAt.getTime();\r\n    });\r\n\r\n    return candidates.length > 0 ? candidates[0] : null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate retry delay\r\n   */\r\n  private calculateRetryDelay(attempt: number, retryPolicy: QueueConfig['retryPolicy']): number {\r\n    const delay = retryPolicy.initialDelay * Math.pow(retryPolicy.backoffMultiplier, attempt - 1);\r\n    return Math.min(delay, retryPolicy.maxDelay);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Send to dead letter queue\r\n   */\r\n  private async sendToDeadLetterQueue(message: QueueMessage, error: Error): Promise<void> {\r\n    // CRITICAL: Remove from active store\r\n    this.messageStore.delete(message.id);\r\n\r\n    // CRITICAL: Update metrics\r\n    const boundary = this.getBoundaryMessage(message.id);\r\n    if (boundary) {\r\n      this.updateBoundaryMetrics(boundary, 'DEAD_LETTER', message);\r\n    }\r\n\r\n    // CRITICAL: Log dead letter\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: message.tenantId,\r\n      actorId: 'queue-system',\r\n      action: 'MESSAGE_DEAD_LETTER',\r\n      resourceType: 'QUEUE_MESSAGE',\r\n      resourceId: message.id,\r\n      outcome: 'FAILURE',\r\n      correlationId: message.correlationId,\r\n      metadata: {\r\n        queueName: message.queueName,\r\n        attempts: message.attempts,\r\n        error: error.message,\r\n        processingTime: Date.now() - message.createdAt.getTime()\r\n      }\r\n    });\r\n\r\n    logger.error('Message sent to dead letter queue', {\r\n      messageId: message.id,\r\n      queueName: message.queueName,\r\n      tenantId: message.tenantId,\r\n      attempts: message.attempts,\r\n      error: error.message\r\n    });\r\n\r\n    // CRITICAL: In a real implementation, this would store the message in a dead letter queue\r\n    // For now, we just log and remove it\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get boundary for message\r\n   */\r\n  private getBoundaryMessage(messageId: string): QueueBoundary | null {\r\n    const message = this.messageStore.get(messageId);\r\n    return message ? this.boundaries.get(message.queueName) : null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update boundary metrics\r\n   */\r\n  private updateBoundaryMetrics(boundary: QueueBoundary, action: string, message?: QueueMessage): void {\r\n    const now = new Date();\r\n    boundary.lastActivity = now;\r\n\r\n    // CRITICAL: Recalculate metrics from message store\r\n    const messages = Array.from(this.messageStore.values())\r\n      .filter(msg => msg.queueName === boundary.queueName);\r\n\r\n    boundary.metrics.totalMessages = messages.length;\r\n    boundary.metrics.pendingMessages = messages.filter(msg => msg.scheduledAt <= now && msg.expiresAt > now).length;\r\n    boundary.metrics.processingMessages = messages.filter(msg => msg.attempts > 0).length;\r\n    \r\n    // CRITICAL: Calculate tenant backlog\r\n    boundary.metrics.tenantBacklog = {};\r\n    for (const msg of messages) {\r\n      boundary.metrics.tenantBacklog[msg.tenantId] = (boundary.metrics.tenantBacklog[msg.tenantId] || 0) + 1;\r\n    }\r\n\r\n    // CRITICAL: Calculate priority backlog\r\n    boundary.metrics.priorityBacklog = {\r\n      CRITICAL: 0,\r\n      HIGH: 0,\r\n      NORMAL: 0,\r\n      LOW: 0,\r\n      BACKGROUND: 0\r\n    };\r\n    \r\n    for (const msg of messages) {\r\n      boundary.metrics.priorityBacklog[msg.priority]++;\r\n    }\r\n\r\n    // CRITICAL: Update circuit breaker state based on failures\r\n    this.updateCircuitBreakerState(boundary);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Update circuit breaker state\r\n   */\r\n  private updateCircuitBreakerState(boundary: QueueBoundary): void {\r\n    const recentMessages = Array.from(this.messageStore.values())\r\n      .filter(msg => msg.queueName === boundary.queueName)\r\n      .filter(msg => Date.now() - msg.createdAt.getTime() < 300000); // Last 5 minutes\r\n\r\n    const failureRate = recentMessages.length > 0 \r\n      ? (recentMessages.filter(msg => msg.attempts >= msg.maxAttempts).length / recentMessages.length) * 100\r\n      : 0;\r\n\r\n    if (boundary.circuitBreakerState === 'CLOSED' && failureRate > 50) {\r\n      boundary.circuitBreakerState = 'OPEN';\r\n      boundary.status = 'CIRCUIT_BROKEN';\r\n      \r\n      logger.error('Queue circuit breaker tripped', {\r\n        queueName: boundary.queueName,\r\n        failureRate,\r\n        recentFailures: recentMessages.filter(msg => msg.attempts >= msg.maxAttempts).length\r\n      });\r\n    } else if (boundary.circuitBreakerState === 'OPEN' && failureRate < 20) {\r\n      boundary.circuitBreakerState = 'HALF_OPEN';\r\n      \r\n      logger.info('Queue circuit breaker entering half-open state', {\r\n        queueName: boundary.queueName,\r\n        failureRate\r\n      });\r\n    } else if (boundary.circuitBreakerState === 'HALF_OPEN' && failureRate < 10) {\r\n      boundary.circuitBreakerState = 'CLOSED';\r\n      boundary.status = 'ACTIVE';\r\n      \r\n      logger.info('Queue circuit breaker reset', {\r\n        queueName: boundary.queueName,\r\n        failureRate\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize boundary\r\n   */\r\n  private initializeBoundary(queueName: string, config: QueueConfig): QueueBoundary {\r\n    return {\r\n      queueName,\r\n      status: 'ACTIVE',\r\n      config,\r\n      metrics: this.initializeMetrics(),\r\n      lastActivity: new Date(),\r\n      circuitBreakerState: 'CLOSED',\r\n      tenantQuarantines: new Set(),\r\n      rateLimits: new Map()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize metrics\r\n   */\r\n  private initializeMetrics(): QueueMetrics {\r\n    return {\r\n      totalMessages: 0,\r\n      pendingMessages: 0,\r\n      processingMessages: 0,\r\n      completedMessages: 0,\r\n      failedMessages: 0,\r\n      deadLetterMessages: 0,\r\n      averageProcessingTime: 0,\r\n      throughputPerSecond: 0,\r\n      errorRate: 0,\r\n      tenantBacklog: {},\r\n      priorityBacklog: {\r\n        CRITICAL: 0,\r\n        HIGH: 0,\r\n        NORMAL: 0,\r\n        LOW: 0,\r\n        BACKGROUND: 0\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize default config\r\n   */\r\n  private initializeDefaultConfig(): QueueConfig {\r\n    return {\r\n      maxSize: 10000,\r\n      processingConcurrency: 10,\r\n      retryPolicy: {\r\n        maxAttempts: 3,\r\n        backoffMultiplier: 2,\r\n        initialDelay: 1000, // 1 second\r\n        maxDelay: 300000 // 5 minutes\r\n      },\r\n      deadLetterQueue: true,\r\n      priorityQueues: true,\r\n      tenantIsolation: true,\r\n      circuitBreaker: {\r\n        failureThreshold: 10,\r\n        resetTimeout: 60000 // 1 minute\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start queue processor\r\n   */\r\n  private startQueueProcessor(queueName: string): void {\r\n    const processor = setInterval(() => {\r\n      this.processQueue(queueName);\r\n    }, 1000); // Process every second\r\n\r\n    this.processors.set(queueName, processor);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Process queue\r\n   */\r\n  private async processQueue(queueName: string): Promise<void> {\r\n    try {\r\n      const boundary = this.getQueueBoundary(queueName);\r\n      \r\n      if (boundary.status !== 'ACTIVE') {\r\n        return;\r\n      }\r\n\r\n      // CRITICAL: Process up to concurrency limit\r\n      const processingCount = Math.min(boundary.config.processingConcurrency, boundary.metrics.pendingMessages);\r\n      \r\n      for (let i = 0; i < processingCount; i++) {\r\n        const message = await this.dequeue(queueName);\r\n        \r\n        if (message) {\r\n          // CRITICAL: In a real implementation, this would call the actual message handler\r\n          // For now, we'll just acknowledge the message\r\n          await this.acknowledge(message.id, { processed: true });\r\n        }\r\n      }\r\n\r\n    } catch (error) {\r\n      logger.error('Queue processor error', error as Error, { queueName });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start queue monitoring\r\n   */\r\n  private startQueueMonitoring(): void {\r\n    // CRITICAL: Periodic metrics update\r\n    setInterval(() => {\r\n      for (const boundary of this.boundaries.values()) {\r\n        this.updateBoundaryMetrics(boundary, 'MONITOR');\r\n      }\r\n    }, 10000); // Every 10 seconds\r\n\r\n    // CRITICAL: Periodic cleanup\r\n    setInterval(() => {\r\n      this.cleanupExpiredMessages();\r\n    }, 60000); // Every minute\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup expired messages\r\n   */\r\n  private cleanupExpiredMessages(): void {\r\n    const now = new Date();\r\n    let cleanedCount = 0;\r\n\r\n    for (const [messageId, message] of this.messageStore.entries()) {\r\n      if (message.expiresAt < now) {\r\n        this.messageStore.delete(messageId);\r\n        cleanedCount++;\r\n      }\r\n    }\r\n\r\n    if (cleanedCount > 0) {\r\n      logger.info('Cleaned up expired messages', { cleanedCount });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate message ID\r\n   */\r\n  private generateMessageId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `msg_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global queue boundary manager instance\r\n */\r\nexport const queueBoundaryManager = QueueBoundaryManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const enqueueMessage = async (\r\n  queueName: string,\r\n  tenantId: string,\r\n  payload: Record<string, any>,\r\n  priority: QueuePriority = 'NORMAL',\r\n  delayUntil?: Date,\r\n  correlationId?: string,\r\n  metadata: Record<string, any> = {}\r\n): Promise<string> => {\r\n  return await queueBoundaryManager.enqueue(queueName, tenantId, payload, priority, delayUntil, correlationId, metadata);\r\n};\r\n\r\nexport const dequeueMessage = async (queueName: string, tenantId?: string): Promise<QueueMessage | null> => {\r\n  return await queueBoundaryManager.dequeue(queueName, tenantId);\r\n};\r\n\r\nexport const acknowledgeMessage = async (messageId: string, result?: any): Promise<void> => {\r\n  return await queueBoundaryManager.acknowledge(messageId, result);\r\n};\r\n\r\nexport const rejectMessage = async (messageId: string, error: Error, shouldRetry: boolean = true): Promise<void> => {\r\n  return await queueBoundaryManager.reject(messageId, error, shouldRetry);\r\n};\r\n\r\nexport const getQueueMetrics = (queueName: string): QueueMetrics | null => {\r\n  return queueBoundaryManager.getBoundaryMetrics(queueName);\r\n};\r\n\r\nexport const quarantineTenantFromQueue = (queueName: string, tenantId: string, reason: string): void => {\r\n  queueBoundaryManager.quarantineTenant(queueName, tenantId, reason);\r\n};\r\n\r\nexport const isolateQueue = (queueName: string, reason: string): void => {\r\n  queueBoundaryManager.isolateBoundary(queueName, reason);\r\n};\r\n\r\nexport const restoreQueue = (queueName: string): void => {\r\n  queueBoundaryManager.restoreBoundary(queueName);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\rate-limiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\recovery-strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":649,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":649,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":1103,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":1103,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":1112,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":1112,"endColumn":37},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":1121,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":1121,"endColumn":37}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Recovery Strategy Implementation\r\n// MANDATORY: Point-in-time recovery with tenant isolation and RPO/RTO enforcement\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\nimport { getImmutableAuditLogger } from '../compliance/immutable-audit-log.js';\r\nimport { TenantContext } from '../tenant/tenant-isolation.js';\r\n\r\nexport type RecoveryType = 'FULL' | 'PARTIAL' | 'TENANT' | 'DATABASE' | 'AUDIT' | 'CONFIG';\r\nexport type RecoveryStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED' | 'CANCELLED';\r\n\r\nexport interface RecoveryPoint {\r\n  id: string;\r\n  type: RecoveryType;\r\n  tenantId?: string;\r\n  timestamp: Date;\r\n  description: string;\r\n  size: number; // Size in bytes\r\n  checksum: string;\r\n  metadata: Record<string, any>;\r\n  expiresAt: Date;\r\n  retentionDays: number;\r\n}\r\n\r\nexport interface RecoveryOperation {\r\n  id: string;\r\n  type: RecoveryType;\r\n  tenantId?: string;\r\n  recoveryPointId: string;\r\n  status: RecoveryStatus;\r\n  startedAt: Date;\r\n  completedAt?: Date;\r\n  estimatedDuration: number;\r\n  actualDuration?: number;\r\n  progress: number;\r\n  error?: string;\r\n  metadata: Record<string, any>;\r\n  correlationId: string;\r\n}\r\n\r\nexport interface RPO_RTO_Definitions {\r\n  database: {\r\n    RPO: number; // Recovery Point Objective in seconds\r\n    RTO: number; // Recovery Time Objective in seconds\r\n    backupFrequency: number; // Backup frequency in seconds\r\n    retentionDays: number;\r\n  };\r\n  audit: {\r\n    RPO: number;\r\n    RTO: number;\r\n    backupFrequency: number;\r\n    retentionDays: number;\r\n  };\r\n  tenant: {\r\n    RPO: number;\r\n    RTO: number;\r\n    backupFrequency: number;\r\n    retentionDays: number;\r\n  };\r\n  config: {\r\n    RPO: number;\r\n    RTO: number;\r\n    backupFrequency: number;\r\n    retentionDays: number;\r\n  };\r\n}\r\n\r\nexport interface RecoveryStrategy {\r\n  type: RecoveryType;\r\n  description: string;\r\n  preconditions: string[];\r\n  steps: Array<{\r\n    step: number;\r\n    description: string;\r\n    action: string;\r\n    estimatedDuration: number;\r\n    rollbackAction?: string;\r\n  }>;\r\n  rollbackSteps: Array<{\r\n    step: number;\r\n    description: string;\r\n    action: string;\r\n  }>;\r\n  validationSteps: Array<{\r\n    step: number;\r\n    description: string;\r\n    action: string;\r\n    expectedResult: string;\r\n  }>;\r\n}\r\n\r\n/**\r\n * CRITICAL: Recovery Strategy Manager\r\n * \r\n * This class manages point-in-time recovery with tenant isolation,\r\n * RPO/RTO enforcement, and comprehensive recovery procedures.\r\n */\r\nexport class RecoveryStrategyManager {\r\n  private static instance: RecoveryStrategyManager;\r\n  private auditLogger: any;\r\n  private recoveryPoints: Map<string, RecoveryPoint> = new Map();\r\n  private recoveryOperations: Map<string, RecoveryOperation> = new Map();\r\n  private rpoRtoDefinitions: RPO_RTO_Definitions;\r\n  private recoveryStrategies: Map<RecoveryType, RecoveryStrategy>;\r\n\r\n  private constructor() {\r\n    this.auditLogger = getImmutableAuditLogger();\r\n    this.rpoRtoDefinitions = this.initializeRPORTO();\r\n    this.recoveryStrategies = this.initializeStrategies();\r\n    this.startRecoveryMonitoring();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): RecoveryStrategyManager {\r\n    if (!RecoveryStrategyManager.instance) {\r\n      RecoveryStrategyManager.instance = new RecoveryStrategyManager();\r\n    }\r\n    return RecoveryStrategyManager.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Create recovery point\r\n   */\r\n  async createRecoveryPoint(\r\n    type: RecoveryType,\r\n    tenantId: string | undefined,\r\n    description: string,\r\n    metadata: Record<string, any> = {}\r\n  ): Promise<RecoveryPoint> {\r\n    const recoveryPointId = this.generateRecoveryPointId();\r\n    const timestamp = new Date();\r\n    const retentionDays = this.getRetentionDays(type);\r\n\r\n    // CRITICAL: Validate preconditions\r\n    await this.validateRecoveryPointPreconditions(type, tenantId);\r\n\r\n    // CRITICAL: Create recovery point\r\n    const recoveryPoint: RecoveryPoint = {\r\n      id: recoveryPointId,\r\n      type,\r\n      tenantId,\r\n      timestamp,\r\n      description,\r\n      size: await this.calculateRecoveryPointSize(type, tenantId),\r\n      checksum: await this.generateChecksum(type, tenantId, timestamp),\r\n      metadata,\r\n      expiresAt: new Date(timestamp.getTime() + (retentionDays * 24 * 60 * 60 * 1000)),\r\n      retentionDays\r\n    };\r\n\r\n    // CRITICAL: Store recovery point\r\n    this.recoveryPoints.set(recoveryPointId, recoveryPoint);\r\n\r\n    // CRITICAL: Log recovery point creation\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: tenantId || 'system',\r\n      actorId: 'recovery-system',\r\n      action: 'RECOVERY_POINT_CREATED',\r\n      resourceType: 'RECOVERY_POINT',\r\n      resourceId: recoveryPointId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: `recovery_point_${recoveryPointId}`,\r\n      metadata: {\r\n        type,\r\n        description,\r\n        size: recoveryPoint.size,\r\n        checksum: recoveryPoint.checksum,\r\n        retentionDays\r\n      }\r\n    });\r\n\r\n    logger.info('Recovery point created', {\r\n      recoveryPointId,\r\n      type,\r\n      tenantId,\r\n      description,\r\n      size: recoveryPoint.size\r\n    });\r\n\r\n    return recoveryPoint;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start recovery operation\r\n   */\r\n  async startRecovery(\r\n    type: RecoveryType,\r\n    recoveryPointId: string,\r\n    tenantId?: string,\r\n    correlationId?: string\r\n  ): Promise<RecoveryOperation> {\r\n    const recoveryPoint = this.recoveryPoints.get(recoveryPointId);\r\n    if (!recoveryPoint) {\r\n      throw new Error(`Recovery point ${recoveryPointId} not found`);\r\n    }\r\n\r\n    // CRITICAL: Validate recovery point\r\n    await this.validateRecoveryPoint(recoveryPoint);\r\n\r\n    const operationId = this.generateOperationId();\r\n    const strategy = this.recoveryStrategies.get(type);\r\n    if (!strategy) {\r\n      throw new Error(`Recovery strategy for type ${type} not found`);\r\n    }\r\n    const estimatedDuration = strategy.steps.reduce((sum, step) => sum + step.estimatedDuration, 0);\r\n\r\n    const operation: RecoveryOperation = {\r\n      id: operationId,\r\n      type,\r\n      tenantId,\r\n      recoveryPointId,\r\n      status: 'PENDING',\r\n      startedAt: new Date(),\r\n      estimatedDuration,\r\n      progress: 0,\r\n      correlationId: correlationId || this.generateCorrelationId(),\r\n      metadata: {}\r\n    };\r\n\r\n    // CRITICAL: Store operation\r\n    this.recoveryOperations.set(operationId, operation);\r\n\r\n    // CRITICAL: Log recovery start\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: tenantId || 'system',\r\n      actorId: 'recovery-system',\r\n      action: 'RECOVERY_STARTED',\r\n      resourceType: 'RECOVERY_OPERATION',\r\n      resourceId: operationId,\r\n      outcome: 'SUCCESS',\r\n      correlationId: operation.correlationId,\r\n      metadata: {\r\n        type,\r\n        recoveryPointId,\r\n        estimatedDuration,\r\n        recoveryPointTimestamp: recoveryPoint.timestamp\r\n      }\r\n    });\r\n\r\n    // CRITICAL: Start recovery in background\r\n    setTimeout(() => {\r\n      void this.executeRecovery(operation, strategy);\r\n    }, 0);\r\n\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get recovery operation status\r\n   */\r\n  getRecoveryStatus(operationId: string): RecoveryOperation | null {\r\n    return this.recoveryOperations.get(operationId) || null;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get all recovery points\r\n   */\r\n  getRecoveryPoints(type?: RecoveryType, tenantId?: string): RecoveryPoint[] {\r\n    const points = Array.from(this.recoveryPoints.values());\r\n    \r\n    return points.filter(point => {\r\n      if (type && point.type !== type) return false;\r\n      if (tenantId && point.tenantId !== tenantId) return false;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get recovery operations\r\n   */\r\n  getRecoveryOperations(type?: RecoveryType, tenantId?: string, status?: RecoveryStatus): RecoveryOperation[] {\r\n    const operations = Array.from(this.recoveryOperations.values());\r\n    \r\n    return operations.filter(op => {\r\n      if (type && op.type !== type) return false;\r\n      if (tenantId && op.tenantId !== tenantId) return false;\r\n      if (status && op.status !== status) return false;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  resetForTests(): void {\r\n    this.recoveryPoints.clear();\r\n    this.recoveryOperations.clear();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate RPO/RTO compliance\r\n   */\r\n  async validateRPORTOCompliance(): Promise<{\r\n    compliant: boolean;\r\n    violations: Array<{\r\n      type: string;\r\n      metric: string;\r\n      actual: number;\r\n      required: number;\r\n      violation: string;\r\n    }>;\r\n  }> {\r\n    const violations: any[] = [];\r\n    const now = Date.now();\r\n\r\n    // CRITICAL: Check database RPO/RTO\r\n    const dbPoints = this.getRecoveryPoints('DATABASE');\r\n    if (dbPoints.length > 0) {\r\n      const latestDbPoint = dbPoints[0];\r\n      const dbRPO = (now - latestDbPoint.timestamp.getTime()) / 1000;\r\n      \r\n      if (dbRPO > this.rpoRtoDefinitions.database.RPO) {\r\n        violations.push({\r\n          type: 'DATABASE',\r\n          metric: 'RPO',\r\n          actual: dbRPO,\r\n          required: this.rpoRtoDefinitions.database.RPO,\r\n          violation: `Database RPO exceeded: ${dbRPO}s > ${this.rpoRtoDefinitions.database.RPO}s`\r\n        });\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Check audit RPO/RTO\r\n    const auditPoints = this.getRecoveryPoints('AUDIT');\r\n    if (auditPoints.length > 0) {\r\n      const latestAuditPoint = auditPoints[0];\r\n      const auditRPO = (now - latestAuditPoint.timestamp.getTime()) / 1000;\r\n      \r\n      if (auditRPO > this.rpoRtoDefinitions.audit.RPO) {\r\n        violations.push({\r\n          type: 'AUDIT',\r\n          metric: 'RPO',\r\n          actual: auditRPO,\r\n          required: this.rpoRtoDefinitions.audit.RPO,\r\n          violation: `Audit RPO exceeded: ${auditRPO}s > ${this.rpoRtoDefinitions.audit.RPO}s`\r\n        });\r\n      }\r\n    }\r\n\r\n    // CRITICAL: Check tenant RPO/RTO\r\n    const tenantPoints = this.getRecoveryPoints('TENANT');\r\n    for (const point of tenantPoints) {\r\n      const tenantRPO = (now - point.timestamp.getTime()) / 1000;\r\n      \r\n      if (tenantRPO > this.rpoRtoDefinitions.tenant.RPO) {\r\n        violations.push({\r\n          type: 'TENANT',\r\n          metric: 'RPO',\r\n          actual: tenantRPO,\r\n          required: this.rpoRtoDefinitions.tenant.RPO,\r\n          violation: `Tenant ${point.tenantId} RPO exceeded: ${tenantRPO}s > ${this.rpoRtoDefinitions.tenant.RPO}s`\r\n        });\r\n      }\r\n    }\r\n\r\n    return {\r\n      compliant: violations.length === 0,\r\n      violations\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute recovery operation\r\n   */\r\n  private async executeRecovery(operation: RecoveryOperation, strategy: RecoveryStrategy): Promise<void> {\r\n    try {\r\n      // CRITICAL: Update status to IN_PROGRESS\r\n      operation.status = 'IN_PROGRESS';\r\n      this.recoveryOperations.set(operation.id, operation);\r\n\r\n      // CRITICAL: Execute recovery steps\r\n      for (const step of strategy.steps) {\r\n        await this.executeRecoveryStep(operation, step);\r\n        operation.progress = (step.step / strategy.steps.length) * 100;\r\n        this.recoveryOperations.set(operation.id, operation);\r\n      }\r\n\r\n      // CRITICAL: Validate recovery\r\n      await this.validateRecovery(operation, strategy);\r\n\r\n      // CRITICAL: Mark as completed\r\n      operation.status = 'COMPLETED';\r\n      operation.completedAt = new Date();\r\n      operation.actualDuration = operation.completedAt.getTime() - operation.startedAt.getTime();\r\n      this.recoveryOperations.set(operation.id, operation);\r\n\r\n      // CRITICAL: Log completion\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: operation.tenantId || 'system',\r\n        actorId: 'recovery-system',\r\n        action: 'RECOVERY_COMPLETED',\r\n        resourceType: 'RECOVERY_OPERATION',\r\n        resourceId: operation.id,\r\n        outcome: 'SUCCESS',\r\n        correlationId: operation.correlationId,\r\n        metadata: {\r\n          type: operation.type,\r\n          duration: operation.actualDuration,\r\n          estimatedDuration: operation.estimatedDuration\r\n        }\r\n      });\r\n\r\n      logger.info('Recovery completed', {\r\n        operationId: operation.id,\r\n        type: operation.type,\r\n        tenantId: operation.tenantId,\r\n        duration: operation.actualDuration\r\n      });\r\n\r\n    } catch (error) {\r\n      // CRITICAL: Mark as failed\r\n      operation.status = 'FAILED';\r\n      operation.error = (error as Error).message;\r\n      this.recoveryOperations.set(operation.id, operation);\r\n\r\n      // CRITICAL: Log failure\r\n      this.auditLogger.logDataMutation({\r\n        tenantId: operation.tenantId || 'system',\r\n        actorId: 'recovery-system',\r\n        action: 'RECOVERY_FAILED',\r\n        resourceType: 'RECOVERY_OPERATION',\r\n        resourceId: operation.id,\r\n        outcome: 'FAILURE',\r\n        correlationId: operation.correlationId,\r\n        metadata: {\r\n          type: operation.type,\r\n          error: operation.error,\r\n          duration: Date.now() - operation.startedAt.getTime()\r\n        }\r\n      });\r\n\r\n      logger.error('Recovery failed', error as Error, {\r\n        operationId: operation.id,\r\n        type: operation.type,\r\n        tenantId: operation.tenantId\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute recovery step\r\n   */\r\n  private async executeRecoveryStep(operation: RecoveryOperation, step: any): Promise<void> {\r\n    logger.info('Executing recovery step', {\r\n      operationId: operation.id,\r\n      step: step.step,\r\n      description: step.description,\r\n      action: step.action\r\n    });\r\n\r\n    // CRITICAL: Simulate step execution\r\n    // In a real implementation, this would execute the actual recovery action\r\n    await new Promise(resolve => setTimeout(resolve, step.estimatedDuration * 1000));\r\n\r\n    // CRITICAL: Log step completion\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: operation.tenantId || 'system',\r\n      actorId: 'recovery-system',\r\n      action: 'RECOVERY_STEP_COMPLETED',\r\n      resourceType: 'RECOVERY_OPERATION',\r\n      resourceId: operation.id,\r\n      outcome: 'SUCCESS',\r\n      correlationId: operation.correlationId,\r\n      metadata: {\r\n        step: step.step,\r\n        description: step.description,\r\n        action: step.action,\r\n        duration: step.estimatedDuration\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate recovery\r\n   */\r\n  private async validateRecovery(operation: RecoveryOperation, strategy: RecoveryStrategy): Promise<void> {\r\n    logger.info('Validating recovery', {\r\n      operationId: operation.id,\r\n      type: operation.type,\r\n      tenantId: operation.tenantId\r\n    });\r\n\r\n    // CRITICAL: Execute validation steps\r\n    for (const validationStep of strategy.validationSteps) {\r\n      await this.executeValidationStep(operation, validationStep);\r\n    }\r\n\r\n    logger.info('Recovery validation completed', {\r\n      operationId: operation.id\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute validation step\r\n   */\r\n  private async executeValidationStep(operation: RecoveryOperation, step: any): Promise<void> {\r\n    logger.info('Executing validation step', {\r\n      operationId: operation.id,\r\n      step: step.step,\r\n      description: step.description,\r\n      action: step.action\r\n    });\r\n\r\n    // CRITICAL: Simulate validation\r\n    // In a real implementation, this would execute the actual validation\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n    // CRITICAL: Log validation completion\r\n    this.auditLogger.logDataMutation({\r\n      tenantId: operation.tenantId || 'system',\r\n      actorId: 'recovery-system',\r\n      action: 'RECOVERY_VALIDATION_COMPLETED',\r\n      resourceType: 'RECOVERY_OPERATION',\r\n      resourceId: operation.id,\r\n      outcome: 'SUCCESS',\r\n      correlationId: operation.correlationId,\r\n      metadata: {\r\n        step: step.step,\r\n        description: step.description,\r\n        action: step.action,\r\n        expectedResult: step.expectedResult\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate recovery point\r\n   */\r\n  private async validateRecoveryPoint(recoveryPoint: RecoveryPoint): Promise<void> {\r\n    // CRITICAL: Check if recovery point has expired\r\n    if (recoveryPoint.expiresAt < new Date()) {\r\n      throw new Error(`Recovery point ${recoveryPoint.id} has expired`);\r\n    }\r\n\r\n    // CRITICAL: Validate checksum\r\n    const currentChecksum = await this.generateChecksum(recoveryPoint.type, recoveryPoint.tenantId, recoveryPoint.timestamp);\r\n    if (currentChecksum !== recoveryPoint.checksum) {\r\n      throw new Error(`Recovery point ${recoveryPoint.id} checksum mismatch`);\r\n    }\r\n\r\n    // CRITICAL: Validate size\r\n    const currentSize = await this.calculateRecoveryPointSize(recoveryPoint.type, recoveryPoint.tenantId);\r\n    if (Math.abs(currentSize - recoveryPoint.size) > (recoveryPoint.size * 0.1)) {\r\n      throw new Error(`Recovery point ${recoveryPoint.id} size mismatch`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate recovery point preconditions\r\n   */\r\n  private async validateRecoveryPointPreconditions(type: RecoveryType, tenantId?: string): Promise<void> {\r\n    // CRITICAL: Check system state\r\n    const systemState = await this.getSystemState();\r\n    \r\n    if (systemState.overallLoad > 90) {\r\n      throw new Error('System load too high for recovery point creation');\r\n    }\r\n\r\n    // CRITICAL: Check type-specific preconditions\r\n    switch (type) {\r\n      case 'DATABASE':\r\n        await this.validateDatabasePreconditions();\r\n        break;\r\n      case 'AUDIT':\r\n        await this.validateAuditPreconditions();\r\n        break;\r\n      case 'TENANT':\r\n        await this.validateTenantPreconditions(tenantId);\r\n        break;\r\n      case 'CONFIG':\r\n        await this.validateConfigPreconditions();\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate database preconditions\r\n   */\r\n  private async validateDatabasePreconditions(): Promise<void> {\r\n    // CRITICAL: Check database connectivity\r\n    // In a real implementation, this would check actual database connectivity\r\n    logger.info('Validating database preconditions');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate audit preconditions\r\n   */\r\n  private async validateAuditPreconditions(): Promise<void> {\r\n    // CRITICAL: Check audit log accessibility\r\n    // In a real implementation, this would check audit log accessibility\r\n    logger.info('Validating audit preconditions');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate tenant preconditions\r\n   */\r\n  private async validateTenantPreconditions(tenantId?: string): Promise<void> {\r\n    if (!tenantId) {\r\n      throw new Error('Tenant ID required for tenant recovery point');\r\n    }\r\n\r\n    // CRITICAL: Check tenant exists and is accessible\r\n    // In a real implementation, this would check tenant existence\r\n    logger.info('Validating tenant preconditions', { tenantId });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate config preconditions\r\n   */\r\n  private async validateConfigPreconditions(): Promise<void> {\r\n    // CRITICAL: Check configuration consistency\r\n    // In a real implementation, this would check configuration consistency\r\n    logger.info('Validating config preconditions');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get system state\r\n   */\r\n  private async getSystemState(): Promise<{ overallLoad: number }> {\r\n    // CRITICAL: Get current system load\r\n    // In a real implementation, this would get actual system metrics\r\n    return { overallLoad: 25 }; // Simulated 25% load\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Calculate recovery point size\r\n   */\r\n  private async calculateRecoveryPointSize(type: RecoveryType, tenantId?: string): Promise<number> {\r\n    // CRITICAL: Calculate actual size of recovery point\r\n    // In a real implementation, this would calculate the actual size\r\n    const baseSize = 1024 * 1024; // 1MB base size\r\n    \r\n    switch (type) {\r\n      case 'DATABASE':\r\n        return baseSize * 100; // 100MB\r\n      case 'AUDIT':\r\n        return baseSize * 50; // 50MB\r\n      case 'TENANT':\r\n        return baseSize * 10; // 10MB\r\n      case 'CONFIG':\r\n        return baseSize * 1; // 1MB\r\n      default:\r\n        return baseSize;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate checksum\r\n   */\r\n  private async generateChecksum(type: RecoveryType, tenantId?: string, timestamp?: Date): Promise<string> {\r\n    const crypto = require('crypto');\r\n    const ts = timestamp ?? new Date(0);\r\n    const data = `${type}:${tenantId || 'system'}:${ts.toISOString()}`;\r\n    return crypto.createHash('sha256').update(data).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get retention days\r\n   */\r\n  private getRetentionDays(type: RecoveryType): number {\r\n    switch (type) {\r\n      case 'DATABASE':\r\n        return this.rpoRtoDefinitions.database.retentionDays;\r\n      case 'AUDIT':\r\n        return this.rpoRtoDefinitions.audit.retentionDays;\r\n      case 'TENANT':\r\n        return this.rpoRtoDefinitions.tenant.retentionDays;\r\n      case 'CONFIG':\r\n        return this.rpoRtoDefinitions.config.retentionDays;\r\n      default:\r\n        return 30;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize RPO/RTO definitions\r\n   */\r\n  private initializeRPORTO(): RPO_RTO_Definitions {\r\n    return {\r\n      database: {\r\n        RPO: 3600, // 1 hour\r\n        RTO: 1800, // 30 minutes\r\n        backupFrequency: 1800, // 30 minutes\r\n        retentionDays: 30\r\n      },\r\n      audit: {\r\n        RPO: 300, // 5 minutes\r\n        RTO: 600, // 10 minutes\r\n        backupFrequency: 300, // 5 minutes\r\n        retentionDays: 255 // 7 years + legal hold\r\n      },\r\n      tenant: {\r\n        RPO: 1800, // 30 minutes\r\n        RTO: 900, // 15 minutes\r\n        backupFrequency: 1800, // 30 minutes\r\n        retentionDays: 90\r\n      },\r\n      config: {\r\n        RPO: 60, // 1 minute\r\n        RTO: 300, // 5 minutes\r\n        backupFrequency: 3600, // 1 hour\r\n        retentionDays: 30\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize recovery strategies\r\n   */\r\n  private initializeStrategies(): Map<RecoveryType, RecoveryStrategy> {\r\n    const strategies = new Map<RecoveryType, RecoveryStrategy>();\r\n\r\n    // Database recovery strategy\r\n    strategies.set('DATABASE', {\r\n      type: 'DATABASE',\r\n      description: 'Full database recovery from backup',\r\n      preconditions: [\r\n        'Database backup available',\r\n        'Sufficient disk space',\r\n        'System load < 80%'\r\n      ],\r\n      steps: [\r\n        {\r\n          step: 1,\r\n          description: 'Stop database services',\r\n          action: 'stop_database_services',\r\n          estimatedDuration: 30,\r\n          rollbackAction: 'start_database_services'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Restore database from backup',\r\n          action: 'restore_database_backup',\r\n          estimatedDuration: 300,\r\n          rollbackAction: 'backup_current_state'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Validate database integrity',\r\n          action: 'validate_database_integrity',\r\n          estimatedDuration: 60,\r\n          rollbackAction: 'mark_as_suspect'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Start database services',\r\n          action: 'start_database_services',\r\n          estimatedDuration: 30,\r\n          rollbackAction: 'stop_database_services'\r\n        }\r\n      ],\r\n      rollbackSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Stop database services',\r\n          action: 'stop_database_services'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Backup current state',\r\n          action: 'backup_current_state'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Restore previous state',\r\n          action: 'restore_previous_state'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Start database services',\r\n          action: 'start_database_services'\r\n        }\r\n      ],\r\n      validationSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Verify database connectivity',\r\n          action: 'verify_database_connectivity',\r\n          expectedResult: 'Database accessible'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Verify data integrity',\r\n          action: 'verify_data_integrity',\r\n          expectedResult: 'Data integrity verified'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Verify service availability',\r\n          action: 'verify_service_availability',\r\n          expectedResult: 'All services available'\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Audit recovery strategy\r\n    strategies.set('AUDIT', {\r\n      type: 'AUDIT',\r\n      description: 'Audit log recovery from backup',\r\n      preconditions: [\r\n        'Audit backup available',\r\n        'Audit log storage accessible',\r\n        'System load < 70%'\r\n      ],\r\n      steps: [\r\n        {\r\n          step: 1,\r\n          description: 'Stop audit logging',\r\n          action: 'stop_audit_logging',\r\n          estimatedDuration: 10,\r\n          rollbackAction: 'start_audit_logging'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Restore audit logs from backup',\r\n          action: 'restore_audit_logs',\r\n          estimatedDuration: 120,\r\n          rollbackAction: 'backup_current_audit_logs'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Validate audit log integrity',\r\n          action: 'validate_audit_integrity',\r\n          estimatedDuration: 30,\r\n          rollbackAction: 'mark_audit_as_suspect'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Start audit logging',\r\n          action: 'start_audit_logging',\r\n          estimatedDuration: 10,\r\n          rollbackAction: 'stop_audit_logging'\r\n        }\r\n      ],\r\n      rollbackSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Stop audit logging',\r\n          action: 'stop_audit_logging'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Backup current audit logs',\r\n          action: 'backup_current_audit_logs'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Restore previous audit logs',\r\n          action: 'restore_previous_audit_logs'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Start audit logging',\r\n          action: 'start_audit_logging'\r\n        }\r\n      ],\r\n      validationSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Verify audit log accessibility',\r\n          action: 'verify_audit_accessibility',\r\n          expectedResult: 'Audit logs accessible'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Verify audit log integrity',\r\n          action: 'verify_audit_integrity',\r\n          expectedResult: 'Audit integrity verified'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Verify audit logging functionality',\r\n          action: 'verify_audit_logging',\r\n          expectedResult: 'Audit logging functional'\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Tenant recovery strategy\r\n    strategies.set('TENANT', {\r\n      type: 'TENANT',\r\n      description: 'Tenant data recovery from backup',\r\n      preconditions: [\r\n        'Tenant backup available',\r\n        'Tenant isolation intact',\r\n        'System load < 60%'\r\n      ],\r\n      steps: [\r\n        {\r\n          step: 1,\r\n          description: 'Isolate tenant services',\r\n          action: 'isolate_tenant_services',\r\n          estimatedDuration: 15,\r\n          rollbackAction: 'restore_tenant_services'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Restore tenant data',\r\n          action: 'restore_tenant_data',\r\n          estimatedDuration: 180,\r\n          rollbackAction: 'backup_tenant_data'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Validate tenant data',\r\n          action: 'validate_tenant_data',\r\n          estimatedDuration: 30,\r\n          rollbackAction: 'mark_tenant_as_suspect'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Restore tenant services',\r\n          action: 'restore_tenant_services',\r\n          estimatedDuration: 15,\r\n          rollbackAction: 'keep_tenant_isolated'\r\n        }\r\n      ],\r\n      rollbackSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Isolate tenant services',\r\n          action: 'isolate_tenant_services'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Backup current tenant data',\r\n          action: 'backup_tenant_data'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Restore previous tenant data',\r\n          action: 'restore_previous_tenant_data'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Keep tenant isolated',\r\n          action: 'keep_tenant_isolated'\r\n        }\r\n      ],\r\n      validationSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Verify tenant accessibility',\r\n          action: 'verify_tenant_accessibility',\r\n          expectedResult: 'Tenant accessible'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Verify tenant data integrity',\r\n          action: 'verify_tenant_data_integrity',\r\n          expectedResult: 'Tenant data integrity verified'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Verify tenant services',\r\n          action: 'verify_tenant_services',\r\n          expectedResult: 'Tenant services functional'\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Config recovery strategy\r\n    strategies.set('CONFIG', {\r\n      type: 'CONFIG',\r\n      description: 'Configuration recovery from backup',\r\n      preconditions: [\r\n        'Configuration backup available',\r\n        'Configuration storage accessible',\r\n        'System load < 50%'\r\n      ],\r\n      steps: [\r\n        {\r\n          step: 1,\r\n          description: 'Stop configuration services',\r\n          action: 'stop_config_services',\r\n          estimatedDuration: 5,\r\n          rollbackAction: 'start_config_services'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Restore configuration',\r\n          action: 'restore_configuration',\r\n          estimatedDuration: 30,\r\n          rollbackAction: 'backup_current_configuration'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Validate configuration',\r\n          action: 'validate_configuration',\r\n          estimatedDuration: 10,\r\n          rollbackAction: 'mark_config_as_suspect'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Start configuration services',\r\n          action: 'start_config_services',\r\n          estimatedDuration: 5,\r\n          rollbackAction: 'stop_config_services'\r\n        }\r\n      ],\r\n      rollbackSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Stop configuration services',\r\n          action: 'stop_config_services'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Backup current configuration',\r\n          action: 'backup_current_configuration'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Restore previous configuration',\r\n          action: 'restore_previous_configuration'\r\n        },\r\n        {\r\n          step: 4,\r\n          description: 'Start configuration services',\r\n          action: 'start_config_services'\r\n        }\r\n      ],\r\n      validationSteps: [\r\n        {\r\n          step: 1,\r\n          description: 'Verify configuration accessibility',\r\n          action: 'verify_configuration_accessibility',\r\n          expectedResult: 'Configuration accessible'\r\n        },\r\n        {\r\n          step: 2,\r\n          description: 'Verify configuration integrity',\r\n          action: 'verify_configuration_integrity',\r\n          expectedResult: 'Configuration integrity verified'\r\n        },\r\n        {\r\n          step: 3,\r\n          description: 'Verify configuration functionality',\r\n          action: 'verify_configuration_functionality',\r\n          expectedResult: 'Configuration functional'\r\n        }\r\n      ]\r\n    });\r\n\r\n    return strategies;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Start recovery monitoring\r\n   */\r\n  private startRecoveryMonitoring(): void {\r\n    // CRITICAL: Periodic RPO/RTO validation\r\n    setInterval(async () => {\r\n      const compliance = await this.validateRPORTOCompliance();\r\n      \r\n      if (!compliance.compliant) {\r\n        logger.error('RPO/RTO compliance violations detected', new Error('RPO_RTO_VIOLATIONS'), { violations: compliance.violations });\r\n        \r\n        // CRITICAL: Alert on violations\r\n        this.auditLogger.logSecurityEvent({\r\n          tenantId: 'system',\r\n          actorId: 'recovery-system',\r\n          action: 'RPO_RTO_VIOLATION',\r\n          resourceType: 'RECOVERY_SYSTEM',\r\n          resourceId: 'system',\r\n          outcome: 'FAILURE',\r\n          correlationId: `rpo_rto_violation_${Date.now()}`,\r\n          severity: 'HIGH',\r\n          metadata: {\r\n            violations: compliance.violations\r\n          }\r\n        });\r\n      }\r\n    }, 300000); // Every 5 minutes\r\n\r\n    // CRITICAL: Periodic cleanup\r\n    setInterval(() => {\r\n      this.cleanupExpiredRecoveryPoints();\r\n    }, 3600000); // Every hour\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cleanup expired recovery points\r\n   */\r\n  private cleanupExpiredRecoveryPoints(): void {\r\n    const now = new Date();\r\n    let cleanedCount = 0;\r\n\r\n    for (const [id, recoveryPoint] of this.recoveryPoints.entries()) {\r\n      if (recoveryPoint.expiresAt < now) {\r\n        this.recoveryPoints.delete(id);\r\n        cleanedCount++;\r\n      }\r\n    }\r\n\r\n    if (cleanedCount > 0) {\r\n      logger.info('Cleaned up expired recovery points', { cleanedCount });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate recovery point ID\r\n   */\r\n  private generateRecoveryPointId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `rp_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate operation ID\r\n   */\r\n  private generateOperationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `op_${bytes.toString('hex')}`;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate correlation ID\r\n   */\r\n  private generateCorrelationId(): string {\r\n    const crypto = require('crypto');\r\n    const bytes = crypto.randomBytes(8);\r\n    return `corr_${bytes.toString('hex')}`;\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global recovery strategy manager instance\r\n */\r\nexport const recoveryStrategyManager = RecoveryStrategyManager.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions\r\n */\r\nexport const createRecoveryPoint = async (\r\n  type: RecoveryType,\r\n  tenantId: string | undefined,\r\n  description: string,\r\n  metadata: Record<string, any> = {}\r\n): Promise<RecoveryPoint> => {\r\n  return await recoveryStrategyManager.createRecoveryPoint(type, tenantId, description, metadata);\r\n};\r\n\r\nexport const startRecovery = async (\r\n  type: RecoveryType,\r\n  recoveryPointId: string,\r\n  tenantId?: string,\r\n  correlationId?: string\r\n): Promise<RecoveryOperation> => {\r\n  return await recoveryStrategyManager.startRecovery(type, recoveryPointId, tenantId, correlationId);\r\n};\r\n\r\nexport const getRecoveryStatus = (operationId: string): RecoveryOperation | null => {\r\n  return recoveryStrategyManager.getRecoveryStatus(operationId);\r\n};\r\n\r\nexport const getRecoveryPoints = (type?: RecoveryType, tenantId?: string): RecoveryPoint[] => {\r\n  return recoveryStrategyManager.getRecoveryPoints(type, tenantId);\r\n};\r\n\r\nexport const getRecoveryOperations = (\r\n  type?: RecoveryType,\r\n  tenantId?: string,\r\n  status?: RecoveryStatus\r\n): RecoveryOperation[] => {\r\n  return recoveryStrategyManager.getRecoveryOperations(type, tenantId, status);\r\n};\r\n\r\nexport const validateRPORTOCompliance = (): Promise<{\r\n  compliant: boolean;\r\n  violations: Array<{\r\n    type: string;\r\n    metric: string;\r\n    actual: number;\r\n    required: number;\r\n    violation: string;\r\n  }>;\r\n}> => {\r\n  return recoveryStrategyManager.validateRPORTOCompliance();\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\resilience-metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\resilience\\retry-policy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes-legacy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\accounting.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\billing.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\billing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\inventory.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\jobs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\owner.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\payroll.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\plaid.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\projects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\reports.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\stripe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\v1\\inventory.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\workflow-instances.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\routes\\workflow.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\runtime\\audit-log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\runtime\\dev-invariants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\security\\abuse-protection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\security\\circuit-breaker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\security\\env-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\security\\rate-limiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\security\\rate-limiting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\security\\secret-redaction.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":480,"column":20,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":480,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Secret Redaction Module\r\n// MANDATORY: Prevent secrets from appearing in logs, errors, and stack traces\r\n\r\nimport { logger } from '../utils/structured-logger.js';\r\n\r\nexport interface RedactionPattern {\r\n  name: string;\r\n  pattern: RegExp;\r\n  replacement: string;\r\n  description: string;\r\n  severity: 'HIGH' | 'MEDIUM' | 'LOW';\r\n}\r\n\r\nexport interface RedactionResult {\r\n  original: string;\r\n  redacted: string;\r\n  patternsApplied: string[];\r\n  secretsDetected: number;\r\n  severity: 'HIGH' | 'MEDIUM' | 'LOW';\r\n}\r\n\r\n/**\r\n * CRITICAL: Secret Redactor\r\n * \r\n * This class provides comprehensive secret redaction for all logs,\r\n * error messages, and stack traces to prevent accidental exposure.\r\n */\r\nexport class SecretRedactor {\r\n  private static instance: SecretRedactor;\r\n  private patterns: RedactionPattern[] = [];\r\n  private cache: Map<string, RedactionResult> = new Map();\r\n  private readonly maxCacheSize = 1000;\r\n\r\n  private constructor() {\r\n    this.initializePatterns();\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get singleton instance\r\n   */\r\n  static getInstance(): SecretRedactor {\r\n    if (!SecretRedactor.instance) {\r\n      SecretRedactor.instance = new SecretRedactor();\r\n    }\r\n    return SecretRedactor.instance;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Redact secrets from string\r\n   */\r\n  redact(input: string): RedactionResult {\r\n    if (!input || typeof input !== 'string') {\r\n      return {\r\n        original: input || '',\r\n        redacted: input || '',\r\n        patternsApplied: [],\r\n        secretsDetected: 0,\r\n        severity: 'LOW'\r\n      };\r\n    }\r\n\r\n    // CRITICAL: Check cache first\r\n    const cacheKey = this.generateCacheKey(input);\r\n    const cached = this.cache.get(cacheKey);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n\r\n    let redacted = input;\r\n    const patternsApplied: string[] = [];\r\n    let secretsDetected = 0;\r\n    let maxSeverity: 'HIGH' | 'MEDIUM' | 'LOW' = 'LOW';\r\n\r\n    // CRITICAL: Apply all redaction patterns\r\n    for (const pattern of this.patterns) {\r\n      const matches = redacted.match(pattern.pattern);\r\n      if (matches && matches.length > 0) {\r\n        redacted = redacted.replace(pattern.pattern, pattern.replacement);\r\n        patternsApplied.push(pattern.name);\r\n        secretsDetected += matches.length;\r\n        \r\n        // CRITICAL: Track highest severity\r\n        if (pattern.severity === 'HIGH') {\r\n          maxSeverity = 'HIGH';\r\n        } else if (pattern.severity === 'MEDIUM' && maxSeverity === 'LOW') {\r\n          maxSeverity = 'MEDIUM';\r\n        }\r\n      }\r\n    }\r\n\r\n    const result: RedactionResult = {\r\n      original: input,\r\n      redacted,\r\n      patternsApplied,\r\n      secretsDetected,\r\n      severity: maxSeverity\r\n    };\r\n\r\n    // CRITICAL: Cache result\r\n    this.cacheResult(cacheKey, result);\r\n\r\n    // CRITICAL: Log redaction if secrets were detected\r\n    if (secretsDetected > 0) {\r\n      logger.warn('Secrets detected and redacted', {\r\n        secretsDetected,\r\n        patternsApplied,\r\n        severity: maxSeverity,\r\n        originalLength: input.length,\r\n        redactedLength: redacted.length\r\n      });\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Redact secrets from object\r\n   */\r\n  redactObject(obj: any): any {\r\n    if (!obj || typeof obj !== 'object') {\r\n      if (typeof obj === 'string') {\r\n        return this.redact(obj).redacted;\r\n      }\r\n      return obj;\r\n    }\r\n\r\n    if (obj instanceof Error) {\r\n      return this.redactError(obj);\r\n    }\r\n\r\n    // CRITICAL: Handle arrays\r\n    if (Array.isArray(obj)) {\r\n      return obj.map(item => this.redactObject(item));\r\n    }\r\n\r\n    // CRITICAL: Handle plain objects\r\n    const redacted: any = {};\r\n    for (const [key, value] of Object.entries(obj)) {\r\n      const k = String(key);\r\n      const lk = k.toLowerCase();\r\n\r\n      if (typeof value === 'string') {\r\n        if (lk === 'jwt_secret' || lk === 'jwt-secret' || lk === 'session_secret' || lk === 'session-secret') {\r\n          redacted[key] = '[REDACTED]';\r\n          continue;\r\n        }\r\n        if (lk === 'encryption_key' || lk === 'encryption-key') {\r\n          redacted[key] = '[REDACTED]';\r\n          continue;\r\n        }\r\n        if (lk === 'token' || lk.endsWith('_token') || lk.endsWith('-token')) {\r\n          redacted[key] = '[REDACTED TOKEN]';\r\n          continue;\r\n        }\r\n        if (lk === 'password' || lk.endsWith('_password') || lk.endsWith('-password')) {\r\n          redacted[key] = '[REDACTED]';\r\n          continue;\r\n        }\r\n        if (lk === 'api_key' || lk === 'api-key' || lk === 'x-api-key') {\r\n          redacted[key] = '[REDACTED]';\r\n          continue;\r\n        }\r\n        if (lk === 'database_url' || lk === 'database-url') {\r\n          redacted[key] = value.replace(/:\\/\\/([^:]+):([^@]+)@/g, '://$1:[REDACTED]@');\r\n          continue;\r\n        }\r\n        if (lk === 'redis_url' || lk === 'redis-url') {\r\n          redacted[key] = this.redact(value).redacted;\r\n          continue;\r\n        }\r\n        if (lk.includes('secret')) {\r\n          redacted[key] = '[REDACTED SECRET]';\r\n          continue;\r\n        }\r\n\r\n        redacted[key] = this.redact(value).redacted;\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        redacted[key] = this.redactObject(value);\r\n      } else {\r\n        redacted[key] = value;\r\n      }\r\n    }\r\n\r\n    return redacted;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Redact secrets from error\r\n   */\r\n  redactError(error: Error): Error {\r\n    const redactedMessage = this.redact(error.message).redacted;\r\n    const redactedStack = error.stack ? this.redact(error.stack).redacted : undefined;\r\n\r\n    // CRITICAL: Create new error with redacted information\r\n    const redactedError = new Error(redactedMessage);\r\n    redactedError.stack = redactedStack;\r\n    \r\n    // CRITICAL: Copy other properties\r\n    Object.getOwnPropertyNames(error).forEach(prop => {\r\n      if (prop !== 'message' && prop !== 'stack') {\r\n        const value = (error as any)[prop];\r\n        if (typeof value === 'string') {\r\n          (redactedError as any)[prop] = this.redact(value).redacted;\r\n        } else if (typeof value === 'object') {\r\n          (redactedError as any)[prop] = this.redactObject(value);\r\n        } else {\r\n          (redactedError as any)[prop] = value;\r\n        }\r\n      }\r\n    });\r\n\r\n    return redactedError;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Redact secrets from JSON string\r\n   */\r\n  redactJSON(jsonString: string): string {\r\n    try {\r\n      const parsed = JSON.parse(jsonString);\r\n      const redacted = this.redactObject(parsed);\r\n      return JSON.stringify(redacted);\r\n    } catch (error) {\r\n      // CRITICAL: If JSON parsing fails, redact the string directly\r\n      return this.redact(jsonString).redacted;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Safe stringification with redaction\r\n   */\r\n  safeStringify(obj: any, space?: number): string {\r\n    try {\r\n      const redactedObj = this.redactObject(obj);\r\n      return JSON.stringify(redactedObj, null, space);\r\n    } catch (error) {\r\n      // CRITICAL: Fallback to string representation with redaction\r\n      return this.redact(String(obj)).redacted;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if string contains secrets\r\n   */\r\n  containsSecrets(input: string): boolean {\r\n    const result = this.redact(input);\r\n    return result.secretsDetected > 0;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get redaction statistics\r\n   */\r\n  getStatistics(): {\r\n    totalRedactions: number;\r\n    patternsUsed: Record<string, number>;\r\n    cacheSize: number;\r\n    severityBreakdown: Record<string, number>;\r\n  } {\r\n    const patternsUsed: Record<string, number> = {};\r\n    const severityBreakdown: Record<string, number> = {\r\n      HIGH: 0,\r\n      MEDIUM: 0,\r\n      LOW: 0\r\n    };\r\n\r\n    // CRITICAL: Analyze cache\r\n    for (const result of this.cache.values()) {\r\n      for (const pattern of result.patternsApplied) {\r\n        patternsUsed[pattern] = (patternsUsed[pattern] || 0) + 1;\r\n      }\r\n      severityBreakdown[result.severity]++;\r\n    }\r\n\r\n    return {\r\n      totalRedactions: this.cache.size,\r\n      patternsUsed,\r\n      cacheSize: this.cache.size,\r\n      severityBreakdown\r\n    };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Clear cache\r\n   */\r\n  clearCache(): void {\r\n    this.cache.clear();\r\n    logger.info('Secret redaction cache cleared');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Add custom redaction pattern\r\n   */\r\n  addPattern(pattern: RedactionPattern): void {\r\n    this.patterns.push(pattern);\r\n    logger.info('Custom redaction pattern added', {\r\n      name: pattern.name,\r\n      severity: pattern.severity\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Remove redaction pattern\r\n   */\r\n  removePattern(name: string): boolean {\r\n    const index = this.patterns.findIndex(p => p.name === name);\r\n    if (index !== -1) {\r\n      this.patterns.splice(index, 1);\r\n      logger.info('Redaction pattern removed', { name });\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get all patterns\r\n   */\r\n  getPatterns(): RedactionPattern[] {\r\n    return [...this.patterns];\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Initialize redaction patterns\r\n   */\r\n  private initializePatterns(): void {\r\n    // CRITICAL: High severity patterns - most sensitive\r\n    this.patterns.push({\r\n      name: 'JWT_SECRET',\r\n      pattern: /\"?jwt[_-]?secret\"?\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gi,\r\n      replacement: 'jwt_secret=[REDACTED]',\r\n      description: 'JWT signing secrets',\r\n      severity: 'HIGH'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'SESSION_SECRET',\r\n      pattern: /\"?session[_-]?secret\"?\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gi,\r\n      replacement: 'session_secret=[REDACTED]',\r\n      description: 'Session encryption secrets',\r\n      severity: 'HIGH'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'ENCRYPTION_KEY',\r\n      pattern: /\"?encryption[_-]?key\"?\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gi,\r\n      replacement: 'encryption_key=[REDACTED]',\r\n      description: 'Data encryption keys',\r\n      severity: 'HIGH'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'PRIVATE_KEY',\r\n      pattern: /-----BEGIN\\s+PRIVATE\\s+KEY-----[\\s\\S]*?-----END\\s+PRIVATE\\s+KEY-----/gi,\r\n      replacement: '[REDACTED PRIVATE KEY]',\r\n      description: 'Private keys',\r\n      severity: 'HIGH'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'API_KEY',\r\n      pattern: /\"?api[_-]?key\"?\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gi,\r\n      replacement: 'api_key=[REDACTED]',\r\n      description: 'API keys',\r\n      severity: 'HIGH'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'DATABASE_PASSWORD',\r\n      pattern: /\"?password\"?\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gi,\r\n      replacement: 'password=[REDACTED]',\r\n      description: 'Database passwords',\r\n      severity: 'HIGH'\r\n    });\r\n\r\n    // CRITICAL: Medium severity patterns - sensitive but less critical\r\n    this.patterns.push({\r\n      name: 'AUTH_TOKEN',\r\n      pattern: /bearer\\s+[a-zA-Z0-9\\-_\\.]+/gi,\r\n      replacement: 'bearer [REDACTED]',\r\n      description: 'Bearer tokens',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'TOKEN_STANDALONE',\r\n      pattern: /\\btoken[a-zA-Z0-9\\-_]*\\b/gi,\r\n      replacement: '[REDACTED TOKEN]',\r\n      description: 'Standalone token-like strings',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'GOOGLE_CLIENT_SECRET',\r\n      pattern: /google[_-]?client[_-]?secret[=:]\\s*[^\\s&;]+/gi,\r\n      replacement: 'google_client_secret=[REDACTED]',\r\n      description: 'Google OAuth client secrets',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'REDIS_PASSWORD',\r\n      pattern: /redis[:@][^\\s&;]*password[=:]\\s*[^\\s&;]+/gi,\r\n      replacement: 'redis://[REDACTED]',\r\n      description: 'Redis passwords',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'EMAIL_ADDRESSES',\r\n      pattern: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/gi,\r\n      replacement: '[REDACTED EMAIL]',\r\n      description: 'Email addresses',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'IP_ADDRESSES',\r\n      pattern: /\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b/g,\r\n      replacement: '[REDACTED IP]',\r\n      description: 'IP addresses',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    // CRITICAL: Low severity patterns - general PII\r\n    this.patterns.push({\r\n      name: 'PHONE_NUMBERS',\r\n      pattern: /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/g,\r\n      replacement: '[REDACTED PHONE]',\r\n      description: 'Phone numbers',\r\n      severity: 'LOW'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'SSN',\r\n      pattern: /\\b\\d{3}-\\d{2}-\\d{4}\\b/g,\r\n      replacement: '[REDACTED SSN]',\r\n      description: 'Social Security Numbers',\r\n      severity: 'LOW'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'CREDIT_CARD',\r\n      pattern: /\\b\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}\\b/g,\r\n      replacement: '[REDACTED CARD]',\r\n      description: 'Credit card numbers',\r\n      severity: 'LOW'\r\n    });\r\n\r\n    // CRITICAL: Generic secret patterns\r\n    this.patterns.push({\r\n      name: 'SECRET_GENERIC',\r\n      pattern:\r\n        /(^|[\\s\"'\\{,;&])(?!jwt[_-]?secret\\b)(?!session[_-]?secret\\b)(?!encryption[_-]?key\\b)(?!api[_-]?key\\b)[a-zA-Z0-9_-]*secret[a-zA-Z0-9_-]*\\b\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gim,\r\n      replacement: '$1[REDACTED SECRET]',\r\n      description: 'Generic secret patterns',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'TOKEN_GENERIC',\r\n      pattern: /(^|[\\s\"'\\{,;&])[a-zA-Z0-9_-]*token[a-zA-Z0-9_-]*\\b\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gim,\r\n      replacement: '$1[REDACTED TOKEN]',\r\n      description: 'Generic token patterns',\r\n      severity: 'MEDIUM'\r\n    });\r\n\r\n    this.patterns.push({\r\n      name: 'KEY_GENERIC',\r\n      pattern: /(^|[\\s\"'\\{,;&])(?!encryption[_-]?key\\b)(?!api[_-]?key\\b)[a-zA-Z0-9_-]*key[a-zA-Z0-9_-]*\\b\\s*[=:]\\s*\"?[^\"\\s&;]*\"?/gim,\r\n      replacement: '$1[REDACTED KEY]',\r\n      description: 'Generic key patterns',\r\n      severity: 'MEDIUM'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Generate cache key\r\n   */\r\n  private generateCacheKey(input: string): string {\r\n    // CRITICAL: Use hash for cache key to avoid storing full strings\r\n    const crypto = require('crypto');\r\n    return crypto.createHash('md5').update(input).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Cache result\r\n   */\r\n  private cacheResult(key: string, result: RedactionResult): void {\r\n    // CRITICAL: Implement LRU cache\r\n    if (this.cache.size >= this.maxCacheSize) {\r\n      // Remove oldest entry\r\n      const firstKey = this.cache.keys().next().value;\r\n      if (firstKey) {\r\n        this.cache.delete(firstKey);\r\n      }\r\n    }\r\n    this.cache.set(key, result);\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Global redactor instance\r\n */\r\nexport const secretRedactor = SecretRedactor.getInstance();\r\n\r\n/**\r\n * CRITICAL: Convenience functions for immediate use\r\n */\r\nexport const redact = (input: string): string => secretRedactor.redact(input).redacted;\r\nexport const redactObject = (obj: any): any => secretRedactor.redactObject(obj);\r\nexport const redactError = (error: Error): Error => secretRedactor.redactError(error);\r\nexport const redactJSON = (jsonString: string): string => secretRedactor.redactJSON(jsonString);\r\nexport const safeStringify = (obj: any, space?: number): string => secretRedactor.safeStringify(obj, space);\r\nexport const containsSecrets = (input: string): boolean => secretRedactor.containsSecrets(input);\r\n\r\n/**\r\n * CRITICAL: Enhanced console methods with automatic redaction\r\n */\r\nexport const safeConsole = {\r\n  log: (...args: any[]) => {\r\n    const redactedArgs = args.map(arg => \r\n      typeof arg === 'string' ? redact(arg) : redactObject(arg)\r\n    );\r\n    console.log(...redactedArgs);\r\n  },\r\n\r\n  error: (...args: any[]) => {\r\n    const redactedArgs = args.map(arg => {\r\n      if (arg instanceof Error) {\r\n        return redactError(arg);\r\n      }\r\n      return typeof arg === 'string' ? redact(arg) : redactObject(arg);\r\n    });\r\n    console.error(...redactedArgs);\r\n  },\r\n\r\n  warn: (...args: any[]) => {\r\n    const redactedArgs = args.map(arg => \r\n      typeof arg === 'string' ? redact(arg) : redactObject(arg)\r\n    );\r\n    console.warn(...redactedArgs);\r\n  },\r\n\r\n  info: (...args: any[]) => {\r\n    const redactedArgs = args.map(arg => \r\n      typeof arg === 'string' ? redact(arg) : redactObject(arg)\r\n    );\r\n    console.info(...redactedArgs);\r\n  },\r\n\r\n  debug: (...args: any[]) => {\r\n    const redactedArgs = args.map(arg => \r\n      typeof arg === 'string' ? redact(arg) : redactObject(arg)\r\n    );\r\n    console.debug(...redactedArgs);\r\n  }\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\security\\security-posture.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\services\\accounting-periods.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\services\\accounting.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\services\\analytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\services\\cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\services\\inventory.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\services\\pricing.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\services\\workflow.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\tenant\\cross-tenant-attack-prevention.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\tenant\\deterministic-failures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\tenant\\tenant-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\tenant\\tenant-isolation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\tenant\\tenant-query-builder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\tenant\\tenant-service-guards.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":316,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":316,"endColumn":54},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":317,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":322,"endColumn":11},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":324,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":324,"endColumn":97}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CRITICAL: Service Layer Guardrails for Tenant Isolation\r\n// MANDATORY: Prevents ALL cross-tenant access at service layer\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { TenantContext, AuthenticatedRequest } from './tenant-isolation.js';\r\nimport { TenantIsolatedQueryBuilder } from './tenant-query-builder.js';\r\nimport { logger } from '../utils/structured-logger.js';\r\n\r\nexport interface ExtendedTenantContext extends TenantContext {\r\n  user: {\r\n    id: string;\r\n    email?: string;\r\n    name?: string;\r\n    role: string;\r\n    isActive: boolean;\r\n  };\r\n}\r\n\r\nexport interface ServiceTenantContext {\r\n  tenantId: string;\r\n  userId: string;\r\n  userRole: string;\r\n  permissions: string[];\r\n  requestId: string;\r\n}\r\n\r\nexport interface ServiceOptions {\r\n  requireTenantContext: boolean;\r\n  allowCrossTenant: boolean;\r\n  validateOwnership: boolean;\r\n  enforcePermissions: boolean;\r\n}\r\n\r\nexport class TenantGuardedService {\r\n  private prisma: PrismaClient;\r\n  private tenantContext: ServiceTenantContext;\r\n  private queryBuilder: TenantIsolatedQueryBuilder;\r\n  private options: ServiceOptions;\r\n\r\n  constructor(\r\n    prisma: PrismaClient,\r\n    tenantContext: TenantContext,\r\n    options: Partial<ServiceOptions> = {}\r\n  ) {\r\n    this.prisma = prisma;\r\n    this.options = {\r\n      requireTenantContext: true,\r\n      allowCrossTenant: false,\r\n      validateOwnership: true,\r\n      enforcePermissions: true,\r\n      ...options\r\n    };\r\n\r\n    // CRITICAL: Validate tenant context immediately\r\n    this.validateTenantContext(tenantContext);\r\n\r\n    // Convert to service tenant context\r\n    this.tenantContext = {\r\n      tenantId: tenantContext.tenantId,\r\n      userId: tenantContext.tenant.user?.id || '',\r\n      userRole: tenantContext.userRole,\r\n      permissions: tenantContext.permissions,\r\n      requestId: (tenantContext as any).requestId || 'unknown'\r\n    };\r\n\r\n    // Create tenant-isolated query builder\r\n    this.queryBuilder = new TenantIsolatedQueryBuilder(prisma, {\r\n      tenantId: this.tenantContext.tenantId,\r\n      userId: this.tenantContext.userId,\r\n      requestId: this.tenantContext.requestId\r\n    }, {\r\n      enforceTenantScope: !this.options.allowCrossTenant,\r\n      requireTenantId: this.options.requireTenantContext\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get tenant-isolated Prisma client\r\n   */\r\n  get db(): PrismaClient {\r\n    return this.queryBuilder.scopedClient;\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate tenant context is present and valid\r\n   */\r\n  private validateTenantContext(context: TenantContext): void {\r\n    if (!context) {\r\n      const error = new Error('TENANT_CONTEXT_REQUIRED');\r\n      logger.error('Service called without tenant context', error as Error);\r\n      throw error;\r\n    }\r\n\r\n    if (!context.tenantId) {\r\n      const error = new Error('TENANT_ID_REQUIRED');\r\n      logger.error('Service called without tenant ID', error as Error);\r\n      throw error;\r\n    }\r\n\r\n    if (!context.user?.id) {\r\n      const error = new Error('USER_ID_REQUIRED');\r\n      logger.error('Service called without user ID', error as Error);\r\n      throw error;\r\n    }\r\n\r\n    // CRITICAL: Validate tenant ID format\r\n    if (!this.isValidTenantId(context.tenantId)) {\r\n      const error = new Error('INVALID_TENANT_ID');\r\n      logger.error('Invalid tenant ID format in service', error as Error, {\r\n        tenantId: context.tenantId\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate tenant ID format\r\n   */\r\n  private isValidTenantId(tenantId: string): boolean {\r\n    const tenantIdPattern = /^tn_[a-f0-9]{32}$/;\r\n    return tenantIdPattern.test(tenantId);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate user has required permission\r\n   */\r\n  requirePermission(permission: string): void {\r\n    if (!this.options.enforcePermissions) {\r\n      return;\r\n    }\r\n\r\n    if (!this.tenantContext.permissions.includes(permission)) {\r\n      const error = new Error('PERMISSION_DENIED');\r\n      logger.error('Permission denied in service', error as Error, {\r\n        requiredPermission: permission,\r\n        userPermissions: this.tenantContext.permissions,\r\n        userId: this.tenantContext.userId,\r\n        tenantId: this.tenantContext.tenantId,\r\n        requestId: this.tenantContext.requestId\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate user has any of the required permissions\r\n   */\r\n  requireAnyPermission(permissions: string[]): void {\r\n    if (!this.options.enforcePermissions) {\r\n      return;\r\n    }\r\n\r\n    const hasPermission = permissions.some(permission => \r\n      this.tenantContext.permissions.includes(permission)\r\n    );\r\n\r\n    if (!hasPermission) {\r\n      const error = new Error('PERMISSION_DENIED');\r\n      logger.error('Any permission denied in service', error as Error, {\r\n        requiredPermissions: permissions,\r\n        userPermissions: this.tenantContext.permissions,\r\n        userId: this.tenantContext.userId,\r\n        tenantId: this.tenantContext.tenantId,\r\n        requestId: this.tenantContext.requestId\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate user has required role\r\n   */\r\n  requireRole(role: string): void {\r\n    if (!this.options.enforcePermissions) {\r\n      return;\r\n    }\r\n\r\n    if (this.tenantContext.userRole !== role) {\r\n      const error = new Error('ROLE_DENIED');\r\n      logger.error('Role denied in service', error as Error, {\r\n        requiredRole: role,\r\n        userRole: this.tenantContext.userRole,\r\n        userId: this.tenantContext.userId,\r\n        tenantId: this.tenantContext.tenantId,\r\n        requestId: this.tenantContext.requestId\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate resource ownership within tenant\r\n   */\r\n  async validateOwnership(\r\n    resourceType: string,\r\n    resourceId: string,\r\n    additionalChecks?: Record<string, any>\r\n  ): Promise<void> {\r\n    if (!this.options.validateOwnership) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // CRITICAL: Check if resource exists and belongs to tenant\r\n      const resource = await this.validateResourceOwnership(\r\n        resourceType,\r\n        resourceId,\r\n        additionalChecks\r\n      );\r\n\r\n      if (!resource) {\r\n        const error = new Error('RESOURCE_NOT_FOUND');\r\n        logger.error('Resource not found in tenant validation', error as Error, {\r\n          resourceType,\r\n          resourceId,\r\n          tenantId: this.tenantContext.tenantId,\r\n          userId: this.tenantContext.userId,\r\n          requestId: this.tenantContext.requestId\r\n        });\r\n        throw error;\r\n      }\r\n\r\n      // CRITICAL: Check if resource belongs to the current tenant\r\n      if (resource.tenantId !== this.tenantContext.tenantId) {\r\n        const error = new Error('CROSS_TENANT_ACCESS_DENIED');\r\n        logger.error('Cross-tenant access blocked in service', error as Error, {\r\n          resourceType,\r\n          resourceId,\r\n          resourceTenantId: resource.tenantId,\r\n          userTenantId: this.tenantContext.tenantId,\r\n          userId: this.tenantContext.userId,\r\n          requestId: this.tenantContext.requestId\r\n        });\r\n        throw error;\r\n      }\r\n\r\n      logger.debug('Resource ownership validated', {\r\n        resourceType,\r\n        resourceId,\r\n        tenantId: this.tenantContext.tenantId,\r\n        requestId: this.tenantContext.requestId\r\n      });\r\n\r\n    } catch (error) {\r\n      if ((error as Error).message === 'RESOURCE_NOT_FOUND' || \r\n          (error as Error).message === 'CROSS_TENANT_ACCESS_DENIED') {\r\n        throw error;\r\n      }\r\n\r\n      // Log unexpected errors but don't leak details\r\n      logger.error('Unexpected error in ownership validation', error as Error, {\r\n        resourceType,\r\n        resourceId,\r\n        tenantId: this.tenantContext.tenantId,\r\n        userId: this.tenantContext.userId,\r\n        requestId: this.tenantContext.requestId\r\n      });\r\n\r\n      throw new Error('OWNERSHIP_VALIDATION_FAILED');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate resource ownership with database query\r\n   */\r\n  private async validateResourceOwnership(\r\n    resourceType: string,\r\n    resourceId: string,\r\n    additionalChecks?: Record<string, any>\r\n  ): Promise<any> {\r\n    const db = this.db;\r\n\r\n    switch (resourceType) {\r\n      case 'user':\r\n        return await db.user.findFirst({\r\n          where: {\r\n            id: resourceId,\r\n            tenantId: this.tenantContext.tenantId,\r\n            deletedAt: null\r\n          },\r\n          select: { id: true, tenantId: true }\r\n        });\r\n\r\n      case 'company':\r\n        return await db.company.findFirst({\r\n          where: {\r\n            id: resourceId,\r\n            tenantId: this.tenantContext.tenantId,\r\n            deletedAt: null\r\n          },\r\n          select: { id: true, tenantId: true }\r\n        });\r\n\r\n      case 'invoice':\r\n        return await db.invoice.findFirst({\r\n          where: {\r\n            id: resourceId,\r\n            tenantId: this.tenantContext.tenantId,\r\n            deletedAt: null\r\n          },\r\n          select: { id: true, tenantId: true }\r\n        });\r\n\r\n      case 'transaction':\r\n        return await db.transaction.findFirst({\r\n          where: {\r\n            id: resourceId,\r\n            tenantId: this.tenantContext.tenantId,\r\n            deletedAt: null\r\n          },\r\n          select: { id: true, tenantId: true }\r\n        });\r\n\r\n      default:\r\n        // For unknown resource types, perform a generic check\r\n        const tableName = resourceType.toLowerCase();\r\n        const query = `\r\n          SELECT id, tenant_id \r\n          FROM ${tableName} \r\n          WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL \r\n          LIMIT 1\r\n        `;\r\n        \r\n        const result = await db.$queryRawUnsafe(query, resourceId, this.tenantContext.tenantId);\r\n        return result[0] || null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Validate bulk operation is tenant-safe\r\n   */\r\n  validateBulkOperation(operation: string, resourceIds: string[]): void {\r\n    if (!Array.isArray(resourceIds) || resourceIds.length === 0) {\r\n      const error = new Error('INVALID_BULK_OPERATION');\r\n      logger.error('Invalid bulk operation parameters', error as Error, {\r\n        operation,\r\n        resourceIdsCount: resourceIds?.length || 0,\r\n        tenantId: this.tenantContext.tenantId,\r\n        userId: this.tenantContext.userId,\r\n        requestId: this.tenantContext.requestId\r\n      });\r\n      throw error;\r\n    }\r\n\r\n    // CRITICAL: Validate all resource IDs format\r\n    for (const resourceId of resourceIds) {\r\n      if (!resourceId || typeof resourceId !== 'string') {\r\n        const error = new Error('INVALID_RESOURCE_ID');\r\n        logger.error('Invalid resource ID in bulk operation', error as Error, {\r\n          operation,\r\n          resourceId,\r\n          tenantId: this.tenantContext.tenantId,\r\n          userId: this.tenantContext.userId,\r\n          requestId: this.tenantContext.requestId\r\n        });\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    logger.debug('Bulk operation validated', {\r\n      operation,\r\n      resourceIdsCount: resourceIds.length,\r\n      tenantId: this.tenantContext.tenantId,\r\n      requestId: this.tenantContext.requestId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute tenant-safe transaction\r\n   */\r\n  async transaction<T>(\r\n    callback: (tx: PrismaClient, context: ServiceTenantContext) => Promise<T>\r\n  ): Promise<T> {\r\n    return await this.queryBuilder.transaction(async (tx) => {\r\n      // Create service context for transaction\r\n      const txContext = {\r\n        ...this.tenantContext,\r\n        requestId: this.tenantContext.requestId + '_tx'\r\n      };\r\n\r\n      return await callback(tx, txContext);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Execute tenant-safe batch operation\r\n   */\r\n  async batch<T>(\r\n    operations: Array<(tx: PrismaClient, context: ServiceTenantContext) => Promise<T>>\r\n  ): Promise<T[]> {\r\n    const queries = operations.map(op => (tx: PrismaClient) => {\r\n      const txContext = {\r\n        ...this.tenantContext,\r\n        requestId: this.tenantContext.requestId + '_batch'\r\n      };\r\n      return op(tx, txContext);\r\n    });\r\n\r\n    return await this.queryBuilder.batch(queries);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Get tenant context for logging and debugging\r\n   */\r\n  getContext(): ServiceTenantContext {\r\n    return { ...this.tenantContext };\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if user is admin or higher\r\n   */\r\n  isAdmin(): boolean {\r\n    return ['OWNER', 'ADMIN'].includes(this.tenantContext.userRole);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if user is manager or higher\r\n   */\r\n  isManager(): boolean {\r\n    return ['OWNER', 'ADMIN', 'MANAGER'].includes(this.tenantContext.userRole);\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Check if user is owner\r\n   */\r\n  isOwner(): boolean {\r\n    return this.tenantContext.userRole === 'OWNER';\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Log tenant-aware operation\r\n   */\r\n  logOperation(operation: string, details?: Record<string, any>): void {\r\n    logger.info('Tenant-aware operation', {\r\n      operation,\r\n      tenantId: this.tenantContext.tenantId,\r\n      userId: this.tenantContext.userId,\r\n      userRole: this.tenantContext.userRole,\r\n      requestId: this.tenantContext.requestId,\r\n      ...details\r\n    });\r\n  }\r\n\r\n  /**\r\n   * CRITICAL: Log tenant-aware error\r\n   */\r\n  logError(operation: string, error: Error, details?: Record<string, any>): void {\r\n    logger.error(`Tenant-aware operation failed: ${operation}`, error, {\r\n      tenantId: this.tenantContext.tenantId,\r\n      userId: this.tenantContext.userId,\r\n      userRole: this.tenantContext.userRole,\r\n      requestId: this.tenantContext.requestId,\r\n      ...details\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * CRITICAL: Factory function for creating tenant-guarded services\r\n */\r\nexport const createTenantGuardedService = (\r\n  prisma: PrismaClient,\r\n  tenantContext: TenantContext,\r\n  options?: Partial<ServiceOptions>\r\n): TenantGuardedService => {\r\n  return new TenantGuardedService(prisma, tenantContext, options);\r\n};\r\n\r\n/**\r\n * CRITICAL: Middleware to create tenant-guarded service for requests\r\n */\r\nexport const createTenantGuardedServiceMiddleware = (\r\n  options?: Partial<ServiceOptions>\r\n) => {\r\n  return (req: any, res: any, next: any) => {\r\n    if (!req.tenantContext) {\r\n      return res.status(403).json({\r\n        error: 'Tenant context required',\r\n        code: 'TENANT_CONTEXT_REQUIRED'\r\n      });\r\n    }\r\n\r\n    // Create service and attach to request\r\n    req.tenantService = createTenantGuardedService(\r\n      req.prisma,\r\n      req.tenantContext,\r\n      options\r\n    );\r\n\r\n    next();\r\n  };\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\tenant\\tenant-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\types\\express.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\types\\inventory.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\utils\\error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\utils\\graceful-shutdown.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\utils\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\utils\\metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\utils\\structured-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\validation\\auth.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\vite.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\server\\worker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\shared\\contracts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\shared\\logging.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\shared\\schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\src\\runtime\\invariants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\FidiMyProjects2025\\Software_Projects\\AccuBooks\\AccuBooks\\src\\types\\external-modules.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
name: Deploy to Production EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ca-central-1
  AWS_ACCOUNT_ID: 971551576768
  EKS_CLUSTER_NAME: accubooks-production
  NAMESPACE: accubooks-prod
  ECR_BACKEND_REPO: accubooks-backend
  ECR_FRONTEND_REPO: accubooks-frontend

jobs:
  deploy:
    name: Build and Deploy to EKS
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories if not exist
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_BACKEND_REPO }} --region ${{ env.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.ECR_BACKEND_REPO }} --region ${{ env.AWS_REGION }} --image-scanning-configuration scanOnPush=true
          
          aws ecr describe-repositories --repository-names ${{ env.ECR_FRONTEND_REPO }} --region ${{ env.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.ECR_FRONTEND_REPO }} --region ${{ env.AWS_REGION }} --image-scanning-configuration scanOnPush=true

      - name: Build and push backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f Dockerfile.backend -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest .
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest
          echo "BACKEND_IMAGE=$ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Build and push frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f Dockerfile.frontend -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest .
          docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest
          echo "FRONTEND_IMAGE=$ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Fetch and create secrets from AWS Secrets Manager
        run: |
          # Fetch database secret
          DB_SECRET=$(aws secretsmanager get-secret-value --secret-id "accubooks/prod/v2/database" --region ${{ env.AWS_REGION }} --query SecretString --output text)
          DATABASE_URL=$(echo $DB_SECRET | jq -r '.DATABASE_URL')
          
          # Fetch Redis secret
          REDIS_SECRET=$(aws secretsmanager get-secret-value --secret-id "accubooks/prod/v2/redis" --region ${{ env.AWS_REGION }} --query SecretString --output text)
          REDIS_URL=$(echo $REDIS_SECRET | jq -r '.REDIS_URL')
          REDIS_PASSWORD=$(echo $REDIS_SECRET | jq -r '.REDIS_PASSWORD')
          
          # Fetch auth secret
          AUTH_SECRET=$(aws secretsmanager get-secret-value --secret-id "accubooks/prod/v2/auth" --region ${{ env.AWS_REGION }} --query SecretString --output text)
          JWT_SECRET=$(echo $AUTH_SECRET | jq -r '.JWT_SECRET')
          JWT_REFRESH_SECRET=$(echo $AUTH_SECRET | jq -r '.JWT_REFRESH_SECRET')
          SESSION_SECRET=$(echo $AUTH_SECRET | jq -r '.SESSION_SECRET')
          ENCRYPTION_KEY=$(echo $AUTH_SECRET | jq -r '.ENCRYPTION_KEY')
          
          # Fetch third-party secret
          THIRD_PARTY_SECRET=$(aws secretsmanager get-secret-value --secret-id "accubooks/prod/v2/third-party" --region ${{ env.AWS_REGION }} --query SecretString --output text)
          STRIPE_SECRET_KEY=$(echo $THIRD_PARTY_SECRET | jq -r '.STRIPE_SECRET_KEY')
          STRIPE_PUBLISHABLE_KEY=$(echo $THIRD_PARTY_SECRET | jq -r '.STRIPE_PUBLISHABLE_KEY')
          GOOGLE_CLIENT_ID=$(echo $THIRD_PARTY_SECRET | jq -r '.GOOGLE_CLIENT_ID')
          GOOGLE_CLIENT_SECRET=$(echo $THIRD_PARTY_SECRET | jq -r '.GOOGLE_CLIENT_SECRET')
          SMTP_HOST=$(echo $THIRD_PARTY_SECRET | jq -r '.SMTP_HOST')
          SMTP_PORT=$(echo $THIRD_PARTY_SECRET | jq -r '.SMTP_PORT')
          SMTP_USER=$(echo $THIRD_PARTY_SECRET | jq -r '.SMTP_USER')
          SMTP_PASS=$(echo $THIRD_PARTY_SECRET | jq -r '.SMTP_PASS')
          
          # Create Kubernetes secret
          kubectl create secret generic accubooks-secrets \
            --from-literal=database-url="$DATABASE_URL" \
            --from-literal=redis-url="$REDIS_URL" \
            --from-literal=redis-password="$REDIS_PASSWORD" \
            --from-literal=jwt-secret="$JWT_SECRET" \
            --from-literal=jwt-refresh-secret="$JWT_REFRESH_SECRET" \
            --from-literal=session-secret="$SESSION_SECRET" \
            --from-literal=encryption-key="$ENCRYPTION_KEY" \
            --from-literal=stripe-secret-key="$STRIPE_SECRET_KEY" \
            --from-literal=stripe-publishable-key="$STRIPE_PUBLISHABLE_KEY" \
            --from-literal=google-client-id="$GOOGLE_CLIENT_ID" \
            --from-literal=google-client-secret="$GOOGLE_CLIENT_SECRET" \
            --from-literal=smtp-host="$SMTP_HOST" \
            --from-literal=smtp-port="$SMTP_PORT" \
            --from-literal=smtp-user="$SMTP_USER" \
            --from-literal=smtp-pass="$SMTP_PASS" \
            --namespace ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Kubernetes resources
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Update image tags in manifests
          sed -i "s|BACKEND_IMAGE_PLACEHOLDER|$ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG|g" k8s/backend-deployment.yaml
          sed -i "s|FRONTEND_IMAGE_PLACEHOLDER|$ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG|g" k8s/frontend-deployment.yaml
          
          # Apply all manifests
          kubectl apply -f k8s/ -n ${{ env.NAMESPACE }}

      - name: Wait for deployment rollout
        run: |
          kubectl rollout status deployment/accubooks-backend -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/accubooks-frontend -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Get LoadBalancer URL
        id: get-url
        run: |
          echo "Waiting for LoadBalancer to be ready..."
          for i in {1..30}; do
            LB_URL=$(kubectl get svc accubooks-frontend -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [ -n "$LB_URL" ]; then
              echo "LoadBalancer URL: http://$LB_URL"
              echo "url=http://$LB_URL" >> $GITHUB_OUTPUT
              break
            fi
            echo "Attempt $i/30: Waiting for LoadBalancer..."
            sleep 10
          done

      - name: Verify deployment
        run: |
          echo "==================================="
          echo "Deployment Status"
          echo "==================================="
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get svc -n ${{ env.NAMESPACE }}
          echo ""
          echo "==================================="
          echo "‚úÖ Deployment Complete"
          echo "üåê Public URL: ${{ steps.get-url.outputs.url }}"
          echo "üì¶ Backend Image: ${{ env.BACKEND_IMAGE }}"
          echo "üì¶ Frontend Image: ${{ env.FRONTEND_IMAGE }}"
          echo "‚ò∏Ô∏è  Cluster: ${{ env.EKS_CLUSTER_NAME }}"
          echo "üïí Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "==================================="


/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model DashboardLayout
 * 
 */
export type DashboardLayout = $Result.DefaultSelection<Prisma.$DashboardLayoutPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model AutomationRule
 * 
 */
export type AutomationRule = $Result.DefaultSelection<Prisma.$AutomationRulePayload>
/**
 * Model AutomationExecution
 * 
 */
export type AutomationExecution = $Result.DefaultSelection<Prisma.$AutomationExecutionPayload>
/**
 * Model SmartInsight
 * 
 */
export type SmartInsight = $Result.DefaultSelection<Prisma.$SmartInsightPayload>
/**
 * Model AutomationTemplate
 * 
 */
export type AutomationTemplate = $Result.DefaultSelection<Prisma.$AutomationTemplatePayload>
/**
 * Model AutomationUsageMetric
 * 
 */
export type AutomationUsageMetric = $Result.DefaultSelection<Prisma.$AutomationUsageMetricPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentReconciliation
 * 
 */
export type PaymentReconciliation = $Result.DefaultSelection<Prisma.$PaymentReconciliationPayload>
/**
 * Model PaymentExplainability
 * 
 */
export type PaymentExplainability = $Result.DefaultSelection<Prisma.$PaymentExplainabilityPayload>
/**
 * Model CashControlRule
 * 
 */
export type CashControlRule = $Result.DefaultSelection<Prisma.$CashControlRulePayload>
/**
 * Model CashControlExecution
 * 
 */
export type CashControlExecution = $Result.DefaultSelection<Prisma.$CashControlExecutionPayload>
/**
 * Model PaymentAnalytics
 * 
 */
export type PaymentAnalytics = $Result.DefaultSelection<Prisma.$PaymentAnalyticsPayload>
/**
 * Model FinancialForecast
 * 
 */
export type FinancialForecast = $Result.DefaultSelection<Prisma.$FinancialForecastPayload>
/**
 * Model Scenario
 * 
 */
export type Scenario = $Result.DefaultSelection<Prisma.$ScenarioPayload>
/**
 * Model ScenarioAnalytics
 * 
 */
export type ScenarioAnalytics = $Result.DefaultSelection<Prisma.$ScenarioAnalyticsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  ACCOUNTANT: 'ACCOUNTANT',
  AUDITOR: 'AUDITOR',
  INVENTORY_MANAGER: 'INVENTORY_MANAGER',
  STAFF: 'STAFF',
  VIEWER: 'VIEWER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const SubscriptionPlan: {
  FREE: 'FREE',
  STARTER: 'STARTER',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const TenantStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  TRIAL: 'TRIAL',
  CANCELLED: 'CANCELLED'
};

export type TenantStatus = (typeof TenantStatus)[keyof typeof TenantStatus]


export const AutomationTriggerType: {
  INVOICE_OVERDUE: 'INVOICE_OVERDUE',
  CASH_BALANCE_THRESHOLD: 'CASH_BALANCE_THRESHOLD',
  EXPENSE_ANOMALY: 'EXPENSE_ANOMALY',
  REVENUE_DROP: 'REVENUE_DROP',
  REVENUE_INCREASE: 'REVENUE_INCREASE',
  MONTH_END: 'MONTH_END',
  QUARTER_END: 'QUARTER_END',
  YEAR_END: 'YEAR_END',
  SCHEDULED_DAILY: 'SCHEDULED_DAILY',
  SCHEDULED_WEEKLY: 'SCHEDULED_WEEKLY',
  SCHEDULED_MONTHLY: 'SCHEDULED_MONTHLY',
  MANUAL: 'MANUAL',
  TRANSACTION_CREATED: 'TRANSACTION_CREATED',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  BUDGET_EXCEEDED: 'BUDGET_EXCEEDED',
  LOW_INVENTORY: 'LOW_INVENTORY',
  LATE_PAYMENT_PATTERN: 'LATE_PAYMENT_PATTERN'
};

export type AutomationTriggerType = (typeof AutomationTriggerType)[keyof typeof AutomationTriggerType]


export const AutomationActionType: {
  SEND_EMAIL: 'SEND_EMAIL',
  SEND_IN_APP_NOTIFICATION: 'SEND_IN_APP_NOTIFICATION',
  GENERATE_REPORT: 'GENERATE_REPORT',
  LOCK_ACTION: 'LOCK_ACTION',
  FLAG_TRANSACTION: 'FLAG_TRANSACTION',
  CREATE_TASK: 'CREATE_TASK',
  NOTIFY_ROLE: 'NOTIFY_ROLE',
  WEBHOOK: 'WEBHOOK',
  UPDATE_FIELD: 'UPDATE_FIELD',
  CREATE_APPROVAL_REQUEST: 'CREATE_APPROVAL_REQUEST'
};

export type AutomationActionType = (typeof AutomationActionType)[keyof typeof AutomationActionType]


export const AutomationStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  DRAFT: 'DRAFT',
  ARCHIVED: 'ARCHIVED'
};

export type AutomationStatus = (typeof AutomationStatus)[keyof typeof AutomationStatus]


export const AutomationExecutionStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  SKIPPED: 'SKIPPED',
  CANCELLED: 'CANCELLED'
};

export type AutomationExecutionStatus = (typeof AutomationExecutionStatus)[keyof typeof AutomationExecutionStatus]


export const InsightType: {
  EXPENSE_ANOMALY: 'EXPENSE_ANOMALY',
  CASH_FLOW_WARNING: 'CASH_FLOW_WARNING',
  REVENUE_TREND: 'REVENUE_TREND',
  PAYMENT_PATTERN: 'PAYMENT_PATTERN',
  BUDGET_ALERT: 'BUDGET_ALERT',
  PROFITABILITY_CHANGE: 'PROFITABILITY_CHANGE',
  SEASONAL_PATTERN: 'SEASONAL_PATTERN',
  VENDOR_RISK: 'VENDOR_RISK'
};

export type InsightType = (typeof InsightType)[keyof typeof InsightType]


export const InsightSeverity: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  CRITICAL: 'CRITICAL'
};

export type InsightSeverity = (typeof InsightSeverity)[keyof typeof InsightSeverity]


export const PaymentMethodType: {
  ACH: 'ACH',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  BANK_ACCOUNT: 'BANK_ACCOUNT'
};

export type PaymentMethodType = (typeof PaymentMethodType)[keyof typeof PaymentMethodType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED',
  DISPUTED: 'DISPUTED',
  REQUIRES_ACTION: 'REQUIRES_ACTION'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentType: {
  INVOICE_PAYMENT: 'INVOICE_PAYMENT',
  VENDOR_PAYMENT: 'VENDOR_PAYMENT',
  TAX_RESERVE: 'TAX_RESERVE',
  REFUND: 'REFUND',
  MANUAL: 'MANUAL'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const ReconciliationStatus: {
  PENDING: 'PENDING',
  MATCHED: 'MATCHED',
  UNMATCHED: 'UNMATCHED',
  DISPUTED: 'DISPUTED',
  RESOLVED: 'RESOLVED'
};

export type ReconciliationStatus = (typeof ReconciliationStatus)[keyof typeof ReconciliationStatus]


export const CashControlRuleType: {
  AUTO_COLLECT_OVERDUE: 'AUTO_COLLECT_OVERDUE',
  RETRY_FAILED_PAYMENT: 'RETRY_FAILED_PAYMENT',
  AUTO_RESERVE_TAXES: 'AUTO_RESERVE_TAXES',
  AUTO_PAY_VENDOR: 'AUTO_PAY_VENDOR',
  PAUSE_ON_DISPUTE: 'PAUSE_ON_DISPUTE',
  SCHEDULE_PAYMENT: 'SCHEDULE_PAYMENT'
};

export type CashControlRuleType = (typeof CashControlRuleType)[keyof typeof CashControlRuleType]


export const ForecastType: {
  CASH_RUNWAY: 'CASH_RUNWAY',
  BURN_RATE: 'BURN_RATE',
  REVENUE_GROWTH: 'REVENUE_GROWTH',
  EXPENSE_TRAJECTORY: 'EXPENSE_TRAJECTORY',
  PAYMENT_INFLOW: 'PAYMENT_INFLOW'
};

export type ForecastType = (typeof ForecastType)[keyof typeof ForecastType]


export const ScenarioType: {
  HIRING: 'HIRING',
  LARGE_PURCHASE: 'LARGE_PURCHASE',
  REVENUE_CHANGE: 'REVENUE_CHANGE',
  PAYMENT_DELAY: 'PAYMENT_DELAY',
  AUTOMATION_CHANGE: 'AUTOMATION_CHANGE',
  CUSTOM: 'CUSTOM'
};

export type ScenarioType = (typeof ScenarioType)[keyof typeof ScenarioType]


export const RiskLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type TenantStatus = $Enums.TenantStatus

export const TenantStatus: typeof $Enums.TenantStatus

export type AutomationTriggerType = $Enums.AutomationTriggerType

export const AutomationTriggerType: typeof $Enums.AutomationTriggerType

export type AutomationActionType = $Enums.AutomationActionType

export const AutomationActionType: typeof $Enums.AutomationActionType

export type AutomationStatus = $Enums.AutomationStatus

export const AutomationStatus: typeof $Enums.AutomationStatus

export type AutomationExecutionStatus = $Enums.AutomationExecutionStatus

export const AutomationExecutionStatus: typeof $Enums.AutomationExecutionStatus

export type InsightType = $Enums.InsightType

export const InsightType: typeof $Enums.InsightType

export type InsightSeverity = $Enums.InsightSeverity

export const InsightSeverity: typeof $Enums.InsightSeverity

export type PaymentMethodType = $Enums.PaymentMethodType

export const PaymentMethodType: typeof $Enums.PaymentMethodType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type ReconciliationStatus = $Enums.ReconciliationStatus

export const ReconciliationStatus: typeof $Enums.ReconciliationStatus

export type CashControlRuleType = $Enums.CashControlRuleType

export const CashControlRuleType: typeof $Enums.CashControlRuleType

export type ForecastType = $Enums.ForecastType

export const ForecastType: typeof $Enums.ForecastType

export type ScenarioType = $Enums.ScenarioType

export const ScenarioType: typeof $Enums.ScenarioType

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardLayout`: Exposes CRUD operations for the **DashboardLayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardLayouts
    * const dashboardLayouts = await prisma.dashboardLayout.findMany()
    * ```
    */
  get dashboardLayout(): Prisma.DashboardLayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationRule`: Exposes CRUD operations for the **AutomationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationRules
    * const automationRules = await prisma.automationRule.findMany()
    * ```
    */
  get automationRule(): Prisma.AutomationRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationExecution`: Exposes CRUD operations for the **AutomationExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationExecutions
    * const automationExecutions = await prisma.automationExecution.findMany()
    * ```
    */
  get automationExecution(): Prisma.AutomationExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.smartInsight`: Exposes CRUD operations for the **SmartInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmartInsights
    * const smartInsights = await prisma.smartInsight.findMany()
    * ```
    */
  get smartInsight(): Prisma.SmartInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationTemplate`: Exposes CRUD operations for the **AutomationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationTemplates
    * const automationTemplates = await prisma.automationTemplate.findMany()
    * ```
    */
  get automationTemplate(): Prisma.AutomationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationUsageMetric`: Exposes CRUD operations for the **AutomationUsageMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationUsageMetrics
    * const automationUsageMetrics = await prisma.automationUsageMetric.findMany()
    * ```
    */
  get automationUsageMetric(): Prisma.AutomationUsageMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentReconciliation`: Exposes CRUD operations for the **PaymentReconciliation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentReconciliations
    * const paymentReconciliations = await prisma.paymentReconciliation.findMany()
    * ```
    */
  get paymentReconciliation(): Prisma.PaymentReconciliationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentExplainability`: Exposes CRUD operations for the **PaymentExplainability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentExplainabilities
    * const paymentExplainabilities = await prisma.paymentExplainability.findMany()
    * ```
    */
  get paymentExplainability(): Prisma.PaymentExplainabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashControlRule`: Exposes CRUD operations for the **CashControlRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashControlRules
    * const cashControlRules = await prisma.cashControlRule.findMany()
    * ```
    */
  get cashControlRule(): Prisma.CashControlRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashControlExecution`: Exposes CRUD operations for the **CashControlExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashControlExecutions
    * const cashControlExecutions = await prisma.cashControlExecution.findMany()
    * ```
    */
  get cashControlExecution(): Prisma.CashControlExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentAnalytics`: Exposes CRUD operations for the **PaymentAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAnalytics
    * const paymentAnalytics = await prisma.paymentAnalytics.findMany()
    * ```
    */
  get paymentAnalytics(): Prisma.PaymentAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialForecast`: Exposes CRUD operations for the **FinancialForecast** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialForecasts
    * const financialForecasts = await prisma.financialForecast.findMany()
    * ```
    */
  get financialForecast(): Prisma.FinancialForecastDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scenario`: Exposes CRUD operations for the **Scenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scenarios
    * const scenarios = await prisma.scenario.findMany()
    * ```
    */
  get scenario(): Prisma.ScenarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scenarioAnalytics`: Exposes CRUD operations for the **ScenarioAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScenarioAnalytics
    * const scenarioAnalytics = await prisma.scenarioAnalytics.findMany()
    * ```
    */
  get scenarioAnalytics(): Prisma.ScenarioAnalyticsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Tenant: 'Tenant',
    DashboardLayout: 'DashboardLayout',
    AuditLog: 'AuditLog',
    AnalyticsEvent: 'AnalyticsEvent',
    AutomationRule: 'AutomationRule',
    AutomationExecution: 'AutomationExecution',
    SmartInsight: 'SmartInsight',
    AutomationTemplate: 'AutomationTemplate',
    AutomationUsageMetric: 'AutomationUsageMetric',
    PaymentMethod: 'PaymentMethod',
    Payment: 'Payment',
    PaymentReconciliation: 'PaymentReconciliation',
    PaymentExplainability: 'PaymentExplainability',
    CashControlRule: 'CashControlRule',
    CashControlExecution: 'CashControlExecution',
    PaymentAnalytics: 'PaymentAnalytics',
    FinancialForecast: 'FinancialForecast',
    Scenario: 'Scenario',
    ScenarioAnalytics: 'ScenarioAnalytics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "tenant" | "dashboardLayout" | "auditLog" | "analyticsEvent" | "automationRule" | "automationExecution" | "smartInsight" | "automationTemplate" | "automationUsageMetric" | "paymentMethod" | "payment" | "paymentReconciliation" | "paymentExplainability" | "cashControlRule" | "cashControlExecution" | "paymentAnalytics" | "financialForecast" | "scenario" | "scenarioAnalytics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      DashboardLayout: {
        payload: Prisma.$DashboardLayoutPayload<ExtArgs>
        fields: Prisma.DashboardLayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardLayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardLayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>
          }
          findFirst: {
            args: Prisma.DashboardLayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardLayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>
          }
          findMany: {
            args: Prisma.DashboardLayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>[]
          }
          create: {
            args: Prisma.DashboardLayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>
          }
          createMany: {
            args: Prisma.DashboardLayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardLayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>[]
          }
          delete: {
            args: Prisma.DashboardLayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>
          }
          update: {
            args: Prisma.DashboardLayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>
          }
          deleteMany: {
            args: Prisma.DashboardLayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardLayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardLayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>[]
          }
          upsert: {
            args: Prisma.DashboardLayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardLayoutPayload>
          }
          aggregate: {
            args: Prisma.DashboardLayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardLayout>
          }
          groupBy: {
            args: Prisma.DashboardLayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardLayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardLayoutCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardLayoutCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      AutomationRule: {
        payload: Prisma.$AutomationRulePayload<ExtArgs>
        fields: Prisma.AutomationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findFirst: {
            args: Prisma.AutomationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findMany: {
            args: Prisma.AutomationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          create: {
            args: Prisma.AutomationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          createMany: {
            args: Prisma.AutomationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          delete: {
            args: Prisma.AutomationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          update: {
            args: Prisma.AutomationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          deleteMany: {
            args: Prisma.AutomationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          upsert: {
            args: Prisma.AutomationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          aggregate: {
            args: Prisma.AutomationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationRule>
          }
          groupBy: {
            args: Prisma.AutomationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleCountAggregateOutputType> | number
          }
        }
      }
      AutomationExecution: {
        payload: Prisma.$AutomationExecutionPayload<ExtArgs>
        fields: Prisma.AutomationExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          findFirst: {
            args: Prisma.AutomationExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          findMany: {
            args: Prisma.AutomationExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>[]
          }
          create: {
            args: Prisma.AutomationExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          createMany: {
            args: Prisma.AutomationExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>[]
          }
          delete: {
            args: Prisma.AutomationExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          update: {
            args: Prisma.AutomationExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          deleteMany: {
            args: Prisma.AutomationExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>[]
          }
          upsert: {
            args: Prisma.AutomationExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationExecutionPayload>
          }
          aggregate: {
            args: Prisma.AutomationExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationExecution>
          }
          groupBy: {
            args: Prisma.AutomationExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationExecutionCountAggregateOutputType> | number
          }
        }
      }
      SmartInsight: {
        payload: Prisma.$SmartInsightPayload<ExtArgs>
        fields: Prisma.SmartInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SmartInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SmartInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>
          }
          findFirst: {
            args: Prisma.SmartInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SmartInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>
          }
          findMany: {
            args: Prisma.SmartInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>[]
          }
          create: {
            args: Prisma.SmartInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>
          }
          createMany: {
            args: Prisma.SmartInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SmartInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>[]
          }
          delete: {
            args: Prisma.SmartInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>
          }
          update: {
            args: Prisma.SmartInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>
          }
          deleteMany: {
            args: Prisma.SmartInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SmartInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SmartInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>[]
          }
          upsert: {
            args: Prisma.SmartInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartInsightPayload>
          }
          aggregate: {
            args: Prisma.SmartInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSmartInsight>
          }
          groupBy: {
            args: Prisma.SmartInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<SmartInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.SmartInsightCountArgs<ExtArgs>
            result: $Utils.Optional<SmartInsightCountAggregateOutputType> | number
          }
        }
      }
      AutomationTemplate: {
        payload: Prisma.$AutomationTemplatePayload<ExtArgs>
        fields: Prisma.AutomationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>
          }
          findFirst: {
            args: Prisma.AutomationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>
          }
          findMany: {
            args: Prisma.AutomationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>[]
          }
          create: {
            args: Prisma.AutomationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>
          }
          createMany: {
            args: Prisma.AutomationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>[]
          }
          delete: {
            args: Prisma.AutomationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>
          }
          update: {
            args: Prisma.AutomationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.AutomationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>[]
          }
          upsert: {
            args: Prisma.AutomationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationTemplatePayload>
          }
          aggregate: {
            args: Prisma.AutomationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationTemplate>
          }
          groupBy: {
            args: Prisma.AutomationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationTemplateCountAggregateOutputType> | number
          }
        }
      }
      AutomationUsageMetric: {
        payload: Prisma.$AutomationUsageMetricPayload<ExtArgs>
        fields: Prisma.AutomationUsageMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationUsageMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationUsageMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>
          }
          findFirst: {
            args: Prisma.AutomationUsageMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationUsageMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>
          }
          findMany: {
            args: Prisma.AutomationUsageMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>[]
          }
          create: {
            args: Prisma.AutomationUsageMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>
          }
          createMany: {
            args: Prisma.AutomationUsageMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationUsageMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>[]
          }
          delete: {
            args: Prisma.AutomationUsageMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>
          }
          update: {
            args: Prisma.AutomationUsageMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>
          }
          deleteMany: {
            args: Prisma.AutomationUsageMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUsageMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationUsageMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>[]
          }
          upsert: {
            args: Prisma.AutomationUsageMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationUsageMetricPayload>
          }
          aggregate: {
            args: Prisma.AutomationUsageMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationUsageMetric>
          }
          groupBy: {
            args: Prisma.AutomationUsageMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationUsageMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationUsageMetricCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationUsageMetricCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentReconciliation: {
        payload: Prisma.$PaymentReconciliationPayload<ExtArgs>
        fields: Prisma.PaymentReconciliationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentReconciliationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentReconciliationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>
          }
          findFirst: {
            args: Prisma.PaymentReconciliationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentReconciliationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>
          }
          findMany: {
            args: Prisma.PaymentReconciliationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>[]
          }
          create: {
            args: Prisma.PaymentReconciliationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>
          }
          createMany: {
            args: Prisma.PaymentReconciliationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentReconciliationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>[]
          }
          delete: {
            args: Prisma.PaymentReconciliationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>
          }
          update: {
            args: Prisma.PaymentReconciliationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>
          }
          deleteMany: {
            args: Prisma.PaymentReconciliationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentReconciliationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentReconciliationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>[]
          }
          upsert: {
            args: Prisma.PaymentReconciliationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReconciliationPayload>
          }
          aggregate: {
            args: Prisma.PaymentReconciliationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentReconciliation>
          }
          groupBy: {
            args: Prisma.PaymentReconciliationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentReconciliationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentReconciliationCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentReconciliationCountAggregateOutputType> | number
          }
        }
      }
      PaymentExplainability: {
        payload: Prisma.$PaymentExplainabilityPayload<ExtArgs>
        fields: Prisma.PaymentExplainabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentExplainabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentExplainabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>
          }
          findFirst: {
            args: Prisma.PaymentExplainabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentExplainabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>
          }
          findMany: {
            args: Prisma.PaymentExplainabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>[]
          }
          create: {
            args: Prisma.PaymentExplainabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>
          }
          createMany: {
            args: Prisma.PaymentExplainabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentExplainabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>[]
          }
          delete: {
            args: Prisma.PaymentExplainabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>
          }
          update: {
            args: Prisma.PaymentExplainabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>
          }
          deleteMany: {
            args: Prisma.PaymentExplainabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentExplainabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentExplainabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>[]
          }
          upsert: {
            args: Prisma.PaymentExplainabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentExplainabilityPayload>
          }
          aggregate: {
            args: Prisma.PaymentExplainabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentExplainability>
          }
          groupBy: {
            args: Prisma.PaymentExplainabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentExplainabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentExplainabilityCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentExplainabilityCountAggregateOutputType> | number
          }
        }
      }
      CashControlRule: {
        payload: Prisma.$CashControlRulePayload<ExtArgs>
        fields: Prisma.CashControlRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashControlRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashControlRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>
          }
          findFirst: {
            args: Prisma.CashControlRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashControlRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>
          }
          findMany: {
            args: Prisma.CashControlRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>[]
          }
          create: {
            args: Prisma.CashControlRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>
          }
          createMany: {
            args: Prisma.CashControlRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashControlRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>[]
          }
          delete: {
            args: Prisma.CashControlRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>
          }
          update: {
            args: Prisma.CashControlRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>
          }
          deleteMany: {
            args: Prisma.CashControlRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashControlRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashControlRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>[]
          }
          upsert: {
            args: Prisma.CashControlRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlRulePayload>
          }
          aggregate: {
            args: Prisma.CashControlRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashControlRule>
          }
          groupBy: {
            args: Prisma.CashControlRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashControlRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashControlRuleCountArgs<ExtArgs>
            result: $Utils.Optional<CashControlRuleCountAggregateOutputType> | number
          }
        }
      }
      CashControlExecution: {
        payload: Prisma.$CashControlExecutionPayload<ExtArgs>
        fields: Prisma.CashControlExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashControlExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashControlExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>
          }
          findFirst: {
            args: Prisma.CashControlExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashControlExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>
          }
          findMany: {
            args: Prisma.CashControlExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>[]
          }
          create: {
            args: Prisma.CashControlExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>
          }
          createMany: {
            args: Prisma.CashControlExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashControlExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>[]
          }
          delete: {
            args: Prisma.CashControlExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>
          }
          update: {
            args: Prisma.CashControlExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>
          }
          deleteMany: {
            args: Prisma.CashControlExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashControlExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashControlExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>[]
          }
          upsert: {
            args: Prisma.CashControlExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashControlExecutionPayload>
          }
          aggregate: {
            args: Prisma.CashControlExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashControlExecution>
          }
          groupBy: {
            args: Prisma.CashControlExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashControlExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashControlExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<CashControlExecutionCountAggregateOutputType> | number
          }
        }
      }
      PaymentAnalytics: {
        payload: Prisma.$PaymentAnalyticsPayload<ExtArgs>
        fields: Prisma.PaymentAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PaymentAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PaymentAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PaymentAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PaymentAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.PaymentAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>
          }
          update: {
            args: Prisma.PaymentAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PaymentAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAnalytics>
          }
          groupBy: {
            args: Prisma.PaymentAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      FinancialForecast: {
        payload: Prisma.$FinancialForecastPayload<ExtArgs>
        fields: Prisma.FinancialForecastFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialForecastFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialForecastFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>
          }
          findFirst: {
            args: Prisma.FinancialForecastFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialForecastFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>
          }
          findMany: {
            args: Prisma.FinancialForecastFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>[]
          }
          create: {
            args: Prisma.FinancialForecastCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>
          }
          createMany: {
            args: Prisma.FinancialForecastCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialForecastCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>[]
          }
          delete: {
            args: Prisma.FinancialForecastDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>
          }
          update: {
            args: Prisma.FinancialForecastUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>
          }
          deleteMany: {
            args: Prisma.FinancialForecastDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialForecastUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialForecastUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>[]
          }
          upsert: {
            args: Prisma.FinancialForecastUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialForecastPayload>
          }
          aggregate: {
            args: Prisma.FinancialForecastAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialForecast>
          }
          groupBy: {
            args: Prisma.FinancialForecastGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialForecastGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialForecastCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialForecastCountAggregateOutputType> | number
          }
        }
      }
      Scenario: {
        payload: Prisma.$ScenarioPayload<ExtArgs>
        fields: Prisma.ScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findFirst: {
            args: Prisma.ScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findMany: {
            args: Prisma.ScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          create: {
            args: Prisma.ScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          createMany: {
            args: Prisma.ScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          delete: {
            args: Prisma.ScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          update: {
            args: Prisma.ScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          deleteMany: {
            args: Prisma.ScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScenarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          upsert: {
            args: Prisma.ScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          aggregate: {
            args: Prisma.ScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScenario>
          }
          groupBy: {
            args: Prisma.ScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<ScenarioCountAggregateOutputType> | number
          }
        }
      }
      ScenarioAnalytics: {
        payload: Prisma.$ScenarioAnalyticsPayload<ExtArgs>
        fields: Prisma.ScenarioAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScenarioAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScenarioAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.ScenarioAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScenarioAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>
          }
          findMany: {
            args: Prisma.ScenarioAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>[]
          }
          create: {
            args: Prisma.ScenarioAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>
          }
          createMany: {
            args: Prisma.ScenarioAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScenarioAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.ScenarioAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>
          }
          update: {
            args: Prisma.ScenarioAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.ScenarioAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScenarioAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScenarioAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.ScenarioAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.ScenarioAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScenarioAnalytics>
          }
          groupBy: {
            args: Prisma.ScenarioAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScenarioAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScenarioAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<ScenarioAnalyticsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    tenant?: TenantOmit
    dashboardLayout?: DashboardLayoutOmit
    auditLog?: AuditLogOmit
    analyticsEvent?: AnalyticsEventOmit
    automationRule?: AutomationRuleOmit
    automationExecution?: AutomationExecutionOmit
    smartInsight?: SmartInsightOmit
    automationTemplate?: AutomationTemplateOmit
    automationUsageMetric?: AutomationUsageMetricOmit
    paymentMethod?: PaymentMethodOmit
    payment?: PaymentOmit
    paymentReconciliation?: PaymentReconciliationOmit
    paymentExplainability?: PaymentExplainabilityOmit
    cashControlRule?: CashControlRuleOmit
    cashControlExecution?: CashControlExecutionOmit
    paymentAnalytics?: PaymentAnalyticsOmit
    financialForecast?: FinancialForecastOmit
    scenario?: ScenarioOmit
    scenarioAnalytics?: ScenarioAnalyticsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    dashboardLayouts: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    dashboardLayouts?: boolean | UserCountOutputTypeCountDashboardLayoutsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDashboardLayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardLayoutWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    dashboardLayouts: number
    auditLogs: number
    analyticsEvents: number
    automationRules: number
    automationExecutions: number
    smartInsights: number
    automationMetrics: number
    paymentMethods: number
    payments: number
    paymentReconciliations: number
    paymentExplainability: number
    cashControlRules: number
    cashControlExecutions: number
    paymentAnalytics: number
    financialForecasts: number
    scenarios: number
    scenarioAnalytics: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    dashboardLayouts?: boolean | TenantCountOutputTypeCountDashboardLayoutsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    analyticsEvents?: boolean | TenantCountOutputTypeCountAnalyticsEventsArgs
    automationRules?: boolean | TenantCountOutputTypeCountAutomationRulesArgs
    automationExecutions?: boolean | TenantCountOutputTypeCountAutomationExecutionsArgs
    smartInsights?: boolean | TenantCountOutputTypeCountSmartInsightsArgs
    automationMetrics?: boolean | TenantCountOutputTypeCountAutomationMetricsArgs
    paymentMethods?: boolean | TenantCountOutputTypeCountPaymentMethodsArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
    paymentReconciliations?: boolean | TenantCountOutputTypeCountPaymentReconciliationsArgs
    paymentExplainability?: boolean | TenantCountOutputTypeCountPaymentExplainabilityArgs
    cashControlRules?: boolean | TenantCountOutputTypeCountCashControlRulesArgs
    cashControlExecutions?: boolean | TenantCountOutputTypeCountCashControlExecutionsArgs
    paymentAnalytics?: boolean | TenantCountOutputTypeCountPaymentAnalyticsArgs
    financialForecasts?: boolean | TenantCountOutputTypeCountFinancialForecastsArgs
    scenarios?: boolean | TenantCountOutputTypeCountScenariosArgs
    scenarioAnalytics?: boolean | TenantCountOutputTypeCountScenarioAnalyticsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDashboardLayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardLayoutWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAnalyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAutomationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAutomationExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationExecutionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSmartInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmartInsightWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAutomationMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationUsageMetricWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentReconciliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentReconciliationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentExplainabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentExplainabilityWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCashControlRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashControlRuleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCashControlExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashControlExecutionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAnalyticsWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountFinancialForecastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialForecastWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountScenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountScenarioAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioAnalyticsWhereInput
  }


  /**
   * Count Type AutomationRuleCountOutputType
   */

  export type AutomationRuleCountOutputType = {
    executions: number
  }

  export type AutomationRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | AutomationRuleCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * AutomationRuleCountOutputType without action
   */
  export type AutomationRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRuleCountOutputType
     */
    select?: AutomationRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationRuleCountOutputType without action
   */
  export type AutomationRuleCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationExecutionWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    payments: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethodCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CashControlRuleCountOutputType
   */

  export type CashControlRuleCountOutputType = {
    executions: number
  }

  export type CashControlRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | CashControlRuleCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * CashControlRuleCountOutputType without action
   */
  export type CashControlRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRuleCountOutputType
     */
    select?: CashControlRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashControlRuleCountOutputType without action
   */
  export type CashControlRuleCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashControlExecutionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.Role | null
    tenantId: string | null
    isActive: boolean | null
    lastLogin: Date | null
    refreshToken: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.Role | null
    tenantId: string | null
    isActive: boolean | null
    lastLogin: Date | null
    refreshToken: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    password: number
    role: number
    tenantId: number
    isActive: number
    lastLogin: number
    refreshToken: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    tenantId?: true
    isActive?: true
    lastLogin?: true
    refreshToken?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    tenantId?: true
    isActive?: true
    lastLogin?: true
    refreshToken?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    tenantId?: true
    isActive?: true
    lastLogin?: true
    refreshToken?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.Role
    tenantId: string
    isActive: boolean
    lastLogin: Date | null
    refreshToken: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    dashboardLayouts?: boolean | User$dashboardLayoutsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "password" | "role" | "tenantId" | "isActive" | "lastLogin" | "refreshToken" | "resetToken" | "resetTokenExpiry" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    dashboardLayouts?: boolean | User$dashboardLayoutsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      dashboardLayouts: Prisma.$DashboardLayoutPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      password: string | null
      role: $Enums.Role
      tenantId: string
      isActive: boolean
      lastLogin: Date | null
      refreshToken: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dashboardLayouts<T extends User$dashboardLayoutsArgs<ExtArgs> = {}>(args?: Subset<T, User$dashboardLayoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly updatedBy: FieldRef<"User", 'String'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.dashboardLayouts
   */
  export type User$dashboardLayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    where?: DashboardLayoutWhereInput
    orderBy?: DashboardLayoutOrderByWithRelationInput | DashboardLayoutOrderByWithRelationInput[]
    cursor?: DashboardLayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardLayoutScalarFieldEnum | DashboardLayoutScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountSumAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    expiresAt: number | null
    tokenType: string | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    expiresAt: number | null
    tokenType: string | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refreshToken: number
    accessToken: number
    expiresAt: number
    tokenType: number
    scope: number
    idToken: number
    sessionState: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expiresAt?: true
  }

  export type AccountSumAggregateInputType = {
    expiresAt?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiresAt?: true
    tokenType?: true
    scope?: true
    idToken?: true
    sessionState?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiresAt?: true
    tokenType?: true
    scope?: true
    idToken?: true
    sessionState?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiresAt?: true
    tokenType?: true
    scope?: true
    idToken?: true
    sessionState?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken: string | null
    accessToken: string | null
    expiresAt: number | null
    tokenType: string | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refreshToken" | "accessToken" | "expiresAt" | "tokenType" | "scope" | "idToken" | "sessionState", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refreshToken: string | null
      accessToken: string | null
      expiresAt: number | null
      tokenType: string | null
      scope: string | null
      idToken: string | null
      sessionState: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'Int'>
    readonly tokenType: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly sessionState: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    customDomain: string | null
    favicon: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.TenantStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    customDomain: string | null
    favicon: string | null
    plan: $Enums.SubscriptionPlan | null
    status: $Enums.TenantStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    customDomain: number
    logo: number
    favicon: number
    theme: number
    featureFlags: number
    settings: number
    plan: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    customDomain?: true
    favicon?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    customDomain?: true
    favicon?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    customDomain?: true
    logo?: true
    favicon?: true
    theme?: true
    featureFlags?: true
    settings?: true
    plan?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    subdomain: string
    customDomain: string | null
    logo: JsonValue | null
    favicon: string | null
    theme: JsonValue | null
    featureFlags: JsonValue
    settings: JsonValue
    plan: $Enums.SubscriptionPlan
    status: $Enums.TenantStatus
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    customDomain?: boolean
    logo?: boolean
    favicon?: boolean
    theme?: boolean
    featureFlags?: boolean
    settings?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    dashboardLayouts?: boolean | Tenant$dashboardLayoutsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    analyticsEvents?: boolean | Tenant$analyticsEventsArgs<ExtArgs>
    automationRules?: boolean | Tenant$automationRulesArgs<ExtArgs>
    automationExecutions?: boolean | Tenant$automationExecutionsArgs<ExtArgs>
    smartInsights?: boolean | Tenant$smartInsightsArgs<ExtArgs>
    automationMetrics?: boolean | Tenant$automationMetricsArgs<ExtArgs>
    paymentMethods?: boolean | Tenant$paymentMethodsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    paymentReconciliations?: boolean | Tenant$paymentReconciliationsArgs<ExtArgs>
    paymentExplainability?: boolean | Tenant$paymentExplainabilityArgs<ExtArgs>
    cashControlRules?: boolean | Tenant$cashControlRulesArgs<ExtArgs>
    cashControlExecutions?: boolean | Tenant$cashControlExecutionsArgs<ExtArgs>
    paymentAnalytics?: boolean | Tenant$paymentAnalyticsArgs<ExtArgs>
    financialForecasts?: boolean | Tenant$financialForecastsArgs<ExtArgs>
    scenarios?: boolean | Tenant$scenariosArgs<ExtArgs>
    scenarioAnalytics?: boolean | Tenant$scenarioAnalyticsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    customDomain?: boolean
    logo?: boolean
    favicon?: boolean
    theme?: boolean
    featureFlags?: boolean
    settings?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    customDomain?: boolean
    logo?: boolean
    favicon?: boolean
    theme?: boolean
    featureFlags?: boolean
    settings?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    customDomain?: boolean
    logo?: boolean
    favicon?: boolean
    theme?: boolean
    featureFlags?: boolean
    settings?: boolean
    plan?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subdomain" | "customDomain" | "logo" | "favicon" | "theme" | "featureFlags" | "settings" | "plan" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    dashboardLayouts?: boolean | Tenant$dashboardLayoutsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    analyticsEvents?: boolean | Tenant$analyticsEventsArgs<ExtArgs>
    automationRules?: boolean | Tenant$automationRulesArgs<ExtArgs>
    automationExecutions?: boolean | Tenant$automationExecutionsArgs<ExtArgs>
    smartInsights?: boolean | Tenant$smartInsightsArgs<ExtArgs>
    automationMetrics?: boolean | Tenant$automationMetricsArgs<ExtArgs>
    paymentMethods?: boolean | Tenant$paymentMethodsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    paymentReconciliations?: boolean | Tenant$paymentReconciliationsArgs<ExtArgs>
    paymentExplainability?: boolean | Tenant$paymentExplainabilityArgs<ExtArgs>
    cashControlRules?: boolean | Tenant$cashControlRulesArgs<ExtArgs>
    cashControlExecutions?: boolean | Tenant$cashControlExecutionsArgs<ExtArgs>
    paymentAnalytics?: boolean | Tenant$paymentAnalyticsArgs<ExtArgs>
    financialForecasts?: boolean | Tenant$financialForecastsArgs<ExtArgs>
    scenarios?: boolean | Tenant$scenariosArgs<ExtArgs>
    scenarioAnalytics?: boolean | Tenant$scenarioAnalyticsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      dashboardLayouts: Prisma.$DashboardLayoutPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      analyticsEvents: Prisma.$AnalyticsEventPayload<ExtArgs>[]
      automationRules: Prisma.$AutomationRulePayload<ExtArgs>[]
      automationExecutions: Prisma.$AutomationExecutionPayload<ExtArgs>[]
      smartInsights: Prisma.$SmartInsightPayload<ExtArgs>[]
      automationMetrics: Prisma.$AutomationUsageMetricPayload<ExtArgs>[]
      paymentMethods: Prisma.$PaymentMethodPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      paymentReconciliations: Prisma.$PaymentReconciliationPayload<ExtArgs>[]
      paymentExplainability: Prisma.$PaymentExplainabilityPayload<ExtArgs>[]
      cashControlRules: Prisma.$CashControlRulePayload<ExtArgs>[]
      cashControlExecutions: Prisma.$CashControlExecutionPayload<ExtArgs>[]
      paymentAnalytics: Prisma.$PaymentAnalyticsPayload<ExtArgs>[]
      financialForecasts: Prisma.$FinancialForecastPayload<ExtArgs>[]
      scenarios: Prisma.$ScenarioPayload<ExtArgs>[]
      scenarioAnalytics: Prisma.$ScenarioAnalyticsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subdomain: string
      customDomain: string | null
      logo: Prisma.JsonValue | null
      favicon: string | null
      theme: Prisma.JsonValue | null
      featureFlags: Prisma.JsonValue
      settings: Prisma.JsonValue
      plan: $Enums.SubscriptionPlan
      status: $Enums.TenantStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dashboardLayouts<T extends Tenant$dashboardLayoutsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$dashboardLayoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analyticsEvents<T extends Tenant$analyticsEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$analyticsEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    automationRules<T extends Tenant$automationRulesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$automationRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    automationExecutions<T extends Tenant$automationExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$automationExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smartInsights<T extends Tenant$smartInsightsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$smartInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    automationMetrics<T extends Tenant$automationMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$automationMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentMethods<T extends Tenant$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentReconciliations<T extends Tenant$paymentReconciliationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentReconciliationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentExplainability<T extends Tenant$paymentExplainabilityArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentExplainabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashControlRules<T extends Tenant$cashControlRulesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cashControlRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashControlExecutions<T extends Tenant$cashControlExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cashControlExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentAnalytics<T extends Tenant$paymentAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialForecasts<T extends Tenant$financialForecastsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$financialForecastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scenarios<T extends Tenant$scenariosArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$scenariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scenarioAnalytics<T extends Tenant$scenarioAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$scenarioAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly subdomain: FieldRef<"Tenant", 'String'>
    readonly customDomain: FieldRef<"Tenant", 'String'>
    readonly logo: FieldRef<"Tenant", 'Json'>
    readonly favicon: FieldRef<"Tenant", 'String'>
    readonly theme: FieldRef<"Tenant", 'Json'>
    readonly featureFlags: FieldRef<"Tenant", 'Json'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly plan: FieldRef<"Tenant", 'SubscriptionPlan'>
    readonly status: FieldRef<"Tenant", 'TenantStatus'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.dashboardLayouts
   */
  export type Tenant$dashboardLayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    where?: DashboardLayoutWhereInput
    orderBy?: DashboardLayoutOrderByWithRelationInput | DashboardLayoutOrderByWithRelationInput[]
    cursor?: DashboardLayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardLayoutScalarFieldEnum | DashboardLayoutScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.analyticsEvents
   */
  export type Tenant$analyticsEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    cursor?: AnalyticsEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * Tenant.automationRules
   */
  export type Tenant$automationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    cursor?: AutomationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * Tenant.automationExecutions
   */
  export type Tenant$automationExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    where?: AutomationExecutionWhereInput
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    cursor?: AutomationExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * Tenant.smartInsights
   */
  export type Tenant$smartInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    where?: SmartInsightWhereInput
    orderBy?: SmartInsightOrderByWithRelationInput | SmartInsightOrderByWithRelationInput[]
    cursor?: SmartInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SmartInsightScalarFieldEnum | SmartInsightScalarFieldEnum[]
  }

  /**
   * Tenant.automationMetrics
   */
  export type Tenant$automationMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    where?: AutomationUsageMetricWhereInput
    orderBy?: AutomationUsageMetricOrderByWithRelationInput | AutomationUsageMetricOrderByWithRelationInput[]
    cursor?: AutomationUsageMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationUsageMetricScalarFieldEnum | AutomationUsageMetricScalarFieldEnum[]
  }

  /**
   * Tenant.paymentMethods
   */
  export type Tenant$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    cursor?: PaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Tenant.paymentReconciliations
   */
  export type Tenant$paymentReconciliationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    where?: PaymentReconciliationWhereInput
    orderBy?: PaymentReconciliationOrderByWithRelationInput | PaymentReconciliationOrderByWithRelationInput[]
    cursor?: PaymentReconciliationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentReconciliationScalarFieldEnum | PaymentReconciliationScalarFieldEnum[]
  }

  /**
   * Tenant.paymentExplainability
   */
  export type Tenant$paymentExplainabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    where?: PaymentExplainabilityWhereInput
    orderBy?: PaymentExplainabilityOrderByWithRelationInput | PaymentExplainabilityOrderByWithRelationInput[]
    cursor?: PaymentExplainabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentExplainabilityScalarFieldEnum | PaymentExplainabilityScalarFieldEnum[]
  }

  /**
   * Tenant.cashControlRules
   */
  export type Tenant$cashControlRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    where?: CashControlRuleWhereInput
    orderBy?: CashControlRuleOrderByWithRelationInput | CashControlRuleOrderByWithRelationInput[]
    cursor?: CashControlRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashControlRuleScalarFieldEnum | CashControlRuleScalarFieldEnum[]
  }

  /**
   * Tenant.cashControlExecutions
   */
  export type Tenant$cashControlExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    where?: CashControlExecutionWhereInput
    orderBy?: CashControlExecutionOrderByWithRelationInput | CashControlExecutionOrderByWithRelationInput[]
    cursor?: CashControlExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashControlExecutionScalarFieldEnum | CashControlExecutionScalarFieldEnum[]
  }

  /**
   * Tenant.paymentAnalytics
   */
  export type Tenant$paymentAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    where?: PaymentAnalyticsWhereInput
    orderBy?: PaymentAnalyticsOrderByWithRelationInput | PaymentAnalyticsOrderByWithRelationInput[]
    cursor?: PaymentAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAnalyticsScalarFieldEnum | PaymentAnalyticsScalarFieldEnum[]
  }

  /**
   * Tenant.financialForecasts
   */
  export type Tenant$financialForecastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    where?: FinancialForecastWhereInput
    orderBy?: FinancialForecastOrderByWithRelationInput | FinancialForecastOrderByWithRelationInput[]
    cursor?: FinancialForecastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialForecastScalarFieldEnum | FinancialForecastScalarFieldEnum[]
  }

  /**
   * Tenant.scenarios
   */
  export type Tenant$scenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    cursor?: ScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Tenant.scenarioAnalytics
   */
  export type Tenant$scenarioAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    where?: ScenarioAnalyticsWhereInput
    orderBy?: ScenarioAnalyticsOrderByWithRelationInput | ScenarioAnalyticsOrderByWithRelationInput[]
    cursor?: ScenarioAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioAnalyticsScalarFieldEnum | ScenarioAnalyticsScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model DashboardLayout
   */

  export type AggregateDashboardLayout = {
    _count: DashboardLayoutCountAggregateOutputType | null
    _min: DashboardLayoutMinAggregateOutputType | null
    _max: DashboardLayoutMaxAggregateOutputType | null
  }

  export type DashboardLayoutMinAggregateOutputType = {
    id: string | null
    userId: string | null
    role: $Enums.Role | null
    tenantId: string | null
    name: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardLayoutMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    role: $Enums.Role | null
    tenantId: string | null
    name: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardLayoutCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    tenantId: number
    name: number
    isDefault: number
    layout: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DashboardLayoutMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    tenantId?: true
    name?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardLayoutMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    tenantId?: true
    name?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardLayoutCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    tenantId?: true
    name?: true
    isDefault?: true
    layout?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DashboardLayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardLayout to aggregate.
     */
    where?: DashboardLayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardLayouts to fetch.
     */
    orderBy?: DashboardLayoutOrderByWithRelationInput | DashboardLayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardLayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardLayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardLayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardLayouts
    **/
    _count?: true | DashboardLayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardLayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardLayoutMaxAggregateInputType
  }

  export type GetDashboardLayoutAggregateType<T extends DashboardLayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardLayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardLayout[P]>
      : GetScalarType<T[P], AggregateDashboardLayout[P]>
  }




  export type DashboardLayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardLayoutWhereInput
    orderBy?: DashboardLayoutOrderByWithAggregationInput | DashboardLayoutOrderByWithAggregationInput[]
    by: DashboardLayoutScalarFieldEnum[] | DashboardLayoutScalarFieldEnum
    having?: DashboardLayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardLayoutCountAggregateInputType | true
    _min?: DashboardLayoutMinAggregateInputType
    _max?: DashboardLayoutMaxAggregateInputType
  }

  export type DashboardLayoutGroupByOutputType = {
    id: string
    userId: string | null
    role: $Enums.Role | null
    tenantId: string
    name: string
    isDefault: boolean
    layout: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DashboardLayoutCountAggregateOutputType | null
    _min: DashboardLayoutMinAggregateOutputType | null
    _max: DashboardLayoutMaxAggregateOutputType | null
  }

  type GetDashboardLayoutGroupByPayload<T extends DashboardLayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardLayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardLayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardLayoutGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardLayoutGroupByOutputType[P]>
        }
      >
    >


  export type DashboardLayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    tenantId?: boolean
    name?: boolean
    isDefault?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | DashboardLayout$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardLayout"]>

  export type DashboardLayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    tenantId?: boolean
    name?: boolean
    isDefault?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | DashboardLayout$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardLayout"]>

  export type DashboardLayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    tenantId?: boolean
    name?: boolean
    isDefault?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | DashboardLayout$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboardLayout"]>

  export type DashboardLayoutSelectScalar = {
    id?: boolean
    userId?: boolean
    role?: boolean
    tenantId?: boolean
    name?: boolean
    isDefault?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DashboardLayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "role" | "tenantId" | "name" | "isDefault" | "layout" | "createdAt" | "updatedAt", ExtArgs["result"]["dashboardLayout"]>
  export type DashboardLayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | DashboardLayout$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type DashboardLayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | DashboardLayout$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type DashboardLayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | DashboardLayout$userArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $DashboardLayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardLayout"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      role: $Enums.Role | null
      tenantId: string
      name: string
      isDefault: boolean
      layout: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dashboardLayout"]>
    composites: {}
  }

  type DashboardLayoutGetPayload<S extends boolean | null | undefined | DashboardLayoutDefaultArgs> = $Result.GetResult<Prisma.$DashboardLayoutPayload, S>

  type DashboardLayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardLayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardLayoutCountAggregateInputType | true
    }

  export interface DashboardLayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardLayout'], meta: { name: 'DashboardLayout' } }
    /**
     * Find zero or one DashboardLayout that matches the filter.
     * @param {DashboardLayoutFindUniqueArgs} args - Arguments to find a DashboardLayout
     * @example
     * // Get one DashboardLayout
     * const dashboardLayout = await prisma.dashboardLayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardLayoutFindUniqueArgs>(args: SelectSubset<T, DashboardLayoutFindUniqueArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardLayout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardLayoutFindUniqueOrThrowArgs} args - Arguments to find a DashboardLayout
     * @example
     * // Get one DashboardLayout
     * const dashboardLayout = await prisma.dashboardLayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardLayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardLayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardLayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardLayoutFindFirstArgs} args - Arguments to find a DashboardLayout
     * @example
     * // Get one DashboardLayout
     * const dashboardLayout = await prisma.dashboardLayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardLayoutFindFirstArgs>(args?: SelectSubset<T, DashboardLayoutFindFirstArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardLayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardLayoutFindFirstOrThrowArgs} args - Arguments to find a DashboardLayout
     * @example
     * // Get one DashboardLayout
     * const dashboardLayout = await prisma.dashboardLayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardLayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardLayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardLayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardLayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardLayouts
     * const dashboardLayouts = await prisma.dashboardLayout.findMany()
     * 
     * // Get first 10 DashboardLayouts
     * const dashboardLayouts = await prisma.dashboardLayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardLayoutWithIdOnly = await prisma.dashboardLayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardLayoutFindManyArgs>(args?: SelectSubset<T, DashboardLayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardLayout.
     * @param {DashboardLayoutCreateArgs} args - Arguments to create a DashboardLayout.
     * @example
     * // Create one DashboardLayout
     * const DashboardLayout = await prisma.dashboardLayout.create({
     *   data: {
     *     // ... data to create a DashboardLayout
     *   }
     * })
     * 
     */
    create<T extends DashboardLayoutCreateArgs>(args: SelectSubset<T, DashboardLayoutCreateArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardLayouts.
     * @param {DashboardLayoutCreateManyArgs} args - Arguments to create many DashboardLayouts.
     * @example
     * // Create many DashboardLayouts
     * const dashboardLayout = await prisma.dashboardLayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardLayoutCreateManyArgs>(args?: SelectSubset<T, DashboardLayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardLayouts and returns the data saved in the database.
     * @param {DashboardLayoutCreateManyAndReturnArgs} args - Arguments to create many DashboardLayouts.
     * @example
     * // Create many DashboardLayouts
     * const dashboardLayout = await prisma.dashboardLayout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardLayouts and only return the `id`
     * const dashboardLayoutWithIdOnly = await prisma.dashboardLayout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardLayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardLayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardLayout.
     * @param {DashboardLayoutDeleteArgs} args - Arguments to delete one DashboardLayout.
     * @example
     * // Delete one DashboardLayout
     * const DashboardLayout = await prisma.dashboardLayout.delete({
     *   where: {
     *     // ... filter to delete one DashboardLayout
     *   }
     * })
     * 
     */
    delete<T extends DashboardLayoutDeleteArgs>(args: SelectSubset<T, DashboardLayoutDeleteArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardLayout.
     * @param {DashboardLayoutUpdateArgs} args - Arguments to update one DashboardLayout.
     * @example
     * // Update one DashboardLayout
     * const dashboardLayout = await prisma.dashboardLayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardLayoutUpdateArgs>(args: SelectSubset<T, DashboardLayoutUpdateArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardLayouts.
     * @param {DashboardLayoutDeleteManyArgs} args - Arguments to filter DashboardLayouts to delete.
     * @example
     * // Delete a few DashboardLayouts
     * const { count } = await prisma.dashboardLayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardLayoutDeleteManyArgs>(args?: SelectSubset<T, DashboardLayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardLayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardLayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardLayouts
     * const dashboardLayout = await prisma.dashboardLayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardLayoutUpdateManyArgs>(args: SelectSubset<T, DashboardLayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardLayouts and returns the data updated in the database.
     * @param {DashboardLayoutUpdateManyAndReturnArgs} args - Arguments to update many DashboardLayouts.
     * @example
     * // Update many DashboardLayouts
     * const dashboardLayout = await prisma.dashboardLayout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DashboardLayouts and only return the `id`
     * const dashboardLayoutWithIdOnly = await prisma.dashboardLayout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardLayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardLayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DashboardLayout.
     * @param {DashboardLayoutUpsertArgs} args - Arguments to update or create a DashboardLayout.
     * @example
     * // Update or create a DashboardLayout
     * const dashboardLayout = await prisma.dashboardLayout.upsert({
     *   create: {
     *     // ... data to create a DashboardLayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardLayout we want to update
     *   }
     * })
     */
    upsert<T extends DashboardLayoutUpsertArgs>(args: SelectSubset<T, DashboardLayoutUpsertArgs<ExtArgs>>): Prisma__DashboardLayoutClient<$Result.GetResult<Prisma.$DashboardLayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardLayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardLayoutCountArgs} args - Arguments to filter DashboardLayouts to count.
     * @example
     * // Count the number of DashboardLayouts
     * const count = await prisma.dashboardLayout.count({
     *   where: {
     *     // ... the filter for the DashboardLayouts we want to count
     *   }
     * })
    **/
    count<T extends DashboardLayoutCountArgs>(
      args?: Subset<T, DashboardLayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardLayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardLayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardLayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardLayoutAggregateArgs>(args: Subset<T, DashboardLayoutAggregateArgs>): Prisma.PrismaPromise<GetDashboardLayoutAggregateType<T>>

    /**
     * Group by DashboardLayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardLayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardLayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardLayoutGroupByArgs['orderBy'] }
        : { orderBy?: DashboardLayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardLayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardLayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardLayout model
   */
  readonly fields: DashboardLayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardLayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardLayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends DashboardLayout$userArgs<ExtArgs> = {}>(args?: Subset<T, DashboardLayout$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardLayout model
   */
  interface DashboardLayoutFieldRefs {
    readonly id: FieldRef<"DashboardLayout", 'String'>
    readonly userId: FieldRef<"DashboardLayout", 'String'>
    readonly role: FieldRef<"DashboardLayout", 'Role'>
    readonly tenantId: FieldRef<"DashboardLayout", 'String'>
    readonly name: FieldRef<"DashboardLayout", 'String'>
    readonly isDefault: FieldRef<"DashboardLayout", 'Boolean'>
    readonly layout: FieldRef<"DashboardLayout", 'Json'>
    readonly createdAt: FieldRef<"DashboardLayout", 'DateTime'>
    readonly updatedAt: FieldRef<"DashboardLayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardLayout findUnique
   */
  export type DashboardLayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * Filter, which DashboardLayout to fetch.
     */
    where: DashboardLayoutWhereUniqueInput
  }

  /**
   * DashboardLayout findUniqueOrThrow
   */
  export type DashboardLayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * Filter, which DashboardLayout to fetch.
     */
    where: DashboardLayoutWhereUniqueInput
  }

  /**
   * DashboardLayout findFirst
   */
  export type DashboardLayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * Filter, which DashboardLayout to fetch.
     */
    where?: DashboardLayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardLayouts to fetch.
     */
    orderBy?: DashboardLayoutOrderByWithRelationInput | DashboardLayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardLayouts.
     */
    cursor?: DashboardLayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardLayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardLayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardLayouts.
     */
    distinct?: DashboardLayoutScalarFieldEnum | DashboardLayoutScalarFieldEnum[]
  }

  /**
   * DashboardLayout findFirstOrThrow
   */
  export type DashboardLayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * Filter, which DashboardLayout to fetch.
     */
    where?: DashboardLayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardLayouts to fetch.
     */
    orderBy?: DashboardLayoutOrderByWithRelationInput | DashboardLayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardLayouts.
     */
    cursor?: DashboardLayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardLayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardLayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardLayouts.
     */
    distinct?: DashboardLayoutScalarFieldEnum | DashboardLayoutScalarFieldEnum[]
  }

  /**
   * DashboardLayout findMany
   */
  export type DashboardLayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * Filter, which DashboardLayouts to fetch.
     */
    where?: DashboardLayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardLayouts to fetch.
     */
    orderBy?: DashboardLayoutOrderByWithRelationInput | DashboardLayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardLayouts.
     */
    cursor?: DashboardLayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardLayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardLayouts.
     */
    skip?: number
    distinct?: DashboardLayoutScalarFieldEnum | DashboardLayoutScalarFieldEnum[]
  }

  /**
   * DashboardLayout create
   */
  export type DashboardLayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a DashboardLayout.
     */
    data: XOR<DashboardLayoutCreateInput, DashboardLayoutUncheckedCreateInput>
  }

  /**
   * DashboardLayout createMany
   */
  export type DashboardLayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardLayouts.
     */
    data: DashboardLayoutCreateManyInput | DashboardLayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardLayout createManyAndReturn
   */
  export type DashboardLayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardLayouts.
     */
    data: DashboardLayoutCreateManyInput | DashboardLayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardLayout update
   */
  export type DashboardLayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a DashboardLayout.
     */
    data: XOR<DashboardLayoutUpdateInput, DashboardLayoutUncheckedUpdateInput>
    /**
     * Choose, which DashboardLayout to update.
     */
    where: DashboardLayoutWhereUniqueInput
  }

  /**
   * DashboardLayout updateMany
   */
  export type DashboardLayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardLayouts.
     */
    data: XOR<DashboardLayoutUpdateManyMutationInput, DashboardLayoutUncheckedUpdateManyInput>
    /**
     * Filter which DashboardLayouts to update
     */
    where?: DashboardLayoutWhereInput
    /**
     * Limit how many DashboardLayouts to update.
     */
    limit?: number
  }

  /**
   * DashboardLayout updateManyAndReturn
   */
  export type DashboardLayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * The data used to update DashboardLayouts.
     */
    data: XOR<DashboardLayoutUpdateManyMutationInput, DashboardLayoutUncheckedUpdateManyInput>
    /**
     * Filter which DashboardLayouts to update
     */
    where?: DashboardLayoutWhereInput
    /**
     * Limit how many DashboardLayouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DashboardLayout upsert
   */
  export type DashboardLayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the DashboardLayout to update in case it exists.
     */
    where: DashboardLayoutWhereUniqueInput
    /**
     * In case the DashboardLayout found by the `where` argument doesn't exist, create a new DashboardLayout with this data.
     */
    create: XOR<DashboardLayoutCreateInput, DashboardLayoutUncheckedCreateInput>
    /**
     * In case the DashboardLayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardLayoutUpdateInput, DashboardLayoutUncheckedUpdateInput>
  }

  /**
   * DashboardLayout delete
   */
  export type DashboardLayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
    /**
     * Filter which DashboardLayout to delete.
     */
    where: DashboardLayoutWhereUniqueInput
  }

  /**
   * DashboardLayout deleteMany
   */
  export type DashboardLayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardLayouts to delete
     */
    where?: DashboardLayoutWhereInput
    /**
     * Limit how many DashboardLayouts to delete.
     */
    limit?: number
  }

  /**
   * DashboardLayout.user
   */
  export type DashboardLayout$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DashboardLayout without action
   */
  export type DashboardLayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardLayout
     */
    select?: DashboardLayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardLayout
     */
    omit?: DashboardLayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardLayoutInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    allowed: boolean | null
    reason: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    allowed: boolean | null
    reason: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    action: number
    resource: number
    resourceId: number
    allowed: number
    reason: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    allowed?: true
    reason?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    allowed?: true
    reason?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    allowed?: true
    reason?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    action: string
    resource: string | null
    resourceId: string | null
    allowed: boolean
    reason: string | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    allowed?: boolean
    reason?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    allowed?: boolean
    reason?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    allowed?: boolean
    reason?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    allowed?: boolean
    reason?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "action" | "resource" | "resourceId" | "allowed" | "reason" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      action: string
      resource: string | null
      resourceId: string | null
      allowed: boolean
      reason: string | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly allowed: FieldRef<"AuditLog", 'Boolean'>
    readonly reason: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: string | null
    featureFlag: string | null
    featureName: string | null
    userId: string | null
    userRole: $Enums.Role | null
    tenantId: string | null
    sessionId: string | null
    timestamp: Date | null
    serverTimestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: string | null
    featureFlag: string | null
    featureName: string | null
    userId: string | null
    userRole: $Enums.Role | null
    tenantId: string | null
    sessionId: string | null
    timestamp: Date | null
    serverTimestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    eventId: number
    eventType: number
    featureFlag: number
    featureName: number
    userId: number
    userRole: number
    tenantId: number
    sessionId: number
    metadata: number
    timestamp: number
    serverTimestamp: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    featureFlag?: true
    featureName?: true
    userId?: true
    userRole?: true
    tenantId?: true
    sessionId?: true
    timestamp?: true
    serverTimestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    featureFlag?: true
    featureName?: true
    userId?: true
    userRole?: true
    tenantId?: true
    sessionId?: true
    timestamp?: true
    serverTimestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    featureFlag?: true
    featureName?: true
    userId?: true
    userRole?: true
    tenantId?: true
    sessionId?: true
    metadata?: true
    timestamp?: true
    serverTimestamp?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    eventId: string
    eventType: string
    featureFlag: string
    featureName: string
    userId: string
    userRole: $Enums.Role
    tenantId: string
    sessionId: string
    metadata: JsonValue | null
    timestamp: Date
    serverTimestamp: Date
    ipAddress: string | null
    userAgent: string | null
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    featureFlag?: boolean
    featureName?: boolean
    userId?: boolean
    userRole?: boolean
    tenantId?: boolean
    sessionId?: boolean
    metadata?: boolean
    timestamp?: boolean
    serverTimestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    featureFlag?: boolean
    featureName?: boolean
    userId?: boolean
    userRole?: boolean
    tenantId?: boolean
    sessionId?: boolean
    metadata?: boolean
    timestamp?: boolean
    serverTimestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    featureFlag?: boolean
    featureName?: boolean
    userId?: boolean
    userRole?: boolean
    tenantId?: boolean
    sessionId?: boolean
    metadata?: boolean
    timestamp?: boolean
    serverTimestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    featureFlag?: boolean
    featureName?: boolean
    userId?: boolean
    userRole?: boolean
    tenantId?: boolean
    sessionId?: boolean
    metadata?: boolean
    timestamp?: boolean
    serverTimestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type AnalyticsEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "eventType" | "featureFlag" | "featureName" | "userId" | "userRole" | "tenantId" | "sessionId" | "metadata" | "timestamp" | "serverTimestamp" | "ipAddress" | "userAgent", ExtArgs["result"]["analyticsEvent"]>
  export type AnalyticsEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AnalyticsEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AnalyticsEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      eventType: string
      featureFlag: string
      featureName: string
      userId: string
      userRole: $Enums.Role
      tenantId: string
      sessionId: string
      metadata: Prisma.JsonValue | null
      timestamp: Date
      serverTimestamp: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents and returns the data updated in the database.
     * @param {AnalyticsEventUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsEvents.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventId: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventType: FieldRef<"AnalyticsEvent", 'String'>
    readonly featureFlag: FieldRef<"AnalyticsEvent", 'String'>
    readonly featureName: FieldRef<"AnalyticsEvent", 'String'>
    readonly userId: FieldRef<"AnalyticsEvent", 'String'>
    readonly userRole: FieldRef<"AnalyticsEvent", 'Role'>
    readonly tenantId: FieldRef<"AnalyticsEvent", 'String'>
    readonly sessionId: FieldRef<"AnalyticsEvent", 'String'>
    readonly metadata: FieldRef<"AnalyticsEvent", 'Json'>
    readonly timestamp: FieldRef<"AnalyticsEvent", 'DateTime'>
    readonly serverTimestamp: FieldRef<"AnalyticsEvent", 'DateTime'>
    readonly ipAddress: FieldRef<"AnalyticsEvent", 'String'>
    readonly userAgent: FieldRef<"AnalyticsEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent updateManyAndReturn
   */
  export type AnalyticsEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
  }


  /**
   * Model AutomationRule
   */

  export type AggregateAutomationRule = {
    _count: AutomationRuleCountAggregateOutputType | null
    _avg: AutomationRuleAvgAggregateOutputType | null
    _sum: AutomationRuleSumAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  export type AutomationRuleAvgAggregateOutputType = {
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
  }

  export type AutomationRuleSumAggregateOutputType = {
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
  }

  export type AutomationRuleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    triggerType: $Enums.AutomationTriggerType | null
    status: $Enums.AutomationStatus | null
    isTemplate: boolean | null
    requiresApproval: boolean | null
    createdBy: string | null
    updatedBy: string | null
    lastTriggered: Date | null
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationRuleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    triggerType: $Enums.AutomationTriggerType | null
    status: $Enums.AutomationStatus | null
    isTemplate: boolean | null
    requiresApproval: boolean | null
    createdBy: string | null
    updatedBy: string | null
    lastTriggered: Date | null
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationRuleCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    triggerType: number
    triggerConfig: number
    conditions: number
    actions: number
    status: number
    isTemplate: number
    requiresApproval: number
    createdBy: number
    updatedBy: number
    lastTriggered: number
    executionCount: number
    successCount: number
    failureCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationRuleAvgAggregateInputType = {
    executionCount?: true
    successCount?: true
    failureCount?: true
  }

  export type AutomationRuleSumAggregateInputType = {
    executionCount?: true
    successCount?: true
    failureCount?: true
  }

  export type AutomationRuleMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    triggerType?: true
    status?: true
    isTemplate?: true
    requiresApproval?: true
    createdBy?: true
    updatedBy?: true
    lastTriggered?: true
    executionCount?: true
    successCount?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationRuleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    triggerType?: true
    status?: true
    isTemplate?: true
    requiresApproval?: true
    createdBy?: true
    updatedBy?: true
    lastTriggered?: true
    executionCount?: true
    successCount?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationRuleCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    triggerType?: true
    triggerConfig?: true
    conditions?: true
    actions?: true
    status?: true
    isTemplate?: true
    requiresApproval?: true
    createdBy?: true
    updatedBy?: true
    lastTriggered?: true
    executionCount?: true
    successCount?: true
    failureCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRule to aggregate.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationRules
    **/
    _count?: true | AutomationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type GetAutomationRuleAggregateType<T extends AutomationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationRule[P]>
      : GetScalarType<T[P], AggregateAutomationRule[P]>
  }




  export type AutomationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithAggregationInput | AutomationRuleOrderByWithAggregationInput[]
    by: AutomationRuleScalarFieldEnum[] | AutomationRuleScalarFieldEnum
    having?: AutomationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationRuleCountAggregateInputType | true
    _avg?: AutomationRuleAvgAggregateInputType
    _sum?: AutomationRuleSumAggregateInputType
    _min?: AutomationRuleMinAggregateInputType
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type AutomationRuleGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonValue
    conditions: JsonValue
    actions: JsonValue
    status: $Enums.AutomationStatus
    isTemplate: boolean
    requiresApproval: boolean
    createdBy: string
    updatedBy: string | null
    lastTriggered: Date | null
    executionCount: number
    successCount: number
    failureCount: number
    createdAt: Date
    updatedAt: Date
    _count: AutomationRuleCountAggregateOutputType | null
    _avg: AutomationRuleAvgAggregateOutputType | null
    _sum: AutomationRuleSumAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  type GetAutomationRuleGroupByPayload<T extends AutomationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
        }
      >
    >


  export type AutomationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    status?: boolean
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    lastTriggered?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    executions?: boolean | AutomationRule$executionsArgs<ExtArgs>
    _count?: boolean | AutomationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    status?: boolean
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    lastTriggered?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    status?: boolean
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    lastTriggered?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationRule"]>

  export type AutomationRuleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    status?: boolean
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    lastTriggered?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutomationRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "triggerType" | "triggerConfig" | "conditions" | "actions" | "status" | "isTemplate" | "requiresApproval" | "createdBy" | "updatedBy" | "lastTriggered" | "executionCount" | "successCount" | "failureCount" | "createdAt" | "updatedAt", ExtArgs["result"]["automationRule"]>
  export type AutomationRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    executions?: boolean | AutomationRule$executionsArgs<ExtArgs>
    _count?: boolean | AutomationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AutomationRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AutomationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationRule"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      executions: Prisma.$AutomationExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      triggerType: $Enums.AutomationTriggerType
      triggerConfig: Prisma.JsonValue
      conditions: Prisma.JsonValue
      actions: Prisma.JsonValue
      status: $Enums.AutomationStatus
      isTemplate: boolean
      requiresApproval: boolean
      createdBy: string
      updatedBy: string | null
      lastTriggered: Date | null
      executionCount: number
      successCount: number
      failureCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automationRule"]>
    composites: {}
  }

  type AutomationRuleGetPayload<S extends boolean | null | undefined | AutomationRuleDefaultArgs> = $Result.GetResult<Prisma.$AutomationRulePayload, S>

  type AutomationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationRuleCountAggregateInputType | true
    }

  export interface AutomationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationRule'], meta: { name: 'AutomationRule' } }
    /**
     * Find zero or one AutomationRule that matches the filter.
     * @param {AutomationRuleFindUniqueArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationRuleFindUniqueArgs>(args: SelectSubset<T, AutomationRuleFindUniqueArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationRuleFindUniqueOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationRuleFindFirstArgs>(args?: SelectSubset<T, AutomationRuleFindFirstArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationRules
     * const automationRules = await prisma.automationRule.findMany()
     * 
     * // Get first 10 AutomationRules
     * const automationRules = await prisma.automationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationRuleFindManyArgs>(args?: SelectSubset<T, AutomationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationRule.
     * @param {AutomationRuleCreateArgs} args - Arguments to create a AutomationRule.
     * @example
     * // Create one AutomationRule
     * const AutomationRule = await prisma.automationRule.create({
     *   data: {
     *     // ... data to create a AutomationRule
     *   }
     * })
     * 
     */
    create<T extends AutomationRuleCreateArgs>(args: SelectSubset<T, AutomationRuleCreateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationRules.
     * @param {AutomationRuleCreateManyArgs} args - Arguments to create many AutomationRules.
     * @example
     * // Create many AutomationRules
     * const automationRule = await prisma.automationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationRuleCreateManyArgs>(args?: SelectSubset<T, AutomationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationRules and returns the data saved in the database.
     * @param {AutomationRuleCreateManyAndReturnArgs} args - Arguments to create many AutomationRules.
     * @example
     * // Create many AutomationRules
     * const automationRule = await prisma.automationRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationRules and only return the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationRule.
     * @param {AutomationRuleDeleteArgs} args - Arguments to delete one AutomationRule.
     * @example
     * // Delete one AutomationRule
     * const AutomationRule = await prisma.automationRule.delete({
     *   where: {
     *     // ... filter to delete one AutomationRule
     *   }
     * })
     * 
     */
    delete<T extends AutomationRuleDeleteArgs>(args: SelectSubset<T, AutomationRuleDeleteArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationRule.
     * @param {AutomationRuleUpdateArgs} args - Arguments to update one AutomationRule.
     * @example
     * // Update one AutomationRule
     * const automationRule = await prisma.automationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationRuleUpdateArgs>(args: SelectSubset<T, AutomationRuleUpdateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationRules.
     * @param {AutomationRuleDeleteManyArgs} args - Arguments to filter AutomationRules to delete.
     * @example
     * // Delete a few AutomationRules
     * const { count } = await prisma.automationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationRuleDeleteManyArgs>(args?: SelectSubset<T, AutomationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationRules
     * const automationRule = await prisma.automationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationRuleUpdateManyArgs>(args: SelectSubset<T, AutomationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationRules and returns the data updated in the database.
     * @param {AutomationRuleUpdateManyAndReturnArgs} args - Arguments to update many AutomationRules.
     * @example
     * // Update many AutomationRules
     * const automationRule = await prisma.automationRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationRules and only return the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationRule.
     * @param {AutomationRuleUpsertArgs} args - Arguments to update or create a AutomationRule.
     * @example
     * // Update or create a AutomationRule
     * const automationRule = await prisma.automationRule.upsert({
     *   create: {
     *     // ... data to create a AutomationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationRule we want to update
     *   }
     * })
     */
    upsert<T extends AutomationRuleUpsertArgs>(args: SelectSubset<T, AutomationRuleUpsertArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleCountArgs} args - Arguments to filter AutomationRules to count.
     * @example
     * // Count the number of AutomationRules
     * const count = await prisma.automationRule.count({
     *   where: {
     *     // ... the filter for the AutomationRules we want to count
     *   }
     * })
    **/
    count<T extends AutomationRuleCountArgs>(
      args?: Subset<T, AutomationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationRuleAggregateArgs>(args: Subset<T, AutomationRuleAggregateArgs>): Prisma.PrismaPromise<GetAutomationRuleAggregateType<T>>

    /**
     * Group by AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationRuleGroupByArgs['orderBy'] }
        : { orderBy?: AutomationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationRule model
   */
  readonly fields: AutomationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executions<T extends AutomationRule$executionsArgs<ExtArgs> = {}>(args?: Subset<T, AutomationRule$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationRule model
   */
  interface AutomationRuleFieldRefs {
    readonly id: FieldRef<"AutomationRule", 'String'>
    readonly tenantId: FieldRef<"AutomationRule", 'String'>
    readonly name: FieldRef<"AutomationRule", 'String'>
    readonly description: FieldRef<"AutomationRule", 'String'>
    readonly triggerType: FieldRef<"AutomationRule", 'AutomationTriggerType'>
    readonly triggerConfig: FieldRef<"AutomationRule", 'Json'>
    readonly conditions: FieldRef<"AutomationRule", 'Json'>
    readonly actions: FieldRef<"AutomationRule", 'Json'>
    readonly status: FieldRef<"AutomationRule", 'AutomationStatus'>
    readonly isTemplate: FieldRef<"AutomationRule", 'Boolean'>
    readonly requiresApproval: FieldRef<"AutomationRule", 'Boolean'>
    readonly createdBy: FieldRef<"AutomationRule", 'String'>
    readonly updatedBy: FieldRef<"AutomationRule", 'String'>
    readonly lastTriggered: FieldRef<"AutomationRule", 'DateTime'>
    readonly executionCount: FieldRef<"AutomationRule", 'Int'>
    readonly successCount: FieldRef<"AutomationRule", 'Int'>
    readonly failureCount: FieldRef<"AutomationRule", 'Int'>
    readonly createdAt: FieldRef<"AutomationRule", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationRule findUnique
   */
  export type AutomationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findUniqueOrThrow
   */
  export type AutomationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findFirst
   */
  export type AutomationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findFirstOrThrow
   */
  export type AutomationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findMany
   */
  export type AutomationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRules to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule create
   */
  export type AutomationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationRule.
     */
    data: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
  }

  /**
   * AutomationRule createMany
   */
  export type AutomationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationRules.
     */
    data: AutomationRuleCreateManyInput | AutomationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationRule createManyAndReturn
   */
  export type AutomationRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationRules.
     */
    data: AutomationRuleCreateManyInput | AutomationRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationRule update
   */
  export type AutomationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationRule.
     */
    data: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
    /**
     * Choose, which AutomationRule to update.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule updateMany
   */
  export type AutomationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationRules.
     */
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutomationRules to update
     */
    where?: AutomationRuleWhereInput
    /**
     * Limit how many AutomationRules to update.
     */
    limit?: number
  }

  /**
   * AutomationRule updateManyAndReturn
   */
  export type AutomationRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * The data used to update AutomationRules.
     */
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutomationRules to update
     */
    where?: AutomationRuleWhereInput
    /**
     * Limit how many AutomationRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationRule upsert
   */
  export type AutomationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationRule to update in case it exists.
     */
    where: AutomationRuleWhereUniqueInput
    /**
     * In case the AutomationRule found by the `where` argument doesn't exist, create a new AutomationRule with this data.
     */
    create: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
    /**
     * In case the AutomationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
  }

  /**
   * AutomationRule delete
   */
  export type AutomationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter which AutomationRule to delete.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule deleteMany
   */
  export type AutomationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRules to delete
     */
    where?: AutomationRuleWhereInput
    /**
     * Limit how many AutomationRules to delete.
     */
    limit?: number
  }

  /**
   * AutomationRule.executions
   */
  export type AutomationRule$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    where?: AutomationExecutionWhereInput
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    cursor?: AutomationExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationRule without action
   */
  export type AutomationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationRule
     */
    omit?: AutomationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
  }


  /**
   * Model AutomationExecution
   */

  export type AggregateAutomationExecution = {
    _count: AutomationExecutionCountAggregateOutputType | null
    _avg: AutomationExecutionAvgAggregateOutputType | null
    _sum: AutomationExecutionSumAggregateOutputType | null
    _min: AutomationExecutionMinAggregateOutputType | null
    _max: AutomationExecutionMaxAggregateOutputType | null
  }

  export type AutomationExecutionAvgAggregateOutputType = {
    executionTime: number | null
    retryCount: number | null
  }

  export type AutomationExecutionSumAggregateOutputType = {
    executionTime: number | null
    retryCount: number | null
  }

  export type AutomationExecutionMinAggregateOutputType = {
    id: string | null
    ruleId: string | null
    tenantId: string | null
    status: $Enums.AutomationExecutionStatus | null
    triggeredBy: string | null
    conditionsMet: boolean | null
    isDryRun: boolean | null
    errorMessage: string | null
    executionTime: number | null
    retryCount: number | null
    nextRetryAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type AutomationExecutionMaxAggregateOutputType = {
    id: string | null
    ruleId: string | null
    tenantId: string | null
    status: $Enums.AutomationExecutionStatus | null
    triggeredBy: string | null
    conditionsMet: boolean | null
    isDryRun: boolean | null
    errorMessage: string | null
    executionTime: number | null
    retryCount: number | null
    nextRetryAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type AutomationExecutionCountAggregateOutputType = {
    id: number
    ruleId: number
    tenantId: number
    status: number
    triggeredBy: number
    triggerData: number
    conditionsEvaluated: number
    conditionsMet: number
    actionsExecuted: number
    isDryRun: number
    errorMessage: number
    executionTime: number
    retryCount: number
    nextRetryAt: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type AutomationExecutionAvgAggregateInputType = {
    executionTime?: true
    retryCount?: true
  }

  export type AutomationExecutionSumAggregateInputType = {
    executionTime?: true
    retryCount?: true
  }

  export type AutomationExecutionMinAggregateInputType = {
    id?: true
    ruleId?: true
    tenantId?: true
    status?: true
    triggeredBy?: true
    conditionsMet?: true
    isDryRun?: true
    errorMessage?: true
    executionTime?: true
    retryCount?: true
    nextRetryAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type AutomationExecutionMaxAggregateInputType = {
    id?: true
    ruleId?: true
    tenantId?: true
    status?: true
    triggeredBy?: true
    conditionsMet?: true
    isDryRun?: true
    errorMessage?: true
    executionTime?: true
    retryCount?: true
    nextRetryAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type AutomationExecutionCountAggregateInputType = {
    id?: true
    ruleId?: true
    tenantId?: true
    status?: true
    triggeredBy?: true
    triggerData?: true
    conditionsEvaluated?: true
    conditionsMet?: true
    actionsExecuted?: true
    isDryRun?: true
    errorMessage?: true
    executionTime?: true
    retryCount?: true
    nextRetryAt?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AutomationExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationExecution to aggregate.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationExecutions
    **/
    _count?: true | AutomationExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationExecutionMaxAggregateInputType
  }

  export type GetAutomationExecutionAggregateType<T extends AutomationExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationExecution[P]>
      : GetScalarType<T[P], AggregateAutomationExecution[P]>
  }




  export type AutomationExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationExecutionWhereInput
    orderBy?: AutomationExecutionOrderByWithAggregationInput | AutomationExecutionOrderByWithAggregationInput[]
    by: AutomationExecutionScalarFieldEnum[] | AutomationExecutionScalarFieldEnum
    having?: AutomationExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationExecutionCountAggregateInputType | true
    _avg?: AutomationExecutionAvgAggregateInputType
    _sum?: AutomationExecutionSumAggregateInputType
    _min?: AutomationExecutionMinAggregateInputType
    _max?: AutomationExecutionMaxAggregateInputType
  }

  export type AutomationExecutionGroupByOutputType = {
    id: string
    ruleId: string
    tenantId: string
    status: $Enums.AutomationExecutionStatus
    triggeredBy: string | null
    triggerData: JsonValue
    conditionsEvaluated: JsonValue
    conditionsMet: boolean
    actionsExecuted: JsonValue
    isDryRun: boolean
    errorMessage: string | null
    executionTime: number | null
    retryCount: number
    nextRetryAt: Date | null
    completedAt: Date | null
    createdAt: Date
    _count: AutomationExecutionCountAggregateOutputType | null
    _avg: AutomationExecutionAvgAggregateOutputType | null
    _sum: AutomationExecutionSumAggregateOutputType | null
    _min: AutomationExecutionMinAggregateOutputType | null
    _max: AutomationExecutionMaxAggregateOutputType | null
  }

  type GetAutomationExecutionGroupByPayload<T extends AutomationExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationExecutionGroupByOutputType[P]>
        }
      >
    >


  export type AutomationExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggeredBy?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    conditionsMet?: boolean
    actionsExecuted?: boolean
    isDryRun?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationExecution"]>

  export type AutomationExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggeredBy?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    conditionsMet?: boolean
    actionsExecuted?: boolean
    isDryRun?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationExecution"]>

  export type AutomationExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggeredBy?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    conditionsMet?: boolean
    actionsExecuted?: boolean
    isDryRun?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationExecution"]>

  export type AutomationExecutionSelectScalar = {
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggeredBy?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    conditionsMet?: boolean
    actionsExecuted?: boolean
    isDryRun?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type AutomationExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ruleId" | "tenantId" | "status" | "triggeredBy" | "triggerData" | "conditionsEvaluated" | "conditionsMet" | "actionsExecuted" | "isDryRun" | "errorMessage" | "executionTime" | "retryCount" | "nextRetryAt" | "completedAt" | "createdAt", ExtArgs["result"]["automationExecution"]>
  export type AutomationExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AutomationExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AutomationExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | AutomationRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AutomationExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationExecution"
    objects: {
      rule: Prisma.$AutomationRulePayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ruleId: string
      tenantId: string
      status: $Enums.AutomationExecutionStatus
      triggeredBy: string | null
      triggerData: Prisma.JsonValue
      conditionsEvaluated: Prisma.JsonValue
      conditionsMet: boolean
      actionsExecuted: Prisma.JsonValue
      isDryRun: boolean
      errorMessage: string | null
      executionTime: number | null
      retryCount: number
      nextRetryAt: Date | null
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["automationExecution"]>
    composites: {}
  }

  type AutomationExecutionGetPayload<S extends boolean | null | undefined | AutomationExecutionDefaultArgs> = $Result.GetResult<Prisma.$AutomationExecutionPayload, S>

  type AutomationExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationExecutionCountAggregateInputType | true
    }

  export interface AutomationExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationExecution'], meta: { name: 'AutomationExecution' } }
    /**
     * Find zero or one AutomationExecution that matches the filter.
     * @param {AutomationExecutionFindUniqueArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationExecutionFindUniqueArgs>(args: SelectSubset<T, AutomationExecutionFindUniqueArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationExecutionFindUniqueOrThrowArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindFirstArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationExecutionFindFirstArgs>(args?: SelectSubset<T, AutomationExecutionFindFirstArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindFirstOrThrowArgs} args - Arguments to find a AutomationExecution
     * @example
     * // Get one AutomationExecution
     * const automationExecution = await prisma.automationExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationExecutions
     * const automationExecutions = await prisma.automationExecution.findMany()
     * 
     * // Get first 10 AutomationExecutions
     * const automationExecutions = await prisma.automationExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationExecutionWithIdOnly = await prisma.automationExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationExecutionFindManyArgs>(args?: SelectSubset<T, AutomationExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationExecution.
     * @param {AutomationExecutionCreateArgs} args - Arguments to create a AutomationExecution.
     * @example
     * // Create one AutomationExecution
     * const AutomationExecution = await prisma.automationExecution.create({
     *   data: {
     *     // ... data to create a AutomationExecution
     *   }
     * })
     * 
     */
    create<T extends AutomationExecutionCreateArgs>(args: SelectSubset<T, AutomationExecutionCreateArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationExecutions.
     * @param {AutomationExecutionCreateManyArgs} args - Arguments to create many AutomationExecutions.
     * @example
     * // Create many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationExecutionCreateManyArgs>(args?: SelectSubset<T, AutomationExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationExecutions and returns the data saved in the database.
     * @param {AutomationExecutionCreateManyAndReturnArgs} args - Arguments to create many AutomationExecutions.
     * @example
     * // Create many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationExecutions and only return the `id`
     * const automationExecutionWithIdOnly = await prisma.automationExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationExecution.
     * @param {AutomationExecutionDeleteArgs} args - Arguments to delete one AutomationExecution.
     * @example
     * // Delete one AutomationExecution
     * const AutomationExecution = await prisma.automationExecution.delete({
     *   where: {
     *     // ... filter to delete one AutomationExecution
     *   }
     * })
     * 
     */
    delete<T extends AutomationExecutionDeleteArgs>(args: SelectSubset<T, AutomationExecutionDeleteArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationExecution.
     * @param {AutomationExecutionUpdateArgs} args - Arguments to update one AutomationExecution.
     * @example
     * // Update one AutomationExecution
     * const automationExecution = await prisma.automationExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationExecutionUpdateArgs>(args: SelectSubset<T, AutomationExecutionUpdateArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationExecutions.
     * @param {AutomationExecutionDeleteManyArgs} args - Arguments to filter AutomationExecutions to delete.
     * @example
     * // Delete a few AutomationExecutions
     * const { count } = await prisma.automationExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationExecutionDeleteManyArgs>(args?: SelectSubset<T, AutomationExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationExecutionUpdateManyArgs>(args: SelectSubset<T, AutomationExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationExecutions and returns the data updated in the database.
     * @param {AutomationExecutionUpdateManyAndReturnArgs} args - Arguments to update many AutomationExecutions.
     * @example
     * // Update many AutomationExecutions
     * const automationExecution = await prisma.automationExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationExecutions and only return the `id`
     * const automationExecutionWithIdOnly = await prisma.automationExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationExecution.
     * @param {AutomationExecutionUpsertArgs} args - Arguments to update or create a AutomationExecution.
     * @example
     * // Update or create a AutomationExecution
     * const automationExecution = await prisma.automationExecution.upsert({
     *   create: {
     *     // ... data to create a AutomationExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationExecution we want to update
     *   }
     * })
     */
    upsert<T extends AutomationExecutionUpsertArgs>(args: SelectSubset<T, AutomationExecutionUpsertArgs<ExtArgs>>): Prisma__AutomationExecutionClient<$Result.GetResult<Prisma.$AutomationExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionCountArgs} args - Arguments to filter AutomationExecutions to count.
     * @example
     * // Count the number of AutomationExecutions
     * const count = await prisma.automationExecution.count({
     *   where: {
     *     // ... the filter for the AutomationExecutions we want to count
     *   }
     * })
    **/
    count<T extends AutomationExecutionCountArgs>(
      args?: Subset<T, AutomationExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationExecutionAggregateArgs>(args: Subset<T, AutomationExecutionAggregateArgs>): Prisma.PrismaPromise<GetAutomationExecutionAggregateType<T>>

    /**
     * Group by AutomationExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationExecutionGroupByArgs['orderBy'] }
        : { orderBy?: AutomationExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationExecution model
   */
  readonly fields: AutomationExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rule<T extends AutomationRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationRuleDefaultArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationExecution model
   */
  interface AutomationExecutionFieldRefs {
    readonly id: FieldRef<"AutomationExecution", 'String'>
    readonly ruleId: FieldRef<"AutomationExecution", 'String'>
    readonly tenantId: FieldRef<"AutomationExecution", 'String'>
    readonly status: FieldRef<"AutomationExecution", 'AutomationExecutionStatus'>
    readonly triggeredBy: FieldRef<"AutomationExecution", 'String'>
    readonly triggerData: FieldRef<"AutomationExecution", 'Json'>
    readonly conditionsEvaluated: FieldRef<"AutomationExecution", 'Json'>
    readonly conditionsMet: FieldRef<"AutomationExecution", 'Boolean'>
    readonly actionsExecuted: FieldRef<"AutomationExecution", 'Json'>
    readonly isDryRun: FieldRef<"AutomationExecution", 'Boolean'>
    readonly errorMessage: FieldRef<"AutomationExecution", 'String'>
    readonly executionTime: FieldRef<"AutomationExecution", 'Int'>
    readonly retryCount: FieldRef<"AutomationExecution", 'Int'>
    readonly nextRetryAt: FieldRef<"AutomationExecution", 'DateTime'>
    readonly completedAt: FieldRef<"AutomationExecution", 'DateTime'>
    readonly createdAt: FieldRef<"AutomationExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationExecution findUnique
   */
  export type AutomationExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution findUniqueOrThrow
   */
  export type AutomationExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution findFirst
   */
  export type AutomationExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationExecutions.
     */
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution findFirstOrThrow
   */
  export type AutomationExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecution to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationExecutions.
     */
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution findMany
   */
  export type AutomationExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter, which AutomationExecutions to fetch.
     */
    where?: AutomationExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationExecutions to fetch.
     */
    orderBy?: AutomationExecutionOrderByWithRelationInput | AutomationExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationExecutions.
     */
    cursor?: AutomationExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationExecutions.
     */
    skip?: number
    distinct?: AutomationExecutionScalarFieldEnum | AutomationExecutionScalarFieldEnum[]
  }

  /**
   * AutomationExecution create
   */
  export type AutomationExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationExecution.
     */
    data: XOR<AutomationExecutionCreateInput, AutomationExecutionUncheckedCreateInput>
  }

  /**
   * AutomationExecution createMany
   */
  export type AutomationExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationExecutions.
     */
    data: AutomationExecutionCreateManyInput | AutomationExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationExecution createManyAndReturn
   */
  export type AutomationExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationExecutions.
     */
    data: AutomationExecutionCreateManyInput | AutomationExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationExecution update
   */
  export type AutomationExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationExecution.
     */
    data: XOR<AutomationExecutionUpdateInput, AutomationExecutionUncheckedUpdateInput>
    /**
     * Choose, which AutomationExecution to update.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution updateMany
   */
  export type AutomationExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationExecutions.
     */
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyInput>
    /**
     * Filter which AutomationExecutions to update
     */
    where?: AutomationExecutionWhereInput
    /**
     * Limit how many AutomationExecutions to update.
     */
    limit?: number
  }

  /**
   * AutomationExecution updateManyAndReturn
   */
  export type AutomationExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * The data used to update AutomationExecutions.
     */
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyInput>
    /**
     * Filter which AutomationExecutions to update
     */
    where?: AutomationExecutionWhereInput
    /**
     * Limit how many AutomationExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationExecution upsert
   */
  export type AutomationExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationExecution to update in case it exists.
     */
    where: AutomationExecutionWhereUniqueInput
    /**
     * In case the AutomationExecution found by the `where` argument doesn't exist, create a new AutomationExecution with this data.
     */
    create: XOR<AutomationExecutionCreateInput, AutomationExecutionUncheckedCreateInput>
    /**
     * In case the AutomationExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationExecutionUpdateInput, AutomationExecutionUncheckedUpdateInput>
  }

  /**
   * AutomationExecution delete
   */
  export type AutomationExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
    /**
     * Filter which AutomationExecution to delete.
     */
    where: AutomationExecutionWhereUniqueInput
  }

  /**
   * AutomationExecution deleteMany
   */
  export type AutomationExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationExecutions to delete
     */
    where?: AutomationExecutionWhereInput
    /**
     * Limit how many AutomationExecutions to delete.
     */
    limit?: number
  }

  /**
   * AutomationExecution without action
   */
  export type AutomationExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationExecution
     */
    select?: AutomationExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationExecution
     */
    omit?: AutomationExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationExecutionInclude<ExtArgs> | null
  }


  /**
   * Model SmartInsight
   */

  export type AggregateSmartInsight = {
    _count: SmartInsightCountAggregateOutputType | null
    _avg: SmartInsightAvgAggregateOutputType | null
    _sum: SmartInsightSumAggregateOutputType | null
    _min: SmartInsightMinAggregateOutputType | null
    _max: SmartInsightMaxAggregateOutputType | null
  }

  export type SmartInsightAvgAggregateOutputType = {
    confidence: number | null
  }

  export type SmartInsightSumAggregateOutputType = {
    confidence: number | null
  }

  export type SmartInsightMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    insightType: $Enums.InsightType | null
    severity: $Enums.InsightSeverity | null
    title: string | null
    description: string | null
    explanation: string | null
    confidence: number | null
    actionable: boolean | null
    dismissedBy: string | null
    dismissedAt: Date | null
    dismissReason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SmartInsightMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    insightType: $Enums.InsightType | null
    severity: $Enums.InsightSeverity | null
    title: string | null
    description: string | null
    explanation: string | null
    confidence: number | null
    actionable: boolean | null
    dismissedBy: string | null
    dismissedAt: Date | null
    dismissReason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SmartInsightCountAggregateOutputType = {
    id: number
    tenantId: number
    insightType: number
    severity: number
    title: number
    description: number
    explanation: number
    confidence: number
    metadata: number
    relatedEntities: number
    actionable: number
    suggestedActions: number
    dismissedBy: number
    dismissedAt: number
    dismissReason: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type SmartInsightAvgAggregateInputType = {
    confidence?: true
  }

  export type SmartInsightSumAggregateInputType = {
    confidence?: true
  }

  export type SmartInsightMinAggregateInputType = {
    id?: true
    tenantId?: true
    insightType?: true
    severity?: true
    title?: true
    description?: true
    explanation?: true
    confidence?: true
    actionable?: true
    dismissedBy?: true
    dismissedAt?: true
    dismissReason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SmartInsightMaxAggregateInputType = {
    id?: true
    tenantId?: true
    insightType?: true
    severity?: true
    title?: true
    description?: true
    explanation?: true
    confidence?: true
    actionable?: true
    dismissedBy?: true
    dismissedAt?: true
    dismissReason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SmartInsightCountAggregateInputType = {
    id?: true
    tenantId?: true
    insightType?: true
    severity?: true
    title?: true
    description?: true
    explanation?: true
    confidence?: true
    metadata?: true
    relatedEntities?: true
    actionable?: true
    suggestedActions?: true
    dismissedBy?: true
    dismissedAt?: true
    dismissReason?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SmartInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmartInsight to aggregate.
     */
    where?: SmartInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartInsights to fetch.
     */
    orderBy?: SmartInsightOrderByWithRelationInput | SmartInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SmartInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmartInsights
    **/
    _count?: true | SmartInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SmartInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SmartInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmartInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmartInsightMaxAggregateInputType
  }

  export type GetSmartInsightAggregateType<T extends SmartInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateSmartInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmartInsight[P]>
      : GetScalarType<T[P], AggregateSmartInsight[P]>
  }




  export type SmartInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmartInsightWhereInput
    orderBy?: SmartInsightOrderByWithAggregationInput | SmartInsightOrderByWithAggregationInput[]
    by: SmartInsightScalarFieldEnum[] | SmartInsightScalarFieldEnum
    having?: SmartInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmartInsightCountAggregateInputType | true
    _avg?: SmartInsightAvgAggregateInputType
    _sum?: SmartInsightSumAggregateInputType
    _min?: SmartInsightMinAggregateInputType
    _max?: SmartInsightMaxAggregateInputType
  }

  export type SmartInsightGroupByOutputType = {
    id: string
    tenantId: string
    insightType: $Enums.InsightType
    severity: $Enums.InsightSeverity
    title: string
    description: string
    explanation: string
    confidence: number
    metadata: JsonValue
    relatedEntities: JsonValue
    actionable: boolean
    suggestedActions: JsonValue
    dismissedBy: string | null
    dismissedAt: Date | null
    dismissReason: string | null
    createdAt: Date
    expiresAt: Date | null
    _count: SmartInsightCountAggregateOutputType | null
    _avg: SmartInsightAvgAggregateOutputType | null
    _sum: SmartInsightSumAggregateOutputType | null
    _min: SmartInsightMinAggregateOutputType | null
    _max: SmartInsightMaxAggregateOutputType | null
  }

  type GetSmartInsightGroupByPayload<T extends SmartInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SmartInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmartInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmartInsightGroupByOutputType[P]>
            : GetScalarType<T[P], SmartInsightGroupByOutputType[P]>
        }
      >
    >


  export type SmartInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    insightType?: boolean
    severity?: boolean
    title?: boolean
    description?: boolean
    explanation?: boolean
    confidence?: boolean
    metadata?: boolean
    relatedEntities?: boolean
    actionable?: boolean
    suggestedActions?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    dismissReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smartInsight"]>

  export type SmartInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    insightType?: boolean
    severity?: boolean
    title?: boolean
    description?: boolean
    explanation?: boolean
    confidence?: boolean
    metadata?: boolean
    relatedEntities?: boolean
    actionable?: boolean
    suggestedActions?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    dismissReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smartInsight"]>

  export type SmartInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    insightType?: boolean
    severity?: boolean
    title?: boolean
    description?: boolean
    explanation?: boolean
    confidence?: boolean
    metadata?: boolean
    relatedEntities?: boolean
    actionable?: boolean
    suggestedActions?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    dismissReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smartInsight"]>

  export type SmartInsightSelectScalar = {
    id?: boolean
    tenantId?: boolean
    insightType?: boolean
    severity?: boolean
    title?: boolean
    description?: boolean
    explanation?: boolean
    confidence?: boolean
    metadata?: boolean
    relatedEntities?: boolean
    actionable?: boolean
    suggestedActions?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    dismissReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type SmartInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "insightType" | "severity" | "title" | "description" | "explanation" | "confidence" | "metadata" | "relatedEntities" | "actionable" | "suggestedActions" | "dismissedBy" | "dismissedAt" | "dismissReason" | "createdAt" | "expiresAt", ExtArgs["result"]["smartInsight"]>
  export type SmartInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SmartInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SmartInsightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SmartInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SmartInsight"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      insightType: $Enums.InsightType
      severity: $Enums.InsightSeverity
      title: string
      description: string
      explanation: string
      confidence: number
      metadata: Prisma.JsonValue
      relatedEntities: Prisma.JsonValue
      actionable: boolean
      suggestedActions: Prisma.JsonValue
      dismissedBy: string | null
      dismissedAt: Date | null
      dismissReason: string | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["smartInsight"]>
    composites: {}
  }

  type SmartInsightGetPayload<S extends boolean | null | undefined | SmartInsightDefaultArgs> = $Result.GetResult<Prisma.$SmartInsightPayload, S>

  type SmartInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SmartInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SmartInsightCountAggregateInputType | true
    }

  export interface SmartInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SmartInsight'], meta: { name: 'SmartInsight' } }
    /**
     * Find zero or one SmartInsight that matches the filter.
     * @param {SmartInsightFindUniqueArgs} args - Arguments to find a SmartInsight
     * @example
     * // Get one SmartInsight
     * const smartInsight = await prisma.smartInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SmartInsightFindUniqueArgs>(args: SelectSubset<T, SmartInsightFindUniqueArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SmartInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SmartInsightFindUniqueOrThrowArgs} args - Arguments to find a SmartInsight
     * @example
     * // Get one SmartInsight
     * const smartInsight = await prisma.smartInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SmartInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, SmartInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmartInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartInsightFindFirstArgs} args - Arguments to find a SmartInsight
     * @example
     * // Get one SmartInsight
     * const smartInsight = await prisma.smartInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SmartInsightFindFirstArgs>(args?: SelectSubset<T, SmartInsightFindFirstArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmartInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartInsightFindFirstOrThrowArgs} args - Arguments to find a SmartInsight
     * @example
     * // Get one SmartInsight
     * const smartInsight = await prisma.smartInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SmartInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, SmartInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SmartInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmartInsights
     * const smartInsights = await prisma.smartInsight.findMany()
     * 
     * // Get first 10 SmartInsights
     * const smartInsights = await prisma.smartInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smartInsightWithIdOnly = await prisma.smartInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SmartInsightFindManyArgs>(args?: SelectSubset<T, SmartInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SmartInsight.
     * @param {SmartInsightCreateArgs} args - Arguments to create a SmartInsight.
     * @example
     * // Create one SmartInsight
     * const SmartInsight = await prisma.smartInsight.create({
     *   data: {
     *     // ... data to create a SmartInsight
     *   }
     * })
     * 
     */
    create<T extends SmartInsightCreateArgs>(args: SelectSubset<T, SmartInsightCreateArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SmartInsights.
     * @param {SmartInsightCreateManyArgs} args - Arguments to create many SmartInsights.
     * @example
     * // Create many SmartInsights
     * const smartInsight = await prisma.smartInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SmartInsightCreateManyArgs>(args?: SelectSubset<T, SmartInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SmartInsights and returns the data saved in the database.
     * @param {SmartInsightCreateManyAndReturnArgs} args - Arguments to create many SmartInsights.
     * @example
     * // Create many SmartInsights
     * const smartInsight = await prisma.smartInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SmartInsights and only return the `id`
     * const smartInsightWithIdOnly = await prisma.smartInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SmartInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, SmartInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SmartInsight.
     * @param {SmartInsightDeleteArgs} args - Arguments to delete one SmartInsight.
     * @example
     * // Delete one SmartInsight
     * const SmartInsight = await prisma.smartInsight.delete({
     *   where: {
     *     // ... filter to delete one SmartInsight
     *   }
     * })
     * 
     */
    delete<T extends SmartInsightDeleteArgs>(args: SelectSubset<T, SmartInsightDeleteArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SmartInsight.
     * @param {SmartInsightUpdateArgs} args - Arguments to update one SmartInsight.
     * @example
     * // Update one SmartInsight
     * const smartInsight = await prisma.smartInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SmartInsightUpdateArgs>(args: SelectSubset<T, SmartInsightUpdateArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SmartInsights.
     * @param {SmartInsightDeleteManyArgs} args - Arguments to filter SmartInsights to delete.
     * @example
     * // Delete a few SmartInsights
     * const { count } = await prisma.smartInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SmartInsightDeleteManyArgs>(args?: SelectSubset<T, SmartInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmartInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmartInsights
     * const smartInsight = await prisma.smartInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SmartInsightUpdateManyArgs>(args: SelectSubset<T, SmartInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmartInsights and returns the data updated in the database.
     * @param {SmartInsightUpdateManyAndReturnArgs} args - Arguments to update many SmartInsights.
     * @example
     * // Update many SmartInsights
     * const smartInsight = await prisma.smartInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SmartInsights and only return the `id`
     * const smartInsightWithIdOnly = await prisma.smartInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SmartInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, SmartInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SmartInsight.
     * @param {SmartInsightUpsertArgs} args - Arguments to update or create a SmartInsight.
     * @example
     * // Update or create a SmartInsight
     * const smartInsight = await prisma.smartInsight.upsert({
     *   create: {
     *     // ... data to create a SmartInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmartInsight we want to update
     *   }
     * })
     */
    upsert<T extends SmartInsightUpsertArgs>(args: SelectSubset<T, SmartInsightUpsertArgs<ExtArgs>>): Prisma__SmartInsightClient<$Result.GetResult<Prisma.$SmartInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SmartInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartInsightCountArgs} args - Arguments to filter SmartInsights to count.
     * @example
     * // Count the number of SmartInsights
     * const count = await prisma.smartInsight.count({
     *   where: {
     *     // ... the filter for the SmartInsights we want to count
     *   }
     * })
    **/
    count<T extends SmartInsightCountArgs>(
      args?: Subset<T, SmartInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmartInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmartInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmartInsightAggregateArgs>(args: Subset<T, SmartInsightAggregateArgs>): Prisma.PrismaPromise<GetSmartInsightAggregateType<T>>

    /**
     * Group by SmartInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmartInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmartInsightGroupByArgs['orderBy'] }
        : { orderBy?: SmartInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmartInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmartInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SmartInsight model
   */
  readonly fields: SmartInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SmartInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SmartInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SmartInsight model
   */
  interface SmartInsightFieldRefs {
    readonly id: FieldRef<"SmartInsight", 'String'>
    readonly tenantId: FieldRef<"SmartInsight", 'String'>
    readonly insightType: FieldRef<"SmartInsight", 'InsightType'>
    readonly severity: FieldRef<"SmartInsight", 'InsightSeverity'>
    readonly title: FieldRef<"SmartInsight", 'String'>
    readonly description: FieldRef<"SmartInsight", 'String'>
    readonly explanation: FieldRef<"SmartInsight", 'String'>
    readonly confidence: FieldRef<"SmartInsight", 'Float'>
    readonly metadata: FieldRef<"SmartInsight", 'Json'>
    readonly relatedEntities: FieldRef<"SmartInsight", 'Json'>
    readonly actionable: FieldRef<"SmartInsight", 'Boolean'>
    readonly suggestedActions: FieldRef<"SmartInsight", 'Json'>
    readonly dismissedBy: FieldRef<"SmartInsight", 'String'>
    readonly dismissedAt: FieldRef<"SmartInsight", 'DateTime'>
    readonly dismissReason: FieldRef<"SmartInsight", 'String'>
    readonly createdAt: FieldRef<"SmartInsight", 'DateTime'>
    readonly expiresAt: FieldRef<"SmartInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SmartInsight findUnique
   */
  export type SmartInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * Filter, which SmartInsight to fetch.
     */
    where: SmartInsightWhereUniqueInput
  }

  /**
   * SmartInsight findUniqueOrThrow
   */
  export type SmartInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * Filter, which SmartInsight to fetch.
     */
    where: SmartInsightWhereUniqueInput
  }

  /**
   * SmartInsight findFirst
   */
  export type SmartInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * Filter, which SmartInsight to fetch.
     */
    where?: SmartInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartInsights to fetch.
     */
    orderBy?: SmartInsightOrderByWithRelationInput | SmartInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmartInsights.
     */
    cursor?: SmartInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmartInsights.
     */
    distinct?: SmartInsightScalarFieldEnum | SmartInsightScalarFieldEnum[]
  }

  /**
   * SmartInsight findFirstOrThrow
   */
  export type SmartInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * Filter, which SmartInsight to fetch.
     */
    where?: SmartInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartInsights to fetch.
     */
    orderBy?: SmartInsightOrderByWithRelationInput | SmartInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmartInsights.
     */
    cursor?: SmartInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmartInsights.
     */
    distinct?: SmartInsightScalarFieldEnum | SmartInsightScalarFieldEnum[]
  }

  /**
   * SmartInsight findMany
   */
  export type SmartInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * Filter, which SmartInsights to fetch.
     */
    where?: SmartInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartInsights to fetch.
     */
    orderBy?: SmartInsightOrderByWithRelationInput | SmartInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmartInsights.
     */
    cursor?: SmartInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartInsights.
     */
    skip?: number
    distinct?: SmartInsightScalarFieldEnum | SmartInsightScalarFieldEnum[]
  }

  /**
   * SmartInsight create
   */
  export type SmartInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a SmartInsight.
     */
    data: XOR<SmartInsightCreateInput, SmartInsightUncheckedCreateInput>
  }

  /**
   * SmartInsight createMany
   */
  export type SmartInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SmartInsights.
     */
    data: SmartInsightCreateManyInput | SmartInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmartInsight createManyAndReturn
   */
  export type SmartInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * The data used to create many SmartInsights.
     */
    data: SmartInsightCreateManyInput | SmartInsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SmartInsight update
   */
  export type SmartInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a SmartInsight.
     */
    data: XOR<SmartInsightUpdateInput, SmartInsightUncheckedUpdateInput>
    /**
     * Choose, which SmartInsight to update.
     */
    where: SmartInsightWhereUniqueInput
  }

  /**
   * SmartInsight updateMany
   */
  export type SmartInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SmartInsights.
     */
    data: XOR<SmartInsightUpdateManyMutationInput, SmartInsightUncheckedUpdateManyInput>
    /**
     * Filter which SmartInsights to update
     */
    where?: SmartInsightWhereInput
    /**
     * Limit how many SmartInsights to update.
     */
    limit?: number
  }

  /**
   * SmartInsight updateManyAndReturn
   */
  export type SmartInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * The data used to update SmartInsights.
     */
    data: XOR<SmartInsightUpdateManyMutationInput, SmartInsightUncheckedUpdateManyInput>
    /**
     * Filter which SmartInsights to update
     */
    where?: SmartInsightWhereInput
    /**
     * Limit how many SmartInsights to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SmartInsight upsert
   */
  export type SmartInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the SmartInsight to update in case it exists.
     */
    where: SmartInsightWhereUniqueInput
    /**
     * In case the SmartInsight found by the `where` argument doesn't exist, create a new SmartInsight with this data.
     */
    create: XOR<SmartInsightCreateInput, SmartInsightUncheckedCreateInput>
    /**
     * In case the SmartInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmartInsightUpdateInput, SmartInsightUncheckedUpdateInput>
  }

  /**
   * SmartInsight delete
   */
  export type SmartInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
    /**
     * Filter which SmartInsight to delete.
     */
    where: SmartInsightWhereUniqueInput
  }

  /**
   * SmartInsight deleteMany
   */
  export type SmartInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmartInsights to delete
     */
    where?: SmartInsightWhereInput
    /**
     * Limit how many SmartInsights to delete.
     */
    limit?: number
  }

  /**
   * SmartInsight without action
   */
  export type SmartInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartInsight
     */
    select?: SmartInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartInsight
     */
    omit?: SmartInsightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartInsightInclude<ExtArgs> | null
  }


  /**
   * Model AutomationTemplate
   */

  export type AggregateAutomationTemplate = {
    _count: AutomationTemplateCountAggregateOutputType | null
    _avg: AutomationTemplateAvgAggregateOutputType | null
    _sum: AutomationTemplateSumAggregateOutputType | null
    _min: AutomationTemplateMinAggregateOutputType | null
    _max: AutomationTemplateMaxAggregateOutputType | null
  }

  export type AutomationTemplateAvgAggregateOutputType = {
    popularity: number | null
  }

  export type AutomationTemplateSumAggregateOutputType = {
    popularity: number | null
  }

  export type AutomationTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    triggerType: $Enums.AutomationTriggerType | null
    requiredPlan: $Enums.SubscriptionPlan | null
    popularity: number | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    triggerType: $Enums.AutomationTriggerType | null
    requiredPlan: $Enums.SubscriptionPlan | null
    popularity: number | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutomationTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    triggerType: number
    triggerConfig: number
    conditions: number
    actions: number
    requiredPlan: number
    popularity: number
    isPublic: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutomationTemplateAvgAggregateInputType = {
    popularity?: true
  }

  export type AutomationTemplateSumAggregateInputType = {
    popularity?: true
  }

  export type AutomationTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    triggerType?: true
    requiredPlan?: true
    popularity?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    triggerType?: true
    requiredPlan?: true
    popularity?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutomationTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    triggerType?: true
    triggerConfig?: true
    conditions?: true
    actions?: true
    requiredPlan?: true
    popularity?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutomationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationTemplate to aggregate.
     */
    where?: AutomationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTemplates to fetch.
     */
    orderBy?: AutomationTemplateOrderByWithRelationInput | AutomationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationTemplates
    **/
    _count?: true | AutomationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationTemplateMaxAggregateInputType
  }

  export type GetAutomationTemplateAggregateType<T extends AutomationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationTemplate[P]>
      : GetScalarType<T[P], AggregateAutomationTemplate[P]>
  }




  export type AutomationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationTemplateWhereInput
    orderBy?: AutomationTemplateOrderByWithAggregationInput | AutomationTemplateOrderByWithAggregationInput[]
    by: AutomationTemplateScalarFieldEnum[] | AutomationTemplateScalarFieldEnum
    having?: AutomationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationTemplateCountAggregateInputType | true
    _avg?: AutomationTemplateAvgAggregateInputType
    _sum?: AutomationTemplateSumAggregateInputType
    _min?: AutomationTemplateMinAggregateInputType
    _max?: AutomationTemplateMaxAggregateInputType
  }

  export type AutomationTemplateGroupByOutputType = {
    id: string
    name: string
    description: string
    category: string
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonValue
    conditions: JsonValue
    actions: JsonValue
    requiredPlan: $Enums.SubscriptionPlan
    popularity: number
    isPublic: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: AutomationTemplateCountAggregateOutputType | null
    _avg: AutomationTemplateAvgAggregateOutputType | null
    _sum: AutomationTemplateSumAggregateOutputType | null
    _min: AutomationTemplateMinAggregateOutputType | null
    _max: AutomationTemplateMaxAggregateOutputType | null
  }

  type GetAutomationTemplateGroupByPayload<T extends AutomationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type AutomationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    requiredPlan?: boolean
    popularity?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automationTemplate"]>

  export type AutomationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    requiredPlan?: boolean
    popularity?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automationTemplate"]>

  export type AutomationTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    requiredPlan?: boolean
    popularity?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["automationTemplate"]>

  export type AutomationTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    conditions?: boolean
    actions?: boolean
    requiredPlan?: boolean
    popularity?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutomationTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "triggerType" | "triggerConfig" | "conditions" | "actions" | "requiredPlan" | "popularity" | "isPublic" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["automationTemplate"]>

  export type $AutomationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      category: string
      triggerType: $Enums.AutomationTriggerType
      triggerConfig: Prisma.JsonValue
      conditions: Prisma.JsonValue
      actions: Prisma.JsonValue
      requiredPlan: $Enums.SubscriptionPlan
      popularity: number
      isPublic: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["automationTemplate"]>
    composites: {}
  }

  type AutomationTemplateGetPayload<S extends boolean | null | undefined | AutomationTemplateDefaultArgs> = $Result.GetResult<Prisma.$AutomationTemplatePayload, S>

  type AutomationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationTemplateCountAggregateInputType | true
    }

  export interface AutomationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationTemplate'], meta: { name: 'AutomationTemplate' } }
    /**
     * Find zero or one AutomationTemplate that matches the filter.
     * @param {AutomationTemplateFindUniqueArgs} args - Arguments to find a AutomationTemplate
     * @example
     * // Get one AutomationTemplate
     * const automationTemplate = await prisma.automationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationTemplateFindUniqueArgs>(args: SelectSubset<T, AutomationTemplateFindUniqueArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationTemplateFindUniqueOrThrowArgs} args - Arguments to find a AutomationTemplate
     * @example
     * // Get one AutomationTemplate
     * const automationTemplate = await prisma.automationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTemplateFindFirstArgs} args - Arguments to find a AutomationTemplate
     * @example
     * // Get one AutomationTemplate
     * const automationTemplate = await prisma.automationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationTemplateFindFirstArgs>(args?: SelectSubset<T, AutomationTemplateFindFirstArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTemplateFindFirstOrThrowArgs} args - Arguments to find a AutomationTemplate
     * @example
     * // Get one AutomationTemplate
     * const automationTemplate = await prisma.automationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationTemplates
     * const automationTemplates = await prisma.automationTemplate.findMany()
     * 
     * // Get first 10 AutomationTemplates
     * const automationTemplates = await prisma.automationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationTemplateWithIdOnly = await prisma.automationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationTemplateFindManyArgs>(args?: SelectSubset<T, AutomationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationTemplate.
     * @param {AutomationTemplateCreateArgs} args - Arguments to create a AutomationTemplate.
     * @example
     * // Create one AutomationTemplate
     * const AutomationTemplate = await prisma.automationTemplate.create({
     *   data: {
     *     // ... data to create a AutomationTemplate
     *   }
     * })
     * 
     */
    create<T extends AutomationTemplateCreateArgs>(args: SelectSubset<T, AutomationTemplateCreateArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationTemplates.
     * @param {AutomationTemplateCreateManyArgs} args - Arguments to create many AutomationTemplates.
     * @example
     * // Create many AutomationTemplates
     * const automationTemplate = await prisma.automationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationTemplateCreateManyArgs>(args?: SelectSubset<T, AutomationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationTemplates and returns the data saved in the database.
     * @param {AutomationTemplateCreateManyAndReturnArgs} args - Arguments to create many AutomationTemplates.
     * @example
     * // Create many AutomationTemplates
     * const automationTemplate = await prisma.automationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationTemplates and only return the `id`
     * const automationTemplateWithIdOnly = await prisma.automationTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationTemplate.
     * @param {AutomationTemplateDeleteArgs} args - Arguments to delete one AutomationTemplate.
     * @example
     * // Delete one AutomationTemplate
     * const AutomationTemplate = await prisma.automationTemplate.delete({
     *   where: {
     *     // ... filter to delete one AutomationTemplate
     *   }
     * })
     * 
     */
    delete<T extends AutomationTemplateDeleteArgs>(args: SelectSubset<T, AutomationTemplateDeleteArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationTemplate.
     * @param {AutomationTemplateUpdateArgs} args - Arguments to update one AutomationTemplate.
     * @example
     * // Update one AutomationTemplate
     * const automationTemplate = await prisma.automationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationTemplateUpdateArgs>(args: SelectSubset<T, AutomationTemplateUpdateArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationTemplates.
     * @param {AutomationTemplateDeleteManyArgs} args - Arguments to filter AutomationTemplates to delete.
     * @example
     * // Delete a few AutomationTemplates
     * const { count } = await prisma.automationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationTemplateDeleteManyArgs>(args?: SelectSubset<T, AutomationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationTemplates
     * const automationTemplate = await prisma.automationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationTemplateUpdateManyArgs>(args: SelectSubset<T, AutomationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationTemplates and returns the data updated in the database.
     * @param {AutomationTemplateUpdateManyAndReturnArgs} args - Arguments to update many AutomationTemplates.
     * @example
     * // Update many AutomationTemplates
     * const automationTemplate = await prisma.automationTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationTemplates and only return the `id`
     * const automationTemplateWithIdOnly = await prisma.automationTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationTemplate.
     * @param {AutomationTemplateUpsertArgs} args - Arguments to update or create a AutomationTemplate.
     * @example
     * // Update or create a AutomationTemplate
     * const automationTemplate = await prisma.automationTemplate.upsert({
     *   create: {
     *     // ... data to create a AutomationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends AutomationTemplateUpsertArgs>(args: SelectSubset<T, AutomationTemplateUpsertArgs<ExtArgs>>): Prisma__AutomationTemplateClient<$Result.GetResult<Prisma.$AutomationTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTemplateCountArgs} args - Arguments to filter AutomationTemplates to count.
     * @example
     * // Count the number of AutomationTemplates
     * const count = await prisma.automationTemplate.count({
     *   where: {
     *     // ... the filter for the AutomationTemplates we want to count
     *   }
     * })
    **/
    count<T extends AutomationTemplateCountArgs>(
      args?: Subset<T, AutomationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationTemplateAggregateArgs>(args: Subset<T, AutomationTemplateAggregateArgs>): Prisma.PrismaPromise<GetAutomationTemplateAggregateType<T>>

    /**
     * Group by AutomationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: AutomationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationTemplate model
   */
  readonly fields: AutomationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationTemplate model
   */
  interface AutomationTemplateFieldRefs {
    readonly id: FieldRef<"AutomationTemplate", 'String'>
    readonly name: FieldRef<"AutomationTemplate", 'String'>
    readonly description: FieldRef<"AutomationTemplate", 'String'>
    readonly category: FieldRef<"AutomationTemplate", 'String'>
    readonly triggerType: FieldRef<"AutomationTemplate", 'AutomationTriggerType'>
    readonly triggerConfig: FieldRef<"AutomationTemplate", 'Json'>
    readonly conditions: FieldRef<"AutomationTemplate", 'Json'>
    readonly actions: FieldRef<"AutomationTemplate", 'Json'>
    readonly requiredPlan: FieldRef<"AutomationTemplate", 'SubscriptionPlan'>
    readonly popularity: FieldRef<"AutomationTemplate", 'Int'>
    readonly isPublic: FieldRef<"AutomationTemplate", 'Boolean'>
    readonly createdBy: FieldRef<"AutomationTemplate", 'String'>
    readonly createdAt: FieldRef<"AutomationTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationTemplate findUnique
   */
  export type AutomationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AutomationTemplate to fetch.
     */
    where: AutomationTemplateWhereUniqueInput
  }

  /**
   * AutomationTemplate findUniqueOrThrow
   */
  export type AutomationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AutomationTemplate to fetch.
     */
    where: AutomationTemplateWhereUniqueInput
  }

  /**
   * AutomationTemplate findFirst
   */
  export type AutomationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AutomationTemplate to fetch.
     */
    where?: AutomationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTemplates to fetch.
     */
    orderBy?: AutomationTemplateOrderByWithRelationInput | AutomationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationTemplates.
     */
    cursor?: AutomationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationTemplates.
     */
    distinct?: AutomationTemplateScalarFieldEnum | AutomationTemplateScalarFieldEnum[]
  }

  /**
   * AutomationTemplate findFirstOrThrow
   */
  export type AutomationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AutomationTemplate to fetch.
     */
    where?: AutomationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTemplates to fetch.
     */
    orderBy?: AutomationTemplateOrderByWithRelationInput | AutomationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationTemplates.
     */
    cursor?: AutomationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationTemplates.
     */
    distinct?: AutomationTemplateScalarFieldEnum | AutomationTemplateScalarFieldEnum[]
  }

  /**
   * AutomationTemplate findMany
   */
  export type AutomationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AutomationTemplates to fetch.
     */
    where?: AutomationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationTemplates to fetch.
     */
    orderBy?: AutomationTemplateOrderByWithRelationInput | AutomationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationTemplates.
     */
    cursor?: AutomationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationTemplates.
     */
    skip?: number
    distinct?: AutomationTemplateScalarFieldEnum | AutomationTemplateScalarFieldEnum[]
  }

  /**
   * AutomationTemplate create
   */
  export type AutomationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a AutomationTemplate.
     */
    data: XOR<AutomationTemplateCreateInput, AutomationTemplateUncheckedCreateInput>
  }

  /**
   * AutomationTemplate createMany
   */
  export type AutomationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationTemplates.
     */
    data: AutomationTemplateCreateManyInput | AutomationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationTemplate createManyAndReturn
   */
  export type AutomationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationTemplates.
     */
    data: AutomationTemplateCreateManyInput | AutomationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationTemplate update
   */
  export type AutomationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a AutomationTemplate.
     */
    data: XOR<AutomationTemplateUpdateInput, AutomationTemplateUncheckedUpdateInput>
    /**
     * Choose, which AutomationTemplate to update.
     */
    where: AutomationTemplateWhereUniqueInput
  }

  /**
   * AutomationTemplate updateMany
   */
  export type AutomationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationTemplates.
     */
    data: XOR<AutomationTemplateUpdateManyMutationInput, AutomationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AutomationTemplates to update
     */
    where?: AutomationTemplateWhereInput
    /**
     * Limit how many AutomationTemplates to update.
     */
    limit?: number
  }

  /**
   * AutomationTemplate updateManyAndReturn
   */
  export type AutomationTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * The data used to update AutomationTemplates.
     */
    data: XOR<AutomationTemplateUpdateManyMutationInput, AutomationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AutomationTemplates to update
     */
    where?: AutomationTemplateWhereInput
    /**
     * Limit how many AutomationTemplates to update.
     */
    limit?: number
  }

  /**
   * AutomationTemplate upsert
   */
  export type AutomationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the AutomationTemplate to update in case it exists.
     */
    where: AutomationTemplateWhereUniqueInput
    /**
     * In case the AutomationTemplate found by the `where` argument doesn't exist, create a new AutomationTemplate with this data.
     */
    create: XOR<AutomationTemplateCreateInput, AutomationTemplateUncheckedCreateInput>
    /**
     * In case the AutomationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationTemplateUpdateInput, AutomationTemplateUncheckedUpdateInput>
  }

  /**
   * AutomationTemplate delete
   */
  export type AutomationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
    /**
     * Filter which AutomationTemplate to delete.
     */
    where: AutomationTemplateWhereUniqueInput
  }

  /**
   * AutomationTemplate deleteMany
   */
  export type AutomationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationTemplates to delete
     */
    where?: AutomationTemplateWhereInput
    /**
     * Limit how many AutomationTemplates to delete.
     */
    limit?: number
  }

  /**
   * AutomationTemplate without action
   */
  export type AutomationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationTemplate
     */
    select?: AutomationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationTemplate
     */
    omit?: AutomationTemplateOmit<ExtArgs> | null
  }


  /**
   * Model AutomationUsageMetric
   */

  export type AggregateAutomationUsageMetric = {
    _count: AutomationUsageMetricCountAggregateOutputType | null
    _avg: AutomationUsageMetricAvgAggregateOutputType | null
    _sum: AutomationUsageMetricSumAggregateOutputType | null
    _min: AutomationUsageMetricMinAggregateOutputType | null
    _max: AutomationUsageMetricMaxAggregateOutputType | null
  }

  export type AutomationUsageMetricAvgAggregateOutputType = {
    executionTime: number | null
    costImpact: number | null
  }

  export type AutomationUsageMetricSumAggregateOutputType = {
    executionTime: number | null
    costImpact: number | null
  }

  export type AutomationUsageMetricMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    ruleId: string | null
    executionId: string | null
    actionType: string | null
    success: boolean | null
    executionTime: number | null
    costImpact: number | null
    timestamp: Date | null
  }

  export type AutomationUsageMetricMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    ruleId: string | null
    executionId: string | null
    actionType: string | null
    success: boolean | null
    executionTime: number | null
    costImpact: number | null
    timestamp: Date | null
  }

  export type AutomationUsageMetricCountAggregateOutputType = {
    id: number
    tenantId: number
    ruleId: number
    executionId: number
    actionType: number
    success: number
    executionTime: number
    costImpact: number
    businessImpact: number
    timestamp: number
    _all: number
  }


  export type AutomationUsageMetricAvgAggregateInputType = {
    executionTime?: true
    costImpact?: true
  }

  export type AutomationUsageMetricSumAggregateInputType = {
    executionTime?: true
    costImpact?: true
  }

  export type AutomationUsageMetricMinAggregateInputType = {
    id?: true
    tenantId?: true
    ruleId?: true
    executionId?: true
    actionType?: true
    success?: true
    executionTime?: true
    costImpact?: true
    timestamp?: true
  }

  export type AutomationUsageMetricMaxAggregateInputType = {
    id?: true
    tenantId?: true
    ruleId?: true
    executionId?: true
    actionType?: true
    success?: true
    executionTime?: true
    costImpact?: true
    timestamp?: true
  }

  export type AutomationUsageMetricCountAggregateInputType = {
    id?: true
    tenantId?: true
    ruleId?: true
    executionId?: true
    actionType?: true
    success?: true
    executionTime?: true
    costImpact?: true
    businessImpact?: true
    timestamp?: true
    _all?: true
  }

  export type AutomationUsageMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationUsageMetric to aggregate.
     */
    where?: AutomationUsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationUsageMetrics to fetch.
     */
    orderBy?: AutomationUsageMetricOrderByWithRelationInput | AutomationUsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationUsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationUsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationUsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationUsageMetrics
    **/
    _count?: true | AutomationUsageMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationUsageMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationUsageMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationUsageMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationUsageMetricMaxAggregateInputType
  }

  export type GetAutomationUsageMetricAggregateType<T extends AutomationUsageMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationUsageMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationUsageMetric[P]>
      : GetScalarType<T[P], AggregateAutomationUsageMetric[P]>
  }




  export type AutomationUsageMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationUsageMetricWhereInput
    orderBy?: AutomationUsageMetricOrderByWithAggregationInput | AutomationUsageMetricOrderByWithAggregationInput[]
    by: AutomationUsageMetricScalarFieldEnum[] | AutomationUsageMetricScalarFieldEnum
    having?: AutomationUsageMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationUsageMetricCountAggregateInputType | true
    _avg?: AutomationUsageMetricAvgAggregateInputType
    _sum?: AutomationUsageMetricSumAggregateInputType
    _min?: AutomationUsageMetricMinAggregateInputType
    _max?: AutomationUsageMetricMaxAggregateInputType
  }

  export type AutomationUsageMetricGroupByOutputType = {
    id: string
    tenantId: string
    ruleId: string
    executionId: string
    actionType: string
    success: boolean
    executionTime: number
    costImpact: number | null
    businessImpact: JsonValue | null
    timestamp: Date
    _count: AutomationUsageMetricCountAggregateOutputType | null
    _avg: AutomationUsageMetricAvgAggregateOutputType | null
    _sum: AutomationUsageMetricSumAggregateOutputType | null
    _min: AutomationUsageMetricMinAggregateOutputType | null
    _max: AutomationUsageMetricMaxAggregateOutputType | null
  }

  type GetAutomationUsageMetricGroupByPayload<T extends AutomationUsageMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationUsageMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationUsageMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationUsageMetricGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationUsageMetricGroupByOutputType[P]>
        }
      >
    >


  export type AutomationUsageMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    ruleId?: boolean
    executionId?: boolean
    actionType?: boolean
    success?: boolean
    executionTime?: boolean
    costImpact?: boolean
    businessImpact?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationUsageMetric"]>

  export type AutomationUsageMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    ruleId?: boolean
    executionId?: boolean
    actionType?: boolean
    success?: boolean
    executionTime?: boolean
    costImpact?: boolean
    businessImpact?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationUsageMetric"]>

  export type AutomationUsageMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    ruleId?: boolean
    executionId?: boolean
    actionType?: boolean
    success?: boolean
    executionTime?: boolean
    costImpact?: boolean
    businessImpact?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationUsageMetric"]>

  export type AutomationUsageMetricSelectScalar = {
    id?: boolean
    tenantId?: boolean
    ruleId?: boolean
    executionId?: boolean
    actionType?: boolean
    success?: boolean
    executionTime?: boolean
    costImpact?: boolean
    businessImpact?: boolean
    timestamp?: boolean
  }

  export type AutomationUsageMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "ruleId" | "executionId" | "actionType" | "success" | "executionTime" | "costImpact" | "businessImpact" | "timestamp", ExtArgs["result"]["automationUsageMetric"]>
  export type AutomationUsageMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AutomationUsageMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AutomationUsageMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AutomationUsageMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationUsageMetric"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      ruleId: string
      executionId: string
      actionType: string
      success: boolean
      executionTime: number
      costImpact: number | null
      businessImpact: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["automationUsageMetric"]>
    composites: {}
  }

  type AutomationUsageMetricGetPayload<S extends boolean | null | undefined | AutomationUsageMetricDefaultArgs> = $Result.GetResult<Prisma.$AutomationUsageMetricPayload, S>

  type AutomationUsageMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationUsageMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationUsageMetricCountAggregateInputType | true
    }

  export interface AutomationUsageMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationUsageMetric'], meta: { name: 'AutomationUsageMetric' } }
    /**
     * Find zero or one AutomationUsageMetric that matches the filter.
     * @param {AutomationUsageMetricFindUniqueArgs} args - Arguments to find a AutomationUsageMetric
     * @example
     * // Get one AutomationUsageMetric
     * const automationUsageMetric = await prisma.automationUsageMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationUsageMetricFindUniqueArgs>(args: SelectSubset<T, AutomationUsageMetricFindUniqueArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationUsageMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationUsageMetricFindUniqueOrThrowArgs} args - Arguments to find a AutomationUsageMetric
     * @example
     * // Get one AutomationUsageMetric
     * const automationUsageMetric = await prisma.automationUsageMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationUsageMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationUsageMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationUsageMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUsageMetricFindFirstArgs} args - Arguments to find a AutomationUsageMetric
     * @example
     * // Get one AutomationUsageMetric
     * const automationUsageMetric = await prisma.automationUsageMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationUsageMetricFindFirstArgs>(args?: SelectSubset<T, AutomationUsageMetricFindFirstArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationUsageMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUsageMetricFindFirstOrThrowArgs} args - Arguments to find a AutomationUsageMetric
     * @example
     * // Get one AutomationUsageMetric
     * const automationUsageMetric = await prisma.automationUsageMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationUsageMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationUsageMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationUsageMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUsageMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationUsageMetrics
     * const automationUsageMetrics = await prisma.automationUsageMetric.findMany()
     * 
     * // Get first 10 AutomationUsageMetrics
     * const automationUsageMetrics = await prisma.automationUsageMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationUsageMetricWithIdOnly = await prisma.automationUsageMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationUsageMetricFindManyArgs>(args?: SelectSubset<T, AutomationUsageMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationUsageMetric.
     * @param {AutomationUsageMetricCreateArgs} args - Arguments to create a AutomationUsageMetric.
     * @example
     * // Create one AutomationUsageMetric
     * const AutomationUsageMetric = await prisma.automationUsageMetric.create({
     *   data: {
     *     // ... data to create a AutomationUsageMetric
     *   }
     * })
     * 
     */
    create<T extends AutomationUsageMetricCreateArgs>(args: SelectSubset<T, AutomationUsageMetricCreateArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationUsageMetrics.
     * @param {AutomationUsageMetricCreateManyArgs} args - Arguments to create many AutomationUsageMetrics.
     * @example
     * // Create many AutomationUsageMetrics
     * const automationUsageMetric = await prisma.automationUsageMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationUsageMetricCreateManyArgs>(args?: SelectSubset<T, AutomationUsageMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationUsageMetrics and returns the data saved in the database.
     * @param {AutomationUsageMetricCreateManyAndReturnArgs} args - Arguments to create many AutomationUsageMetrics.
     * @example
     * // Create many AutomationUsageMetrics
     * const automationUsageMetric = await prisma.automationUsageMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationUsageMetrics and only return the `id`
     * const automationUsageMetricWithIdOnly = await prisma.automationUsageMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationUsageMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationUsageMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationUsageMetric.
     * @param {AutomationUsageMetricDeleteArgs} args - Arguments to delete one AutomationUsageMetric.
     * @example
     * // Delete one AutomationUsageMetric
     * const AutomationUsageMetric = await prisma.automationUsageMetric.delete({
     *   where: {
     *     // ... filter to delete one AutomationUsageMetric
     *   }
     * })
     * 
     */
    delete<T extends AutomationUsageMetricDeleteArgs>(args: SelectSubset<T, AutomationUsageMetricDeleteArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationUsageMetric.
     * @param {AutomationUsageMetricUpdateArgs} args - Arguments to update one AutomationUsageMetric.
     * @example
     * // Update one AutomationUsageMetric
     * const automationUsageMetric = await prisma.automationUsageMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUsageMetricUpdateArgs>(args: SelectSubset<T, AutomationUsageMetricUpdateArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationUsageMetrics.
     * @param {AutomationUsageMetricDeleteManyArgs} args - Arguments to filter AutomationUsageMetrics to delete.
     * @example
     * // Delete a few AutomationUsageMetrics
     * const { count } = await prisma.automationUsageMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationUsageMetricDeleteManyArgs>(args?: SelectSubset<T, AutomationUsageMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationUsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUsageMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationUsageMetrics
     * const automationUsageMetric = await prisma.automationUsageMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUsageMetricUpdateManyArgs>(args: SelectSubset<T, AutomationUsageMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationUsageMetrics and returns the data updated in the database.
     * @param {AutomationUsageMetricUpdateManyAndReturnArgs} args - Arguments to update many AutomationUsageMetrics.
     * @example
     * // Update many AutomationUsageMetrics
     * const automationUsageMetric = await prisma.automationUsageMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationUsageMetrics and only return the `id`
     * const automationUsageMetricWithIdOnly = await prisma.automationUsageMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationUsageMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationUsageMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationUsageMetric.
     * @param {AutomationUsageMetricUpsertArgs} args - Arguments to update or create a AutomationUsageMetric.
     * @example
     * // Update or create a AutomationUsageMetric
     * const automationUsageMetric = await prisma.automationUsageMetric.upsert({
     *   create: {
     *     // ... data to create a AutomationUsageMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationUsageMetric we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUsageMetricUpsertArgs>(args: SelectSubset<T, AutomationUsageMetricUpsertArgs<ExtArgs>>): Prisma__AutomationUsageMetricClient<$Result.GetResult<Prisma.$AutomationUsageMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationUsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUsageMetricCountArgs} args - Arguments to filter AutomationUsageMetrics to count.
     * @example
     * // Count the number of AutomationUsageMetrics
     * const count = await prisma.automationUsageMetric.count({
     *   where: {
     *     // ... the filter for the AutomationUsageMetrics we want to count
     *   }
     * })
    **/
    count<T extends AutomationUsageMetricCountArgs>(
      args?: Subset<T, AutomationUsageMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationUsageMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationUsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUsageMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationUsageMetricAggregateArgs>(args: Subset<T, AutomationUsageMetricAggregateArgs>): Prisma.PrismaPromise<GetAutomationUsageMetricAggregateType<T>>

    /**
     * Group by AutomationUsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUsageMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationUsageMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationUsageMetricGroupByArgs['orderBy'] }
        : { orderBy?: AutomationUsageMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationUsageMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationUsageMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationUsageMetric model
   */
  readonly fields: AutomationUsageMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationUsageMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationUsageMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationUsageMetric model
   */
  interface AutomationUsageMetricFieldRefs {
    readonly id: FieldRef<"AutomationUsageMetric", 'String'>
    readonly tenantId: FieldRef<"AutomationUsageMetric", 'String'>
    readonly ruleId: FieldRef<"AutomationUsageMetric", 'String'>
    readonly executionId: FieldRef<"AutomationUsageMetric", 'String'>
    readonly actionType: FieldRef<"AutomationUsageMetric", 'String'>
    readonly success: FieldRef<"AutomationUsageMetric", 'Boolean'>
    readonly executionTime: FieldRef<"AutomationUsageMetric", 'Int'>
    readonly costImpact: FieldRef<"AutomationUsageMetric", 'Float'>
    readonly businessImpact: FieldRef<"AutomationUsageMetric", 'Json'>
    readonly timestamp: FieldRef<"AutomationUsageMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutomationUsageMetric findUnique
   */
  export type AutomationUsageMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which AutomationUsageMetric to fetch.
     */
    where: AutomationUsageMetricWhereUniqueInput
  }

  /**
   * AutomationUsageMetric findUniqueOrThrow
   */
  export type AutomationUsageMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which AutomationUsageMetric to fetch.
     */
    where: AutomationUsageMetricWhereUniqueInput
  }

  /**
   * AutomationUsageMetric findFirst
   */
  export type AutomationUsageMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which AutomationUsageMetric to fetch.
     */
    where?: AutomationUsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationUsageMetrics to fetch.
     */
    orderBy?: AutomationUsageMetricOrderByWithRelationInput | AutomationUsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationUsageMetrics.
     */
    cursor?: AutomationUsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationUsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationUsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationUsageMetrics.
     */
    distinct?: AutomationUsageMetricScalarFieldEnum | AutomationUsageMetricScalarFieldEnum[]
  }

  /**
   * AutomationUsageMetric findFirstOrThrow
   */
  export type AutomationUsageMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which AutomationUsageMetric to fetch.
     */
    where?: AutomationUsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationUsageMetrics to fetch.
     */
    orderBy?: AutomationUsageMetricOrderByWithRelationInput | AutomationUsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationUsageMetrics.
     */
    cursor?: AutomationUsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationUsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationUsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationUsageMetrics.
     */
    distinct?: AutomationUsageMetricScalarFieldEnum | AutomationUsageMetricScalarFieldEnum[]
  }

  /**
   * AutomationUsageMetric findMany
   */
  export type AutomationUsageMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * Filter, which AutomationUsageMetrics to fetch.
     */
    where?: AutomationUsageMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationUsageMetrics to fetch.
     */
    orderBy?: AutomationUsageMetricOrderByWithRelationInput | AutomationUsageMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationUsageMetrics.
     */
    cursor?: AutomationUsageMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationUsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationUsageMetrics.
     */
    skip?: number
    distinct?: AutomationUsageMetricScalarFieldEnum | AutomationUsageMetricScalarFieldEnum[]
  }

  /**
   * AutomationUsageMetric create
   */
  export type AutomationUsageMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationUsageMetric.
     */
    data: XOR<AutomationUsageMetricCreateInput, AutomationUsageMetricUncheckedCreateInput>
  }

  /**
   * AutomationUsageMetric createMany
   */
  export type AutomationUsageMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationUsageMetrics.
     */
    data: AutomationUsageMetricCreateManyInput | AutomationUsageMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationUsageMetric createManyAndReturn
   */
  export type AutomationUsageMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationUsageMetrics.
     */
    data: AutomationUsageMetricCreateManyInput | AutomationUsageMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationUsageMetric update
   */
  export type AutomationUsageMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationUsageMetric.
     */
    data: XOR<AutomationUsageMetricUpdateInput, AutomationUsageMetricUncheckedUpdateInput>
    /**
     * Choose, which AutomationUsageMetric to update.
     */
    where: AutomationUsageMetricWhereUniqueInput
  }

  /**
   * AutomationUsageMetric updateMany
   */
  export type AutomationUsageMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationUsageMetrics.
     */
    data: XOR<AutomationUsageMetricUpdateManyMutationInput, AutomationUsageMetricUncheckedUpdateManyInput>
    /**
     * Filter which AutomationUsageMetrics to update
     */
    where?: AutomationUsageMetricWhereInput
    /**
     * Limit how many AutomationUsageMetrics to update.
     */
    limit?: number
  }

  /**
   * AutomationUsageMetric updateManyAndReturn
   */
  export type AutomationUsageMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * The data used to update AutomationUsageMetrics.
     */
    data: XOR<AutomationUsageMetricUpdateManyMutationInput, AutomationUsageMetricUncheckedUpdateManyInput>
    /**
     * Filter which AutomationUsageMetrics to update
     */
    where?: AutomationUsageMetricWhereInput
    /**
     * Limit how many AutomationUsageMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationUsageMetric upsert
   */
  export type AutomationUsageMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationUsageMetric to update in case it exists.
     */
    where: AutomationUsageMetricWhereUniqueInput
    /**
     * In case the AutomationUsageMetric found by the `where` argument doesn't exist, create a new AutomationUsageMetric with this data.
     */
    create: XOR<AutomationUsageMetricCreateInput, AutomationUsageMetricUncheckedCreateInput>
    /**
     * In case the AutomationUsageMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUsageMetricUpdateInput, AutomationUsageMetricUncheckedUpdateInput>
  }

  /**
   * AutomationUsageMetric delete
   */
  export type AutomationUsageMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
    /**
     * Filter which AutomationUsageMetric to delete.
     */
    where: AutomationUsageMetricWhereUniqueInput
  }

  /**
   * AutomationUsageMetric deleteMany
   */
  export type AutomationUsageMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationUsageMetrics to delete
     */
    where?: AutomationUsageMetricWhereInput
    /**
     * Limit how many AutomationUsageMetrics to delete.
     */
    limit?: number
  }

  /**
   * AutomationUsageMetric without action
   */
  export type AutomationUsageMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationUsageMetric
     */
    select?: AutomationUsageMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationUsageMetric
     */
    omit?: AutomationUsageMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationUsageMetricInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    expiryMonth: number | null
    expiryYear: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    customerId: string | null
    type: $Enums.PaymentMethodType | null
    isDefault: boolean | null
    token: string | null
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    accountType: string | null
    routingNumber: string | null
    nickname: string | null
    isActive: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    customerId: string | null
    type: $Enums.PaymentMethodType | null
    isDefault: boolean | null
    token: string | null
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    accountType: string | null
    routingNumber: string | null
    nickname: string | null
    isActive: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    tenantId: number
    customerId: number
    type: number
    isDefault: number
    token: number
    last4: number
    brand: number
    expiryMonth: number
    expiryYear: number
    accountType: number
    routingNumber: number
    nickname: number
    billingAddress: number
    metadata: number
    isActive: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    expiryMonth?: true
    expiryYear?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    tenantId?: true
    customerId?: true
    type?: true
    isDefault?: true
    token?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    accountType?: true
    routingNumber?: true
    nickname?: true
    isActive?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    tenantId?: true
    customerId?: true
    type?: true
    isDefault?: true
    token?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    accountType?: true
    routingNumber?: true
    nickname?: true
    isActive?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    tenantId?: true
    customerId?: true
    type?: true
    isDefault?: true
    token?: true
    last4?: true
    brand?: true
    expiryMonth?: true
    expiryYear?: true
    accountType?: true
    routingNumber?: true
    nickname?: true
    billingAddress?: true
    metadata?: true
    isActive?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    tenantId: string
    customerId: string | null
    type: $Enums.PaymentMethodType
    isDefault: boolean
    token: string
    last4: string | null
    brand: string | null
    expiryMonth: number | null
    expiryYear: number | null
    accountType: string | null
    routingNumber: string | null
    nickname: string | null
    billingAddress: JsonValue | null
    metadata: JsonValue
    isActive: boolean
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerId?: boolean
    type?: boolean
    isDefault?: boolean
    token?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    accountType?: boolean
    routingNumber?: boolean
    nickname?: boolean
    billingAddress?: boolean
    metadata?: boolean
    isActive?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerId?: boolean
    type?: boolean
    isDefault?: boolean
    token?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    accountType?: boolean
    routingNumber?: boolean
    nickname?: boolean
    billingAddress?: boolean
    metadata?: boolean
    isActive?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerId?: boolean
    type?: boolean
    isDefault?: boolean
    token?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    accountType?: boolean
    routingNumber?: boolean
    nickname?: boolean
    billingAddress?: boolean
    metadata?: boolean
    isActive?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    tenantId?: boolean
    customerId?: boolean
    type?: boolean
    isDefault?: boolean
    token?: boolean
    last4?: boolean
    brand?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    accountType?: boolean
    routingNumber?: boolean
    nickname?: boolean
    billingAddress?: boolean
    metadata?: boolean
    isActive?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "customerId" | "type" | "isDefault" | "token" | "last4" | "brand" | "expiryMonth" | "expiryYear" | "accountType" | "routingNumber" | "nickname" | "billingAddress" | "metadata" | "isActive" | "verifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      customerId: string | null
      type: $Enums.PaymentMethodType
      isDefault: boolean
      token: string
      last4: string | null
      brand: string | null
      expiryMonth: number | null
      expiryYear: number | null
      accountType: string | null
      routingNumber: string | null
      nickname: string | null
      billingAddress: Prisma.JsonValue | null
      metadata: Prisma.JsonValue
      isActive: boolean
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends PaymentMethod$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly tenantId: FieldRef<"PaymentMethod", 'String'>
    readonly customerId: FieldRef<"PaymentMethod", 'String'>
    readonly type: FieldRef<"PaymentMethod", 'PaymentMethodType'>
    readonly isDefault: FieldRef<"PaymentMethod", 'Boolean'>
    readonly token: FieldRef<"PaymentMethod", 'String'>
    readonly last4: FieldRef<"PaymentMethod", 'String'>
    readonly brand: FieldRef<"PaymentMethod", 'String'>
    readonly expiryMonth: FieldRef<"PaymentMethod", 'Int'>
    readonly expiryYear: FieldRef<"PaymentMethod", 'Int'>
    readonly accountType: FieldRef<"PaymentMethod", 'String'>
    readonly routingNumber: FieldRef<"PaymentMethod", 'String'>
    readonly nickname: FieldRef<"PaymentMethod", 'String'>
    readonly billingAddress: FieldRef<"PaymentMethod", 'Json'>
    readonly metadata: FieldRef<"PaymentMethod", 'Json'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly verifiedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.payments
   */
  export type PaymentMethod$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    retryCount: number | null
    maxRetries: number | null
    processingFee: number | null
    netAmount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    retryCount: number | null
    maxRetries: number | null
    processingFee: number | null
    netAmount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    paymentMethodId: string | null
    invoiceId: string | null
    type: $Enums.PaymentType | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    currency: string | null
    description: string | null
    processorId: string | null
    processorStatus: string | null
    automationRuleId: string | null
    automationExecutionId: string | null
    isAutomated: boolean | null
    scheduledFor: Date | null
    processedAt: Date | null
    retryCount: number | null
    maxRetries: number | null
    nextRetryAt: Date | null
    reconciledAt: Date | null
    ledgerEntryId: string | null
    processingFee: number | null
    netAmount: number | null
    isDisputed: boolean | null
    disputeReason: string | null
    disputedAt: Date | null
    requiresApproval: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    paymentMethodId: string | null
    invoiceId: string | null
    type: $Enums.PaymentType | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    currency: string | null
    description: string | null
    processorId: string | null
    processorStatus: string | null
    automationRuleId: string | null
    automationExecutionId: string | null
    isAutomated: boolean | null
    scheduledFor: Date | null
    processedAt: Date | null
    retryCount: number | null
    maxRetries: number | null
    nextRetryAt: Date | null
    reconciledAt: Date | null
    ledgerEntryId: string | null
    processingFee: number | null
    netAmount: number | null
    isDisputed: boolean | null
    disputeReason: string | null
    disputedAt: Date | null
    requiresApproval: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    paymentMethodId: number
    invoiceId: number
    type: number
    status: number
    amount: number
    currency: number
    description: number
    processorId: number
    processorStatus: number
    processorResponse: number
    automationRuleId: number
    automationExecutionId: number
    isAutomated: number
    scheduledFor: number
    processedAt: number
    retryCount: number
    maxRetries: number
    nextRetryAt: number
    reconciledAt: number
    ledgerEntryId: number
    processingFee: number
    netAmount: number
    isDisputed: number
    disputeReason: number
    disputedAt: number
    requiresApproval: number
    approvedBy: number
    approvedAt: number
    metadata: number
    failureReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    retryCount?: true
    maxRetries?: true
    processingFee?: true
    netAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    retryCount?: true
    maxRetries?: true
    processingFee?: true
    netAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    paymentMethodId?: true
    invoiceId?: true
    type?: true
    status?: true
    amount?: true
    currency?: true
    description?: true
    processorId?: true
    processorStatus?: true
    automationRuleId?: true
    automationExecutionId?: true
    isAutomated?: true
    scheduledFor?: true
    processedAt?: true
    retryCount?: true
    maxRetries?: true
    nextRetryAt?: true
    reconciledAt?: true
    ledgerEntryId?: true
    processingFee?: true
    netAmount?: true
    isDisputed?: true
    disputeReason?: true
    disputedAt?: true
    requiresApproval?: true
    approvedBy?: true
    approvedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    paymentMethodId?: true
    invoiceId?: true
    type?: true
    status?: true
    amount?: true
    currency?: true
    description?: true
    processorId?: true
    processorStatus?: true
    automationRuleId?: true
    automationExecutionId?: true
    isAutomated?: true
    scheduledFor?: true
    processedAt?: true
    retryCount?: true
    maxRetries?: true
    nextRetryAt?: true
    reconciledAt?: true
    ledgerEntryId?: true
    processingFee?: true
    netAmount?: true
    isDisputed?: true
    disputeReason?: true
    disputedAt?: true
    requiresApproval?: true
    approvedBy?: true
    approvedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    paymentMethodId?: true
    invoiceId?: true
    type?: true
    status?: true
    amount?: true
    currency?: true
    description?: true
    processorId?: true
    processorStatus?: true
    processorResponse?: true
    automationRuleId?: true
    automationExecutionId?: true
    isAutomated?: true
    scheduledFor?: true
    processedAt?: true
    retryCount?: true
    maxRetries?: true
    nextRetryAt?: true
    reconciledAt?: true
    ledgerEntryId?: true
    processingFee?: true
    netAmount?: true
    isDisputed?: true
    disputeReason?: true
    disputedAt?: true
    requiresApproval?: true
    approvedBy?: true
    approvedAt?: true
    metadata?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    tenantId: string
    paymentMethodId: string | null
    invoiceId: string | null
    type: $Enums.PaymentType
    status: $Enums.PaymentStatus
    amount: number
    currency: string
    description: string | null
    processorId: string | null
    processorStatus: string | null
    processorResponse: JsonValue | null
    automationRuleId: string | null
    automationExecutionId: string | null
    isAutomated: boolean
    scheduledFor: Date | null
    processedAt: Date | null
    retryCount: number
    maxRetries: number
    nextRetryAt: Date | null
    reconciledAt: Date | null
    ledgerEntryId: string | null
    processingFee: number | null
    netAmount: number | null
    isDisputed: boolean
    disputeReason: string | null
    disputedAt: Date | null
    requiresApproval: boolean
    approvedBy: string | null
    approvedAt: Date | null
    metadata: JsonValue
    failureReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    paymentMethodId?: boolean
    invoiceId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    processorId?: boolean
    processorStatus?: boolean
    processorResponse?: boolean
    automationRuleId?: boolean
    automationExecutionId?: boolean
    isAutomated?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    nextRetryAt?: boolean
    reconciledAt?: boolean
    ledgerEntryId?: boolean
    processingFee?: boolean
    netAmount?: boolean
    isDisputed?: boolean
    disputeReason?: boolean
    disputedAt?: boolean
    requiresApproval?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    metadata?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Payment$paymentMethodArgs<ExtArgs>
    reconciliation?: boolean | Payment$reconciliationArgs<ExtArgs>
    explainability?: boolean | Payment$explainabilityArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    paymentMethodId?: boolean
    invoiceId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    processorId?: boolean
    processorStatus?: boolean
    processorResponse?: boolean
    automationRuleId?: boolean
    automationExecutionId?: boolean
    isAutomated?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    nextRetryAt?: boolean
    reconciledAt?: boolean
    ledgerEntryId?: boolean
    processingFee?: boolean
    netAmount?: boolean
    isDisputed?: boolean
    disputeReason?: boolean
    disputedAt?: boolean
    requiresApproval?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    metadata?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Payment$paymentMethodArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    paymentMethodId?: boolean
    invoiceId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    processorId?: boolean
    processorStatus?: boolean
    processorResponse?: boolean
    automationRuleId?: boolean
    automationExecutionId?: boolean
    isAutomated?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    nextRetryAt?: boolean
    reconciledAt?: boolean
    ledgerEntryId?: boolean
    processingFee?: boolean
    netAmount?: boolean
    isDisputed?: boolean
    disputeReason?: boolean
    disputedAt?: boolean
    requiresApproval?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    metadata?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Payment$paymentMethodArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    paymentMethodId?: boolean
    invoiceId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    processorId?: boolean
    processorStatus?: boolean
    processorResponse?: boolean
    automationRuleId?: boolean
    automationExecutionId?: boolean
    isAutomated?: boolean
    scheduledFor?: boolean
    processedAt?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    nextRetryAt?: boolean
    reconciledAt?: boolean
    ledgerEntryId?: boolean
    processingFee?: boolean
    netAmount?: boolean
    isDisputed?: boolean
    disputeReason?: boolean
    disputedAt?: boolean
    requiresApproval?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    metadata?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "paymentMethodId" | "invoiceId" | "type" | "status" | "amount" | "currency" | "description" | "processorId" | "processorStatus" | "processorResponse" | "automationRuleId" | "automationExecutionId" | "isAutomated" | "scheduledFor" | "processedAt" | "retryCount" | "maxRetries" | "nextRetryAt" | "reconciledAt" | "ledgerEntryId" | "processingFee" | "netAmount" | "isDisputed" | "disputeReason" | "disputedAt" | "requiresApproval" | "approvedBy" | "approvedAt" | "metadata" | "failureReason" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Payment$paymentMethodArgs<ExtArgs>
    reconciliation?: boolean | Payment$reconciliationArgs<ExtArgs>
    explainability?: boolean | Payment$explainabilityArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Payment$paymentMethodArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    paymentMethod?: boolean | Payment$paymentMethodArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs> | null
      reconciliation: Prisma.$PaymentReconciliationPayload<ExtArgs> | null
      explainability: Prisma.$PaymentExplainabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      paymentMethodId: string | null
      invoiceId: string | null
      type: $Enums.PaymentType
      status: $Enums.PaymentStatus
      amount: number
      currency: string
      description: string | null
      processorId: string | null
      processorStatus: string | null
      processorResponse: Prisma.JsonValue | null
      automationRuleId: string | null
      automationExecutionId: string | null
      isAutomated: boolean
      scheduledFor: Date | null
      processedAt: Date | null
      retryCount: number
      maxRetries: number
      nextRetryAt: Date | null
      reconciledAt: Date | null
      ledgerEntryId: string | null
      processingFee: number | null
      netAmount: number | null
      isDisputed: boolean
      disputeReason: string | null
      disputedAt: Date | null
      requiresApproval: boolean
      approvedBy: string | null
      approvedAt: Date | null
      metadata: Prisma.JsonValue
      failureReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends Payment$paymentMethodArgs<ExtArgs> = {}>(args?: Subset<T, Payment$paymentMethodArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reconciliation<T extends Payment$reconciliationArgs<ExtArgs> = {}>(args?: Subset<T, Payment$reconciliationArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    explainability<T extends Payment$explainabilityArgs<ExtArgs> = {}>(args?: Subset<T, Payment$explainabilityArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly paymentMethodId: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly type: FieldRef<"Payment", 'PaymentType'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly processorId: FieldRef<"Payment", 'String'>
    readonly processorStatus: FieldRef<"Payment", 'String'>
    readonly processorResponse: FieldRef<"Payment", 'Json'>
    readonly automationRuleId: FieldRef<"Payment", 'String'>
    readonly automationExecutionId: FieldRef<"Payment", 'String'>
    readonly isAutomated: FieldRef<"Payment", 'Boolean'>
    readonly scheduledFor: FieldRef<"Payment", 'DateTime'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly retryCount: FieldRef<"Payment", 'Int'>
    readonly maxRetries: FieldRef<"Payment", 'Int'>
    readonly nextRetryAt: FieldRef<"Payment", 'DateTime'>
    readonly reconciledAt: FieldRef<"Payment", 'DateTime'>
    readonly ledgerEntryId: FieldRef<"Payment", 'String'>
    readonly processingFee: FieldRef<"Payment", 'Float'>
    readonly netAmount: FieldRef<"Payment", 'Float'>
    readonly isDisputed: FieldRef<"Payment", 'Boolean'>
    readonly disputeReason: FieldRef<"Payment", 'String'>
    readonly disputedAt: FieldRef<"Payment", 'DateTime'>
    readonly requiresApproval: FieldRef<"Payment", 'Boolean'>
    readonly approvedBy: FieldRef<"Payment", 'String'>
    readonly approvedAt: FieldRef<"Payment", 'DateTime'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly failureReason: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.paymentMethod
   */
  export type Payment$paymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
  }

  /**
   * Payment.reconciliation
   */
  export type Payment$reconciliationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    where?: PaymentReconciliationWhereInput
  }

  /**
   * Payment.explainability
   */
  export type Payment$explainabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    where?: PaymentExplainabilityWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentReconciliation
   */

  export type AggregatePaymentReconciliation = {
    _count: PaymentReconciliationCountAggregateOutputType | null
    _avg: PaymentReconciliationAvgAggregateOutputType | null
    _sum: PaymentReconciliationSumAggregateOutputType | null
    _min: PaymentReconciliationMinAggregateOutputType | null
    _max: PaymentReconciliationMaxAggregateOutputType | null
  }

  export type PaymentReconciliationAvgAggregateOutputType = {
    matchedAmount: number | null
    variance: number | null
  }

  export type PaymentReconciliationSumAggregateOutputType = {
    matchedAmount: number | null
    variance: number | null
  }

  export type PaymentReconciliationMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    tenantId: string | null
    status: $Enums.ReconciliationStatus | null
    ledgerEntryId: string | null
    accountId: string | null
    matchedAmount: number | null
    variance: number | null
    varianceReason: string | null
    reconciledBy: string | null
    reconciledAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentReconciliationMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    tenantId: string | null
    status: $Enums.ReconciliationStatus | null
    ledgerEntryId: string | null
    accountId: string | null
    matchedAmount: number | null
    variance: number | null
    varianceReason: string | null
    reconciledBy: string | null
    reconciledAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentReconciliationCountAggregateOutputType = {
    id: number
    paymentId: number
    tenantId: number
    status: number
    ledgerEntryId: number
    accountId: number
    matchedAmount: number
    variance: number
    varianceReason: number
    reconciledBy: number
    reconciledAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentReconciliationAvgAggregateInputType = {
    matchedAmount?: true
    variance?: true
  }

  export type PaymentReconciliationSumAggregateInputType = {
    matchedAmount?: true
    variance?: true
  }

  export type PaymentReconciliationMinAggregateInputType = {
    id?: true
    paymentId?: true
    tenantId?: true
    status?: true
    ledgerEntryId?: true
    accountId?: true
    matchedAmount?: true
    variance?: true
    varianceReason?: true
    reconciledBy?: true
    reconciledAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentReconciliationMaxAggregateInputType = {
    id?: true
    paymentId?: true
    tenantId?: true
    status?: true
    ledgerEntryId?: true
    accountId?: true
    matchedAmount?: true
    variance?: true
    varianceReason?: true
    reconciledBy?: true
    reconciledAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentReconciliationCountAggregateInputType = {
    id?: true
    paymentId?: true
    tenantId?: true
    status?: true
    ledgerEntryId?: true
    accountId?: true
    matchedAmount?: true
    variance?: true
    varianceReason?: true
    reconciledBy?: true
    reconciledAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentReconciliationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentReconciliation to aggregate.
     */
    where?: PaymentReconciliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReconciliations to fetch.
     */
    orderBy?: PaymentReconciliationOrderByWithRelationInput | PaymentReconciliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentReconciliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReconciliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReconciliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentReconciliations
    **/
    _count?: true | PaymentReconciliationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentReconciliationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentReconciliationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentReconciliationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentReconciliationMaxAggregateInputType
  }

  export type GetPaymentReconciliationAggregateType<T extends PaymentReconciliationAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentReconciliation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentReconciliation[P]>
      : GetScalarType<T[P], AggregatePaymentReconciliation[P]>
  }




  export type PaymentReconciliationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentReconciliationWhereInput
    orderBy?: PaymentReconciliationOrderByWithAggregationInput | PaymentReconciliationOrderByWithAggregationInput[]
    by: PaymentReconciliationScalarFieldEnum[] | PaymentReconciliationScalarFieldEnum
    having?: PaymentReconciliationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentReconciliationCountAggregateInputType | true
    _avg?: PaymentReconciliationAvgAggregateInputType
    _sum?: PaymentReconciliationSumAggregateInputType
    _min?: PaymentReconciliationMinAggregateInputType
    _max?: PaymentReconciliationMaxAggregateInputType
  }

  export type PaymentReconciliationGroupByOutputType = {
    id: string
    paymentId: string
    tenantId: string
    status: $Enums.ReconciliationStatus
    ledgerEntryId: string | null
    accountId: string | null
    matchedAmount: number | null
    variance: number | null
    varianceReason: string | null
    reconciledBy: string | null
    reconciledAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentReconciliationCountAggregateOutputType | null
    _avg: PaymentReconciliationAvgAggregateOutputType | null
    _sum: PaymentReconciliationSumAggregateOutputType | null
    _min: PaymentReconciliationMinAggregateOutputType | null
    _max: PaymentReconciliationMaxAggregateOutputType | null
  }

  type GetPaymentReconciliationGroupByPayload<T extends PaymentReconciliationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentReconciliationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentReconciliationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentReconciliationGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentReconciliationGroupByOutputType[P]>
        }
      >
    >


  export type PaymentReconciliationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    status?: boolean
    ledgerEntryId?: boolean
    accountId?: boolean
    matchedAmount?: boolean
    variance?: boolean
    varianceReason?: boolean
    reconciledBy?: boolean
    reconciledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentReconciliation"]>

  export type PaymentReconciliationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    status?: boolean
    ledgerEntryId?: boolean
    accountId?: boolean
    matchedAmount?: boolean
    variance?: boolean
    varianceReason?: boolean
    reconciledBy?: boolean
    reconciledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentReconciliation"]>

  export type PaymentReconciliationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    status?: boolean
    ledgerEntryId?: boolean
    accountId?: boolean
    matchedAmount?: boolean
    variance?: boolean
    varianceReason?: boolean
    reconciledBy?: boolean
    reconciledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentReconciliation"]>

  export type PaymentReconciliationSelectScalar = {
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    status?: boolean
    ledgerEntryId?: boolean
    accountId?: boolean
    matchedAmount?: boolean
    variance?: boolean
    varianceReason?: boolean
    reconciledBy?: boolean
    reconciledAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentReconciliationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "tenantId" | "status" | "ledgerEntryId" | "accountId" | "matchedAmount" | "variance" | "varianceReason" | "reconciledBy" | "reconciledAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentReconciliation"]>
  export type PaymentReconciliationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentReconciliationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentReconciliationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentReconciliationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentReconciliation"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      tenantId: string
      status: $Enums.ReconciliationStatus
      ledgerEntryId: string | null
      accountId: string | null
      matchedAmount: number | null
      variance: number | null
      varianceReason: string | null
      reconciledBy: string | null
      reconciledAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentReconciliation"]>
    composites: {}
  }

  type PaymentReconciliationGetPayload<S extends boolean | null | undefined | PaymentReconciliationDefaultArgs> = $Result.GetResult<Prisma.$PaymentReconciliationPayload, S>

  type PaymentReconciliationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentReconciliationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentReconciliationCountAggregateInputType | true
    }

  export interface PaymentReconciliationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentReconciliation'], meta: { name: 'PaymentReconciliation' } }
    /**
     * Find zero or one PaymentReconciliation that matches the filter.
     * @param {PaymentReconciliationFindUniqueArgs} args - Arguments to find a PaymentReconciliation
     * @example
     * // Get one PaymentReconciliation
     * const paymentReconciliation = await prisma.paymentReconciliation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentReconciliationFindUniqueArgs>(args: SelectSubset<T, PaymentReconciliationFindUniqueArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentReconciliation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentReconciliationFindUniqueOrThrowArgs} args - Arguments to find a PaymentReconciliation
     * @example
     * // Get one PaymentReconciliation
     * const paymentReconciliation = await prisma.paymentReconciliation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentReconciliationFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentReconciliationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentReconciliation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReconciliationFindFirstArgs} args - Arguments to find a PaymentReconciliation
     * @example
     * // Get one PaymentReconciliation
     * const paymentReconciliation = await prisma.paymentReconciliation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentReconciliationFindFirstArgs>(args?: SelectSubset<T, PaymentReconciliationFindFirstArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentReconciliation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReconciliationFindFirstOrThrowArgs} args - Arguments to find a PaymentReconciliation
     * @example
     * // Get one PaymentReconciliation
     * const paymentReconciliation = await prisma.paymentReconciliation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentReconciliationFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentReconciliationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentReconciliations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReconciliationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentReconciliations
     * const paymentReconciliations = await prisma.paymentReconciliation.findMany()
     * 
     * // Get first 10 PaymentReconciliations
     * const paymentReconciliations = await prisma.paymentReconciliation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentReconciliationWithIdOnly = await prisma.paymentReconciliation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentReconciliationFindManyArgs>(args?: SelectSubset<T, PaymentReconciliationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentReconciliation.
     * @param {PaymentReconciliationCreateArgs} args - Arguments to create a PaymentReconciliation.
     * @example
     * // Create one PaymentReconciliation
     * const PaymentReconciliation = await prisma.paymentReconciliation.create({
     *   data: {
     *     // ... data to create a PaymentReconciliation
     *   }
     * })
     * 
     */
    create<T extends PaymentReconciliationCreateArgs>(args: SelectSubset<T, PaymentReconciliationCreateArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentReconciliations.
     * @param {PaymentReconciliationCreateManyArgs} args - Arguments to create many PaymentReconciliations.
     * @example
     * // Create many PaymentReconciliations
     * const paymentReconciliation = await prisma.paymentReconciliation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentReconciliationCreateManyArgs>(args?: SelectSubset<T, PaymentReconciliationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentReconciliations and returns the data saved in the database.
     * @param {PaymentReconciliationCreateManyAndReturnArgs} args - Arguments to create many PaymentReconciliations.
     * @example
     * // Create many PaymentReconciliations
     * const paymentReconciliation = await prisma.paymentReconciliation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentReconciliations and only return the `id`
     * const paymentReconciliationWithIdOnly = await prisma.paymentReconciliation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentReconciliationCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentReconciliationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentReconciliation.
     * @param {PaymentReconciliationDeleteArgs} args - Arguments to delete one PaymentReconciliation.
     * @example
     * // Delete one PaymentReconciliation
     * const PaymentReconciliation = await prisma.paymentReconciliation.delete({
     *   where: {
     *     // ... filter to delete one PaymentReconciliation
     *   }
     * })
     * 
     */
    delete<T extends PaymentReconciliationDeleteArgs>(args: SelectSubset<T, PaymentReconciliationDeleteArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentReconciliation.
     * @param {PaymentReconciliationUpdateArgs} args - Arguments to update one PaymentReconciliation.
     * @example
     * // Update one PaymentReconciliation
     * const paymentReconciliation = await prisma.paymentReconciliation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentReconciliationUpdateArgs>(args: SelectSubset<T, PaymentReconciliationUpdateArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentReconciliations.
     * @param {PaymentReconciliationDeleteManyArgs} args - Arguments to filter PaymentReconciliations to delete.
     * @example
     * // Delete a few PaymentReconciliations
     * const { count } = await prisma.paymentReconciliation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentReconciliationDeleteManyArgs>(args?: SelectSubset<T, PaymentReconciliationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentReconciliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReconciliationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentReconciliations
     * const paymentReconciliation = await prisma.paymentReconciliation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentReconciliationUpdateManyArgs>(args: SelectSubset<T, PaymentReconciliationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentReconciliations and returns the data updated in the database.
     * @param {PaymentReconciliationUpdateManyAndReturnArgs} args - Arguments to update many PaymentReconciliations.
     * @example
     * // Update many PaymentReconciliations
     * const paymentReconciliation = await prisma.paymentReconciliation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentReconciliations and only return the `id`
     * const paymentReconciliationWithIdOnly = await prisma.paymentReconciliation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentReconciliationUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentReconciliationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentReconciliation.
     * @param {PaymentReconciliationUpsertArgs} args - Arguments to update or create a PaymentReconciliation.
     * @example
     * // Update or create a PaymentReconciliation
     * const paymentReconciliation = await prisma.paymentReconciliation.upsert({
     *   create: {
     *     // ... data to create a PaymentReconciliation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentReconciliation we want to update
     *   }
     * })
     */
    upsert<T extends PaymentReconciliationUpsertArgs>(args: SelectSubset<T, PaymentReconciliationUpsertArgs<ExtArgs>>): Prisma__PaymentReconciliationClient<$Result.GetResult<Prisma.$PaymentReconciliationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentReconciliations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReconciliationCountArgs} args - Arguments to filter PaymentReconciliations to count.
     * @example
     * // Count the number of PaymentReconciliations
     * const count = await prisma.paymentReconciliation.count({
     *   where: {
     *     // ... the filter for the PaymentReconciliations we want to count
     *   }
     * })
    **/
    count<T extends PaymentReconciliationCountArgs>(
      args?: Subset<T, PaymentReconciliationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentReconciliationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentReconciliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReconciliationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentReconciliationAggregateArgs>(args: Subset<T, PaymentReconciliationAggregateArgs>): Prisma.PrismaPromise<GetPaymentReconciliationAggregateType<T>>

    /**
     * Group by PaymentReconciliation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReconciliationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentReconciliationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentReconciliationGroupByArgs['orderBy'] }
        : { orderBy?: PaymentReconciliationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentReconciliationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentReconciliationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentReconciliation model
   */
  readonly fields: PaymentReconciliationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentReconciliation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentReconciliationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentReconciliation model
   */
  interface PaymentReconciliationFieldRefs {
    readonly id: FieldRef<"PaymentReconciliation", 'String'>
    readonly paymentId: FieldRef<"PaymentReconciliation", 'String'>
    readonly tenantId: FieldRef<"PaymentReconciliation", 'String'>
    readonly status: FieldRef<"PaymentReconciliation", 'ReconciliationStatus'>
    readonly ledgerEntryId: FieldRef<"PaymentReconciliation", 'String'>
    readonly accountId: FieldRef<"PaymentReconciliation", 'String'>
    readonly matchedAmount: FieldRef<"PaymentReconciliation", 'Float'>
    readonly variance: FieldRef<"PaymentReconciliation", 'Float'>
    readonly varianceReason: FieldRef<"PaymentReconciliation", 'String'>
    readonly reconciledBy: FieldRef<"PaymentReconciliation", 'String'>
    readonly reconciledAt: FieldRef<"PaymentReconciliation", 'DateTime'>
    readonly notes: FieldRef<"PaymentReconciliation", 'String'>
    readonly createdAt: FieldRef<"PaymentReconciliation", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentReconciliation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentReconciliation findUnique
   */
  export type PaymentReconciliationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReconciliation to fetch.
     */
    where: PaymentReconciliationWhereUniqueInput
  }

  /**
   * PaymentReconciliation findUniqueOrThrow
   */
  export type PaymentReconciliationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReconciliation to fetch.
     */
    where: PaymentReconciliationWhereUniqueInput
  }

  /**
   * PaymentReconciliation findFirst
   */
  export type PaymentReconciliationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReconciliation to fetch.
     */
    where?: PaymentReconciliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReconciliations to fetch.
     */
    orderBy?: PaymentReconciliationOrderByWithRelationInput | PaymentReconciliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentReconciliations.
     */
    cursor?: PaymentReconciliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReconciliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReconciliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentReconciliations.
     */
    distinct?: PaymentReconciliationScalarFieldEnum | PaymentReconciliationScalarFieldEnum[]
  }

  /**
   * PaymentReconciliation findFirstOrThrow
   */
  export type PaymentReconciliationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReconciliation to fetch.
     */
    where?: PaymentReconciliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReconciliations to fetch.
     */
    orderBy?: PaymentReconciliationOrderByWithRelationInput | PaymentReconciliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentReconciliations.
     */
    cursor?: PaymentReconciliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReconciliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReconciliations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentReconciliations.
     */
    distinct?: PaymentReconciliationScalarFieldEnum | PaymentReconciliationScalarFieldEnum[]
  }

  /**
   * PaymentReconciliation findMany
   */
  export type PaymentReconciliationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReconciliations to fetch.
     */
    where?: PaymentReconciliationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReconciliations to fetch.
     */
    orderBy?: PaymentReconciliationOrderByWithRelationInput | PaymentReconciliationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentReconciliations.
     */
    cursor?: PaymentReconciliationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReconciliations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReconciliations.
     */
    skip?: number
    distinct?: PaymentReconciliationScalarFieldEnum | PaymentReconciliationScalarFieldEnum[]
  }

  /**
   * PaymentReconciliation create
   */
  export type PaymentReconciliationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentReconciliation.
     */
    data: XOR<PaymentReconciliationCreateInput, PaymentReconciliationUncheckedCreateInput>
  }

  /**
   * PaymentReconciliation createMany
   */
  export type PaymentReconciliationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentReconciliations.
     */
    data: PaymentReconciliationCreateManyInput | PaymentReconciliationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentReconciliation createManyAndReturn
   */
  export type PaymentReconciliationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentReconciliations.
     */
    data: PaymentReconciliationCreateManyInput | PaymentReconciliationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentReconciliation update
   */
  export type PaymentReconciliationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentReconciliation.
     */
    data: XOR<PaymentReconciliationUpdateInput, PaymentReconciliationUncheckedUpdateInput>
    /**
     * Choose, which PaymentReconciliation to update.
     */
    where: PaymentReconciliationWhereUniqueInput
  }

  /**
   * PaymentReconciliation updateMany
   */
  export type PaymentReconciliationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentReconciliations.
     */
    data: XOR<PaymentReconciliationUpdateManyMutationInput, PaymentReconciliationUncheckedUpdateManyInput>
    /**
     * Filter which PaymentReconciliations to update
     */
    where?: PaymentReconciliationWhereInput
    /**
     * Limit how many PaymentReconciliations to update.
     */
    limit?: number
  }

  /**
   * PaymentReconciliation updateManyAndReturn
   */
  export type PaymentReconciliationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * The data used to update PaymentReconciliations.
     */
    data: XOR<PaymentReconciliationUpdateManyMutationInput, PaymentReconciliationUncheckedUpdateManyInput>
    /**
     * Filter which PaymentReconciliations to update
     */
    where?: PaymentReconciliationWhereInput
    /**
     * Limit how many PaymentReconciliations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentReconciliation upsert
   */
  export type PaymentReconciliationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentReconciliation to update in case it exists.
     */
    where: PaymentReconciliationWhereUniqueInput
    /**
     * In case the PaymentReconciliation found by the `where` argument doesn't exist, create a new PaymentReconciliation with this data.
     */
    create: XOR<PaymentReconciliationCreateInput, PaymentReconciliationUncheckedCreateInput>
    /**
     * In case the PaymentReconciliation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentReconciliationUpdateInput, PaymentReconciliationUncheckedUpdateInput>
  }

  /**
   * PaymentReconciliation delete
   */
  export type PaymentReconciliationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
    /**
     * Filter which PaymentReconciliation to delete.
     */
    where: PaymentReconciliationWhereUniqueInput
  }

  /**
   * PaymentReconciliation deleteMany
   */
  export type PaymentReconciliationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentReconciliations to delete
     */
    where?: PaymentReconciliationWhereInput
    /**
     * Limit how many PaymentReconciliations to delete.
     */
    limit?: number
  }

  /**
   * PaymentReconciliation without action
   */
  export type PaymentReconciliationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReconciliation
     */
    select?: PaymentReconciliationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReconciliation
     */
    omit?: PaymentReconciliationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReconciliationInclude<ExtArgs> | null
  }


  /**
   * Model PaymentExplainability
   */

  export type AggregatePaymentExplainability = {
    _count: PaymentExplainabilityCountAggregateOutputType | null
    _avg: PaymentExplainabilityAvgAggregateOutputType | null
    _sum: PaymentExplainabilitySumAggregateOutputType | null
    _min: PaymentExplainabilityMinAggregateOutputType | null
    _max: PaymentExplainabilityMaxAggregateOutputType | null
  }

  export type PaymentExplainabilityAvgAggregateOutputType = {
    baseAmount: number | null
    confidenceScore: number | null
    estimatedTimeSaved: number | null
  }

  export type PaymentExplainabilitySumAggregateOutputType = {
    baseAmount: number | null
    confidenceScore: number | null
    estimatedTimeSaved: number | null
  }

  export type PaymentExplainabilityMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    tenantId: string | null
    trigger: string | null
    amountCalculation: string | null
    baseAmount: number | null
    confidenceScore: number | null
    approvalRequired: boolean | null
    approvalStatus: string | null
    estimatedTimeSaved: number | null
    explanation: string | null
    createdAt: Date | null
  }

  export type PaymentExplainabilityMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    tenantId: string | null
    trigger: string | null
    amountCalculation: string | null
    baseAmount: number | null
    confidenceScore: number | null
    approvalRequired: boolean | null
    approvalStatus: string | null
    estimatedTimeSaved: number | null
    explanation: string | null
    createdAt: Date | null
  }

  export type PaymentExplainabilityCountAggregateOutputType = {
    id: number
    paymentId: number
    tenantId: number
    trigger: number
    triggerDetails: number
    conditionsMet: number
    amountCalculation: number
    baseAmount: number
    adjustments: number
    confidenceScore: number
    safeguards: number
    riskFactors: number
    approvalRequired: number
    approvalStatus: number
    businessImpact: number
    estimatedTimeSaved: number
    explanation: number
    createdAt: number
    _all: number
  }


  export type PaymentExplainabilityAvgAggregateInputType = {
    baseAmount?: true
    confidenceScore?: true
    estimatedTimeSaved?: true
  }

  export type PaymentExplainabilitySumAggregateInputType = {
    baseAmount?: true
    confidenceScore?: true
    estimatedTimeSaved?: true
  }

  export type PaymentExplainabilityMinAggregateInputType = {
    id?: true
    paymentId?: true
    tenantId?: true
    trigger?: true
    amountCalculation?: true
    baseAmount?: true
    confidenceScore?: true
    approvalRequired?: true
    approvalStatus?: true
    estimatedTimeSaved?: true
    explanation?: true
    createdAt?: true
  }

  export type PaymentExplainabilityMaxAggregateInputType = {
    id?: true
    paymentId?: true
    tenantId?: true
    trigger?: true
    amountCalculation?: true
    baseAmount?: true
    confidenceScore?: true
    approvalRequired?: true
    approvalStatus?: true
    estimatedTimeSaved?: true
    explanation?: true
    createdAt?: true
  }

  export type PaymentExplainabilityCountAggregateInputType = {
    id?: true
    paymentId?: true
    tenantId?: true
    trigger?: true
    triggerDetails?: true
    conditionsMet?: true
    amountCalculation?: true
    baseAmount?: true
    adjustments?: true
    confidenceScore?: true
    safeguards?: true
    riskFactors?: true
    approvalRequired?: true
    approvalStatus?: true
    businessImpact?: true
    estimatedTimeSaved?: true
    explanation?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentExplainabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentExplainability to aggregate.
     */
    where?: PaymentExplainabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentExplainabilities to fetch.
     */
    orderBy?: PaymentExplainabilityOrderByWithRelationInput | PaymentExplainabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentExplainabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentExplainabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentExplainabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentExplainabilities
    **/
    _count?: true | PaymentExplainabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentExplainabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentExplainabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentExplainabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentExplainabilityMaxAggregateInputType
  }

  export type GetPaymentExplainabilityAggregateType<T extends PaymentExplainabilityAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentExplainability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentExplainability[P]>
      : GetScalarType<T[P], AggregatePaymentExplainability[P]>
  }




  export type PaymentExplainabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentExplainabilityWhereInput
    orderBy?: PaymentExplainabilityOrderByWithAggregationInput | PaymentExplainabilityOrderByWithAggregationInput[]
    by: PaymentExplainabilityScalarFieldEnum[] | PaymentExplainabilityScalarFieldEnum
    having?: PaymentExplainabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentExplainabilityCountAggregateInputType | true
    _avg?: PaymentExplainabilityAvgAggregateInputType
    _sum?: PaymentExplainabilitySumAggregateInputType
    _min?: PaymentExplainabilityMinAggregateInputType
    _max?: PaymentExplainabilityMaxAggregateInputType
  }

  export type PaymentExplainabilityGroupByOutputType = {
    id: string
    paymentId: string
    tenantId: string
    trigger: string
    triggerDetails: JsonValue
    conditionsMet: JsonValue
    amountCalculation: string
    baseAmount: number
    adjustments: JsonValue
    confidenceScore: number
    safeguards: JsonValue
    riskFactors: JsonValue
    approvalRequired: boolean
    approvalStatus: string | null
    businessImpact: JsonValue
    estimatedTimeSaved: number | null
    explanation: string
    createdAt: Date
    _count: PaymentExplainabilityCountAggregateOutputType | null
    _avg: PaymentExplainabilityAvgAggregateOutputType | null
    _sum: PaymentExplainabilitySumAggregateOutputType | null
    _min: PaymentExplainabilityMinAggregateOutputType | null
    _max: PaymentExplainabilityMaxAggregateOutputType | null
  }

  type GetPaymentExplainabilityGroupByPayload<T extends PaymentExplainabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentExplainabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentExplainabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentExplainabilityGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentExplainabilityGroupByOutputType[P]>
        }
      >
    >


  export type PaymentExplainabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    trigger?: boolean
    triggerDetails?: boolean
    conditionsMet?: boolean
    amountCalculation?: boolean
    baseAmount?: boolean
    adjustments?: boolean
    confidenceScore?: boolean
    safeguards?: boolean
    riskFactors?: boolean
    approvalRequired?: boolean
    approvalStatus?: boolean
    businessImpact?: boolean
    estimatedTimeSaved?: boolean
    explanation?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentExplainability"]>

  export type PaymentExplainabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    trigger?: boolean
    triggerDetails?: boolean
    conditionsMet?: boolean
    amountCalculation?: boolean
    baseAmount?: boolean
    adjustments?: boolean
    confidenceScore?: boolean
    safeguards?: boolean
    riskFactors?: boolean
    approvalRequired?: boolean
    approvalStatus?: boolean
    businessImpact?: boolean
    estimatedTimeSaved?: boolean
    explanation?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentExplainability"]>

  export type PaymentExplainabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    trigger?: boolean
    triggerDetails?: boolean
    conditionsMet?: boolean
    amountCalculation?: boolean
    baseAmount?: boolean
    adjustments?: boolean
    confidenceScore?: boolean
    safeguards?: boolean
    riskFactors?: boolean
    approvalRequired?: boolean
    approvalStatus?: boolean
    businessImpact?: boolean
    estimatedTimeSaved?: boolean
    explanation?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentExplainability"]>

  export type PaymentExplainabilitySelectScalar = {
    id?: boolean
    paymentId?: boolean
    tenantId?: boolean
    trigger?: boolean
    triggerDetails?: boolean
    conditionsMet?: boolean
    amountCalculation?: boolean
    baseAmount?: boolean
    adjustments?: boolean
    confidenceScore?: boolean
    safeguards?: boolean
    riskFactors?: boolean
    approvalRequired?: boolean
    approvalStatus?: boolean
    businessImpact?: boolean
    estimatedTimeSaved?: boolean
    explanation?: boolean
    createdAt?: boolean
  }

  export type PaymentExplainabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "tenantId" | "trigger" | "triggerDetails" | "conditionsMet" | "amountCalculation" | "baseAmount" | "adjustments" | "confidenceScore" | "safeguards" | "riskFactors" | "approvalRequired" | "approvalStatus" | "businessImpact" | "estimatedTimeSaved" | "explanation" | "createdAt", ExtArgs["result"]["paymentExplainability"]>
  export type PaymentExplainabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentExplainabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentExplainabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentExplainabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentExplainability"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      tenantId: string
      trigger: string
      triggerDetails: Prisma.JsonValue
      conditionsMet: Prisma.JsonValue
      amountCalculation: string
      baseAmount: number
      adjustments: Prisma.JsonValue
      confidenceScore: number
      safeguards: Prisma.JsonValue
      riskFactors: Prisma.JsonValue
      approvalRequired: boolean
      approvalStatus: string | null
      businessImpact: Prisma.JsonValue
      estimatedTimeSaved: number | null
      explanation: string
      createdAt: Date
    }, ExtArgs["result"]["paymentExplainability"]>
    composites: {}
  }

  type PaymentExplainabilityGetPayload<S extends boolean | null | undefined | PaymentExplainabilityDefaultArgs> = $Result.GetResult<Prisma.$PaymentExplainabilityPayload, S>

  type PaymentExplainabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentExplainabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentExplainabilityCountAggregateInputType | true
    }

  export interface PaymentExplainabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentExplainability'], meta: { name: 'PaymentExplainability' } }
    /**
     * Find zero or one PaymentExplainability that matches the filter.
     * @param {PaymentExplainabilityFindUniqueArgs} args - Arguments to find a PaymentExplainability
     * @example
     * // Get one PaymentExplainability
     * const paymentExplainability = await prisma.paymentExplainability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentExplainabilityFindUniqueArgs>(args: SelectSubset<T, PaymentExplainabilityFindUniqueArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentExplainability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentExplainabilityFindUniqueOrThrowArgs} args - Arguments to find a PaymentExplainability
     * @example
     * // Get one PaymentExplainability
     * const paymentExplainability = await prisma.paymentExplainability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentExplainabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentExplainabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentExplainability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentExplainabilityFindFirstArgs} args - Arguments to find a PaymentExplainability
     * @example
     * // Get one PaymentExplainability
     * const paymentExplainability = await prisma.paymentExplainability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentExplainabilityFindFirstArgs>(args?: SelectSubset<T, PaymentExplainabilityFindFirstArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentExplainability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentExplainabilityFindFirstOrThrowArgs} args - Arguments to find a PaymentExplainability
     * @example
     * // Get one PaymentExplainability
     * const paymentExplainability = await prisma.paymentExplainability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentExplainabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentExplainabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentExplainabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentExplainabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentExplainabilities
     * const paymentExplainabilities = await prisma.paymentExplainability.findMany()
     * 
     * // Get first 10 PaymentExplainabilities
     * const paymentExplainabilities = await prisma.paymentExplainability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentExplainabilityWithIdOnly = await prisma.paymentExplainability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentExplainabilityFindManyArgs>(args?: SelectSubset<T, PaymentExplainabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentExplainability.
     * @param {PaymentExplainabilityCreateArgs} args - Arguments to create a PaymentExplainability.
     * @example
     * // Create one PaymentExplainability
     * const PaymentExplainability = await prisma.paymentExplainability.create({
     *   data: {
     *     // ... data to create a PaymentExplainability
     *   }
     * })
     * 
     */
    create<T extends PaymentExplainabilityCreateArgs>(args: SelectSubset<T, PaymentExplainabilityCreateArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentExplainabilities.
     * @param {PaymentExplainabilityCreateManyArgs} args - Arguments to create many PaymentExplainabilities.
     * @example
     * // Create many PaymentExplainabilities
     * const paymentExplainability = await prisma.paymentExplainability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentExplainabilityCreateManyArgs>(args?: SelectSubset<T, PaymentExplainabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentExplainabilities and returns the data saved in the database.
     * @param {PaymentExplainabilityCreateManyAndReturnArgs} args - Arguments to create many PaymentExplainabilities.
     * @example
     * // Create many PaymentExplainabilities
     * const paymentExplainability = await prisma.paymentExplainability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentExplainabilities and only return the `id`
     * const paymentExplainabilityWithIdOnly = await prisma.paymentExplainability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentExplainabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentExplainabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentExplainability.
     * @param {PaymentExplainabilityDeleteArgs} args - Arguments to delete one PaymentExplainability.
     * @example
     * // Delete one PaymentExplainability
     * const PaymentExplainability = await prisma.paymentExplainability.delete({
     *   where: {
     *     // ... filter to delete one PaymentExplainability
     *   }
     * })
     * 
     */
    delete<T extends PaymentExplainabilityDeleteArgs>(args: SelectSubset<T, PaymentExplainabilityDeleteArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentExplainability.
     * @param {PaymentExplainabilityUpdateArgs} args - Arguments to update one PaymentExplainability.
     * @example
     * // Update one PaymentExplainability
     * const paymentExplainability = await prisma.paymentExplainability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentExplainabilityUpdateArgs>(args: SelectSubset<T, PaymentExplainabilityUpdateArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentExplainabilities.
     * @param {PaymentExplainabilityDeleteManyArgs} args - Arguments to filter PaymentExplainabilities to delete.
     * @example
     * // Delete a few PaymentExplainabilities
     * const { count } = await prisma.paymentExplainability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentExplainabilityDeleteManyArgs>(args?: SelectSubset<T, PaymentExplainabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentExplainabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentExplainabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentExplainabilities
     * const paymentExplainability = await prisma.paymentExplainability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentExplainabilityUpdateManyArgs>(args: SelectSubset<T, PaymentExplainabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentExplainabilities and returns the data updated in the database.
     * @param {PaymentExplainabilityUpdateManyAndReturnArgs} args - Arguments to update many PaymentExplainabilities.
     * @example
     * // Update many PaymentExplainabilities
     * const paymentExplainability = await prisma.paymentExplainability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentExplainabilities and only return the `id`
     * const paymentExplainabilityWithIdOnly = await prisma.paymentExplainability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentExplainabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentExplainabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentExplainability.
     * @param {PaymentExplainabilityUpsertArgs} args - Arguments to update or create a PaymentExplainability.
     * @example
     * // Update or create a PaymentExplainability
     * const paymentExplainability = await prisma.paymentExplainability.upsert({
     *   create: {
     *     // ... data to create a PaymentExplainability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentExplainability we want to update
     *   }
     * })
     */
    upsert<T extends PaymentExplainabilityUpsertArgs>(args: SelectSubset<T, PaymentExplainabilityUpsertArgs<ExtArgs>>): Prisma__PaymentExplainabilityClient<$Result.GetResult<Prisma.$PaymentExplainabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentExplainabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentExplainabilityCountArgs} args - Arguments to filter PaymentExplainabilities to count.
     * @example
     * // Count the number of PaymentExplainabilities
     * const count = await prisma.paymentExplainability.count({
     *   where: {
     *     // ... the filter for the PaymentExplainabilities we want to count
     *   }
     * })
    **/
    count<T extends PaymentExplainabilityCountArgs>(
      args?: Subset<T, PaymentExplainabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentExplainabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentExplainability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentExplainabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentExplainabilityAggregateArgs>(args: Subset<T, PaymentExplainabilityAggregateArgs>): Prisma.PrismaPromise<GetPaymentExplainabilityAggregateType<T>>

    /**
     * Group by PaymentExplainability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentExplainabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentExplainabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentExplainabilityGroupByArgs['orderBy'] }
        : { orderBy?: PaymentExplainabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentExplainabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentExplainabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentExplainability model
   */
  readonly fields: PaymentExplainabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentExplainability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentExplainabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentExplainability model
   */
  interface PaymentExplainabilityFieldRefs {
    readonly id: FieldRef<"PaymentExplainability", 'String'>
    readonly paymentId: FieldRef<"PaymentExplainability", 'String'>
    readonly tenantId: FieldRef<"PaymentExplainability", 'String'>
    readonly trigger: FieldRef<"PaymentExplainability", 'String'>
    readonly triggerDetails: FieldRef<"PaymentExplainability", 'Json'>
    readonly conditionsMet: FieldRef<"PaymentExplainability", 'Json'>
    readonly amountCalculation: FieldRef<"PaymentExplainability", 'String'>
    readonly baseAmount: FieldRef<"PaymentExplainability", 'Float'>
    readonly adjustments: FieldRef<"PaymentExplainability", 'Json'>
    readonly confidenceScore: FieldRef<"PaymentExplainability", 'Float'>
    readonly safeguards: FieldRef<"PaymentExplainability", 'Json'>
    readonly riskFactors: FieldRef<"PaymentExplainability", 'Json'>
    readonly approvalRequired: FieldRef<"PaymentExplainability", 'Boolean'>
    readonly approvalStatus: FieldRef<"PaymentExplainability", 'String'>
    readonly businessImpact: FieldRef<"PaymentExplainability", 'Json'>
    readonly estimatedTimeSaved: FieldRef<"PaymentExplainability", 'Int'>
    readonly explanation: FieldRef<"PaymentExplainability", 'String'>
    readonly createdAt: FieldRef<"PaymentExplainability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentExplainability findUnique
   */
  export type PaymentExplainabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * Filter, which PaymentExplainability to fetch.
     */
    where: PaymentExplainabilityWhereUniqueInput
  }

  /**
   * PaymentExplainability findUniqueOrThrow
   */
  export type PaymentExplainabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * Filter, which PaymentExplainability to fetch.
     */
    where: PaymentExplainabilityWhereUniqueInput
  }

  /**
   * PaymentExplainability findFirst
   */
  export type PaymentExplainabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * Filter, which PaymentExplainability to fetch.
     */
    where?: PaymentExplainabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentExplainabilities to fetch.
     */
    orderBy?: PaymentExplainabilityOrderByWithRelationInput | PaymentExplainabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentExplainabilities.
     */
    cursor?: PaymentExplainabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentExplainabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentExplainabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentExplainabilities.
     */
    distinct?: PaymentExplainabilityScalarFieldEnum | PaymentExplainabilityScalarFieldEnum[]
  }

  /**
   * PaymentExplainability findFirstOrThrow
   */
  export type PaymentExplainabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * Filter, which PaymentExplainability to fetch.
     */
    where?: PaymentExplainabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentExplainabilities to fetch.
     */
    orderBy?: PaymentExplainabilityOrderByWithRelationInput | PaymentExplainabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentExplainabilities.
     */
    cursor?: PaymentExplainabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentExplainabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentExplainabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentExplainabilities.
     */
    distinct?: PaymentExplainabilityScalarFieldEnum | PaymentExplainabilityScalarFieldEnum[]
  }

  /**
   * PaymentExplainability findMany
   */
  export type PaymentExplainabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * Filter, which PaymentExplainabilities to fetch.
     */
    where?: PaymentExplainabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentExplainabilities to fetch.
     */
    orderBy?: PaymentExplainabilityOrderByWithRelationInput | PaymentExplainabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentExplainabilities.
     */
    cursor?: PaymentExplainabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentExplainabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentExplainabilities.
     */
    skip?: number
    distinct?: PaymentExplainabilityScalarFieldEnum | PaymentExplainabilityScalarFieldEnum[]
  }

  /**
   * PaymentExplainability create
   */
  export type PaymentExplainabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentExplainability.
     */
    data: XOR<PaymentExplainabilityCreateInput, PaymentExplainabilityUncheckedCreateInput>
  }

  /**
   * PaymentExplainability createMany
   */
  export type PaymentExplainabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentExplainabilities.
     */
    data: PaymentExplainabilityCreateManyInput | PaymentExplainabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentExplainability createManyAndReturn
   */
  export type PaymentExplainabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentExplainabilities.
     */
    data: PaymentExplainabilityCreateManyInput | PaymentExplainabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentExplainability update
   */
  export type PaymentExplainabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentExplainability.
     */
    data: XOR<PaymentExplainabilityUpdateInput, PaymentExplainabilityUncheckedUpdateInput>
    /**
     * Choose, which PaymentExplainability to update.
     */
    where: PaymentExplainabilityWhereUniqueInput
  }

  /**
   * PaymentExplainability updateMany
   */
  export type PaymentExplainabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentExplainabilities.
     */
    data: XOR<PaymentExplainabilityUpdateManyMutationInput, PaymentExplainabilityUncheckedUpdateManyInput>
    /**
     * Filter which PaymentExplainabilities to update
     */
    where?: PaymentExplainabilityWhereInput
    /**
     * Limit how many PaymentExplainabilities to update.
     */
    limit?: number
  }

  /**
   * PaymentExplainability updateManyAndReturn
   */
  export type PaymentExplainabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * The data used to update PaymentExplainabilities.
     */
    data: XOR<PaymentExplainabilityUpdateManyMutationInput, PaymentExplainabilityUncheckedUpdateManyInput>
    /**
     * Filter which PaymentExplainabilities to update
     */
    where?: PaymentExplainabilityWhereInput
    /**
     * Limit how many PaymentExplainabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentExplainability upsert
   */
  export type PaymentExplainabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentExplainability to update in case it exists.
     */
    where: PaymentExplainabilityWhereUniqueInput
    /**
     * In case the PaymentExplainability found by the `where` argument doesn't exist, create a new PaymentExplainability with this data.
     */
    create: XOR<PaymentExplainabilityCreateInput, PaymentExplainabilityUncheckedCreateInput>
    /**
     * In case the PaymentExplainability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentExplainabilityUpdateInput, PaymentExplainabilityUncheckedUpdateInput>
  }

  /**
   * PaymentExplainability delete
   */
  export type PaymentExplainabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
    /**
     * Filter which PaymentExplainability to delete.
     */
    where: PaymentExplainabilityWhereUniqueInput
  }

  /**
   * PaymentExplainability deleteMany
   */
  export type PaymentExplainabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentExplainabilities to delete
     */
    where?: PaymentExplainabilityWhereInput
    /**
     * Limit how many PaymentExplainabilities to delete.
     */
    limit?: number
  }

  /**
   * PaymentExplainability without action
   */
  export type PaymentExplainabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentExplainability
     */
    select?: PaymentExplainabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentExplainability
     */
    omit?: PaymentExplainabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentExplainabilityInclude<ExtArgs> | null
  }


  /**
   * Model CashControlRule
   */

  export type AggregateCashControlRule = {
    _count: CashControlRuleCountAggregateOutputType | null
    _avg: CashControlRuleAvgAggregateOutputType | null
    _sum: CashControlRuleSumAggregateOutputType | null
    _min: CashControlRuleMinAggregateOutputType | null
    _max: CashControlRuleMaxAggregateOutputType | null
  }

  export type CashControlRuleAvgAggregateOutputType = {
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
    totalAmountProcessed: number | null
  }

  export type CashControlRuleSumAggregateOutputType = {
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
    totalAmountProcessed: number | null
  }

  export type CashControlRuleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    ruleType: $Enums.CashControlRuleType | null
    isActive: boolean | null
    requiresApproval: boolean | null
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
    totalAmountProcessed: number | null
    createdBy: string | null
    lastExecuted: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashControlRuleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    ruleType: $Enums.CashControlRuleType | null
    isActive: boolean | null
    requiresApproval: boolean | null
    executionCount: number | null
    successCount: number | null
    failureCount: number | null
    totalAmountProcessed: number | null
    createdBy: string | null
    lastExecuted: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashControlRuleCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    ruleType: number
    config: number
    conditions: number
    isActive: number
    requiresApproval: number
    executionCount: number
    successCount: number
    failureCount: number
    totalAmountProcessed: number
    createdBy: number
    lastExecuted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashControlRuleAvgAggregateInputType = {
    executionCount?: true
    successCount?: true
    failureCount?: true
    totalAmountProcessed?: true
  }

  export type CashControlRuleSumAggregateInputType = {
    executionCount?: true
    successCount?: true
    failureCount?: true
    totalAmountProcessed?: true
  }

  export type CashControlRuleMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    ruleType?: true
    isActive?: true
    requiresApproval?: true
    executionCount?: true
    successCount?: true
    failureCount?: true
    totalAmountProcessed?: true
    createdBy?: true
    lastExecuted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashControlRuleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    ruleType?: true
    isActive?: true
    requiresApproval?: true
    executionCount?: true
    successCount?: true
    failureCount?: true
    totalAmountProcessed?: true
    createdBy?: true
    lastExecuted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashControlRuleCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    ruleType?: true
    config?: true
    conditions?: true
    isActive?: true
    requiresApproval?: true
    executionCount?: true
    successCount?: true
    failureCount?: true
    totalAmountProcessed?: true
    createdBy?: true
    lastExecuted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashControlRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashControlRule to aggregate.
     */
    where?: CashControlRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlRules to fetch.
     */
    orderBy?: CashControlRuleOrderByWithRelationInput | CashControlRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashControlRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashControlRules
    **/
    _count?: true | CashControlRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashControlRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashControlRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashControlRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashControlRuleMaxAggregateInputType
  }

  export type GetCashControlRuleAggregateType<T extends CashControlRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCashControlRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashControlRule[P]>
      : GetScalarType<T[P], AggregateCashControlRule[P]>
  }




  export type CashControlRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashControlRuleWhereInput
    orderBy?: CashControlRuleOrderByWithAggregationInput | CashControlRuleOrderByWithAggregationInput[]
    by: CashControlRuleScalarFieldEnum[] | CashControlRuleScalarFieldEnum
    having?: CashControlRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashControlRuleCountAggregateInputType | true
    _avg?: CashControlRuleAvgAggregateInputType
    _sum?: CashControlRuleSumAggregateInputType
    _min?: CashControlRuleMinAggregateInputType
    _max?: CashControlRuleMaxAggregateInputType
  }

  export type CashControlRuleGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    ruleType: $Enums.CashControlRuleType
    config: JsonValue
    conditions: JsonValue
    isActive: boolean
    requiresApproval: boolean
    executionCount: number
    successCount: number
    failureCount: number
    totalAmountProcessed: number
    createdBy: string
    lastExecuted: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CashControlRuleCountAggregateOutputType | null
    _avg: CashControlRuleAvgAggregateOutputType | null
    _sum: CashControlRuleSumAggregateOutputType | null
    _min: CashControlRuleMinAggregateOutputType | null
    _max: CashControlRuleMaxAggregateOutputType | null
  }

  type GetCashControlRuleGroupByPayload<T extends CashControlRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashControlRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashControlRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashControlRuleGroupByOutputType[P]>
            : GetScalarType<T[P], CashControlRuleGroupByOutputType[P]>
        }
      >
    >


  export type CashControlRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    config?: boolean
    conditions?: boolean
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    totalAmountProcessed?: boolean
    createdBy?: boolean
    lastExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    executions?: boolean | CashControlRule$executionsArgs<ExtArgs>
    _count?: boolean | CashControlRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashControlRule"]>

  export type CashControlRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    config?: boolean
    conditions?: boolean
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    totalAmountProcessed?: boolean
    createdBy?: boolean
    lastExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashControlRule"]>

  export type CashControlRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    config?: boolean
    conditions?: boolean
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    totalAmountProcessed?: boolean
    createdBy?: boolean
    lastExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashControlRule"]>

  export type CashControlRuleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    config?: boolean
    conditions?: boolean
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: boolean
    successCount?: boolean
    failureCount?: boolean
    totalAmountProcessed?: boolean
    createdBy?: boolean
    lastExecuted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashControlRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "ruleType" | "config" | "conditions" | "isActive" | "requiresApproval" | "executionCount" | "successCount" | "failureCount" | "totalAmountProcessed" | "createdBy" | "lastExecuted" | "createdAt" | "updatedAt", ExtArgs["result"]["cashControlRule"]>
  export type CashControlRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    executions?: boolean | CashControlRule$executionsArgs<ExtArgs>
    _count?: boolean | CashControlRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CashControlRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CashControlRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CashControlRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashControlRule"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      executions: Prisma.$CashControlExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      ruleType: $Enums.CashControlRuleType
      config: Prisma.JsonValue
      conditions: Prisma.JsonValue
      isActive: boolean
      requiresApproval: boolean
      executionCount: number
      successCount: number
      failureCount: number
      totalAmountProcessed: number
      createdBy: string
      lastExecuted: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashControlRule"]>
    composites: {}
  }

  type CashControlRuleGetPayload<S extends boolean | null | undefined | CashControlRuleDefaultArgs> = $Result.GetResult<Prisma.$CashControlRulePayload, S>

  type CashControlRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashControlRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashControlRuleCountAggregateInputType | true
    }

  export interface CashControlRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashControlRule'], meta: { name: 'CashControlRule' } }
    /**
     * Find zero or one CashControlRule that matches the filter.
     * @param {CashControlRuleFindUniqueArgs} args - Arguments to find a CashControlRule
     * @example
     * // Get one CashControlRule
     * const cashControlRule = await prisma.cashControlRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashControlRuleFindUniqueArgs>(args: SelectSubset<T, CashControlRuleFindUniqueArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashControlRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashControlRuleFindUniqueOrThrowArgs} args - Arguments to find a CashControlRule
     * @example
     * // Get one CashControlRule
     * const cashControlRule = await prisma.cashControlRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashControlRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CashControlRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashControlRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlRuleFindFirstArgs} args - Arguments to find a CashControlRule
     * @example
     * // Get one CashControlRule
     * const cashControlRule = await prisma.cashControlRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashControlRuleFindFirstArgs>(args?: SelectSubset<T, CashControlRuleFindFirstArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashControlRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlRuleFindFirstOrThrowArgs} args - Arguments to find a CashControlRule
     * @example
     * // Get one CashControlRule
     * const cashControlRule = await prisma.cashControlRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashControlRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CashControlRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashControlRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashControlRules
     * const cashControlRules = await prisma.cashControlRule.findMany()
     * 
     * // Get first 10 CashControlRules
     * const cashControlRules = await prisma.cashControlRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashControlRuleWithIdOnly = await prisma.cashControlRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashControlRuleFindManyArgs>(args?: SelectSubset<T, CashControlRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashControlRule.
     * @param {CashControlRuleCreateArgs} args - Arguments to create a CashControlRule.
     * @example
     * // Create one CashControlRule
     * const CashControlRule = await prisma.cashControlRule.create({
     *   data: {
     *     // ... data to create a CashControlRule
     *   }
     * })
     * 
     */
    create<T extends CashControlRuleCreateArgs>(args: SelectSubset<T, CashControlRuleCreateArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashControlRules.
     * @param {CashControlRuleCreateManyArgs} args - Arguments to create many CashControlRules.
     * @example
     * // Create many CashControlRules
     * const cashControlRule = await prisma.cashControlRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashControlRuleCreateManyArgs>(args?: SelectSubset<T, CashControlRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashControlRules and returns the data saved in the database.
     * @param {CashControlRuleCreateManyAndReturnArgs} args - Arguments to create many CashControlRules.
     * @example
     * // Create many CashControlRules
     * const cashControlRule = await prisma.cashControlRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashControlRules and only return the `id`
     * const cashControlRuleWithIdOnly = await prisma.cashControlRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashControlRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CashControlRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashControlRule.
     * @param {CashControlRuleDeleteArgs} args - Arguments to delete one CashControlRule.
     * @example
     * // Delete one CashControlRule
     * const CashControlRule = await prisma.cashControlRule.delete({
     *   where: {
     *     // ... filter to delete one CashControlRule
     *   }
     * })
     * 
     */
    delete<T extends CashControlRuleDeleteArgs>(args: SelectSubset<T, CashControlRuleDeleteArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashControlRule.
     * @param {CashControlRuleUpdateArgs} args - Arguments to update one CashControlRule.
     * @example
     * // Update one CashControlRule
     * const cashControlRule = await prisma.cashControlRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashControlRuleUpdateArgs>(args: SelectSubset<T, CashControlRuleUpdateArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashControlRules.
     * @param {CashControlRuleDeleteManyArgs} args - Arguments to filter CashControlRules to delete.
     * @example
     * // Delete a few CashControlRules
     * const { count } = await prisma.cashControlRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashControlRuleDeleteManyArgs>(args?: SelectSubset<T, CashControlRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashControlRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashControlRules
     * const cashControlRule = await prisma.cashControlRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashControlRuleUpdateManyArgs>(args: SelectSubset<T, CashControlRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashControlRules and returns the data updated in the database.
     * @param {CashControlRuleUpdateManyAndReturnArgs} args - Arguments to update many CashControlRules.
     * @example
     * // Update many CashControlRules
     * const cashControlRule = await prisma.cashControlRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashControlRules and only return the `id`
     * const cashControlRuleWithIdOnly = await prisma.cashControlRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashControlRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, CashControlRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashControlRule.
     * @param {CashControlRuleUpsertArgs} args - Arguments to update or create a CashControlRule.
     * @example
     * // Update or create a CashControlRule
     * const cashControlRule = await prisma.cashControlRule.upsert({
     *   create: {
     *     // ... data to create a CashControlRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashControlRule we want to update
     *   }
     * })
     */
    upsert<T extends CashControlRuleUpsertArgs>(args: SelectSubset<T, CashControlRuleUpsertArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashControlRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlRuleCountArgs} args - Arguments to filter CashControlRules to count.
     * @example
     * // Count the number of CashControlRules
     * const count = await prisma.cashControlRule.count({
     *   where: {
     *     // ... the filter for the CashControlRules we want to count
     *   }
     * })
    **/
    count<T extends CashControlRuleCountArgs>(
      args?: Subset<T, CashControlRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashControlRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashControlRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashControlRuleAggregateArgs>(args: Subset<T, CashControlRuleAggregateArgs>): Prisma.PrismaPromise<GetCashControlRuleAggregateType<T>>

    /**
     * Group by CashControlRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashControlRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashControlRuleGroupByArgs['orderBy'] }
        : { orderBy?: CashControlRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashControlRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashControlRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashControlRule model
   */
  readonly fields: CashControlRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashControlRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashControlRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executions<T extends CashControlRule$executionsArgs<ExtArgs> = {}>(args?: Subset<T, CashControlRule$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashControlRule model
   */
  interface CashControlRuleFieldRefs {
    readonly id: FieldRef<"CashControlRule", 'String'>
    readonly tenantId: FieldRef<"CashControlRule", 'String'>
    readonly name: FieldRef<"CashControlRule", 'String'>
    readonly description: FieldRef<"CashControlRule", 'String'>
    readonly ruleType: FieldRef<"CashControlRule", 'CashControlRuleType'>
    readonly config: FieldRef<"CashControlRule", 'Json'>
    readonly conditions: FieldRef<"CashControlRule", 'Json'>
    readonly isActive: FieldRef<"CashControlRule", 'Boolean'>
    readonly requiresApproval: FieldRef<"CashControlRule", 'Boolean'>
    readonly executionCount: FieldRef<"CashControlRule", 'Int'>
    readonly successCount: FieldRef<"CashControlRule", 'Int'>
    readonly failureCount: FieldRef<"CashControlRule", 'Int'>
    readonly totalAmountProcessed: FieldRef<"CashControlRule", 'Float'>
    readonly createdBy: FieldRef<"CashControlRule", 'String'>
    readonly lastExecuted: FieldRef<"CashControlRule", 'DateTime'>
    readonly createdAt: FieldRef<"CashControlRule", 'DateTime'>
    readonly updatedAt: FieldRef<"CashControlRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashControlRule findUnique
   */
  export type CashControlRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * Filter, which CashControlRule to fetch.
     */
    where: CashControlRuleWhereUniqueInput
  }

  /**
   * CashControlRule findUniqueOrThrow
   */
  export type CashControlRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * Filter, which CashControlRule to fetch.
     */
    where: CashControlRuleWhereUniqueInput
  }

  /**
   * CashControlRule findFirst
   */
  export type CashControlRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * Filter, which CashControlRule to fetch.
     */
    where?: CashControlRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlRules to fetch.
     */
    orderBy?: CashControlRuleOrderByWithRelationInput | CashControlRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashControlRules.
     */
    cursor?: CashControlRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashControlRules.
     */
    distinct?: CashControlRuleScalarFieldEnum | CashControlRuleScalarFieldEnum[]
  }

  /**
   * CashControlRule findFirstOrThrow
   */
  export type CashControlRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * Filter, which CashControlRule to fetch.
     */
    where?: CashControlRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlRules to fetch.
     */
    orderBy?: CashControlRuleOrderByWithRelationInput | CashControlRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashControlRules.
     */
    cursor?: CashControlRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashControlRules.
     */
    distinct?: CashControlRuleScalarFieldEnum | CashControlRuleScalarFieldEnum[]
  }

  /**
   * CashControlRule findMany
   */
  export type CashControlRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * Filter, which CashControlRules to fetch.
     */
    where?: CashControlRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlRules to fetch.
     */
    orderBy?: CashControlRuleOrderByWithRelationInput | CashControlRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashControlRules.
     */
    cursor?: CashControlRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlRules.
     */
    skip?: number
    distinct?: CashControlRuleScalarFieldEnum | CashControlRuleScalarFieldEnum[]
  }

  /**
   * CashControlRule create
   */
  export type CashControlRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CashControlRule.
     */
    data: XOR<CashControlRuleCreateInput, CashControlRuleUncheckedCreateInput>
  }

  /**
   * CashControlRule createMany
   */
  export type CashControlRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashControlRules.
     */
    data: CashControlRuleCreateManyInput | CashControlRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashControlRule createManyAndReturn
   */
  export type CashControlRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * The data used to create many CashControlRules.
     */
    data: CashControlRuleCreateManyInput | CashControlRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashControlRule update
   */
  export type CashControlRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CashControlRule.
     */
    data: XOR<CashControlRuleUpdateInput, CashControlRuleUncheckedUpdateInput>
    /**
     * Choose, which CashControlRule to update.
     */
    where: CashControlRuleWhereUniqueInput
  }

  /**
   * CashControlRule updateMany
   */
  export type CashControlRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashControlRules.
     */
    data: XOR<CashControlRuleUpdateManyMutationInput, CashControlRuleUncheckedUpdateManyInput>
    /**
     * Filter which CashControlRules to update
     */
    where?: CashControlRuleWhereInput
    /**
     * Limit how many CashControlRules to update.
     */
    limit?: number
  }

  /**
   * CashControlRule updateManyAndReturn
   */
  export type CashControlRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * The data used to update CashControlRules.
     */
    data: XOR<CashControlRuleUpdateManyMutationInput, CashControlRuleUncheckedUpdateManyInput>
    /**
     * Filter which CashControlRules to update
     */
    where?: CashControlRuleWhereInput
    /**
     * Limit how many CashControlRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashControlRule upsert
   */
  export type CashControlRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CashControlRule to update in case it exists.
     */
    where: CashControlRuleWhereUniqueInput
    /**
     * In case the CashControlRule found by the `where` argument doesn't exist, create a new CashControlRule with this data.
     */
    create: XOR<CashControlRuleCreateInput, CashControlRuleUncheckedCreateInput>
    /**
     * In case the CashControlRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashControlRuleUpdateInput, CashControlRuleUncheckedUpdateInput>
  }

  /**
   * CashControlRule delete
   */
  export type CashControlRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
    /**
     * Filter which CashControlRule to delete.
     */
    where: CashControlRuleWhereUniqueInput
  }

  /**
   * CashControlRule deleteMany
   */
  export type CashControlRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashControlRules to delete
     */
    where?: CashControlRuleWhereInput
    /**
     * Limit how many CashControlRules to delete.
     */
    limit?: number
  }

  /**
   * CashControlRule.executions
   */
  export type CashControlRule$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    where?: CashControlExecutionWhereInput
    orderBy?: CashControlExecutionOrderByWithRelationInput | CashControlExecutionOrderByWithRelationInput[]
    cursor?: CashControlExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashControlExecutionScalarFieldEnum | CashControlExecutionScalarFieldEnum[]
  }

  /**
   * CashControlRule without action
   */
  export type CashControlRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlRule
     */
    select?: CashControlRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlRule
     */
    omit?: CashControlRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlRuleInclude<ExtArgs> | null
  }


  /**
   * Model CashControlExecution
   */

  export type AggregateCashControlExecution = {
    _count: CashControlExecutionCountAggregateOutputType | null
    _avg: CashControlExecutionAvgAggregateOutputType | null
    _sum: CashControlExecutionSumAggregateOutputType | null
    _min: CashControlExecutionMinAggregateOutputType | null
    _max: CashControlExecutionMaxAggregateOutputType | null
  }

  export type CashControlExecutionAvgAggregateOutputType = {
    amount: number | null
    executionTime: number | null
  }

  export type CashControlExecutionSumAggregateOutputType = {
    amount: number | null
    executionTime: number | null
  }

  export type CashControlExecutionMinAggregateOutputType = {
    id: string | null
    ruleId: string | null
    tenantId: string | null
    status: string | null
    paymentId: string | null
    amount: number | null
    success: boolean | null
    errorMessage: string | null
    executionTime: number | null
    isDryRun: boolean | null
    createdAt: Date | null
  }

  export type CashControlExecutionMaxAggregateOutputType = {
    id: string | null
    ruleId: string | null
    tenantId: string | null
    status: string | null
    paymentId: string | null
    amount: number | null
    success: boolean | null
    errorMessage: string | null
    executionTime: number | null
    isDryRun: boolean | null
    createdAt: Date | null
  }

  export type CashControlExecutionCountAggregateOutputType = {
    id: number
    ruleId: number
    tenantId: number
    status: number
    triggerData: number
    conditionsEvaluated: number
    paymentId: number
    amount: number
    success: number
    errorMessage: number
    executionTime: number
    isDryRun: number
    createdAt: number
    _all: number
  }


  export type CashControlExecutionAvgAggregateInputType = {
    amount?: true
    executionTime?: true
  }

  export type CashControlExecutionSumAggregateInputType = {
    amount?: true
    executionTime?: true
  }

  export type CashControlExecutionMinAggregateInputType = {
    id?: true
    ruleId?: true
    tenantId?: true
    status?: true
    paymentId?: true
    amount?: true
    success?: true
    errorMessage?: true
    executionTime?: true
    isDryRun?: true
    createdAt?: true
  }

  export type CashControlExecutionMaxAggregateInputType = {
    id?: true
    ruleId?: true
    tenantId?: true
    status?: true
    paymentId?: true
    amount?: true
    success?: true
    errorMessage?: true
    executionTime?: true
    isDryRun?: true
    createdAt?: true
  }

  export type CashControlExecutionCountAggregateInputType = {
    id?: true
    ruleId?: true
    tenantId?: true
    status?: true
    triggerData?: true
    conditionsEvaluated?: true
    paymentId?: true
    amount?: true
    success?: true
    errorMessage?: true
    executionTime?: true
    isDryRun?: true
    createdAt?: true
    _all?: true
  }

  export type CashControlExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashControlExecution to aggregate.
     */
    where?: CashControlExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlExecutions to fetch.
     */
    orderBy?: CashControlExecutionOrderByWithRelationInput | CashControlExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashControlExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashControlExecutions
    **/
    _count?: true | CashControlExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashControlExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashControlExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashControlExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashControlExecutionMaxAggregateInputType
  }

  export type GetCashControlExecutionAggregateType<T extends CashControlExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashControlExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashControlExecution[P]>
      : GetScalarType<T[P], AggregateCashControlExecution[P]>
  }




  export type CashControlExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashControlExecutionWhereInput
    orderBy?: CashControlExecutionOrderByWithAggregationInput | CashControlExecutionOrderByWithAggregationInput[]
    by: CashControlExecutionScalarFieldEnum[] | CashControlExecutionScalarFieldEnum
    having?: CashControlExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashControlExecutionCountAggregateInputType | true
    _avg?: CashControlExecutionAvgAggregateInputType
    _sum?: CashControlExecutionSumAggregateInputType
    _min?: CashControlExecutionMinAggregateInputType
    _max?: CashControlExecutionMaxAggregateInputType
  }

  export type CashControlExecutionGroupByOutputType = {
    id: string
    ruleId: string
    tenantId: string
    status: string
    triggerData: JsonValue
    conditionsEvaluated: JsonValue
    paymentId: string | null
    amount: number | null
    success: boolean
    errorMessage: string | null
    executionTime: number | null
    isDryRun: boolean
    createdAt: Date
    _count: CashControlExecutionCountAggregateOutputType | null
    _avg: CashControlExecutionAvgAggregateOutputType | null
    _sum: CashControlExecutionSumAggregateOutputType | null
    _min: CashControlExecutionMinAggregateOutputType | null
    _max: CashControlExecutionMaxAggregateOutputType | null
  }

  type GetCashControlExecutionGroupByPayload<T extends CashControlExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashControlExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashControlExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashControlExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], CashControlExecutionGroupByOutputType[P]>
        }
      >
    >


  export type CashControlExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    paymentId?: boolean
    amount?: boolean
    success?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    isDryRun?: boolean
    createdAt?: boolean
    rule?: boolean | CashControlRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashControlExecution"]>

  export type CashControlExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    paymentId?: boolean
    amount?: boolean
    success?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    isDryRun?: boolean
    createdAt?: boolean
    rule?: boolean | CashControlRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashControlExecution"]>

  export type CashControlExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    paymentId?: boolean
    amount?: boolean
    success?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    isDryRun?: boolean
    createdAt?: boolean
    rule?: boolean | CashControlRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashControlExecution"]>

  export type CashControlExecutionSelectScalar = {
    id?: boolean
    ruleId?: boolean
    tenantId?: boolean
    status?: boolean
    triggerData?: boolean
    conditionsEvaluated?: boolean
    paymentId?: boolean
    amount?: boolean
    success?: boolean
    errorMessage?: boolean
    executionTime?: boolean
    isDryRun?: boolean
    createdAt?: boolean
  }

  export type CashControlExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ruleId" | "tenantId" | "status" | "triggerData" | "conditionsEvaluated" | "paymentId" | "amount" | "success" | "errorMessage" | "executionTime" | "isDryRun" | "createdAt", ExtArgs["result"]["cashControlExecution"]>
  export type CashControlExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | CashControlRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CashControlExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | CashControlRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CashControlExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | CashControlRuleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CashControlExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashControlExecution"
    objects: {
      rule: Prisma.$CashControlRulePayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ruleId: string
      tenantId: string
      status: string
      triggerData: Prisma.JsonValue
      conditionsEvaluated: Prisma.JsonValue
      paymentId: string | null
      amount: number | null
      success: boolean
      errorMessage: string | null
      executionTime: number | null
      isDryRun: boolean
      createdAt: Date
    }, ExtArgs["result"]["cashControlExecution"]>
    composites: {}
  }

  type CashControlExecutionGetPayload<S extends boolean | null | undefined | CashControlExecutionDefaultArgs> = $Result.GetResult<Prisma.$CashControlExecutionPayload, S>

  type CashControlExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashControlExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashControlExecutionCountAggregateInputType | true
    }

  export interface CashControlExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashControlExecution'], meta: { name: 'CashControlExecution' } }
    /**
     * Find zero or one CashControlExecution that matches the filter.
     * @param {CashControlExecutionFindUniqueArgs} args - Arguments to find a CashControlExecution
     * @example
     * // Get one CashControlExecution
     * const cashControlExecution = await prisma.cashControlExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashControlExecutionFindUniqueArgs>(args: SelectSubset<T, CashControlExecutionFindUniqueArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashControlExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashControlExecutionFindUniqueOrThrowArgs} args - Arguments to find a CashControlExecution
     * @example
     * // Get one CashControlExecution
     * const cashControlExecution = await prisma.cashControlExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashControlExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashControlExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashControlExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlExecutionFindFirstArgs} args - Arguments to find a CashControlExecution
     * @example
     * // Get one CashControlExecution
     * const cashControlExecution = await prisma.cashControlExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashControlExecutionFindFirstArgs>(args?: SelectSubset<T, CashControlExecutionFindFirstArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashControlExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlExecutionFindFirstOrThrowArgs} args - Arguments to find a CashControlExecution
     * @example
     * // Get one CashControlExecution
     * const cashControlExecution = await prisma.cashControlExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashControlExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashControlExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashControlExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashControlExecutions
     * const cashControlExecutions = await prisma.cashControlExecution.findMany()
     * 
     * // Get first 10 CashControlExecutions
     * const cashControlExecutions = await prisma.cashControlExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashControlExecutionWithIdOnly = await prisma.cashControlExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashControlExecutionFindManyArgs>(args?: SelectSubset<T, CashControlExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashControlExecution.
     * @param {CashControlExecutionCreateArgs} args - Arguments to create a CashControlExecution.
     * @example
     * // Create one CashControlExecution
     * const CashControlExecution = await prisma.cashControlExecution.create({
     *   data: {
     *     // ... data to create a CashControlExecution
     *   }
     * })
     * 
     */
    create<T extends CashControlExecutionCreateArgs>(args: SelectSubset<T, CashControlExecutionCreateArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashControlExecutions.
     * @param {CashControlExecutionCreateManyArgs} args - Arguments to create many CashControlExecutions.
     * @example
     * // Create many CashControlExecutions
     * const cashControlExecution = await prisma.cashControlExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashControlExecutionCreateManyArgs>(args?: SelectSubset<T, CashControlExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashControlExecutions and returns the data saved in the database.
     * @param {CashControlExecutionCreateManyAndReturnArgs} args - Arguments to create many CashControlExecutions.
     * @example
     * // Create many CashControlExecutions
     * const cashControlExecution = await prisma.cashControlExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashControlExecutions and only return the `id`
     * const cashControlExecutionWithIdOnly = await prisma.cashControlExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashControlExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashControlExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashControlExecution.
     * @param {CashControlExecutionDeleteArgs} args - Arguments to delete one CashControlExecution.
     * @example
     * // Delete one CashControlExecution
     * const CashControlExecution = await prisma.cashControlExecution.delete({
     *   where: {
     *     // ... filter to delete one CashControlExecution
     *   }
     * })
     * 
     */
    delete<T extends CashControlExecutionDeleteArgs>(args: SelectSubset<T, CashControlExecutionDeleteArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashControlExecution.
     * @param {CashControlExecutionUpdateArgs} args - Arguments to update one CashControlExecution.
     * @example
     * // Update one CashControlExecution
     * const cashControlExecution = await prisma.cashControlExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashControlExecutionUpdateArgs>(args: SelectSubset<T, CashControlExecutionUpdateArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashControlExecutions.
     * @param {CashControlExecutionDeleteManyArgs} args - Arguments to filter CashControlExecutions to delete.
     * @example
     * // Delete a few CashControlExecutions
     * const { count } = await prisma.cashControlExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashControlExecutionDeleteManyArgs>(args?: SelectSubset<T, CashControlExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashControlExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashControlExecutions
     * const cashControlExecution = await prisma.cashControlExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashControlExecutionUpdateManyArgs>(args: SelectSubset<T, CashControlExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashControlExecutions and returns the data updated in the database.
     * @param {CashControlExecutionUpdateManyAndReturnArgs} args - Arguments to update many CashControlExecutions.
     * @example
     * // Update many CashControlExecutions
     * const cashControlExecution = await prisma.cashControlExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashControlExecutions and only return the `id`
     * const cashControlExecutionWithIdOnly = await prisma.cashControlExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashControlExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, CashControlExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashControlExecution.
     * @param {CashControlExecutionUpsertArgs} args - Arguments to update or create a CashControlExecution.
     * @example
     * // Update or create a CashControlExecution
     * const cashControlExecution = await prisma.cashControlExecution.upsert({
     *   create: {
     *     // ... data to create a CashControlExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashControlExecution we want to update
     *   }
     * })
     */
    upsert<T extends CashControlExecutionUpsertArgs>(args: SelectSubset<T, CashControlExecutionUpsertArgs<ExtArgs>>): Prisma__CashControlExecutionClient<$Result.GetResult<Prisma.$CashControlExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashControlExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlExecutionCountArgs} args - Arguments to filter CashControlExecutions to count.
     * @example
     * // Count the number of CashControlExecutions
     * const count = await prisma.cashControlExecution.count({
     *   where: {
     *     // ... the filter for the CashControlExecutions we want to count
     *   }
     * })
    **/
    count<T extends CashControlExecutionCountArgs>(
      args?: Subset<T, CashControlExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashControlExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashControlExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashControlExecutionAggregateArgs>(args: Subset<T, CashControlExecutionAggregateArgs>): Prisma.PrismaPromise<GetCashControlExecutionAggregateType<T>>

    /**
     * Group by CashControlExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashControlExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashControlExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashControlExecutionGroupByArgs['orderBy'] }
        : { orderBy?: CashControlExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashControlExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashControlExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashControlExecution model
   */
  readonly fields: CashControlExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashControlExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashControlExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rule<T extends CashControlRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashControlRuleDefaultArgs<ExtArgs>>): Prisma__CashControlRuleClient<$Result.GetResult<Prisma.$CashControlRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashControlExecution model
   */
  interface CashControlExecutionFieldRefs {
    readonly id: FieldRef<"CashControlExecution", 'String'>
    readonly ruleId: FieldRef<"CashControlExecution", 'String'>
    readonly tenantId: FieldRef<"CashControlExecution", 'String'>
    readonly status: FieldRef<"CashControlExecution", 'String'>
    readonly triggerData: FieldRef<"CashControlExecution", 'Json'>
    readonly conditionsEvaluated: FieldRef<"CashControlExecution", 'Json'>
    readonly paymentId: FieldRef<"CashControlExecution", 'String'>
    readonly amount: FieldRef<"CashControlExecution", 'Float'>
    readonly success: FieldRef<"CashControlExecution", 'Boolean'>
    readonly errorMessage: FieldRef<"CashControlExecution", 'String'>
    readonly executionTime: FieldRef<"CashControlExecution", 'Int'>
    readonly isDryRun: FieldRef<"CashControlExecution", 'Boolean'>
    readonly createdAt: FieldRef<"CashControlExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashControlExecution findUnique
   */
  export type CashControlExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CashControlExecution to fetch.
     */
    where: CashControlExecutionWhereUniqueInput
  }

  /**
   * CashControlExecution findUniqueOrThrow
   */
  export type CashControlExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CashControlExecution to fetch.
     */
    where: CashControlExecutionWhereUniqueInput
  }

  /**
   * CashControlExecution findFirst
   */
  export type CashControlExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CashControlExecution to fetch.
     */
    where?: CashControlExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlExecutions to fetch.
     */
    orderBy?: CashControlExecutionOrderByWithRelationInput | CashControlExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashControlExecutions.
     */
    cursor?: CashControlExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashControlExecutions.
     */
    distinct?: CashControlExecutionScalarFieldEnum | CashControlExecutionScalarFieldEnum[]
  }

  /**
   * CashControlExecution findFirstOrThrow
   */
  export type CashControlExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CashControlExecution to fetch.
     */
    where?: CashControlExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlExecutions to fetch.
     */
    orderBy?: CashControlExecutionOrderByWithRelationInput | CashControlExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashControlExecutions.
     */
    cursor?: CashControlExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashControlExecutions.
     */
    distinct?: CashControlExecutionScalarFieldEnum | CashControlExecutionScalarFieldEnum[]
  }

  /**
   * CashControlExecution findMany
   */
  export type CashControlExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * Filter, which CashControlExecutions to fetch.
     */
    where?: CashControlExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashControlExecutions to fetch.
     */
    orderBy?: CashControlExecutionOrderByWithRelationInput | CashControlExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashControlExecutions.
     */
    cursor?: CashControlExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashControlExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashControlExecutions.
     */
    skip?: number
    distinct?: CashControlExecutionScalarFieldEnum | CashControlExecutionScalarFieldEnum[]
  }

  /**
   * CashControlExecution create
   */
  export type CashControlExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a CashControlExecution.
     */
    data: XOR<CashControlExecutionCreateInput, CashControlExecutionUncheckedCreateInput>
  }

  /**
   * CashControlExecution createMany
   */
  export type CashControlExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashControlExecutions.
     */
    data: CashControlExecutionCreateManyInput | CashControlExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashControlExecution createManyAndReturn
   */
  export type CashControlExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many CashControlExecutions.
     */
    data: CashControlExecutionCreateManyInput | CashControlExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashControlExecution update
   */
  export type CashControlExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a CashControlExecution.
     */
    data: XOR<CashControlExecutionUpdateInput, CashControlExecutionUncheckedUpdateInput>
    /**
     * Choose, which CashControlExecution to update.
     */
    where: CashControlExecutionWhereUniqueInput
  }

  /**
   * CashControlExecution updateMany
   */
  export type CashControlExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashControlExecutions.
     */
    data: XOR<CashControlExecutionUpdateManyMutationInput, CashControlExecutionUncheckedUpdateManyInput>
    /**
     * Filter which CashControlExecutions to update
     */
    where?: CashControlExecutionWhereInput
    /**
     * Limit how many CashControlExecutions to update.
     */
    limit?: number
  }

  /**
   * CashControlExecution updateManyAndReturn
   */
  export type CashControlExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * The data used to update CashControlExecutions.
     */
    data: XOR<CashControlExecutionUpdateManyMutationInput, CashControlExecutionUncheckedUpdateManyInput>
    /**
     * Filter which CashControlExecutions to update
     */
    where?: CashControlExecutionWhereInput
    /**
     * Limit how many CashControlExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashControlExecution upsert
   */
  export type CashControlExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the CashControlExecution to update in case it exists.
     */
    where: CashControlExecutionWhereUniqueInput
    /**
     * In case the CashControlExecution found by the `where` argument doesn't exist, create a new CashControlExecution with this data.
     */
    create: XOR<CashControlExecutionCreateInput, CashControlExecutionUncheckedCreateInput>
    /**
     * In case the CashControlExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashControlExecutionUpdateInput, CashControlExecutionUncheckedUpdateInput>
  }

  /**
   * CashControlExecution delete
   */
  export type CashControlExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
    /**
     * Filter which CashControlExecution to delete.
     */
    where: CashControlExecutionWhereUniqueInput
  }

  /**
   * CashControlExecution deleteMany
   */
  export type CashControlExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashControlExecutions to delete
     */
    where?: CashControlExecutionWhereInput
    /**
     * Limit how many CashControlExecutions to delete.
     */
    limit?: number
  }

  /**
   * CashControlExecution without action
   */
  export type CashControlExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashControlExecution
     */
    select?: CashControlExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashControlExecution
     */
    omit?: CashControlExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashControlExecutionInclude<ExtArgs> | null
  }


  /**
   * Model PaymentAnalytics
   */

  export type AggregatePaymentAnalytics = {
    _count: PaymentAnalyticsCountAggregateOutputType | null
    _avg: PaymentAnalyticsAvgAggregateOutputType | null
    _sum: PaymentAnalyticsSumAggregateOutputType | null
    _min: PaymentAnalyticsMinAggregateOutputType | null
    _max: PaymentAnalyticsMaxAggregateOutputType | null
  }

  export type PaymentAnalyticsAvgAggregateOutputType = {
    amount: number | null
    processingFee: number | null
    timeToCash: number | null
    retryCount: number | null
    revenueImpact: number | null
  }

  export type PaymentAnalyticsSumAggregateOutputType = {
    amount: number | null
    processingFee: number | null
    timeToCash: number | null
    retryCount: number | null
    revenueImpact: number | null
  }

  export type PaymentAnalyticsMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    paymentId: string | null
    eventType: string | null
    amount: number | null
    processingFee: number | null
    isAutomated: boolean | null
    automationRuleId: string | null
    timeToCash: number | null
    retryCount: number | null
    revenueImpact: number | null
    timestamp: Date | null
  }

  export type PaymentAnalyticsMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    paymentId: string | null
    eventType: string | null
    amount: number | null
    processingFee: number | null
    isAutomated: boolean | null
    automationRuleId: string | null
    timeToCash: number | null
    retryCount: number | null
    revenueImpact: number | null
    timestamp: Date | null
  }

  export type PaymentAnalyticsCountAggregateOutputType = {
    id: number
    tenantId: number
    paymentId: number
    eventType: number
    amount: number
    processingFee: number
    isAutomated: number
    automationRuleId: number
    timeToCash: number
    retryCount: number
    revenueImpact: number
    timestamp: number
    _all: number
  }


  export type PaymentAnalyticsAvgAggregateInputType = {
    amount?: true
    processingFee?: true
    timeToCash?: true
    retryCount?: true
    revenueImpact?: true
  }

  export type PaymentAnalyticsSumAggregateInputType = {
    amount?: true
    processingFee?: true
    timeToCash?: true
    retryCount?: true
    revenueImpact?: true
  }

  export type PaymentAnalyticsMinAggregateInputType = {
    id?: true
    tenantId?: true
    paymentId?: true
    eventType?: true
    amount?: true
    processingFee?: true
    isAutomated?: true
    automationRuleId?: true
    timeToCash?: true
    retryCount?: true
    revenueImpact?: true
    timestamp?: true
  }

  export type PaymentAnalyticsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    paymentId?: true
    eventType?: true
    amount?: true
    processingFee?: true
    isAutomated?: true
    automationRuleId?: true
    timeToCash?: true
    retryCount?: true
    revenueImpact?: true
    timestamp?: true
  }

  export type PaymentAnalyticsCountAggregateInputType = {
    id?: true
    tenantId?: true
    paymentId?: true
    eventType?: true
    amount?: true
    processingFee?: true
    isAutomated?: true
    automationRuleId?: true
    timeToCash?: true
    retryCount?: true
    revenueImpact?: true
    timestamp?: true
    _all?: true
  }

  export type PaymentAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAnalytics to aggregate.
     */
    where?: PaymentAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAnalytics to fetch.
     */
    orderBy?: PaymentAnalyticsOrderByWithRelationInput | PaymentAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAnalytics
    **/
    _count?: true | PaymentAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAnalyticsMaxAggregateInputType
  }

  export type GetPaymentAnalyticsAggregateType<T extends PaymentAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAnalytics[P]>
      : GetScalarType<T[P], AggregatePaymentAnalytics[P]>
  }




  export type PaymentAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAnalyticsWhereInput
    orderBy?: PaymentAnalyticsOrderByWithAggregationInput | PaymentAnalyticsOrderByWithAggregationInput[]
    by: PaymentAnalyticsScalarFieldEnum[] | PaymentAnalyticsScalarFieldEnum
    having?: PaymentAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAnalyticsCountAggregateInputType | true
    _avg?: PaymentAnalyticsAvgAggregateInputType
    _sum?: PaymentAnalyticsSumAggregateInputType
    _min?: PaymentAnalyticsMinAggregateInputType
    _max?: PaymentAnalyticsMaxAggregateInputType
  }

  export type PaymentAnalyticsGroupByOutputType = {
    id: string
    tenantId: string
    paymentId: string | null
    eventType: string
    amount: number | null
    processingFee: number | null
    isAutomated: boolean
    automationRuleId: string | null
    timeToCash: number | null
    retryCount: number | null
    revenueImpact: number | null
    timestamp: Date
    _count: PaymentAnalyticsCountAggregateOutputType | null
    _avg: PaymentAnalyticsAvgAggregateOutputType | null
    _sum: PaymentAnalyticsSumAggregateOutputType | null
    _min: PaymentAnalyticsMinAggregateOutputType | null
    _max: PaymentAnalyticsMaxAggregateOutputType | null
  }

  type GetPaymentAnalyticsGroupByPayload<T extends PaymentAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    paymentId?: boolean
    eventType?: boolean
    amount?: boolean
    processingFee?: boolean
    isAutomated?: boolean
    automationRuleId?: boolean
    timeToCash?: boolean
    retryCount?: boolean
    revenueImpact?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAnalytics"]>

  export type PaymentAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    paymentId?: boolean
    eventType?: boolean
    amount?: boolean
    processingFee?: boolean
    isAutomated?: boolean
    automationRuleId?: boolean
    timeToCash?: boolean
    retryCount?: boolean
    revenueImpact?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAnalytics"]>

  export type PaymentAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    paymentId?: boolean
    eventType?: boolean
    amount?: boolean
    processingFee?: boolean
    isAutomated?: boolean
    automationRuleId?: boolean
    timeToCash?: boolean
    retryCount?: boolean
    revenueImpact?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAnalytics"]>

  export type PaymentAnalyticsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    paymentId?: boolean
    eventType?: boolean
    amount?: boolean
    processingFee?: boolean
    isAutomated?: boolean
    automationRuleId?: boolean
    timeToCash?: boolean
    retryCount?: boolean
    revenueImpact?: boolean
    timestamp?: boolean
  }

  export type PaymentAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "paymentId" | "eventType" | "amount" | "processingFee" | "isAutomated" | "automationRuleId" | "timeToCash" | "retryCount" | "revenueImpact" | "timestamp", ExtArgs["result"]["paymentAnalytics"]>
  export type PaymentAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAnalytics"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      paymentId: string | null
      eventType: string
      amount: number | null
      processingFee: number | null
      isAutomated: boolean
      automationRuleId: string | null
      timeToCash: number | null
      retryCount: number | null
      revenueImpact: number | null
      timestamp: Date
    }, ExtArgs["result"]["paymentAnalytics"]>
    composites: {}
  }

  type PaymentAnalyticsGetPayload<S extends boolean | null | undefined | PaymentAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$PaymentAnalyticsPayload, S>

  type PaymentAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentAnalyticsCountAggregateInputType | true
    }

  export interface PaymentAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAnalytics'], meta: { name: 'PaymentAnalytics' } }
    /**
     * Find zero or one PaymentAnalytics that matches the filter.
     * @param {PaymentAnalyticsFindUniqueArgs} args - Arguments to find a PaymentAnalytics
     * @example
     * // Get one PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAnalyticsFindUniqueArgs>(args: SelectSubset<T, PaymentAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PaymentAnalytics
     * @example
     * // Get one PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAnalyticsFindFirstArgs} args - Arguments to find a PaymentAnalytics
     * @example
     * // Get one PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAnalyticsFindFirstArgs>(args?: SelectSubset<T, PaymentAnalyticsFindFirstArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PaymentAnalytics
     * @example
     * // Get one PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.findMany()
     * 
     * // Get first 10 PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAnalyticsWithIdOnly = await prisma.paymentAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAnalyticsFindManyArgs>(args?: SelectSubset<T, PaymentAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentAnalytics.
     * @param {PaymentAnalyticsCreateArgs} args - Arguments to create a PaymentAnalytics.
     * @example
     * // Create one PaymentAnalytics
     * const PaymentAnalytics = await prisma.paymentAnalytics.create({
     *   data: {
     *     // ... data to create a PaymentAnalytics
     *   }
     * })
     * 
     */
    create<T extends PaymentAnalyticsCreateArgs>(args: SelectSubset<T, PaymentAnalyticsCreateArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentAnalytics.
     * @param {PaymentAnalyticsCreateManyArgs} args - Arguments to create many PaymentAnalytics.
     * @example
     * // Create many PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAnalyticsCreateManyArgs>(args?: SelectSubset<T, PaymentAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentAnalytics and returns the data saved in the database.
     * @param {PaymentAnalyticsCreateManyAndReturnArgs} args - Arguments to create many PaymentAnalytics.
     * @example
     * // Create many PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentAnalytics and only return the `id`
     * const paymentAnalyticsWithIdOnly = await prisma.paymentAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentAnalytics.
     * @param {PaymentAnalyticsDeleteArgs} args - Arguments to delete one PaymentAnalytics.
     * @example
     * // Delete one PaymentAnalytics
     * const PaymentAnalytics = await prisma.paymentAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PaymentAnalytics
     *   }
     * })
     * 
     */
    delete<T extends PaymentAnalyticsDeleteArgs>(args: SelectSubset<T, PaymentAnalyticsDeleteArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentAnalytics.
     * @param {PaymentAnalyticsUpdateArgs} args - Arguments to update one PaymentAnalytics.
     * @example
     * // Update one PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAnalyticsUpdateArgs>(args: SelectSubset<T, PaymentAnalyticsUpdateArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentAnalytics.
     * @param {PaymentAnalyticsDeleteManyArgs} args - Arguments to filter PaymentAnalytics to delete.
     * @example
     * // Delete a few PaymentAnalytics
     * const { count } = await prisma.paymentAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAnalyticsDeleteManyArgs>(args?: SelectSubset<T, PaymentAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAnalyticsUpdateManyArgs>(args: SelectSubset<T, PaymentAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAnalytics and returns the data updated in the database.
     * @param {PaymentAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many PaymentAnalytics.
     * @example
     * // Update many PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentAnalytics and only return the `id`
     * const paymentAnalyticsWithIdOnly = await prisma.paymentAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentAnalytics.
     * @param {PaymentAnalyticsUpsertArgs} args - Arguments to update or create a PaymentAnalytics.
     * @example
     * // Update or create a PaymentAnalytics
     * const paymentAnalytics = await prisma.paymentAnalytics.upsert({
     *   create: {
     *     // ... data to create a PaymentAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAnalyticsUpsertArgs>(args: SelectSubset<T, PaymentAnalyticsUpsertArgs<ExtArgs>>): Prisma__PaymentAnalyticsClient<$Result.GetResult<Prisma.$PaymentAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAnalyticsCountArgs} args - Arguments to filter PaymentAnalytics to count.
     * @example
     * // Count the number of PaymentAnalytics
     * const count = await prisma.paymentAnalytics.count({
     *   where: {
     *     // ... the filter for the PaymentAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PaymentAnalyticsCountArgs>(
      args?: Subset<T, PaymentAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAnalyticsAggregateArgs>(args: Subset<T, PaymentAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPaymentAnalyticsAggregateType<T>>

    /**
     * Group by PaymentAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAnalytics model
   */
  readonly fields: PaymentAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAnalytics model
   */
  interface PaymentAnalyticsFieldRefs {
    readonly id: FieldRef<"PaymentAnalytics", 'String'>
    readonly tenantId: FieldRef<"PaymentAnalytics", 'String'>
    readonly paymentId: FieldRef<"PaymentAnalytics", 'String'>
    readonly eventType: FieldRef<"PaymentAnalytics", 'String'>
    readonly amount: FieldRef<"PaymentAnalytics", 'Float'>
    readonly processingFee: FieldRef<"PaymentAnalytics", 'Float'>
    readonly isAutomated: FieldRef<"PaymentAnalytics", 'Boolean'>
    readonly automationRuleId: FieldRef<"PaymentAnalytics", 'String'>
    readonly timeToCash: FieldRef<"PaymentAnalytics", 'Int'>
    readonly retryCount: FieldRef<"PaymentAnalytics", 'Int'>
    readonly revenueImpact: FieldRef<"PaymentAnalytics", 'Float'>
    readonly timestamp: FieldRef<"PaymentAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAnalytics findUnique
   */
  export type PaymentAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAnalytics to fetch.
     */
    where: PaymentAnalyticsWhereUniqueInput
  }

  /**
   * PaymentAnalytics findUniqueOrThrow
   */
  export type PaymentAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAnalytics to fetch.
     */
    where: PaymentAnalyticsWhereUniqueInput
  }

  /**
   * PaymentAnalytics findFirst
   */
  export type PaymentAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAnalytics to fetch.
     */
    where?: PaymentAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAnalytics to fetch.
     */
    orderBy?: PaymentAnalyticsOrderByWithRelationInput | PaymentAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAnalytics.
     */
    cursor?: PaymentAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAnalytics.
     */
    distinct?: PaymentAnalyticsScalarFieldEnum | PaymentAnalyticsScalarFieldEnum[]
  }

  /**
   * PaymentAnalytics findFirstOrThrow
   */
  export type PaymentAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAnalytics to fetch.
     */
    where?: PaymentAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAnalytics to fetch.
     */
    orderBy?: PaymentAnalyticsOrderByWithRelationInput | PaymentAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAnalytics.
     */
    cursor?: PaymentAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAnalytics.
     */
    distinct?: PaymentAnalyticsScalarFieldEnum | PaymentAnalyticsScalarFieldEnum[]
  }

  /**
   * PaymentAnalytics findMany
   */
  export type PaymentAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAnalytics to fetch.
     */
    where?: PaymentAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAnalytics to fetch.
     */
    orderBy?: PaymentAnalyticsOrderByWithRelationInput | PaymentAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAnalytics.
     */
    cursor?: PaymentAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAnalytics.
     */
    skip?: number
    distinct?: PaymentAnalyticsScalarFieldEnum | PaymentAnalyticsScalarFieldEnum[]
  }

  /**
   * PaymentAnalytics create
   */
  export type PaymentAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentAnalytics.
     */
    data: XOR<PaymentAnalyticsCreateInput, PaymentAnalyticsUncheckedCreateInput>
  }

  /**
   * PaymentAnalytics createMany
   */
  export type PaymentAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAnalytics.
     */
    data: PaymentAnalyticsCreateManyInput | PaymentAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAnalytics createManyAndReturn
   */
  export type PaymentAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentAnalytics.
     */
    data: PaymentAnalyticsCreateManyInput | PaymentAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAnalytics update
   */
  export type PaymentAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentAnalytics.
     */
    data: XOR<PaymentAnalyticsUpdateInput, PaymentAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PaymentAnalytics to update.
     */
    where: PaymentAnalyticsWhereUniqueInput
  }

  /**
   * PaymentAnalytics updateMany
   */
  export type PaymentAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAnalytics.
     */
    data: XOR<PaymentAnalyticsUpdateManyMutationInput, PaymentAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAnalytics to update
     */
    where?: PaymentAnalyticsWhereInput
    /**
     * Limit how many PaymentAnalytics to update.
     */
    limit?: number
  }

  /**
   * PaymentAnalytics updateManyAndReturn
   */
  export type PaymentAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update PaymentAnalytics.
     */
    data: XOR<PaymentAnalyticsUpdateManyMutationInput, PaymentAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAnalytics to update
     */
    where?: PaymentAnalyticsWhereInput
    /**
     * Limit how many PaymentAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAnalytics upsert
   */
  export type PaymentAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentAnalytics to update in case it exists.
     */
    where: PaymentAnalyticsWhereUniqueInput
    /**
     * In case the PaymentAnalytics found by the `where` argument doesn't exist, create a new PaymentAnalytics with this data.
     */
    create: XOR<PaymentAnalyticsCreateInput, PaymentAnalyticsUncheckedCreateInput>
    /**
     * In case the PaymentAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAnalyticsUpdateInput, PaymentAnalyticsUncheckedUpdateInput>
  }

  /**
   * PaymentAnalytics delete
   */
  export type PaymentAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which PaymentAnalytics to delete.
     */
    where: PaymentAnalyticsWhereUniqueInput
  }

  /**
   * PaymentAnalytics deleteMany
   */
  export type PaymentAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAnalytics to delete
     */
    where?: PaymentAnalyticsWhereInput
    /**
     * Limit how many PaymentAnalytics to delete.
     */
    limit?: number
  }

  /**
   * PaymentAnalytics without action
   */
  export type PaymentAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAnalytics
     */
    select?: PaymentAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAnalytics
     */
    omit?: PaymentAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model FinancialForecast
   */

  export type AggregateFinancialForecast = {
    _count: FinancialForecastCountAggregateOutputType | null
    _avg: FinancialForecastAvgAggregateOutputType | null
    _sum: FinancialForecastSumAggregateOutputType | null
    _min: FinancialForecastMinAggregateOutputType | null
    _max: FinancialForecastMaxAggregateOutputType | null
  }

  export type FinancialForecastAvgAggregateOutputType = {
    value: number | null
    confidenceScore: number | null
    forecastHorizon: number | null
  }

  export type FinancialForecastSumAggregateOutputType = {
    value: number | null
    confidenceScore: number | null
    forecastHorizon: number | null
  }

  export type FinancialForecastMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    forecastType: $Enums.ForecastType | null
    value: number | null
    unit: string | null
    confidenceScore: number | null
    forecastDate: Date | null
    forecastHorizon: number | null
    formula: string | null
    calculatedAt: Date | null
  }

  export type FinancialForecastMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    forecastType: $Enums.ForecastType | null
    value: number | null
    unit: string | null
    confidenceScore: number | null
    forecastDate: Date | null
    forecastHorizon: number | null
    formula: string | null
    calculatedAt: Date | null
  }

  export type FinancialForecastCountAggregateOutputType = {
    id: number
    tenantId: number
    forecastType: number
    value: number
    unit: number
    confidenceScore: number
    forecastDate: number
    forecastHorizon: number
    formula: number
    assumptions: number
    dataSources: number
    historicalBaseline: number
    calculatedAt: number
    _all: number
  }


  export type FinancialForecastAvgAggregateInputType = {
    value?: true
    confidenceScore?: true
    forecastHorizon?: true
  }

  export type FinancialForecastSumAggregateInputType = {
    value?: true
    confidenceScore?: true
    forecastHorizon?: true
  }

  export type FinancialForecastMinAggregateInputType = {
    id?: true
    tenantId?: true
    forecastType?: true
    value?: true
    unit?: true
    confidenceScore?: true
    forecastDate?: true
    forecastHorizon?: true
    formula?: true
    calculatedAt?: true
  }

  export type FinancialForecastMaxAggregateInputType = {
    id?: true
    tenantId?: true
    forecastType?: true
    value?: true
    unit?: true
    confidenceScore?: true
    forecastDate?: true
    forecastHorizon?: true
    formula?: true
    calculatedAt?: true
  }

  export type FinancialForecastCountAggregateInputType = {
    id?: true
    tenantId?: true
    forecastType?: true
    value?: true
    unit?: true
    confidenceScore?: true
    forecastDate?: true
    forecastHorizon?: true
    formula?: true
    assumptions?: true
    dataSources?: true
    historicalBaseline?: true
    calculatedAt?: true
    _all?: true
  }

  export type FinancialForecastAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialForecast to aggregate.
     */
    where?: FinancialForecastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialForecasts to fetch.
     */
    orderBy?: FinancialForecastOrderByWithRelationInput | FinancialForecastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialForecastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialForecasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialForecasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialForecasts
    **/
    _count?: true | FinancialForecastCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialForecastAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialForecastSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialForecastMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialForecastMaxAggregateInputType
  }

  export type GetFinancialForecastAggregateType<T extends FinancialForecastAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialForecast]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialForecast[P]>
      : GetScalarType<T[P], AggregateFinancialForecast[P]>
  }




  export type FinancialForecastGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialForecastWhereInput
    orderBy?: FinancialForecastOrderByWithAggregationInput | FinancialForecastOrderByWithAggregationInput[]
    by: FinancialForecastScalarFieldEnum[] | FinancialForecastScalarFieldEnum
    having?: FinancialForecastScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialForecastCountAggregateInputType | true
    _avg?: FinancialForecastAvgAggregateInputType
    _sum?: FinancialForecastSumAggregateInputType
    _min?: FinancialForecastMinAggregateInputType
    _max?: FinancialForecastMaxAggregateInputType
  }

  export type FinancialForecastGroupByOutputType = {
    id: string
    tenantId: string
    forecastType: $Enums.ForecastType
    value: number
    unit: string
    confidenceScore: number
    forecastDate: Date
    forecastHorizon: number
    formula: string
    assumptions: JsonValue
    dataSources: JsonValue
    historicalBaseline: JsonValue | null
    calculatedAt: Date
    _count: FinancialForecastCountAggregateOutputType | null
    _avg: FinancialForecastAvgAggregateOutputType | null
    _sum: FinancialForecastSumAggregateOutputType | null
    _min: FinancialForecastMinAggregateOutputType | null
    _max: FinancialForecastMaxAggregateOutputType | null
  }

  type GetFinancialForecastGroupByPayload<T extends FinancialForecastGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialForecastGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialForecastGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialForecastGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialForecastGroupByOutputType[P]>
        }
      >
    >


  export type FinancialForecastSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    forecastType?: boolean
    value?: boolean
    unit?: boolean
    confidenceScore?: boolean
    forecastDate?: boolean
    forecastHorizon?: boolean
    formula?: boolean
    assumptions?: boolean
    dataSources?: boolean
    historicalBaseline?: boolean
    calculatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialForecast"]>

  export type FinancialForecastSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    forecastType?: boolean
    value?: boolean
    unit?: boolean
    confidenceScore?: boolean
    forecastDate?: boolean
    forecastHorizon?: boolean
    formula?: boolean
    assumptions?: boolean
    dataSources?: boolean
    historicalBaseline?: boolean
    calculatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialForecast"]>

  export type FinancialForecastSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    forecastType?: boolean
    value?: boolean
    unit?: boolean
    confidenceScore?: boolean
    forecastDate?: boolean
    forecastHorizon?: boolean
    formula?: boolean
    assumptions?: boolean
    dataSources?: boolean
    historicalBaseline?: boolean
    calculatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialForecast"]>

  export type FinancialForecastSelectScalar = {
    id?: boolean
    tenantId?: boolean
    forecastType?: boolean
    value?: boolean
    unit?: boolean
    confidenceScore?: boolean
    forecastDate?: boolean
    forecastHorizon?: boolean
    formula?: boolean
    assumptions?: boolean
    dataSources?: boolean
    historicalBaseline?: boolean
    calculatedAt?: boolean
  }

  export type FinancialForecastOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "forecastType" | "value" | "unit" | "confidenceScore" | "forecastDate" | "forecastHorizon" | "formula" | "assumptions" | "dataSources" | "historicalBaseline" | "calculatedAt", ExtArgs["result"]["financialForecast"]>
  export type FinancialForecastInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type FinancialForecastIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type FinancialForecastIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $FinancialForecastPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialForecast"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      forecastType: $Enums.ForecastType
      value: number
      unit: string
      confidenceScore: number
      forecastDate: Date
      forecastHorizon: number
      formula: string
      assumptions: Prisma.JsonValue
      dataSources: Prisma.JsonValue
      historicalBaseline: Prisma.JsonValue | null
      calculatedAt: Date
    }, ExtArgs["result"]["financialForecast"]>
    composites: {}
  }

  type FinancialForecastGetPayload<S extends boolean | null | undefined | FinancialForecastDefaultArgs> = $Result.GetResult<Prisma.$FinancialForecastPayload, S>

  type FinancialForecastCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialForecastFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialForecastCountAggregateInputType | true
    }

  export interface FinancialForecastDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialForecast'], meta: { name: 'FinancialForecast' } }
    /**
     * Find zero or one FinancialForecast that matches the filter.
     * @param {FinancialForecastFindUniqueArgs} args - Arguments to find a FinancialForecast
     * @example
     * // Get one FinancialForecast
     * const financialForecast = await prisma.financialForecast.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialForecastFindUniqueArgs>(args: SelectSubset<T, FinancialForecastFindUniqueArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialForecast that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialForecastFindUniqueOrThrowArgs} args - Arguments to find a FinancialForecast
     * @example
     * // Get one FinancialForecast
     * const financialForecast = await prisma.financialForecast.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialForecastFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialForecastFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialForecast that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialForecastFindFirstArgs} args - Arguments to find a FinancialForecast
     * @example
     * // Get one FinancialForecast
     * const financialForecast = await prisma.financialForecast.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialForecastFindFirstArgs>(args?: SelectSubset<T, FinancialForecastFindFirstArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialForecast that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialForecastFindFirstOrThrowArgs} args - Arguments to find a FinancialForecast
     * @example
     * // Get one FinancialForecast
     * const financialForecast = await prisma.financialForecast.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialForecastFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialForecastFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialForecasts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialForecastFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialForecasts
     * const financialForecasts = await prisma.financialForecast.findMany()
     * 
     * // Get first 10 FinancialForecasts
     * const financialForecasts = await prisma.financialForecast.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialForecastWithIdOnly = await prisma.financialForecast.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialForecastFindManyArgs>(args?: SelectSubset<T, FinancialForecastFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialForecast.
     * @param {FinancialForecastCreateArgs} args - Arguments to create a FinancialForecast.
     * @example
     * // Create one FinancialForecast
     * const FinancialForecast = await prisma.financialForecast.create({
     *   data: {
     *     // ... data to create a FinancialForecast
     *   }
     * })
     * 
     */
    create<T extends FinancialForecastCreateArgs>(args: SelectSubset<T, FinancialForecastCreateArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialForecasts.
     * @param {FinancialForecastCreateManyArgs} args - Arguments to create many FinancialForecasts.
     * @example
     * // Create many FinancialForecasts
     * const financialForecast = await prisma.financialForecast.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialForecastCreateManyArgs>(args?: SelectSubset<T, FinancialForecastCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialForecasts and returns the data saved in the database.
     * @param {FinancialForecastCreateManyAndReturnArgs} args - Arguments to create many FinancialForecasts.
     * @example
     * // Create many FinancialForecasts
     * const financialForecast = await prisma.financialForecast.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialForecasts and only return the `id`
     * const financialForecastWithIdOnly = await prisma.financialForecast.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialForecastCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialForecastCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialForecast.
     * @param {FinancialForecastDeleteArgs} args - Arguments to delete one FinancialForecast.
     * @example
     * // Delete one FinancialForecast
     * const FinancialForecast = await prisma.financialForecast.delete({
     *   where: {
     *     // ... filter to delete one FinancialForecast
     *   }
     * })
     * 
     */
    delete<T extends FinancialForecastDeleteArgs>(args: SelectSubset<T, FinancialForecastDeleteArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialForecast.
     * @param {FinancialForecastUpdateArgs} args - Arguments to update one FinancialForecast.
     * @example
     * // Update one FinancialForecast
     * const financialForecast = await prisma.financialForecast.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialForecastUpdateArgs>(args: SelectSubset<T, FinancialForecastUpdateArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialForecasts.
     * @param {FinancialForecastDeleteManyArgs} args - Arguments to filter FinancialForecasts to delete.
     * @example
     * // Delete a few FinancialForecasts
     * const { count } = await prisma.financialForecast.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialForecastDeleteManyArgs>(args?: SelectSubset<T, FinancialForecastDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialForecasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialForecastUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialForecasts
     * const financialForecast = await prisma.financialForecast.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialForecastUpdateManyArgs>(args: SelectSubset<T, FinancialForecastUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialForecasts and returns the data updated in the database.
     * @param {FinancialForecastUpdateManyAndReturnArgs} args - Arguments to update many FinancialForecasts.
     * @example
     * // Update many FinancialForecasts
     * const financialForecast = await prisma.financialForecast.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialForecasts and only return the `id`
     * const financialForecastWithIdOnly = await prisma.financialForecast.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialForecastUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialForecastUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialForecast.
     * @param {FinancialForecastUpsertArgs} args - Arguments to update or create a FinancialForecast.
     * @example
     * // Update or create a FinancialForecast
     * const financialForecast = await prisma.financialForecast.upsert({
     *   create: {
     *     // ... data to create a FinancialForecast
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialForecast we want to update
     *   }
     * })
     */
    upsert<T extends FinancialForecastUpsertArgs>(args: SelectSubset<T, FinancialForecastUpsertArgs<ExtArgs>>): Prisma__FinancialForecastClient<$Result.GetResult<Prisma.$FinancialForecastPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialForecasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialForecastCountArgs} args - Arguments to filter FinancialForecasts to count.
     * @example
     * // Count the number of FinancialForecasts
     * const count = await prisma.financialForecast.count({
     *   where: {
     *     // ... the filter for the FinancialForecasts we want to count
     *   }
     * })
    **/
    count<T extends FinancialForecastCountArgs>(
      args?: Subset<T, FinancialForecastCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialForecastCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialForecast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialForecastAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialForecastAggregateArgs>(args: Subset<T, FinancialForecastAggregateArgs>): Prisma.PrismaPromise<GetFinancialForecastAggregateType<T>>

    /**
     * Group by FinancialForecast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialForecastGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialForecastGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialForecastGroupByArgs['orderBy'] }
        : { orderBy?: FinancialForecastGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialForecastGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialForecastGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialForecast model
   */
  readonly fields: FinancialForecastFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialForecast.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialForecastClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialForecast model
   */
  interface FinancialForecastFieldRefs {
    readonly id: FieldRef<"FinancialForecast", 'String'>
    readonly tenantId: FieldRef<"FinancialForecast", 'String'>
    readonly forecastType: FieldRef<"FinancialForecast", 'ForecastType'>
    readonly value: FieldRef<"FinancialForecast", 'Float'>
    readonly unit: FieldRef<"FinancialForecast", 'String'>
    readonly confidenceScore: FieldRef<"FinancialForecast", 'Float'>
    readonly forecastDate: FieldRef<"FinancialForecast", 'DateTime'>
    readonly forecastHorizon: FieldRef<"FinancialForecast", 'Int'>
    readonly formula: FieldRef<"FinancialForecast", 'String'>
    readonly assumptions: FieldRef<"FinancialForecast", 'Json'>
    readonly dataSources: FieldRef<"FinancialForecast", 'Json'>
    readonly historicalBaseline: FieldRef<"FinancialForecast", 'Json'>
    readonly calculatedAt: FieldRef<"FinancialForecast", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialForecast findUnique
   */
  export type FinancialForecastFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * Filter, which FinancialForecast to fetch.
     */
    where: FinancialForecastWhereUniqueInput
  }

  /**
   * FinancialForecast findUniqueOrThrow
   */
  export type FinancialForecastFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * Filter, which FinancialForecast to fetch.
     */
    where: FinancialForecastWhereUniqueInput
  }

  /**
   * FinancialForecast findFirst
   */
  export type FinancialForecastFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * Filter, which FinancialForecast to fetch.
     */
    where?: FinancialForecastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialForecasts to fetch.
     */
    orderBy?: FinancialForecastOrderByWithRelationInput | FinancialForecastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialForecasts.
     */
    cursor?: FinancialForecastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialForecasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialForecasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialForecasts.
     */
    distinct?: FinancialForecastScalarFieldEnum | FinancialForecastScalarFieldEnum[]
  }

  /**
   * FinancialForecast findFirstOrThrow
   */
  export type FinancialForecastFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * Filter, which FinancialForecast to fetch.
     */
    where?: FinancialForecastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialForecasts to fetch.
     */
    orderBy?: FinancialForecastOrderByWithRelationInput | FinancialForecastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialForecasts.
     */
    cursor?: FinancialForecastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialForecasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialForecasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialForecasts.
     */
    distinct?: FinancialForecastScalarFieldEnum | FinancialForecastScalarFieldEnum[]
  }

  /**
   * FinancialForecast findMany
   */
  export type FinancialForecastFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * Filter, which FinancialForecasts to fetch.
     */
    where?: FinancialForecastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialForecasts to fetch.
     */
    orderBy?: FinancialForecastOrderByWithRelationInput | FinancialForecastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialForecasts.
     */
    cursor?: FinancialForecastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialForecasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialForecasts.
     */
    skip?: number
    distinct?: FinancialForecastScalarFieldEnum | FinancialForecastScalarFieldEnum[]
  }

  /**
   * FinancialForecast create
   */
  export type FinancialForecastCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialForecast.
     */
    data: XOR<FinancialForecastCreateInput, FinancialForecastUncheckedCreateInput>
  }

  /**
   * FinancialForecast createMany
   */
  export type FinancialForecastCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialForecasts.
     */
    data: FinancialForecastCreateManyInput | FinancialForecastCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialForecast createManyAndReturn
   */
  export type FinancialForecastCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialForecasts.
     */
    data: FinancialForecastCreateManyInput | FinancialForecastCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialForecast update
   */
  export type FinancialForecastUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialForecast.
     */
    data: XOR<FinancialForecastUpdateInput, FinancialForecastUncheckedUpdateInput>
    /**
     * Choose, which FinancialForecast to update.
     */
    where: FinancialForecastWhereUniqueInput
  }

  /**
   * FinancialForecast updateMany
   */
  export type FinancialForecastUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialForecasts.
     */
    data: XOR<FinancialForecastUpdateManyMutationInput, FinancialForecastUncheckedUpdateManyInput>
    /**
     * Filter which FinancialForecasts to update
     */
    where?: FinancialForecastWhereInput
    /**
     * Limit how many FinancialForecasts to update.
     */
    limit?: number
  }

  /**
   * FinancialForecast updateManyAndReturn
   */
  export type FinancialForecastUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * The data used to update FinancialForecasts.
     */
    data: XOR<FinancialForecastUpdateManyMutationInput, FinancialForecastUncheckedUpdateManyInput>
    /**
     * Filter which FinancialForecasts to update
     */
    where?: FinancialForecastWhereInput
    /**
     * Limit how many FinancialForecasts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialForecast upsert
   */
  export type FinancialForecastUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialForecast to update in case it exists.
     */
    where: FinancialForecastWhereUniqueInput
    /**
     * In case the FinancialForecast found by the `where` argument doesn't exist, create a new FinancialForecast with this data.
     */
    create: XOR<FinancialForecastCreateInput, FinancialForecastUncheckedCreateInput>
    /**
     * In case the FinancialForecast was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialForecastUpdateInput, FinancialForecastUncheckedUpdateInput>
  }

  /**
   * FinancialForecast delete
   */
  export type FinancialForecastDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
    /**
     * Filter which FinancialForecast to delete.
     */
    where: FinancialForecastWhereUniqueInput
  }

  /**
   * FinancialForecast deleteMany
   */
  export type FinancialForecastDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialForecasts to delete
     */
    where?: FinancialForecastWhereInput
    /**
     * Limit how many FinancialForecasts to delete.
     */
    limit?: number
  }

  /**
   * FinancialForecast without action
   */
  export type FinancialForecastDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialForecast
     */
    select?: FinancialForecastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialForecast
     */
    omit?: FinancialForecastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialForecastInclude<ExtArgs> | null
  }


  /**
   * Model Scenario
   */

  export type AggregateScenario = {
    _count: ScenarioCountAggregateOutputType | null
    _avg: ScenarioAvgAggregateOutputType | null
    _sum: ScenarioSumAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  export type ScenarioAvgAggregateOutputType = {
    baselineRunway: number | null
    projectedRunway: number | null
    runwayChange: number | null
    riskScore: number | null
    successProbability: number | null
  }

  export type ScenarioSumAggregateOutputType = {
    baselineRunway: number | null
    projectedRunway: number | null
    runwayChange: number | null
    riskScore: number | null
    successProbability: number | null
  }

  export type ScenarioMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    scenarioType: $Enums.ScenarioType | null
    baselineRunway: number | null
    projectedRunway: number | null
    runwayChange: number | null
    riskLevel: $Enums.RiskLevel | null
    riskScore: number | null
    successProbability: number | null
    createdBy: string | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    scenarioType: $Enums.ScenarioType | null
    baselineRunway: number | null
    projectedRunway: number | null
    runwayChange: number | null
    riskLevel: $Enums.RiskLevel | null
    riskScore: number | null
    successProbability: number | null
    createdBy: string | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    scenarioType: number
    config: number
    baselineRunway: number
    projectedRunway: number
    runwayChange: number
    riskLevel: number
    riskScore: number
    successProbability: number
    topRiskDrivers: number
    criticalAssumptions: number
    cashFlowImpact: number
    automationImpact: number
    paymentImpact: number
    recommendations: number
    createdBy: number
    isArchived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScenarioAvgAggregateInputType = {
    baselineRunway?: true
    projectedRunway?: true
    runwayChange?: true
    riskScore?: true
    successProbability?: true
  }

  export type ScenarioSumAggregateInputType = {
    baselineRunway?: true
    projectedRunway?: true
    runwayChange?: true
    riskScore?: true
    successProbability?: true
  }

  export type ScenarioMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    scenarioType?: true
    baselineRunway?: true
    projectedRunway?: true
    runwayChange?: true
    riskLevel?: true
    riskScore?: true
    successProbability?: true
    createdBy?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    scenarioType?: true
    baselineRunway?: true
    projectedRunway?: true
    runwayChange?: true
    riskLevel?: true
    riskScore?: true
    successProbability?: true
    createdBy?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    scenarioType?: true
    config?: true
    baselineRunway?: true
    projectedRunway?: true
    runwayChange?: true
    riskLevel?: true
    riskScore?: true
    successProbability?: true
    topRiskDrivers?: true
    criticalAssumptions?: true
    cashFlowImpact?: true
    automationImpact?: true
    paymentImpact?: true
    recommendations?: true
    createdBy?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenario to aggregate.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scenarios
    **/
    _count?: true | ScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScenarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScenarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScenarioMaxAggregateInputType
  }

  export type GetScenarioAggregateType<T extends ScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScenario[P]>
      : GetScalarType<T[P], AggregateScenario[P]>
  }




  export type ScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithAggregationInput | ScenarioOrderByWithAggregationInput[]
    by: ScenarioScalarFieldEnum[] | ScenarioScalarFieldEnum
    having?: ScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScenarioCountAggregateInputType | true
    _avg?: ScenarioAvgAggregateInputType
    _sum?: ScenarioSumAggregateInputType
    _min?: ScenarioMinAggregateInputType
    _max?: ScenarioMaxAggregateInputType
  }

  export type ScenarioGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    scenarioType: $Enums.ScenarioType
    config: JsonValue
    baselineRunway: number | null
    projectedRunway: number | null
    runwayChange: number | null
    riskLevel: $Enums.RiskLevel | null
    riskScore: number | null
    successProbability: number | null
    topRiskDrivers: JsonValue
    criticalAssumptions: JsonValue
    cashFlowImpact: JsonValue | null
    automationImpact: JsonValue | null
    paymentImpact: JsonValue | null
    recommendations: JsonValue
    createdBy: string
    isArchived: boolean
    createdAt: Date
    updatedAt: Date
    _count: ScenarioCountAggregateOutputType | null
    _avg: ScenarioAvgAggregateOutputType | null
    _sum: ScenarioSumAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  type GetScenarioGroupByPayload<T extends ScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
        }
      >
    >


  export type ScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    scenarioType?: boolean
    config?: boolean
    baselineRunway?: boolean
    projectedRunway?: boolean
    runwayChange?: boolean
    riskLevel?: boolean
    riskScore?: boolean
    successProbability?: boolean
    topRiskDrivers?: boolean
    criticalAssumptions?: boolean
    cashFlowImpact?: boolean
    automationImpact?: boolean
    paymentImpact?: boolean
    recommendations?: boolean
    createdBy?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    scenarioType?: boolean
    config?: boolean
    baselineRunway?: boolean
    projectedRunway?: boolean
    runwayChange?: boolean
    riskLevel?: boolean
    riskScore?: boolean
    successProbability?: boolean
    topRiskDrivers?: boolean
    criticalAssumptions?: boolean
    cashFlowImpact?: boolean
    automationImpact?: boolean
    paymentImpact?: boolean
    recommendations?: boolean
    createdBy?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    scenarioType?: boolean
    config?: boolean
    baselineRunway?: boolean
    projectedRunway?: boolean
    runwayChange?: boolean
    riskLevel?: boolean
    riskScore?: boolean
    successProbability?: boolean
    topRiskDrivers?: boolean
    criticalAssumptions?: boolean
    cashFlowImpact?: boolean
    automationImpact?: boolean
    paymentImpact?: boolean
    recommendations?: boolean
    createdBy?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    scenarioType?: boolean
    config?: boolean
    baselineRunway?: boolean
    projectedRunway?: boolean
    runwayChange?: boolean
    riskLevel?: boolean
    riskScore?: boolean
    successProbability?: boolean
    topRiskDrivers?: boolean
    criticalAssumptions?: boolean
    cashFlowImpact?: boolean
    automationImpact?: boolean
    paymentImpact?: boolean
    recommendations?: boolean
    createdBy?: boolean
    isArchived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScenarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "scenarioType" | "config" | "baselineRunway" | "projectedRunway" | "runwayChange" | "riskLevel" | "riskScore" | "successProbability" | "topRiskDrivers" | "criticalAssumptions" | "cashFlowImpact" | "automationImpact" | "paymentImpact" | "recommendations" | "createdBy" | "isArchived" | "createdAt" | "updatedAt", ExtArgs["result"]["scenario"]>
  export type ScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scenario"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      scenarioType: $Enums.ScenarioType
      config: Prisma.JsonValue
      baselineRunway: number | null
      projectedRunway: number | null
      runwayChange: number | null
      riskLevel: $Enums.RiskLevel | null
      riskScore: number | null
      successProbability: number | null
      topRiskDrivers: Prisma.JsonValue
      criticalAssumptions: Prisma.JsonValue
      cashFlowImpact: Prisma.JsonValue | null
      automationImpact: Prisma.JsonValue | null
      paymentImpact: Prisma.JsonValue | null
      recommendations: Prisma.JsonValue
      createdBy: string
      isArchived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scenario"]>
    composites: {}
  }

  type ScenarioGetPayload<S extends boolean | null | undefined | ScenarioDefaultArgs> = $Result.GetResult<Prisma.$ScenarioPayload, S>

  type ScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScenarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScenarioCountAggregateInputType | true
    }

  export interface ScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scenario'], meta: { name: 'Scenario' } }
    /**
     * Find zero or one Scenario that matches the filter.
     * @param {ScenarioFindUniqueArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScenarioFindUniqueArgs>(args: SelectSubset<T, ScenarioFindUniqueArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scenario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScenarioFindUniqueOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScenarioFindFirstArgs>(args?: SelectSubset<T, ScenarioFindFirstArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scenarios
     * const scenarios = await prisma.scenario.findMany()
     * 
     * // Get first 10 Scenarios
     * const scenarios = await prisma.scenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scenarioWithIdOnly = await prisma.scenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScenarioFindManyArgs>(args?: SelectSubset<T, ScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scenario.
     * @param {ScenarioCreateArgs} args - Arguments to create a Scenario.
     * @example
     * // Create one Scenario
     * const Scenario = await prisma.scenario.create({
     *   data: {
     *     // ... data to create a Scenario
     *   }
     * })
     * 
     */
    create<T extends ScenarioCreateArgs>(args: SelectSubset<T, ScenarioCreateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scenarios.
     * @param {ScenarioCreateManyArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScenarioCreateManyArgs>(args?: SelectSubset<T, ScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scenarios and returns the data saved in the database.
     * @param {ScenarioCreateManyAndReturnArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Scenario.
     * @param {ScenarioDeleteArgs} args - Arguments to delete one Scenario.
     * @example
     * // Delete one Scenario
     * const Scenario = await prisma.scenario.delete({
     *   where: {
     *     // ... filter to delete one Scenario
     *   }
     * })
     * 
     */
    delete<T extends ScenarioDeleteArgs>(args: SelectSubset<T, ScenarioDeleteArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scenario.
     * @param {ScenarioUpdateArgs} args - Arguments to update one Scenario.
     * @example
     * // Update one Scenario
     * const scenario = await prisma.scenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScenarioUpdateArgs>(args: SelectSubset<T, ScenarioUpdateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scenarios.
     * @param {ScenarioDeleteManyArgs} args - Arguments to filter Scenarios to delete.
     * @example
     * // Delete a few Scenarios
     * const { count } = await prisma.scenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScenarioDeleteManyArgs>(args?: SelectSubset<T, ScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScenarioUpdateManyArgs>(args: SelectSubset<T, ScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios and returns the data updated in the database.
     * @param {ScenarioUpdateManyAndReturnArgs} args - Arguments to update many Scenarios.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScenarioUpdateManyAndReturnArgs>(args: SelectSubset<T, ScenarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Scenario.
     * @param {ScenarioUpsertArgs} args - Arguments to update or create a Scenario.
     * @example
     * // Update or create a Scenario
     * const scenario = await prisma.scenario.upsert({
     *   create: {
     *     // ... data to create a Scenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scenario we want to update
     *   }
     * })
     */
    upsert<T extends ScenarioUpsertArgs>(args: SelectSubset<T, ScenarioUpsertArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioCountArgs} args - Arguments to filter Scenarios to count.
     * @example
     * // Count the number of Scenarios
     * const count = await prisma.scenario.count({
     *   where: {
     *     // ... the filter for the Scenarios we want to count
     *   }
     * })
    **/
    count<T extends ScenarioCountArgs>(
      args?: Subset<T, ScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScenarioAggregateArgs>(args: Subset<T, ScenarioAggregateArgs>): Prisma.PrismaPromise<GetScenarioAggregateType<T>>

    /**
     * Group by Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScenarioGroupByArgs['orderBy'] }
        : { orderBy?: ScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scenario model
   */
  readonly fields: ScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scenario model
   */
  interface ScenarioFieldRefs {
    readonly id: FieldRef<"Scenario", 'String'>
    readonly tenantId: FieldRef<"Scenario", 'String'>
    readonly name: FieldRef<"Scenario", 'String'>
    readonly description: FieldRef<"Scenario", 'String'>
    readonly scenarioType: FieldRef<"Scenario", 'ScenarioType'>
    readonly config: FieldRef<"Scenario", 'Json'>
    readonly baselineRunway: FieldRef<"Scenario", 'Float'>
    readonly projectedRunway: FieldRef<"Scenario", 'Float'>
    readonly runwayChange: FieldRef<"Scenario", 'Float'>
    readonly riskLevel: FieldRef<"Scenario", 'RiskLevel'>
    readonly riskScore: FieldRef<"Scenario", 'Float'>
    readonly successProbability: FieldRef<"Scenario", 'Float'>
    readonly topRiskDrivers: FieldRef<"Scenario", 'Json'>
    readonly criticalAssumptions: FieldRef<"Scenario", 'Json'>
    readonly cashFlowImpact: FieldRef<"Scenario", 'Json'>
    readonly automationImpact: FieldRef<"Scenario", 'Json'>
    readonly paymentImpact: FieldRef<"Scenario", 'Json'>
    readonly recommendations: FieldRef<"Scenario", 'Json'>
    readonly createdBy: FieldRef<"Scenario", 'String'>
    readonly isArchived: FieldRef<"Scenario", 'Boolean'>
    readonly createdAt: FieldRef<"Scenario", 'DateTime'>
    readonly updatedAt: FieldRef<"Scenario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Scenario findUnique
   */
  export type ScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findUniqueOrThrow
   */
  export type ScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findFirst
   */
  export type ScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findFirstOrThrow
   */
  export type ScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findMany
   */
  export type ScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenarios to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario create
   */
  export type ScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Scenario.
     */
    data: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
  }

  /**
   * Scenario createMany
   */
  export type ScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scenario createManyAndReturn
   */
  export type ScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scenario update
   */
  export type ScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Scenario.
     */
    data: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
    /**
     * Choose, which Scenario to update.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario updateMany
   */
  export type ScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
  }

  /**
   * Scenario updateManyAndReturn
   */
  export type ScenarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scenario upsert
   */
  export type ScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Scenario to update in case it exists.
     */
    where: ScenarioWhereUniqueInput
    /**
     * In case the Scenario found by the `where` argument doesn't exist, create a new Scenario with this data.
     */
    create: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
    /**
     * In case the Scenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
  }

  /**
   * Scenario delete
   */
  export type ScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter which Scenario to delete.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario deleteMany
   */
  export type ScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenarios to delete
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to delete.
     */
    limit?: number
  }

  /**
   * Scenario without action
   */
  export type ScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
  }


  /**
   * Model ScenarioAnalytics
   */

  export type AggregateScenarioAnalytics = {
    _count: ScenarioAnalyticsCountAggregateOutputType | null
    _avg: ScenarioAnalyticsAvgAggregateOutputType | null
    _sum: ScenarioAnalyticsSumAggregateOutputType | null
    _min: ScenarioAnalyticsMinAggregateOutputType | null
    _max: ScenarioAnalyticsMaxAggregateOutputType | null
  }

  export type ScenarioAnalyticsAvgAggregateOutputType = {
    timeToDecision: number | null
  }

  export type ScenarioAnalyticsSumAggregateOutputType = {
    timeToDecision: number | null
  }

  export type ScenarioAnalyticsMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    scenarioId: string | null
    eventType: string | null
    scenarioType: string | null
    decisionMade: boolean | null
    decisionOutcome: string | null
    riskAvoided: boolean | null
    upgradeTriggered: boolean | null
    planBefore: string | null
    planAfter: string | null
    timeToDecision: number | null
    timestamp: Date | null
  }

  export type ScenarioAnalyticsMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    scenarioId: string | null
    eventType: string | null
    scenarioType: string | null
    decisionMade: boolean | null
    decisionOutcome: string | null
    riskAvoided: boolean | null
    upgradeTriggered: boolean | null
    planBefore: string | null
    planAfter: string | null
    timeToDecision: number | null
    timestamp: Date | null
  }

  export type ScenarioAnalyticsCountAggregateOutputType = {
    id: number
    tenantId: number
    scenarioId: number
    eventType: number
    scenarioType: number
    decisionMade: number
    decisionOutcome: number
    riskAvoided: number
    upgradeTriggered: number
    planBefore: number
    planAfter: number
    timeToDecision: number
    timestamp: number
    _all: number
  }


  export type ScenarioAnalyticsAvgAggregateInputType = {
    timeToDecision?: true
  }

  export type ScenarioAnalyticsSumAggregateInputType = {
    timeToDecision?: true
  }

  export type ScenarioAnalyticsMinAggregateInputType = {
    id?: true
    tenantId?: true
    scenarioId?: true
    eventType?: true
    scenarioType?: true
    decisionMade?: true
    decisionOutcome?: true
    riskAvoided?: true
    upgradeTriggered?: true
    planBefore?: true
    planAfter?: true
    timeToDecision?: true
    timestamp?: true
  }

  export type ScenarioAnalyticsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    scenarioId?: true
    eventType?: true
    scenarioType?: true
    decisionMade?: true
    decisionOutcome?: true
    riskAvoided?: true
    upgradeTriggered?: true
    planBefore?: true
    planAfter?: true
    timeToDecision?: true
    timestamp?: true
  }

  export type ScenarioAnalyticsCountAggregateInputType = {
    id?: true
    tenantId?: true
    scenarioId?: true
    eventType?: true
    scenarioType?: true
    decisionMade?: true
    decisionOutcome?: true
    riskAvoided?: true
    upgradeTriggered?: true
    planBefore?: true
    planAfter?: true
    timeToDecision?: true
    timestamp?: true
    _all?: true
  }

  export type ScenarioAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScenarioAnalytics to aggregate.
     */
    where?: ScenarioAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScenarioAnalytics to fetch.
     */
    orderBy?: ScenarioAnalyticsOrderByWithRelationInput | ScenarioAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScenarioAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScenarioAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScenarioAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScenarioAnalytics
    **/
    _count?: true | ScenarioAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScenarioAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScenarioAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScenarioAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScenarioAnalyticsMaxAggregateInputType
  }

  export type GetScenarioAnalyticsAggregateType<T extends ScenarioAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateScenarioAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScenarioAnalytics[P]>
      : GetScalarType<T[P], AggregateScenarioAnalytics[P]>
  }




  export type ScenarioAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioAnalyticsWhereInput
    orderBy?: ScenarioAnalyticsOrderByWithAggregationInput | ScenarioAnalyticsOrderByWithAggregationInput[]
    by: ScenarioAnalyticsScalarFieldEnum[] | ScenarioAnalyticsScalarFieldEnum
    having?: ScenarioAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScenarioAnalyticsCountAggregateInputType | true
    _avg?: ScenarioAnalyticsAvgAggregateInputType
    _sum?: ScenarioAnalyticsSumAggregateInputType
    _min?: ScenarioAnalyticsMinAggregateInputType
    _max?: ScenarioAnalyticsMaxAggregateInputType
  }

  export type ScenarioAnalyticsGroupByOutputType = {
    id: string
    tenantId: string
    scenarioId: string | null
    eventType: string
    scenarioType: string | null
    decisionMade: boolean | null
    decisionOutcome: string | null
    riskAvoided: boolean | null
    upgradeTriggered: boolean | null
    planBefore: string | null
    planAfter: string | null
    timeToDecision: number | null
    timestamp: Date
    _count: ScenarioAnalyticsCountAggregateOutputType | null
    _avg: ScenarioAnalyticsAvgAggregateOutputType | null
    _sum: ScenarioAnalyticsSumAggregateOutputType | null
    _min: ScenarioAnalyticsMinAggregateOutputType | null
    _max: ScenarioAnalyticsMaxAggregateOutputType | null
  }

  type GetScenarioAnalyticsGroupByPayload<T extends ScenarioAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScenarioAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScenarioAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScenarioAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], ScenarioAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type ScenarioAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    scenarioId?: boolean
    eventType?: boolean
    scenarioType?: boolean
    decisionMade?: boolean
    decisionOutcome?: boolean
    riskAvoided?: boolean
    upgradeTriggered?: boolean
    planBefore?: boolean
    planAfter?: boolean
    timeToDecision?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenarioAnalytics"]>

  export type ScenarioAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    scenarioId?: boolean
    eventType?: boolean
    scenarioType?: boolean
    decisionMade?: boolean
    decisionOutcome?: boolean
    riskAvoided?: boolean
    upgradeTriggered?: boolean
    planBefore?: boolean
    planAfter?: boolean
    timeToDecision?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenarioAnalytics"]>

  export type ScenarioAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    scenarioId?: boolean
    eventType?: boolean
    scenarioType?: boolean
    decisionMade?: boolean
    decisionOutcome?: boolean
    riskAvoided?: boolean
    upgradeTriggered?: boolean
    planBefore?: boolean
    planAfter?: boolean
    timeToDecision?: boolean
    timestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenarioAnalytics"]>

  export type ScenarioAnalyticsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    scenarioId?: boolean
    eventType?: boolean
    scenarioType?: boolean
    decisionMade?: boolean
    decisionOutcome?: boolean
    riskAvoided?: boolean
    upgradeTriggered?: boolean
    planBefore?: boolean
    planAfter?: boolean
    timeToDecision?: boolean
    timestamp?: boolean
  }

  export type ScenarioAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "scenarioId" | "eventType" | "scenarioType" | "decisionMade" | "decisionOutcome" | "riskAvoided" | "upgradeTriggered" | "planBefore" | "planAfter" | "timeToDecision" | "timestamp", ExtArgs["result"]["scenarioAnalytics"]>
  export type ScenarioAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ScenarioAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ScenarioAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ScenarioAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScenarioAnalytics"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      scenarioId: string | null
      eventType: string
      scenarioType: string | null
      decisionMade: boolean | null
      decisionOutcome: string | null
      riskAvoided: boolean | null
      upgradeTriggered: boolean | null
      planBefore: string | null
      planAfter: string | null
      timeToDecision: number | null
      timestamp: Date
    }, ExtArgs["result"]["scenarioAnalytics"]>
    composites: {}
  }

  type ScenarioAnalyticsGetPayload<S extends boolean | null | undefined | ScenarioAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$ScenarioAnalyticsPayload, S>

  type ScenarioAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScenarioAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScenarioAnalyticsCountAggregateInputType | true
    }

  export interface ScenarioAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScenarioAnalytics'], meta: { name: 'ScenarioAnalytics' } }
    /**
     * Find zero or one ScenarioAnalytics that matches the filter.
     * @param {ScenarioAnalyticsFindUniqueArgs} args - Arguments to find a ScenarioAnalytics
     * @example
     * // Get one ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScenarioAnalyticsFindUniqueArgs>(args: SelectSubset<T, ScenarioAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScenarioAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScenarioAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a ScenarioAnalytics
     * @example
     * // Get one ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScenarioAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, ScenarioAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScenarioAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAnalyticsFindFirstArgs} args - Arguments to find a ScenarioAnalytics
     * @example
     * // Get one ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScenarioAnalyticsFindFirstArgs>(args?: SelectSubset<T, ScenarioAnalyticsFindFirstArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScenarioAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAnalyticsFindFirstOrThrowArgs} args - Arguments to find a ScenarioAnalytics
     * @example
     * // Get one ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScenarioAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, ScenarioAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScenarioAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.findMany()
     * 
     * // Get first 10 ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scenarioAnalyticsWithIdOnly = await prisma.scenarioAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScenarioAnalyticsFindManyArgs>(args?: SelectSubset<T, ScenarioAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScenarioAnalytics.
     * @param {ScenarioAnalyticsCreateArgs} args - Arguments to create a ScenarioAnalytics.
     * @example
     * // Create one ScenarioAnalytics
     * const ScenarioAnalytics = await prisma.scenarioAnalytics.create({
     *   data: {
     *     // ... data to create a ScenarioAnalytics
     *   }
     * })
     * 
     */
    create<T extends ScenarioAnalyticsCreateArgs>(args: SelectSubset<T, ScenarioAnalyticsCreateArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScenarioAnalytics.
     * @param {ScenarioAnalyticsCreateManyArgs} args - Arguments to create many ScenarioAnalytics.
     * @example
     * // Create many ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScenarioAnalyticsCreateManyArgs>(args?: SelectSubset<T, ScenarioAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScenarioAnalytics and returns the data saved in the database.
     * @param {ScenarioAnalyticsCreateManyAndReturnArgs} args - Arguments to create many ScenarioAnalytics.
     * @example
     * // Create many ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScenarioAnalytics and only return the `id`
     * const scenarioAnalyticsWithIdOnly = await prisma.scenarioAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScenarioAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, ScenarioAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScenarioAnalytics.
     * @param {ScenarioAnalyticsDeleteArgs} args - Arguments to delete one ScenarioAnalytics.
     * @example
     * // Delete one ScenarioAnalytics
     * const ScenarioAnalytics = await prisma.scenarioAnalytics.delete({
     *   where: {
     *     // ... filter to delete one ScenarioAnalytics
     *   }
     * })
     * 
     */
    delete<T extends ScenarioAnalyticsDeleteArgs>(args: SelectSubset<T, ScenarioAnalyticsDeleteArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScenarioAnalytics.
     * @param {ScenarioAnalyticsUpdateArgs} args - Arguments to update one ScenarioAnalytics.
     * @example
     * // Update one ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScenarioAnalyticsUpdateArgs>(args: SelectSubset<T, ScenarioAnalyticsUpdateArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScenarioAnalytics.
     * @param {ScenarioAnalyticsDeleteManyArgs} args - Arguments to filter ScenarioAnalytics to delete.
     * @example
     * // Delete a few ScenarioAnalytics
     * const { count } = await prisma.scenarioAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScenarioAnalyticsDeleteManyArgs>(args?: SelectSubset<T, ScenarioAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScenarioAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScenarioAnalyticsUpdateManyArgs>(args: SelectSubset<T, ScenarioAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScenarioAnalytics and returns the data updated in the database.
     * @param {ScenarioAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many ScenarioAnalytics.
     * @example
     * // Update many ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScenarioAnalytics and only return the `id`
     * const scenarioAnalyticsWithIdOnly = await prisma.scenarioAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScenarioAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, ScenarioAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScenarioAnalytics.
     * @param {ScenarioAnalyticsUpsertArgs} args - Arguments to update or create a ScenarioAnalytics.
     * @example
     * // Update or create a ScenarioAnalytics
     * const scenarioAnalytics = await prisma.scenarioAnalytics.upsert({
     *   create: {
     *     // ... data to create a ScenarioAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScenarioAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends ScenarioAnalyticsUpsertArgs>(args: SelectSubset<T, ScenarioAnalyticsUpsertArgs<ExtArgs>>): Prisma__ScenarioAnalyticsClient<$Result.GetResult<Prisma.$ScenarioAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScenarioAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAnalyticsCountArgs} args - Arguments to filter ScenarioAnalytics to count.
     * @example
     * // Count the number of ScenarioAnalytics
     * const count = await prisma.scenarioAnalytics.count({
     *   where: {
     *     // ... the filter for the ScenarioAnalytics we want to count
     *   }
     * })
    **/
    count<T extends ScenarioAnalyticsCountArgs>(
      args?: Subset<T, ScenarioAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScenarioAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScenarioAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScenarioAnalyticsAggregateArgs>(args: Subset<T, ScenarioAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetScenarioAnalyticsAggregateType<T>>

    /**
     * Group by ScenarioAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScenarioAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScenarioAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: ScenarioAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScenarioAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScenarioAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScenarioAnalytics model
   */
  readonly fields: ScenarioAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScenarioAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScenarioAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScenarioAnalytics model
   */
  interface ScenarioAnalyticsFieldRefs {
    readonly id: FieldRef<"ScenarioAnalytics", 'String'>
    readonly tenantId: FieldRef<"ScenarioAnalytics", 'String'>
    readonly scenarioId: FieldRef<"ScenarioAnalytics", 'String'>
    readonly eventType: FieldRef<"ScenarioAnalytics", 'String'>
    readonly scenarioType: FieldRef<"ScenarioAnalytics", 'String'>
    readonly decisionMade: FieldRef<"ScenarioAnalytics", 'Boolean'>
    readonly decisionOutcome: FieldRef<"ScenarioAnalytics", 'String'>
    readonly riskAvoided: FieldRef<"ScenarioAnalytics", 'Boolean'>
    readonly upgradeTriggered: FieldRef<"ScenarioAnalytics", 'Boolean'>
    readonly planBefore: FieldRef<"ScenarioAnalytics", 'String'>
    readonly planAfter: FieldRef<"ScenarioAnalytics", 'String'>
    readonly timeToDecision: FieldRef<"ScenarioAnalytics", 'Int'>
    readonly timestamp: FieldRef<"ScenarioAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScenarioAnalytics findUnique
   */
  export type ScenarioAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ScenarioAnalytics to fetch.
     */
    where: ScenarioAnalyticsWhereUniqueInput
  }

  /**
   * ScenarioAnalytics findUniqueOrThrow
   */
  export type ScenarioAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ScenarioAnalytics to fetch.
     */
    where: ScenarioAnalyticsWhereUniqueInput
  }

  /**
   * ScenarioAnalytics findFirst
   */
  export type ScenarioAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ScenarioAnalytics to fetch.
     */
    where?: ScenarioAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScenarioAnalytics to fetch.
     */
    orderBy?: ScenarioAnalyticsOrderByWithRelationInput | ScenarioAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScenarioAnalytics.
     */
    cursor?: ScenarioAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScenarioAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScenarioAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScenarioAnalytics.
     */
    distinct?: ScenarioAnalyticsScalarFieldEnum | ScenarioAnalyticsScalarFieldEnum[]
  }

  /**
   * ScenarioAnalytics findFirstOrThrow
   */
  export type ScenarioAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ScenarioAnalytics to fetch.
     */
    where?: ScenarioAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScenarioAnalytics to fetch.
     */
    orderBy?: ScenarioAnalyticsOrderByWithRelationInput | ScenarioAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScenarioAnalytics.
     */
    cursor?: ScenarioAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScenarioAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScenarioAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScenarioAnalytics.
     */
    distinct?: ScenarioAnalyticsScalarFieldEnum | ScenarioAnalyticsScalarFieldEnum[]
  }

  /**
   * ScenarioAnalytics findMany
   */
  export type ScenarioAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ScenarioAnalytics to fetch.
     */
    where?: ScenarioAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScenarioAnalytics to fetch.
     */
    orderBy?: ScenarioAnalyticsOrderByWithRelationInput | ScenarioAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScenarioAnalytics.
     */
    cursor?: ScenarioAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScenarioAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScenarioAnalytics.
     */
    skip?: number
    distinct?: ScenarioAnalyticsScalarFieldEnum | ScenarioAnalyticsScalarFieldEnum[]
  }

  /**
   * ScenarioAnalytics create
   */
  export type ScenarioAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a ScenarioAnalytics.
     */
    data: XOR<ScenarioAnalyticsCreateInput, ScenarioAnalyticsUncheckedCreateInput>
  }

  /**
   * ScenarioAnalytics createMany
   */
  export type ScenarioAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScenarioAnalytics.
     */
    data: ScenarioAnalyticsCreateManyInput | ScenarioAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScenarioAnalytics createManyAndReturn
   */
  export type ScenarioAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many ScenarioAnalytics.
     */
    data: ScenarioAnalyticsCreateManyInput | ScenarioAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScenarioAnalytics update
   */
  export type ScenarioAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a ScenarioAnalytics.
     */
    data: XOR<ScenarioAnalyticsUpdateInput, ScenarioAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which ScenarioAnalytics to update.
     */
    where: ScenarioAnalyticsWhereUniqueInput
  }

  /**
   * ScenarioAnalytics updateMany
   */
  export type ScenarioAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScenarioAnalytics.
     */
    data: XOR<ScenarioAnalyticsUpdateManyMutationInput, ScenarioAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which ScenarioAnalytics to update
     */
    where?: ScenarioAnalyticsWhereInput
    /**
     * Limit how many ScenarioAnalytics to update.
     */
    limit?: number
  }

  /**
   * ScenarioAnalytics updateManyAndReturn
   */
  export type ScenarioAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update ScenarioAnalytics.
     */
    data: XOR<ScenarioAnalyticsUpdateManyMutationInput, ScenarioAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which ScenarioAnalytics to update
     */
    where?: ScenarioAnalyticsWhereInput
    /**
     * Limit how many ScenarioAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScenarioAnalytics upsert
   */
  export type ScenarioAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the ScenarioAnalytics to update in case it exists.
     */
    where: ScenarioAnalyticsWhereUniqueInput
    /**
     * In case the ScenarioAnalytics found by the `where` argument doesn't exist, create a new ScenarioAnalytics with this data.
     */
    create: XOR<ScenarioAnalyticsCreateInput, ScenarioAnalyticsUncheckedCreateInput>
    /**
     * In case the ScenarioAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScenarioAnalyticsUpdateInput, ScenarioAnalyticsUncheckedUpdateInput>
  }

  /**
   * ScenarioAnalytics delete
   */
  export type ScenarioAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which ScenarioAnalytics to delete.
     */
    where: ScenarioAnalyticsWhereUniqueInput
  }

  /**
   * ScenarioAnalytics deleteMany
   */
  export type ScenarioAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScenarioAnalytics to delete
     */
    where?: ScenarioAnalyticsWhereInput
    /**
     * Limit how many ScenarioAnalytics to delete.
     */
    limit?: number
  }

  /**
   * ScenarioAnalytics without action
   */
  export type ScenarioAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioAnalytics
     */
    select?: ScenarioAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScenarioAnalytics
     */
    omit?: ScenarioAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password',
    role: 'role',
    tenantId: 'tenantId',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    refreshToken: 'refreshToken',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    expiresAt: 'expiresAt',
    tokenType: 'tokenType',
    scope: 'scope',
    idToken: 'idToken',
    sessionState: 'sessionState'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    customDomain: 'customDomain',
    logo: 'logo',
    favicon: 'favicon',
    theme: 'theme',
    featureFlags: 'featureFlags',
    settings: 'settings',
    plan: 'plan',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const DashboardLayoutScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role',
    tenantId: 'tenantId',
    name: 'name',
    isDefault: 'isDefault',
    layout: 'layout',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DashboardLayoutScalarFieldEnum = (typeof DashboardLayoutScalarFieldEnum)[keyof typeof DashboardLayoutScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    allowed: 'allowed',
    reason: 'reason',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    eventType: 'eventType',
    featureFlag: 'featureFlag',
    featureName: 'featureName',
    userId: 'userId',
    userRole: 'userRole',
    tenantId: 'tenantId',
    sessionId: 'sessionId',
    metadata: 'metadata',
    timestamp: 'timestamp',
    serverTimestamp: 'serverTimestamp',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const AutomationRuleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    triggerType: 'triggerType',
    triggerConfig: 'triggerConfig',
    conditions: 'conditions',
    actions: 'actions',
    status: 'status',
    isTemplate: 'isTemplate',
    requiresApproval: 'requiresApproval',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    lastTriggered: 'lastTriggered',
    executionCount: 'executionCount',
    successCount: 'successCount',
    failureCount: 'failureCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationRuleScalarFieldEnum = (typeof AutomationRuleScalarFieldEnum)[keyof typeof AutomationRuleScalarFieldEnum]


  export const AutomationExecutionScalarFieldEnum: {
    id: 'id',
    ruleId: 'ruleId',
    tenantId: 'tenantId',
    status: 'status',
    triggeredBy: 'triggeredBy',
    triggerData: 'triggerData',
    conditionsEvaluated: 'conditionsEvaluated',
    conditionsMet: 'conditionsMet',
    actionsExecuted: 'actionsExecuted',
    isDryRun: 'isDryRun',
    errorMessage: 'errorMessage',
    executionTime: 'executionTime',
    retryCount: 'retryCount',
    nextRetryAt: 'nextRetryAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type AutomationExecutionScalarFieldEnum = (typeof AutomationExecutionScalarFieldEnum)[keyof typeof AutomationExecutionScalarFieldEnum]


  export const SmartInsightScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    insightType: 'insightType',
    severity: 'severity',
    title: 'title',
    description: 'description',
    explanation: 'explanation',
    confidence: 'confidence',
    metadata: 'metadata',
    relatedEntities: 'relatedEntities',
    actionable: 'actionable',
    suggestedActions: 'suggestedActions',
    dismissedBy: 'dismissedBy',
    dismissedAt: 'dismissedAt',
    dismissReason: 'dismissReason',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type SmartInsightScalarFieldEnum = (typeof SmartInsightScalarFieldEnum)[keyof typeof SmartInsightScalarFieldEnum]


  export const AutomationTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    triggerType: 'triggerType',
    triggerConfig: 'triggerConfig',
    conditions: 'conditions',
    actions: 'actions',
    requiredPlan: 'requiredPlan',
    popularity: 'popularity',
    isPublic: 'isPublic',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutomationTemplateScalarFieldEnum = (typeof AutomationTemplateScalarFieldEnum)[keyof typeof AutomationTemplateScalarFieldEnum]


  export const AutomationUsageMetricScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    ruleId: 'ruleId',
    executionId: 'executionId',
    actionType: 'actionType',
    success: 'success',
    executionTime: 'executionTime',
    costImpact: 'costImpact',
    businessImpact: 'businessImpact',
    timestamp: 'timestamp'
  };

  export type AutomationUsageMetricScalarFieldEnum = (typeof AutomationUsageMetricScalarFieldEnum)[keyof typeof AutomationUsageMetricScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    customerId: 'customerId',
    type: 'type',
    isDefault: 'isDefault',
    token: 'token',
    last4: 'last4',
    brand: 'brand',
    expiryMonth: 'expiryMonth',
    expiryYear: 'expiryYear',
    accountType: 'accountType',
    routingNumber: 'routingNumber',
    nickname: 'nickname',
    billingAddress: 'billingAddress',
    metadata: 'metadata',
    isActive: 'isActive',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    paymentMethodId: 'paymentMethodId',
    invoiceId: 'invoiceId',
    type: 'type',
    status: 'status',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    processorId: 'processorId',
    processorStatus: 'processorStatus',
    processorResponse: 'processorResponse',
    automationRuleId: 'automationRuleId',
    automationExecutionId: 'automationExecutionId',
    isAutomated: 'isAutomated',
    scheduledFor: 'scheduledFor',
    processedAt: 'processedAt',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    nextRetryAt: 'nextRetryAt',
    reconciledAt: 'reconciledAt',
    ledgerEntryId: 'ledgerEntryId',
    processingFee: 'processingFee',
    netAmount: 'netAmount',
    isDisputed: 'isDisputed',
    disputeReason: 'disputeReason',
    disputedAt: 'disputedAt',
    requiresApproval: 'requiresApproval',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    metadata: 'metadata',
    failureReason: 'failureReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentReconciliationScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    tenantId: 'tenantId',
    status: 'status',
    ledgerEntryId: 'ledgerEntryId',
    accountId: 'accountId',
    matchedAmount: 'matchedAmount',
    variance: 'variance',
    varianceReason: 'varianceReason',
    reconciledBy: 'reconciledBy',
    reconciledAt: 'reconciledAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentReconciliationScalarFieldEnum = (typeof PaymentReconciliationScalarFieldEnum)[keyof typeof PaymentReconciliationScalarFieldEnum]


  export const PaymentExplainabilityScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    tenantId: 'tenantId',
    trigger: 'trigger',
    triggerDetails: 'triggerDetails',
    conditionsMet: 'conditionsMet',
    amountCalculation: 'amountCalculation',
    baseAmount: 'baseAmount',
    adjustments: 'adjustments',
    confidenceScore: 'confidenceScore',
    safeguards: 'safeguards',
    riskFactors: 'riskFactors',
    approvalRequired: 'approvalRequired',
    approvalStatus: 'approvalStatus',
    businessImpact: 'businessImpact',
    estimatedTimeSaved: 'estimatedTimeSaved',
    explanation: 'explanation',
    createdAt: 'createdAt'
  };

  export type PaymentExplainabilityScalarFieldEnum = (typeof PaymentExplainabilityScalarFieldEnum)[keyof typeof PaymentExplainabilityScalarFieldEnum]


  export const CashControlRuleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    ruleType: 'ruleType',
    config: 'config',
    conditions: 'conditions',
    isActive: 'isActive',
    requiresApproval: 'requiresApproval',
    executionCount: 'executionCount',
    successCount: 'successCount',
    failureCount: 'failureCount',
    totalAmountProcessed: 'totalAmountProcessed',
    createdBy: 'createdBy',
    lastExecuted: 'lastExecuted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashControlRuleScalarFieldEnum = (typeof CashControlRuleScalarFieldEnum)[keyof typeof CashControlRuleScalarFieldEnum]


  export const CashControlExecutionScalarFieldEnum: {
    id: 'id',
    ruleId: 'ruleId',
    tenantId: 'tenantId',
    status: 'status',
    triggerData: 'triggerData',
    conditionsEvaluated: 'conditionsEvaluated',
    paymentId: 'paymentId',
    amount: 'amount',
    success: 'success',
    errorMessage: 'errorMessage',
    executionTime: 'executionTime',
    isDryRun: 'isDryRun',
    createdAt: 'createdAt'
  };

  export type CashControlExecutionScalarFieldEnum = (typeof CashControlExecutionScalarFieldEnum)[keyof typeof CashControlExecutionScalarFieldEnum]


  export const PaymentAnalyticsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    paymentId: 'paymentId',
    eventType: 'eventType',
    amount: 'amount',
    processingFee: 'processingFee',
    isAutomated: 'isAutomated',
    automationRuleId: 'automationRuleId',
    timeToCash: 'timeToCash',
    retryCount: 'retryCount',
    revenueImpact: 'revenueImpact',
    timestamp: 'timestamp'
  };

  export type PaymentAnalyticsScalarFieldEnum = (typeof PaymentAnalyticsScalarFieldEnum)[keyof typeof PaymentAnalyticsScalarFieldEnum]


  export const FinancialForecastScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    forecastType: 'forecastType',
    value: 'value',
    unit: 'unit',
    confidenceScore: 'confidenceScore',
    forecastDate: 'forecastDate',
    forecastHorizon: 'forecastHorizon',
    formula: 'formula',
    assumptions: 'assumptions',
    dataSources: 'dataSources',
    historicalBaseline: 'historicalBaseline',
    calculatedAt: 'calculatedAt'
  };

  export type FinancialForecastScalarFieldEnum = (typeof FinancialForecastScalarFieldEnum)[keyof typeof FinancialForecastScalarFieldEnum]


  export const ScenarioScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    scenarioType: 'scenarioType',
    config: 'config',
    baselineRunway: 'baselineRunway',
    projectedRunway: 'projectedRunway',
    runwayChange: 'runwayChange',
    riskLevel: 'riskLevel',
    riskScore: 'riskScore',
    successProbability: 'successProbability',
    topRiskDrivers: 'topRiskDrivers',
    criticalAssumptions: 'criticalAssumptions',
    cashFlowImpact: 'cashFlowImpact',
    automationImpact: 'automationImpact',
    paymentImpact: 'paymentImpact',
    recommendations: 'recommendations',
    createdBy: 'createdBy',
    isArchived: 'isArchived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScenarioScalarFieldEnum = (typeof ScenarioScalarFieldEnum)[keyof typeof ScenarioScalarFieldEnum]


  export const ScenarioAnalyticsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    scenarioId: 'scenarioId',
    eventType: 'eventType',
    scenarioType: 'scenarioType',
    decisionMade: 'decisionMade',
    decisionOutcome: 'decisionOutcome',
    riskAvoided: 'riskAvoided',
    upgradeTriggered: 'upgradeTriggered',
    planBefore: 'planBefore',
    planAfter: 'planAfter',
    timeToDecision: 'timeToDecision',
    timestamp: 'timestamp'
  };

  export type ScenarioAnalyticsScalarFieldEnum = (typeof ScenarioAnalyticsScalarFieldEnum)[keyof typeof ScenarioAnalyticsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan[]'
   */
  export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


  /**
   * Reference to a field of type 'TenantStatus'
   */
  export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


  /**
   * Reference to a field of type 'TenantStatus[]'
   */
  export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


  /**
   * Reference to a field of type 'AutomationTriggerType'
   */
  export type EnumAutomationTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationTriggerType'>
    


  /**
   * Reference to a field of type 'AutomationTriggerType[]'
   */
  export type ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationTriggerType[]'>
    


  /**
   * Reference to a field of type 'AutomationStatus'
   */
  export type EnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus'>
    


  /**
   * Reference to a field of type 'AutomationStatus[]'
   */
  export type ListEnumAutomationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationStatus[]'>
    


  /**
   * Reference to a field of type 'AutomationExecutionStatus'
   */
  export type EnumAutomationExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationExecutionStatus'>
    


  /**
   * Reference to a field of type 'AutomationExecutionStatus[]'
   */
  export type ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationExecutionStatus[]'>
    


  /**
   * Reference to a field of type 'InsightType'
   */
  export type EnumInsightTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightType'>
    


  /**
   * Reference to a field of type 'InsightType[]'
   */
  export type ListEnumInsightTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightType[]'>
    


  /**
   * Reference to a field of type 'InsightSeverity'
   */
  export type EnumInsightSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightSeverity'>
    


  /**
   * Reference to a field of type 'InsightSeverity[]'
   */
  export type ListEnumInsightSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightSeverity[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentMethodType'
   */
  export type EnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType'>
    


  /**
   * Reference to a field of type 'PaymentMethodType[]'
   */
  export type ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodType[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'ReconciliationStatus'
   */
  export type EnumReconciliationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReconciliationStatus'>
    


  /**
   * Reference to a field of type 'ReconciliationStatus[]'
   */
  export type ListEnumReconciliationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReconciliationStatus[]'>
    


  /**
   * Reference to a field of type 'CashControlRuleType'
   */
  export type EnumCashControlRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashControlRuleType'>
    


  /**
   * Reference to a field of type 'CashControlRuleType[]'
   */
  export type ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashControlRuleType[]'>
    


  /**
   * Reference to a field of type 'ForecastType'
   */
  export type EnumForecastTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForecastType'>
    


  /**
   * Reference to a field of type 'ForecastType[]'
   */
  export type ListEnumForecastTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForecastType[]'>
    


  /**
   * Reference to a field of type 'ScenarioType'
   */
  export type EnumScenarioTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScenarioType'>
    


  /**
   * Reference to a field of type 'ScenarioType[]'
   */
  export type ListEnumScenarioTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScenarioType[]'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tenantId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    dashboardLayouts?: DashboardLayoutListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    dashboardLayouts?: DashboardLayoutOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tenantId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    dashboardLayouts?: DashboardLayoutListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    tenantId?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: IntNullableFilter<"Account"> | number | null
    tokenType?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    sessionState?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    sessionState?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: IntNullableFilter<"Account"> | number | null
    tokenType?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    sessionState?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    sessionState?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: IntNullableWithAggregatesFilter<"Account"> | number | null
    tokenType?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    sessionState?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    subdomain?: StringFilter<"Tenant"> | string
    customDomain?: StringNullableFilter<"Tenant"> | string | null
    logo?: JsonNullableFilter<"Tenant">
    favicon?: StringNullableFilter<"Tenant"> | string | null
    theme?: JsonNullableFilter<"Tenant">
    featureFlags?: JsonFilter<"Tenant">
    settings?: JsonFilter<"Tenant">
    plan?: EnumSubscriptionPlanFilter<"Tenant"> | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    dashboardLayouts?: DashboardLayoutListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    analyticsEvents?: AnalyticsEventListRelationFilter
    automationRules?: AutomationRuleListRelationFilter
    automationExecutions?: AutomationExecutionListRelationFilter
    smartInsights?: SmartInsightListRelationFilter
    automationMetrics?: AutomationUsageMetricListRelationFilter
    paymentMethods?: PaymentMethodListRelationFilter
    payments?: PaymentListRelationFilter
    paymentReconciliations?: PaymentReconciliationListRelationFilter
    paymentExplainability?: PaymentExplainabilityListRelationFilter
    cashControlRules?: CashControlRuleListRelationFilter
    cashControlExecutions?: CashControlExecutionListRelationFilter
    paymentAnalytics?: PaymentAnalyticsListRelationFilter
    financialForecasts?: FinancialForecastListRelationFilter
    scenarios?: ScenarioListRelationFilter
    scenarioAnalytics?: ScenarioAnalyticsListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    featureFlags?: SortOrder
    settings?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    dashboardLayouts?: DashboardLayoutOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    analyticsEvents?: AnalyticsEventOrderByRelationAggregateInput
    automationRules?: AutomationRuleOrderByRelationAggregateInput
    automationExecutions?: AutomationExecutionOrderByRelationAggregateInput
    smartInsights?: SmartInsightOrderByRelationAggregateInput
    automationMetrics?: AutomationUsageMetricOrderByRelationAggregateInput
    paymentMethods?: PaymentMethodOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    paymentReconciliations?: PaymentReconciliationOrderByRelationAggregateInput
    paymentExplainability?: PaymentExplainabilityOrderByRelationAggregateInput
    cashControlRules?: CashControlRuleOrderByRelationAggregateInput
    cashControlExecutions?: CashControlExecutionOrderByRelationAggregateInput
    paymentAnalytics?: PaymentAnalyticsOrderByRelationAggregateInput
    financialForecasts?: FinancialForecastOrderByRelationAggregateInput
    scenarios?: ScenarioOrderByRelationAggregateInput
    scenarioAnalytics?: ScenarioAnalyticsOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    customDomain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    logo?: JsonNullableFilter<"Tenant">
    favicon?: StringNullableFilter<"Tenant"> | string | null
    theme?: JsonNullableFilter<"Tenant">
    featureFlags?: JsonFilter<"Tenant">
    settings?: JsonFilter<"Tenant">
    plan?: EnumSubscriptionPlanFilter<"Tenant"> | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    dashboardLayouts?: DashboardLayoutListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    analyticsEvents?: AnalyticsEventListRelationFilter
    automationRules?: AutomationRuleListRelationFilter
    automationExecutions?: AutomationExecutionListRelationFilter
    smartInsights?: SmartInsightListRelationFilter
    automationMetrics?: AutomationUsageMetricListRelationFilter
    paymentMethods?: PaymentMethodListRelationFilter
    payments?: PaymentListRelationFilter
    paymentReconciliations?: PaymentReconciliationListRelationFilter
    paymentExplainability?: PaymentExplainabilityListRelationFilter
    cashControlRules?: CashControlRuleListRelationFilter
    cashControlExecutions?: CashControlExecutionListRelationFilter
    paymentAnalytics?: PaymentAnalyticsListRelationFilter
    financialForecasts?: FinancialForecastListRelationFilter
    scenarios?: ScenarioListRelationFilter
    scenarioAnalytics?: ScenarioAnalyticsListRelationFilter
  }, "id" | "subdomain" | "customDomain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    featureFlags?: SortOrder
    settings?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    subdomain?: StringWithAggregatesFilter<"Tenant"> | string
    customDomain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    logo?: JsonNullableWithAggregatesFilter<"Tenant">
    favicon?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    theme?: JsonNullableWithAggregatesFilter<"Tenant">
    featureFlags?: JsonWithAggregatesFilter<"Tenant">
    settings?: JsonWithAggregatesFilter<"Tenant">
    plan?: EnumSubscriptionPlanWithAggregatesFilter<"Tenant"> | $Enums.SubscriptionPlan
    status?: EnumTenantStatusWithAggregatesFilter<"Tenant"> | $Enums.TenantStatus
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type DashboardLayoutWhereInput = {
    AND?: DashboardLayoutWhereInput | DashboardLayoutWhereInput[]
    OR?: DashboardLayoutWhereInput[]
    NOT?: DashboardLayoutWhereInput | DashboardLayoutWhereInput[]
    id?: StringFilter<"DashboardLayout"> | string
    userId?: StringNullableFilter<"DashboardLayout"> | string | null
    role?: EnumRoleNullableFilter<"DashboardLayout"> | $Enums.Role | null
    tenantId?: StringFilter<"DashboardLayout"> | string
    name?: StringFilter<"DashboardLayout"> | string
    isDefault?: BoolFilter<"DashboardLayout"> | boolean
    layout?: JsonFilter<"DashboardLayout">
    createdAt?: DateTimeFilter<"DashboardLayout"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardLayout"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type DashboardLayoutOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    layout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type DashboardLayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tenantId?: DashboardLayoutUserIdTenantIdCompoundUniqueInput
    role_tenantId_isDefault?: DashboardLayoutRoleTenantIdIsDefaultCompoundUniqueInput
    AND?: DashboardLayoutWhereInput | DashboardLayoutWhereInput[]
    OR?: DashboardLayoutWhereInput[]
    NOT?: DashboardLayoutWhereInput | DashboardLayoutWhereInput[]
    userId?: StringNullableFilter<"DashboardLayout"> | string | null
    role?: EnumRoleNullableFilter<"DashboardLayout"> | $Enums.Role | null
    tenantId?: StringFilter<"DashboardLayout"> | string
    name?: StringFilter<"DashboardLayout"> | string
    isDefault?: BoolFilter<"DashboardLayout"> | boolean
    layout?: JsonFilter<"DashboardLayout">
    createdAt?: DateTimeFilter<"DashboardLayout"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardLayout"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "userId_tenantId" | "role_tenantId_isDefault">

  export type DashboardLayoutOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    layout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DashboardLayoutCountOrderByAggregateInput
    _max?: DashboardLayoutMaxOrderByAggregateInput
    _min?: DashboardLayoutMinOrderByAggregateInput
  }

  export type DashboardLayoutScalarWhereWithAggregatesInput = {
    AND?: DashboardLayoutScalarWhereWithAggregatesInput | DashboardLayoutScalarWhereWithAggregatesInput[]
    OR?: DashboardLayoutScalarWhereWithAggregatesInput[]
    NOT?: DashboardLayoutScalarWhereWithAggregatesInput | DashboardLayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DashboardLayout"> | string
    userId?: StringNullableWithAggregatesFilter<"DashboardLayout"> | string | null
    role?: EnumRoleNullableWithAggregatesFilter<"DashboardLayout"> | $Enums.Role | null
    tenantId?: StringWithAggregatesFilter<"DashboardLayout"> | string
    name?: StringWithAggregatesFilter<"DashboardLayout"> | string
    isDefault?: BoolWithAggregatesFilter<"DashboardLayout"> | boolean
    layout?: JsonWithAggregatesFilter<"DashboardLayout">
    createdAt?: DateTimeWithAggregatesFilter<"DashboardLayout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DashboardLayout"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    allowed?: BoolFilter<"AuditLog"> | boolean
    reason?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    allowed?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    allowed?: BoolFilter<"AuditLog"> | boolean
    reason?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    allowed?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    allowed?: BoolWithAggregatesFilter<"AuditLog"> | boolean
    reason?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    eventId?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    featureFlag?: StringFilter<"AnalyticsEvent"> | string
    featureName?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringFilter<"AnalyticsEvent"> | string
    userRole?: EnumRoleFilter<"AnalyticsEvent"> | $Enums.Role
    tenantId?: StringFilter<"AnalyticsEvent"> | string
    sessionId?: StringFilter<"AnalyticsEvent"> | string
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    serverTimestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    ipAddress?: StringNullableFilter<"AnalyticsEvent"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsEvent"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    featureFlag?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    userRole?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    serverTimestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    eventType?: StringFilter<"AnalyticsEvent"> | string
    featureFlag?: StringFilter<"AnalyticsEvent"> | string
    featureName?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringFilter<"AnalyticsEvent"> | string
    userRole?: EnumRoleFilter<"AnalyticsEvent"> | $Enums.Role
    tenantId?: StringFilter<"AnalyticsEvent"> | string
    sessionId?: StringFilter<"AnalyticsEvent"> | string
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    serverTimestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    ipAddress?: StringNullableFilter<"AnalyticsEvent"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsEvent"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "eventId">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    featureFlag?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    userRole?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    serverTimestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventId?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventType?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    featureFlag?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    featureName?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userId?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userRole?: EnumRoleWithAggregatesFilter<"AnalyticsEvent"> | $Enums.Role
    tenantId?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    sessionId?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AnalyticsEvent">
    timestamp?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
    serverTimestamp?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
  }

  export type AutomationRuleWhereInput = {
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    id?: StringFilter<"AutomationRule"> | string
    tenantId?: StringFilter<"AutomationRule"> | string
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerType?: EnumAutomationTriggerTypeFilter<"AutomationRule"> | $Enums.AutomationTriggerType
    triggerConfig?: JsonFilter<"AutomationRule">
    conditions?: JsonFilter<"AutomationRule">
    actions?: JsonFilter<"AutomationRule">
    status?: EnumAutomationStatusFilter<"AutomationRule"> | $Enums.AutomationStatus
    isTemplate?: BoolFilter<"AutomationRule"> | boolean
    requiresApproval?: BoolFilter<"AutomationRule"> | boolean
    createdBy?: StringFilter<"AutomationRule"> | string
    updatedBy?: StringNullableFilter<"AutomationRule"> | string | null
    lastTriggered?: DateTimeNullableFilter<"AutomationRule"> | Date | string | null
    executionCount?: IntFilter<"AutomationRule"> | number
    successCount?: IntFilter<"AutomationRule"> | number
    failureCount?: IntFilter<"AutomationRule"> | number
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationRule"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    executions?: AutomationExecutionListRelationFilter
  }

  export type AutomationRuleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    status?: SortOrder
    isTemplate?: SortOrder
    requiresApproval?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    executions?: AutomationExecutionOrderByRelationAggregateInput
  }

  export type AutomationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    tenantId?: StringFilter<"AutomationRule"> | string
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerType?: EnumAutomationTriggerTypeFilter<"AutomationRule"> | $Enums.AutomationTriggerType
    triggerConfig?: JsonFilter<"AutomationRule">
    conditions?: JsonFilter<"AutomationRule">
    actions?: JsonFilter<"AutomationRule">
    status?: EnumAutomationStatusFilter<"AutomationRule"> | $Enums.AutomationStatus
    isTemplate?: BoolFilter<"AutomationRule"> | boolean
    requiresApproval?: BoolFilter<"AutomationRule"> | boolean
    createdBy?: StringFilter<"AutomationRule"> | string
    updatedBy?: StringNullableFilter<"AutomationRule"> | string | null
    lastTriggered?: DateTimeNullableFilter<"AutomationRule"> | Date | string | null
    executionCount?: IntFilter<"AutomationRule"> | number
    successCount?: IntFilter<"AutomationRule"> | number
    failureCount?: IntFilter<"AutomationRule"> | number
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationRule"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    executions?: AutomationExecutionListRelationFilter
  }, "id">

  export type AutomationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    status?: SortOrder
    isTemplate?: SortOrder
    requiresApproval?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationRuleCountOrderByAggregateInput
    _avg?: AutomationRuleAvgOrderByAggregateInput
    _max?: AutomationRuleMaxOrderByAggregateInput
    _min?: AutomationRuleMinOrderByAggregateInput
    _sum?: AutomationRuleSumOrderByAggregateInput
  }

  export type AutomationRuleScalarWhereWithAggregatesInput = {
    AND?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    OR?: AutomationRuleScalarWhereWithAggregatesInput[]
    NOT?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationRule"> | string
    tenantId?: StringWithAggregatesFilter<"AutomationRule"> | string
    name?: StringWithAggregatesFilter<"AutomationRule"> | string
    description?: StringNullableWithAggregatesFilter<"AutomationRule"> | string | null
    triggerType?: EnumAutomationTriggerTypeWithAggregatesFilter<"AutomationRule"> | $Enums.AutomationTriggerType
    triggerConfig?: JsonWithAggregatesFilter<"AutomationRule">
    conditions?: JsonWithAggregatesFilter<"AutomationRule">
    actions?: JsonWithAggregatesFilter<"AutomationRule">
    status?: EnumAutomationStatusWithAggregatesFilter<"AutomationRule"> | $Enums.AutomationStatus
    isTemplate?: BoolWithAggregatesFilter<"AutomationRule"> | boolean
    requiresApproval?: BoolWithAggregatesFilter<"AutomationRule"> | boolean
    createdBy?: StringWithAggregatesFilter<"AutomationRule"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"AutomationRule"> | string | null
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"AutomationRule"> | Date | string | null
    executionCount?: IntWithAggregatesFilter<"AutomationRule"> | number
    successCount?: IntWithAggregatesFilter<"AutomationRule"> | number
    failureCount?: IntWithAggregatesFilter<"AutomationRule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationRule"> | Date | string
  }

  export type AutomationExecutionWhereInput = {
    AND?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    OR?: AutomationExecutionWhereInput[]
    NOT?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    id?: StringFilter<"AutomationExecution"> | string
    ruleId?: StringFilter<"AutomationExecution"> | string
    tenantId?: StringFilter<"AutomationExecution"> | string
    status?: EnumAutomationExecutionStatusFilter<"AutomationExecution"> | $Enums.AutomationExecutionStatus
    triggeredBy?: StringNullableFilter<"AutomationExecution"> | string | null
    triggerData?: JsonFilter<"AutomationExecution">
    conditionsEvaluated?: JsonFilter<"AutomationExecution">
    conditionsMet?: BoolFilter<"AutomationExecution"> | boolean
    actionsExecuted?: JsonFilter<"AutomationExecution">
    isDryRun?: BoolFilter<"AutomationExecution"> | boolean
    errorMessage?: StringNullableFilter<"AutomationExecution"> | string | null
    executionTime?: IntNullableFilter<"AutomationExecution"> | number | null
    retryCount?: IntFilter<"AutomationExecution"> | number
    nextRetryAt?: DateTimeNullableFilter<"AutomationExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutomationExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    rule?: XOR<AutomationRuleScalarRelationFilter, AutomationRuleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AutomationExecutionOrderByWithRelationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    triggerData?: SortOrder
    conditionsEvaluated?: SortOrder
    conditionsMet?: SortOrder
    actionsExecuted?: SortOrder
    isDryRun?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rule?: AutomationRuleOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type AutomationExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    OR?: AutomationExecutionWhereInput[]
    NOT?: AutomationExecutionWhereInput | AutomationExecutionWhereInput[]
    ruleId?: StringFilter<"AutomationExecution"> | string
    tenantId?: StringFilter<"AutomationExecution"> | string
    status?: EnumAutomationExecutionStatusFilter<"AutomationExecution"> | $Enums.AutomationExecutionStatus
    triggeredBy?: StringNullableFilter<"AutomationExecution"> | string | null
    triggerData?: JsonFilter<"AutomationExecution">
    conditionsEvaluated?: JsonFilter<"AutomationExecution">
    conditionsMet?: BoolFilter<"AutomationExecution"> | boolean
    actionsExecuted?: JsonFilter<"AutomationExecution">
    isDryRun?: BoolFilter<"AutomationExecution"> | boolean
    errorMessage?: StringNullableFilter<"AutomationExecution"> | string | null
    executionTime?: IntNullableFilter<"AutomationExecution"> | number | null
    retryCount?: IntFilter<"AutomationExecution"> | number
    nextRetryAt?: DateTimeNullableFilter<"AutomationExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutomationExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"AutomationExecution"> | Date | string
    rule?: XOR<AutomationRuleScalarRelationFilter, AutomationRuleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type AutomationExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    triggerData?: SortOrder
    conditionsEvaluated?: SortOrder
    conditionsMet?: SortOrder
    actionsExecuted?: SortOrder
    isDryRun?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AutomationExecutionCountOrderByAggregateInput
    _avg?: AutomationExecutionAvgOrderByAggregateInput
    _max?: AutomationExecutionMaxOrderByAggregateInput
    _min?: AutomationExecutionMinOrderByAggregateInput
    _sum?: AutomationExecutionSumOrderByAggregateInput
  }

  export type AutomationExecutionScalarWhereWithAggregatesInput = {
    AND?: AutomationExecutionScalarWhereWithAggregatesInput | AutomationExecutionScalarWhereWithAggregatesInput[]
    OR?: AutomationExecutionScalarWhereWithAggregatesInput[]
    NOT?: AutomationExecutionScalarWhereWithAggregatesInput | AutomationExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationExecution"> | string
    ruleId?: StringWithAggregatesFilter<"AutomationExecution"> | string
    tenantId?: StringWithAggregatesFilter<"AutomationExecution"> | string
    status?: EnumAutomationExecutionStatusWithAggregatesFilter<"AutomationExecution"> | $Enums.AutomationExecutionStatus
    triggeredBy?: StringNullableWithAggregatesFilter<"AutomationExecution"> | string | null
    triggerData?: JsonWithAggregatesFilter<"AutomationExecution">
    conditionsEvaluated?: JsonWithAggregatesFilter<"AutomationExecution">
    conditionsMet?: BoolWithAggregatesFilter<"AutomationExecution"> | boolean
    actionsExecuted?: JsonWithAggregatesFilter<"AutomationExecution">
    isDryRun?: BoolWithAggregatesFilter<"AutomationExecution"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"AutomationExecution"> | string | null
    executionTime?: IntNullableWithAggregatesFilter<"AutomationExecution"> | number | null
    retryCount?: IntWithAggregatesFilter<"AutomationExecution"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"AutomationExecution"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AutomationExecution"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AutomationExecution"> | Date | string
  }

  export type SmartInsightWhereInput = {
    AND?: SmartInsightWhereInput | SmartInsightWhereInput[]
    OR?: SmartInsightWhereInput[]
    NOT?: SmartInsightWhereInput | SmartInsightWhereInput[]
    id?: StringFilter<"SmartInsight"> | string
    tenantId?: StringFilter<"SmartInsight"> | string
    insightType?: EnumInsightTypeFilter<"SmartInsight"> | $Enums.InsightType
    severity?: EnumInsightSeverityFilter<"SmartInsight"> | $Enums.InsightSeverity
    title?: StringFilter<"SmartInsight"> | string
    description?: StringFilter<"SmartInsight"> | string
    explanation?: StringFilter<"SmartInsight"> | string
    confidence?: FloatFilter<"SmartInsight"> | number
    metadata?: JsonFilter<"SmartInsight">
    relatedEntities?: JsonFilter<"SmartInsight">
    actionable?: BoolFilter<"SmartInsight"> | boolean
    suggestedActions?: JsonFilter<"SmartInsight">
    dismissedBy?: StringNullableFilter<"SmartInsight"> | string | null
    dismissedAt?: DateTimeNullableFilter<"SmartInsight"> | Date | string | null
    dismissReason?: StringNullableFilter<"SmartInsight"> | string | null
    createdAt?: DateTimeFilter<"SmartInsight"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SmartInsight"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type SmartInsightOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    insightType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrder
    relatedEntities?: SortOrder
    actionable?: SortOrder
    suggestedActions?: SortOrder
    dismissedBy?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    dismissReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type SmartInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SmartInsightWhereInput | SmartInsightWhereInput[]
    OR?: SmartInsightWhereInput[]
    NOT?: SmartInsightWhereInput | SmartInsightWhereInput[]
    tenantId?: StringFilter<"SmartInsight"> | string
    insightType?: EnumInsightTypeFilter<"SmartInsight"> | $Enums.InsightType
    severity?: EnumInsightSeverityFilter<"SmartInsight"> | $Enums.InsightSeverity
    title?: StringFilter<"SmartInsight"> | string
    description?: StringFilter<"SmartInsight"> | string
    explanation?: StringFilter<"SmartInsight"> | string
    confidence?: FloatFilter<"SmartInsight"> | number
    metadata?: JsonFilter<"SmartInsight">
    relatedEntities?: JsonFilter<"SmartInsight">
    actionable?: BoolFilter<"SmartInsight"> | boolean
    suggestedActions?: JsonFilter<"SmartInsight">
    dismissedBy?: StringNullableFilter<"SmartInsight"> | string | null
    dismissedAt?: DateTimeNullableFilter<"SmartInsight"> | Date | string | null
    dismissReason?: StringNullableFilter<"SmartInsight"> | string | null
    createdAt?: DateTimeFilter<"SmartInsight"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SmartInsight"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type SmartInsightOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    insightType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrder
    relatedEntities?: SortOrder
    actionable?: SortOrder
    suggestedActions?: SortOrder
    dismissedBy?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    dismissReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: SmartInsightCountOrderByAggregateInput
    _avg?: SmartInsightAvgOrderByAggregateInput
    _max?: SmartInsightMaxOrderByAggregateInput
    _min?: SmartInsightMinOrderByAggregateInput
    _sum?: SmartInsightSumOrderByAggregateInput
  }

  export type SmartInsightScalarWhereWithAggregatesInput = {
    AND?: SmartInsightScalarWhereWithAggregatesInput | SmartInsightScalarWhereWithAggregatesInput[]
    OR?: SmartInsightScalarWhereWithAggregatesInput[]
    NOT?: SmartInsightScalarWhereWithAggregatesInput | SmartInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SmartInsight"> | string
    tenantId?: StringWithAggregatesFilter<"SmartInsight"> | string
    insightType?: EnumInsightTypeWithAggregatesFilter<"SmartInsight"> | $Enums.InsightType
    severity?: EnumInsightSeverityWithAggregatesFilter<"SmartInsight"> | $Enums.InsightSeverity
    title?: StringWithAggregatesFilter<"SmartInsight"> | string
    description?: StringWithAggregatesFilter<"SmartInsight"> | string
    explanation?: StringWithAggregatesFilter<"SmartInsight"> | string
    confidence?: FloatWithAggregatesFilter<"SmartInsight"> | number
    metadata?: JsonWithAggregatesFilter<"SmartInsight">
    relatedEntities?: JsonWithAggregatesFilter<"SmartInsight">
    actionable?: BoolWithAggregatesFilter<"SmartInsight"> | boolean
    suggestedActions?: JsonWithAggregatesFilter<"SmartInsight">
    dismissedBy?: StringNullableWithAggregatesFilter<"SmartInsight"> | string | null
    dismissedAt?: DateTimeNullableWithAggregatesFilter<"SmartInsight"> | Date | string | null
    dismissReason?: StringNullableWithAggregatesFilter<"SmartInsight"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SmartInsight"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SmartInsight"> | Date | string | null
  }

  export type AutomationTemplateWhereInput = {
    AND?: AutomationTemplateWhereInput | AutomationTemplateWhereInput[]
    OR?: AutomationTemplateWhereInput[]
    NOT?: AutomationTemplateWhereInput | AutomationTemplateWhereInput[]
    id?: StringFilter<"AutomationTemplate"> | string
    name?: StringFilter<"AutomationTemplate"> | string
    description?: StringFilter<"AutomationTemplate"> | string
    category?: StringFilter<"AutomationTemplate"> | string
    triggerType?: EnumAutomationTriggerTypeFilter<"AutomationTemplate"> | $Enums.AutomationTriggerType
    triggerConfig?: JsonFilter<"AutomationTemplate">
    conditions?: JsonFilter<"AutomationTemplate">
    actions?: JsonFilter<"AutomationTemplate">
    requiredPlan?: EnumSubscriptionPlanFilter<"AutomationTemplate"> | $Enums.SubscriptionPlan
    popularity?: IntFilter<"AutomationTemplate"> | number
    isPublic?: BoolFilter<"AutomationTemplate"> | boolean
    createdBy?: StringFilter<"AutomationTemplate"> | string
    createdAt?: DateTimeFilter<"AutomationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationTemplate"> | Date | string
  }

  export type AutomationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    requiredPlan?: SortOrder
    popularity?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationTemplateWhereInput | AutomationTemplateWhereInput[]
    OR?: AutomationTemplateWhereInput[]
    NOT?: AutomationTemplateWhereInput | AutomationTemplateWhereInput[]
    name?: StringFilter<"AutomationTemplate"> | string
    description?: StringFilter<"AutomationTemplate"> | string
    category?: StringFilter<"AutomationTemplate"> | string
    triggerType?: EnumAutomationTriggerTypeFilter<"AutomationTemplate"> | $Enums.AutomationTriggerType
    triggerConfig?: JsonFilter<"AutomationTemplate">
    conditions?: JsonFilter<"AutomationTemplate">
    actions?: JsonFilter<"AutomationTemplate">
    requiredPlan?: EnumSubscriptionPlanFilter<"AutomationTemplate"> | $Enums.SubscriptionPlan
    popularity?: IntFilter<"AutomationTemplate"> | number
    isPublic?: BoolFilter<"AutomationTemplate"> | boolean
    createdBy?: StringFilter<"AutomationTemplate"> | string
    createdAt?: DateTimeFilter<"AutomationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationTemplate"> | Date | string
  }, "id">

  export type AutomationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    requiredPlan?: SortOrder
    popularity?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutomationTemplateCountOrderByAggregateInput
    _avg?: AutomationTemplateAvgOrderByAggregateInput
    _max?: AutomationTemplateMaxOrderByAggregateInput
    _min?: AutomationTemplateMinOrderByAggregateInput
    _sum?: AutomationTemplateSumOrderByAggregateInput
  }

  export type AutomationTemplateScalarWhereWithAggregatesInput = {
    AND?: AutomationTemplateScalarWhereWithAggregatesInput | AutomationTemplateScalarWhereWithAggregatesInput[]
    OR?: AutomationTemplateScalarWhereWithAggregatesInput[]
    NOT?: AutomationTemplateScalarWhereWithAggregatesInput | AutomationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationTemplate"> | string
    name?: StringWithAggregatesFilter<"AutomationTemplate"> | string
    description?: StringWithAggregatesFilter<"AutomationTemplate"> | string
    category?: StringWithAggregatesFilter<"AutomationTemplate"> | string
    triggerType?: EnumAutomationTriggerTypeWithAggregatesFilter<"AutomationTemplate"> | $Enums.AutomationTriggerType
    triggerConfig?: JsonWithAggregatesFilter<"AutomationTemplate">
    conditions?: JsonWithAggregatesFilter<"AutomationTemplate">
    actions?: JsonWithAggregatesFilter<"AutomationTemplate">
    requiredPlan?: EnumSubscriptionPlanWithAggregatesFilter<"AutomationTemplate"> | $Enums.SubscriptionPlan
    popularity?: IntWithAggregatesFilter<"AutomationTemplate"> | number
    isPublic?: BoolWithAggregatesFilter<"AutomationTemplate"> | boolean
    createdBy?: StringWithAggregatesFilter<"AutomationTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutomationTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationTemplate"> | Date | string
  }

  export type AutomationUsageMetricWhereInput = {
    AND?: AutomationUsageMetricWhereInput | AutomationUsageMetricWhereInput[]
    OR?: AutomationUsageMetricWhereInput[]
    NOT?: AutomationUsageMetricWhereInput | AutomationUsageMetricWhereInput[]
    id?: StringFilter<"AutomationUsageMetric"> | string
    tenantId?: StringFilter<"AutomationUsageMetric"> | string
    ruleId?: StringFilter<"AutomationUsageMetric"> | string
    executionId?: StringFilter<"AutomationUsageMetric"> | string
    actionType?: StringFilter<"AutomationUsageMetric"> | string
    success?: BoolFilter<"AutomationUsageMetric"> | boolean
    executionTime?: IntFilter<"AutomationUsageMetric"> | number
    costImpact?: FloatNullableFilter<"AutomationUsageMetric"> | number | null
    businessImpact?: JsonNullableFilter<"AutomationUsageMetric">
    timestamp?: DateTimeFilter<"AutomationUsageMetric"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AutomationUsageMetricOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ruleId?: SortOrder
    executionId?: SortOrder
    actionType?: SortOrder
    success?: SortOrder
    executionTime?: SortOrder
    costImpact?: SortOrderInput | SortOrder
    businessImpact?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type AutomationUsageMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationUsageMetricWhereInput | AutomationUsageMetricWhereInput[]
    OR?: AutomationUsageMetricWhereInput[]
    NOT?: AutomationUsageMetricWhereInput | AutomationUsageMetricWhereInput[]
    tenantId?: StringFilter<"AutomationUsageMetric"> | string
    ruleId?: StringFilter<"AutomationUsageMetric"> | string
    executionId?: StringFilter<"AutomationUsageMetric"> | string
    actionType?: StringFilter<"AutomationUsageMetric"> | string
    success?: BoolFilter<"AutomationUsageMetric"> | boolean
    executionTime?: IntFilter<"AutomationUsageMetric"> | number
    costImpact?: FloatNullableFilter<"AutomationUsageMetric"> | number | null
    businessImpact?: JsonNullableFilter<"AutomationUsageMetric">
    timestamp?: DateTimeFilter<"AutomationUsageMetric"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type AutomationUsageMetricOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ruleId?: SortOrder
    executionId?: SortOrder
    actionType?: SortOrder
    success?: SortOrder
    executionTime?: SortOrder
    costImpact?: SortOrderInput | SortOrder
    businessImpact?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AutomationUsageMetricCountOrderByAggregateInput
    _avg?: AutomationUsageMetricAvgOrderByAggregateInput
    _max?: AutomationUsageMetricMaxOrderByAggregateInput
    _min?: AutomationUsageMetricMinOrderByAggregateInput
    _sum?: AutomationUsageMetricSumOrderByAggregateInput
  }

  export type AutomationUsageMetricScalarWhereWithAggregatesInput = {
    AND?: AutomationUsageMetricScalarWhereWithAggregatesInput | AutomationUsageMetricScalarWhereWithAggregatesInput[]
    OR?: AutomationUsageMetricScalarWhereWithAggregatesInput[]
    NOT?: AutomationUsageMetricScalarWhereWithAggregatesInput | AutomationUsageMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationUsageMetric"> | string
    tenantId?: StringWithAggregatesFilter<"AutomationUsageMetric"> | string
    ruleId?: StringWithAggregatesFilter<"AutomationUsageMetric"> | string
    executionId?: StringWithAggregatesFilter<"AutomationUsageMetric"> | string
    actionType?: StringWithAggregatesFilter<"AutomationUsageMetric"> | string
    success?: BoolWithAggregatesFilter<"AutomationUsageMetric"> | boolean
    executionTime?: IntWithAggregatesFilter<"AutomationUsageMetric"> | number
    costImpact?: FloatNullableWithAggregatesFilter<"AutomationUsageMetric"> | number | null
    businessImpact?: JsonNullableWithAggregatesFilter<"AutomationUsageMetric">
    timestamp?: DateTimeWithAggregatesFilter<"AutomationUsageMetric"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    tenantId?: StringFilter<"PaymentMethod"> | string
    customerId?: StringNullableFilter<"PaymentMethod"> | string | null
    type?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    token?: StringFilter<"PaymentMethod"> | string
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    accountType?: StringNullableFilter<"PaymentMethod"> | string | null
    routingNumber?: StringNullableFilter<"PaymentMethod"> | string | null
    nickname?: StringNullableFilter<"PaymentMethod"> | string | null
    billingAddress?: JsonNullableFilter<"PaymentMethod">
    metadata?: JsonFilter<"PaymentMethod">
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    verifiedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    last4?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    routingNumber?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    metadata?: SortOrder
    isActive?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    tenantId?: StringFilter<"PaymentMethod"> | string
    customerId?: StringNullableFilter<"PaymentMethod"> | string | null
    type?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    accountType?: StringNullableFilter<"PaymentMethod"> | string | null
    routingNumber?: StringNullableFilter<"PaymentMethod"> | string | null
    nickname?: StringNullableFilter<"PaymentMethod"> | string | null
    billingAddress?: JsonNullableFilter<"PaymentMethod">
    metadata?: JsonFilter<"PaymentMethod">
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    verifiedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "token">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    last4?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    routingNumber?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    metadata?: SortOrder
    isActive?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    tenantId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    customerId?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    type?: EnumPaymentMethodTypeWithAggregatesFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    isDefault?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    token?: StringWithAggregatesFilter<"PaymentMethod"> | string
    last4?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    brand?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableWithAggregatesFilter<"PaymentMethod"> | number | null
    accountType?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    routingNumber?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    nickname?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    billingAddress?: JsonNullableWithAggregatesFilter<"PaymentMethod">
    metadata?: JsonWithAggregatesFilter<"PaymentMethod">
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"PaymentMethod"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    paymentMethodId?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    processorId?: StringNullableFilter<"Payment"> | string | null
    processorStatus?: StringNullableFilter<"Payment"> | string | null
    processorResponse?: JsonNullableFilter<"Payment">
    automationRuleId?: StringNullableFilter<"Payment"> | string | null
    automationExecutionId?: StringNullableFilter<"Payment"> | string | null
    isAutomated?: BoolFilter<"Payment"> | boolean
    scheduledFor?: DateTimeNullableFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    retryCount?: IntFilter<"Payment"> | number
    maxRetries?: IntFilter<"Payment"> | number
    nextRetryAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    reconciledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    ledgerEntryId?: StringNullableFilter<"Payment"> | string | null
    processingFee?: FloatNullableFilter<"Payment"> | number | null
    netAmount?: FloatNullableFilter<"Payment"> | number | null
    isDisputed?: BoolFilter<"Payment"> | boolean
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    disputedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    requiresApproval?: BoolFilter<"Payment"> | boolean
    approvedBy?: StringNullableFilter<"Payment"> | string | null
    approvedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    metadata?: JsonFilter<"Payment">
    failureReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    paymentMethod?: XOR<PaymentMethodNullableScalarRelationFilter, PaymentMethodWhereInput> | null
    reconciliation?: XOR<PaymentReconciliationNullableScalarRelationFilter, PaymentReconciliationWhereInput> | null
    explainability?: XOR<PaymentExplainabilityNullableScalarRelationFilter, PaymentExplainabilityWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    processorId?: SortOrderInput | SortOrder
    processorStatus?: SortOrderInput | SortOrder
    processorResponse?: SortOrderInput | SortOrder
    automationRuleId?: SortOrderInput | SortOrder
    automationExecutionId?: SortOrderInput | SortOrder
    isAutomated?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    reconciledAt?: SortOrderInput | SortOrder
    ledgerEntryId?: SortOrderInput | SortOrder
    processingFee?: SortOrderInput | SortOrder
    netAmount?: SortOrderInput | SortOrder
    isDisputed?: SortOrder
    disputeReason?: SortOrderInput | SortOrder
    disputedAt?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
    reconciliation?: PaymentReconciliationOrderByWithRelationInput
    explainability?: PaymentExplainabilityOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    tenantId?: StringFilter<"Payment"> | string
    paymentMethodId?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    processorId?: StringNullableFilter<"Payment"> | string | null
    processorStatus?: StringNullableFilter<"Payment"> | string | null
    processorResponse?: JsonNullableFilter<"Payment">
    automationRuleId?: StringNullableFilter<"Payment"> | string | null
    automationExecutionId?: StringNullableFilter<"Payment"> | string | null
    isAutomated?: BoolFilter<"Payment"> | boolean
    scheduledFor?: DateTimeNullableFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    retryCount?: IntFilter<"Payment"> | number
    maxRetries?: IntFilter<"Payment"> | number
    nextRetryAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    reconciledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    ledgerEntryId?: StringNullableFilter<"Payment"> | string | null
    processingFee?: FloatNullableFilter<"Payment"> | number | null
    netAmount?: FloatNullableFilter<"Payment"> | number | null
    isDisputed?: BoolFilter<"Payment"> | boolean
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    disputedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    requiresApproval?: BoolFilter<"Payment"> | boolean
    approvedBy?: StringNullableFilter<"Payment"> | string | null
    approvedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    metadata?: JsonFilter<"Payment">
    failureReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    paymentMethod?: XOR<PaymentMethodNullableScalarRelationFilter, PaymentMethodWhereInput> | null
    reconciliation?: XOR<PaymentReconciliationNullableScalarRelationFilter, PaymentReconciliationWhereInput> | null
    explainability?: XOR<PaymentExplainabilityNullableScalarRelationFilter, PaymentExplainabilityWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentMethodId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    processorId?: SortOrderInput | SortOrder
    processorStatus?: SortOrderInput | SortOrder
    processorResponse?: SortOrderInput | SortOrder
    automationRuleId?: SortOrderInput | SortOrder
    automationExecutionId?: SortOrderInput | SortOrder
    isAutomated?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    reconciledAt?: SortOrderInput | SortOrder
    ledgerEntryId?: SortOrderInput | SortOrder
    processingFee?: SortOrderInput | SortOrder
    netAmount?: SortOrderInput | SortOrder
    isDisputed?: SortOrder
    disputeReason?: SortOrderInput | SortOrder
    disputedAt?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    tenantId?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethodId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    type?: EnumPaymentTypeWithAggregatesFilter<"Payment"> | $Enums.PaymentType
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    processorId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    processorStatus?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    processorResponse?: JsonNullableWithAggregatesFilter<"Payment">
    automationRuleId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    automationExecutionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    isAutomated?: BoolWithAggregatesFilter<"Payment"> | boolean
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    retryCount?: IntWithAggregatesFilter<"Payment"> | number
    maxRetries?: IntWithAggregatesFilter<"Payment"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    reconciledAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    ledgerEntryId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    processingFee?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    netAmount?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    isDisputed?: BoolWithAggregatesFilter<"Payment"> | boolean
    disputeReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    disputedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    requiresApproval?: BoolWithAggregatesFilter<"Payment"> | boolean
    approvedBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"Payment">
    failureReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentReconciliationWhereInput = {
    AND?: PaymentReconciliationWhereInput | PaymentReconciliationWhereInput[]
    OR?: PaymentReconciliationWhereInput[]
    NOT?: PaymentReconciliationWhereInput | PaymentReconciliationWhereInput[]
    id?: StringFilter<"PaymentReconciliation"> | string
    paymentId?: StringFilter<"PaymentReconciliation"> | string
    tenantId?: StringFilter<"PaymentReconciliation"> | string
    status?: EnumReconciliationStatusFilter<"PaymentReconciliation"> | $Enums.ReconciliationStatus
    ledgerEntryId?: StringNullableFilter<"PaymentReconciliation"> | string | null
    accountId?: StringNullableFilter<"PaymentReconciliation"> | string | null
    matchedAmount?: FloatNullableFilter<"PaymentReconciliation"> | number | null
    variance?: FloatNullableFilter<"PaymentReconciliation"> | number | null
    varianceReason?: StringNullableFilter<"PaymentReconciliation"> | string | null
    reconciledBy?: StringNullableFilter<"PaymentReconciliation"> | string | null
    reconciledAt?: DateTimeNullableFilter<"PaymentReconciliation"> | Date | string | null
    notes?: StringNullableFilter<"PaymentReconciliation"> | string | null
    createdAt?: DateTimeFilter<"PaymentReconciliation"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentReconciliation"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PaymentReconciliationOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    ledgerEntryId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    matchedAmount?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    varianceReason?: SortOrderInput | SortOrder
    reconciledBy?: SortOrderInput | SortOrder
    reconciledAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type PaymentReconciliationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentId?: string
    AND?: PaymentReconciliationWhereInput | PaymentReconciliationWhereInput[]
    OR?: PaymentReconciliationWhereInput[]
    NOT?: PaymentReconciliationWhereInput | PaymentReconciliationWhereInput[]
    tenantId?: StringFilter<"PaymentReconciliation"> | string
    status?: EnumReconciliationStatusFilter<"PaymentReconciliation"> | $Enums.ReconciliationStatus
    ledgerEntryId?: StringNullableFilter<"PaymentReconciliation"> | string | null
    accountId?: StringNullableFilter<"PaymentReconciliation"> | string | null
    matchedAmount?: FloatNullableFilter<"PaymentReconciliation"> | number | null
    variance?: FloatNullableFilter<"PaymentReconciliation"> | number | null
    varianceReason?: StringNullableFilter<"PaymentReconciliation"> | string | null
    reconciledBy?: StringNullableFilter<"PaymentReconciliation"> | string | null
    reconciledAt?: DateTimeNullableFilter<"PaymentReconciliation"> | Date | string | null
    notes?: StringNullableFilter<"PaymentReconciliation"> | string | null
    createdAt?: DateTimeFilter<"PaymentReconciliation"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentReconciliation"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "paymentId">

  export type PaymentReconciliationOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    ledgerEntryId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    matchedAmount?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    varianceReason?: SortOrderInput | SortOrder
    reconciledBy?: SortOrderInput | SortOrder
    reconciledAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentReconciliationCountOrderByAggregateInput
    _avg?: PaymentReconciliationAvgOrderByAggregateInput
    _max?: PaymentReconciliationMaxOrderByAggregateInput
    _min?: PaymentReconciliationMinOrderByAggregateInput
    _sum?: PaymentReconciliationSumOrderByAggregateInput
  }

  export type PaymentReconciliationScalarWhereWithAggregatesInput = {
    AND?: PaymentReconciliationScalarWhereWithAggregatesInput | PaymentReconciliationScalarWhereWithAggregatesInput[]
    OR?: PaymentReconciliationScalarWhereWithAggregatesInput[]
    NOT?: PaymentReconciliationScalarWhereWithAggregatesInput | PaymentReconciliationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentReconciliation"> | string
    paymentId?: StringWithAggregatesFilter<"PaymentReconciliation"> | string
    tenantId?: StringWithAggregatesFilter<"PaymentReconciliation"> | string
    status?: EnumReconciliationStatusWithAggregatesFilter<"PaymentReconciliation"> | $Enums.ReconciliationStatus
    ledgerEntryId?: StringNullableWithAggregatesFilter<"PaymentReconciliation"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"PaymentReconciliation"> | string | null
    matchedAmount?: FloatNullableWithAggregatesFilter<"PaymentReconciliation"> | number | null
    variance?: FloatNullableWithAggregatesFilter<"PaymentReconciliation"> | number | null
    varianceReason?: StringNullableWithAggregatesFilter<"PaymentReconciliation"> | string | null
    reconciledBy?: StringNullableWithAggregatesFilter<"PaymentReconciliation"> | string | null
    reconciledAt?: DateTimeNullableWithAggregatesFilter<"PaymentReconciliation"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PaymentReconciliation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentReconciliation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentReconciliation"> | Date | string
  }

  export type PaymentExplainabilityWhereInput = {
    AND?: PaymentExplainabilityWhereInput | PaymentExplainabilityWhereInput[]
    OR?: PaymentExplainabilityWhereInput[]
    NOT?: PaymentExplainabilityWhereInput | PaymentExplainabilityWhereInput[]
    id?: StringFilter<"PaymentExplainability"> | string
    paymentId?: StringFilter<"PaymentExplainability"> | string
    tenantId?: StringFilter<"PaymentExplainability"> | string
    trigger?: StringFilter<"PaymentExplainability"> | string
    triggerDetails?: JsonFilter<"PaymentExplainability">
    conditionsMet?: JsonFilter<"PaymentExplainability">
    amountCalculation?: StringFilter<"PaymentExplainability"> | string
    baseAmount?: FloatFilter<"PaymentExplainability"> | number
    adjustments?: JsonFilter<"PaymentExplainability">
    confidenceScore?: FloatFilter<"PaymentExplainability"> | number
    safeguards?: JsonFilter<"PaymentExplainability">
    riskFactors?: JsonFilter<"PaymentExplainability">
    approvalRequired?: BoolFilter<"PaymentExplainability"> | boolean
    approvalStatus?: StringNullableFilter<"PaymentExplainability"> | string | null
    businessImpact?: JsonFilter<"PaymentExplainability">
    estimatedTimeSaved?: IntNullableFilter<"PaymentExplainability"> | number | null
    explanation?: StringFilter<"PaymentExplainability"> | string
    createdAt?: DateTimeFilter<"PaymentExplainability"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PaymentExplainabilityOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    trigger?: SortOrder
    triggerDetails?: SortOrder
    conditionsMet?: SortOrder
    amountCalculation?: SortOrder
    baseAmount?: SortOrder
    adjustments?: SortOrder
    confidenceScore?: SortOrder
    safeguards?: SortOrder
    riskFactors?: SortOrder
    approvalRequired?: SortOrder
    approvalStatus?: SortOrderInput | SortOrder
    businessImpact?: SortOrder
    estimatedTimeSaved?: SortOrderInput | SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type PaymentExplainabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentId?: string
    AND?: PaymentExplainabilityWhereInput | PaymentExplainabilityWhereInput[]
    OR?: PaymentExplainabilityWhereInput[]
    NOT?: PaymentExplainabilityWhereInput | PaymentExplainabilityWhereInput[]
    tenantId?: StringFilter<"PaymentExplainability"> | string
    trigger?: StringFilter<"PaymentExplainability"> | string
    triggerDetails?: JsonFilter<"PaymentExplainability">
    conditionsMet?: JsonFilter<"PaymentExplainability">
    amountCalculation?: StringFilter<"PaymentExplainability"> | string
    baseAmount?: FloatFilter<"PaymentExplainability"> | number
    adjustments?: JsonFilter<"PaymentExplainability">
    confidenceScore?: FloatFilter<"PaymentExplainability"> | number
    safeguards?: JsonFilter<"PaymentExplainability">
    riskFactors?: JsonFilter<"PaymentExplainability">
    approvalRequired?: BoolFilter<"PaymentExplainability"> | boolean
    approvalStatus?: StringNullableFilter<"PaymentExplainability"> | string | null
    businessImpact?: JsonFilter<"PaymentExplainability">
    estimatedTimeSaved?: IntNullableFilter<"PaymentExplainability"> | number | null
    explanation?: StringFilter<"PaymentExplainability"> | string
    createdAt?: DateTimeFilter<"PaymentExplainability"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "paymentId">

  export type PaymentExplainabilityOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    trigger?: SortOrder
    triggerDetails?: SortOrder
    conditionsMet?: SortOrder
    amountCalculation?: SortOrder
    baseAmount?: SortOrder
    adjustments?: SortOrder
    confidenceScore?: SortOrder
    safeguards?: SortOrder
    riskFactors?: SortOrder
    approvalRequired?: SortOrder
    approvalStatus?: SortOrderInput | SortOrder
    businessImpact?: SortOrder
    estimatedTimeSaved?: SortOrderInput | SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentExplainabilityCountOrderByAggregateInput
    _avg?: PaymentExplainabilityAvgOrderByAggregateInput
    _max?: PaymentExplainabilityMaxOrderByAggregateInput
    _min?: PaymentExplainabilityMinOrderByAggregateInput
    _sum?: PaymentExplainabilitySumOrderByAggregateInput
  }

  export type PaymentExplainabilityScalarWhereWithAggregatesInput = {
    AND?: PaymentExplainabilityScalarWhereWithAggregatesInput | PaymentExplainabilityScalarWhereWithAggregatesInput[]
    OR?: PaymentExplainabilityScalarWhereWithAggregatesInput[]
    NOT?: PaymentExplainabilityScalarWhereWithAggregatesInput | PaymentExplainabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentExplainability"> | string
    paymentId?: StringWithAggregatesFilter<"PaymentExplainability"> | string
    tenantId?: StringWithAggregatesFilter<"PaymentExplainability"> | string
    trigger?: StringWithAggregatesFilter<"PaymentExplainability"> | string
    triggerDetails?: JsonWithAggregatesFilter<"PaymentExplainability">
    conditionsMet?: JsonWithAggregatesFilter<"PaymentExplainability">
    amountCalculation?: StringWithAggregatesFilter<"PaymentExplainability"> | string
    baseAmount?: FloatWithAggregatesFilter<"PaymentExplainability"> | number
    adjustments?: JsonWithAggregatesFilter<"PaymentExplainability">
    confidenceScore?: FloatWithAggregatesFilter<"PaymentExplainability"> | number
    safeguards?: JsonWithAggregatesFilter<"PaymentExplainability">
    riskFactors?: JsonWithAggregatesFilter<"PaymentExplainability">
    approvalRequired?: BoolWithAggregatesFilter<"PaymentExplainability"> | boolean
    approvalStatus?: StringNullableWithAggregatesFilter<"PaymentExplainability"> | string | null
    businessImpact?: JsonWithAggregatesFilter<"PaymentExplainability">
    estimatedTimeSaved?: IntNullableWithAggregatesFilter<"PaymentExplainability"> | number | null
    explanation?: StringWithAggregatesFilter<"PaymentExplainability"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentExplainability"> | Date | string
  }

  export type CashControlRuleWhereInput = {
    AND?: CashControlRuleWhereInput | CashControlRuleWhereInput[]
    OR?: CashControlRuleWhereInput[]
    NOT?: CashControlRuleWhereInput | CashControlRuleWhereInput[]
    id?: StringFilter<"CashControlRule"> | string
    tenantId?: StringFilter<"CashControlRule"> | string
    name?: StringFilter<"CashControlRule"> | string
    description?: StringNullableFilter<"CashControlRule"> | string | null
    ruleType?: EnumCashControlRuleTypeFilter<"CashControlRule"> | $Enums.CashControlRuleType
    config?: JsonFilter<"CashControlRule">
    conditions?: JsonFilter<"CashControlRule">
    isActive?: BoolFilter<"CashControlRule"> | boolean
    requiresApproval?: BoolFilter<"CashControlRule"> | boolean
    executionCount?: IntFilter<"CashControlRule"> | number
    successCount?: IntFilter<"CashControlRule"> | number
    failureCount?: IntFilter<"CashControlRule"> | number
    totalAmountProcessed?: FloatFilter<"CashControlRule"> | number
    createdBy?: StringFilter<"CashControlRule"> | string
    lastExecuted?: DateTimeNullableFilter<"CashControlRule"> | Date | string | null
    createdAt?: DateTimeFilter<"CashControlRule"> | Date | string
    updatedAt?: DateTimeFilter<"CashControlRule"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    executions?: CashControlExecutionListRelationFilter
  }

  export type CashControlRuleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ruleType?: SortOrder
    config?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    requiresApproval?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    totalAmountProcessed?: SortOrder
    createdBy?: SortOrder
    lastExecuted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    executions?: CashControlExecutionOrderByRelationAggregateInput
  }

  export type CashControlRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashControlRuleWhereInput | CashControlRuleWhereInput[]
    OR?: CashControlRuleWhereInput[]
    NOT?: CashControlRuleWhereInput | CashControlRuleWhereInput[]
    tenantId?: StringFilter<"CashControlRule"> | string
    name?: StringFilter<"CashControlRule"> | string
    description?: StringNullableFilter<"CashControlRule"> | string | null
    ruleType?: EnumCashControlRuleTypeFilter<"CashControlRule"> | $Enums.CashControlRuleType
    config?: JsonFilter<"CashControlRule">
    conditions?: JsonFilter<"CashControlRule">
    isActive?: BoolFilter<"CashControlRule"> | boolean
    requiresApproval?: BoolFilter<"CashControlRule"> | boolean
    executionCount?: IntFilter<"CashControlRule"> | number
    successCount?: IntFilter<"CashControlRule"> | number
    failureCount?: IntFilter<"CashControlRule"> | number
    totalAmountProcessed?: FloatFilter<"CashControlRule"> | number
    createdBy?: StringFilter<"CashControlRule"> | string
    lastExecuted?: DateTimeNullableFilter<"CashControlRule"> | Date | string | null
    createdAt?: DateTimeFilter<"CashControlRule"> | Date | string
    updatedAt?: DateTimeFilter<"CashControlRule"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    executions?: CashControlExecutionListRelationFilter
  }, "id">

  export type CashControlRuleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ruleType?: SortOrder
    config?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    requiresApproval?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    totalAmountProcessed?: SortOrder
    createdBy?: SortOrder
    lastExecuted?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashControlRuleCountOrderByAggregateInput
    _avg?: CashControlRuleAvgOrderByAggregateInput
    _max?: CashControlRuleMaxOrderByAggregateInput
    _min?: CashControlRuleMinOrderByAggregateInput
    _sum?: CashControlRuleSumOrderByAggregateInput
  }

  export type CashControlRuleScalarWhereWithAggregatesInput = {
    AND?: CashControlRuleScalarWhereWithAggregatesInput | CashControlRuleScalarWhereWithAggregatesInput[]
    OR?: CashControlRuleScalarWhereWithAggregatesInput[]
    NOT?: CashControlRuleScalarWhereWithAggregatesInput | CashControlRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashControlRule"> | string
    tenantId?: StringWithAggregatesFilter<"CashControlRule"> | string
    name?: StringWithAggregatesFilter<"CashControlRule"> | string
    description?: StringNullableWithAggregatesFilter<"CashControlRule"> | string | null
    ruleType?: EnumCashControlRuleTypeWithAggregatesFilter<"CashControlRule"> | $Enums.CashControlRuleType
    config?: JsonWithAggregatesFilter<"CashControlRule">
    conditions?: JsonWithAggregatesFilter<"CashControlRule">
    isActive?: BoolWithAggregatesFilter<"CashControlRule"> | boolean
    requiresApproval?: BoolWithAggregatesFilter<"CashControlRule"> | boolean
    executionCount?: IntWithAggregatesFilter<"CashControlRule"> | number
    successCount?: IntWithAggregatesFilter<"CashControlRule"> | number
    failureCount?: IntWithAggregatesFilter<"CashControlRule"> | number
    totalAmountProcessed?: FloatWithAggregatesFilter<"CashControlRule"> | number
    createdBy?: StringWithAggregatesFilter<"CashControlRule"> | string
    lastExecuted?: DateTimeNullableWithAggregatesFilter<"CashControlRule"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CashControlRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashControlRule"> | Date | string
  }

  export type CashControlExecutionWhereInput = {
    AND?: CashControlExecutionWhereInput | CashControlExecutionWhereInput[]
    OR?: CashControlExecutionWhereInput[]
    NOT?: CashControlExecutionWhereInput | CashControlExecutionWhereInput[]
    id?: StringFilter<"CashControlExecution"> | string
    ruleId?: StringFilter<"CashControlExecution"> | string
    tenantId?: StringFilter<"CashControlExecution"> | string
    status?: StringFilter<"CashControlExecution"> | string
    triggerData?: JsonFilter<"CashControlExecution">
    conditionsEvaluated?: JsonFilter<"CashControlExecution">
    paymentId?: StringNullableFilter<"CashControlExecution"> | string | null
    amount?: FloatNullableFilter<"CashControlExecution"> | number | null
    success?: BoolFilter<"CashControlExecution"> | boolean
    errorMessage?: StringNullableFilter<"CashControlExecution"> | string | null
    executionTime?: IntNullableFilter<"CashControlExecution"> | number | null
    isDryRun?: BoolFilter<"CashControlExecution"> | boolean
    createdAt?: DateTimeFilter<"CashControlExecution"> | Date | string
    rule?: XOR<CashControlRuleScalarRelationFilter, CashControlRuleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CashControlExecutionOrderByWithRelationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggerData?: SortOrder
    conditionsEvaluated?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    isDryRun?: SortOrder
    createdAt?: SortOrder
    rule?: CashControlRuleOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CashControlExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashControlExecutionWhereInput | CashControlExecutionWhereInput[]
    OR?: CashControlExecutionWhereInput[]
    NOT?: CashControlExecutionWhereInput | CashControlExecutionWhereInput[]
    ruleId?: StringFilter<"CashControlExecution"> | string
    tenantId?: StringFilter<"CashControlExecution"> | string
    status?: StringFilter<"CashControlExecution"> | string
    triggerData?: JsonFilter<"CashControlExecution">
    conditionsEvaluated?: JsonFilter<"CashControlExecution">
    paymentId?: StringNullableFilter<"CashControlExecution"> | string | null
    amount?: FloatNullableFilter<"CashControlExecution"> | number | null
    success?: BoolFilter<"CashControlExecution"> | boolean
    errorMessage?: StringNullableFilter<"CashControlExecution"> | string | null
    executionTime?: IntNullableFilter<"CashControlExecution"> | number | null
    isDryRun?: BoolFilter<"CashControlExecution"> | boolean
    createdAt?: DateTimeFilter<"CashControlExecution"> | Date | string
    rule?: XOR<CashControlRuleScalarRelationFilter, CashControlRuleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type CashControlExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggerData?: SortOrder
    conditionsEvaluated?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executionTime?: SortOrderInput | SortOrder
    isDryRun?: SortOrder
    createdAt?: SortOrder
    _count?: CashControlExecutionCountOrderByAggregateInput
    _avg?: CashControlExecutionAvgOrderByAggregateInput
    _max?: CashControlExecutionMaxOrderByAggregateInput
    _min?: CashControlExecutionMinOrderByAggregateInput
    _sum?: CashControlExecutionSumOrderByAggregateInput
  }

  export type CashControlExecutionScalarWhereWithAggregatesInput = {
    AND?: CashControlExecutionScalarWhereWithAggregatesInput | CashControlExecutionScalarWhereWithAggregatesInput[]
    OR?: CashControlExecutionScalarWhereWithAggregatesInput[]
    NOT?: CashControlExecutionScalarWhereWithAggregatesInput | CashControlExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashControlExecution"> | string
    ruleId?: StringWithAggregatesFilter<"CashControlExecution"> | string
    tenantId?: StringWithAggregatesFilter<"CashControlExecution"> | string
    status?: StringWithAggregatesFilter<"CashControlExecution"> | string
    triggerData?: JsonWithAggregatesFilter<"CashControlExecution">
    conditionsEvaluated?: JsonWithAggregatesFilter<"CashControlExecution">
    paymentId?: StringNullableWithAggregatesFilter<"CashControlExecution"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"CashControlExecution"> | number | null
    success?: BoolWithAggregatesFilter<"CashControlExecution"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"CashControlExecution"> | string | null
    executionTime?: IntNullableWithAggregatesFilter<"CashControlExecution"> | number | null
    isDryRun?: BoolWithAggregatesFilter<"CashControlExecution"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CashControlExecution"> | Date | string
  }

  export type PaymentAnalyticsWhereInput = {
    AND?: PaymentAnalyticsWhereInput | PaymentAnalyticsWhereInput[]
    OR?: PaymentAnalyticsWhereInput[]
    NOT?: PaymentAnalyticsWhereInput | PaymentAnalyticsWhereInput[]
    id?: StringFilter<"PaymentAnalytics"> | string
    tenantId?: StringFilter<"PaymentAnalytics"> | string
    paymentId?: StringNullableFilter<"PaymentAnalytics"> | string | null
    eventType?: StringFilter<"PaymentAnalytics"> | string
    amount?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    processingFee?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    isAutomated?: BoolFilter<"PaymentAnalytics"> | boolean
    automationRuleId?: StringNullableFilter<"PaymentAnalytics"> | string | null
    timeToCash?: IntNullableFilter<"PaymentAnalytics"> | number | null
    retryCount?: IntNullableFilter<"PaymentAnalytics"> | number | null
    revenueImpact?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    timestamp?: DateTimeFilter<"PaymentAnalytics"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PaymentAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    amount?: SortOrderInput | SortOrder
    processingFee?: SortOrderInput | SortOrder
    isAutomated?: SortOrder
    automationRuleId?: SortOrderInput | SortOrder
    timeToCash?: SortOrderInput | SortOrder
    retryCount?: SortOrderInput | SortOrder
    revenueImpact?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type PaymentAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentAnalyticsWhereInput | PaymentAnalyticsWhereInput[]
    OR?: PaymentAnalyticsWhereInput[]
    NOT?: PaymentAnalyticsWhereInput | PaymentAnalyticsWhereInput[]
    tenantId?: StringFilter<"PaymentAnalytics"> | string
    paymentId?: StringNullableFilter<"PaymentAnalytics"> | string | null
    eventType?: StringFilter<"PaymentAnalytics"> | string
    amount?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    processingFee?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    isAutomated?: BoolFilter<"PaymentAnalytics"> | boolean
    automationRuleId?: StringNullableFilter<"PaymentAnalytics"> | string | null
    timeToCash?: IntNullableFilter<"PaymentAnalytics"> | number | null
    retryCount?: IntNullableFilter<"PaymentAnalytics"> | number | null
    revenueImpact?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    timestamp?: DateTimeFilter<"PaymentAnalytics"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type PaymentAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    amount?: SortOrderInput | SortOrder
    processingFee?: SortOrderInput | SortOrder
    isAutomated?: SortOrder
    automationRuleId?: SortOrderInput | SortOrder
    timeToCash?: SortOrderInput | SortOrder
    retryCount?: SortOrderInput | SortOrder
    revenueImpact?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: PaymentAnalyticsCountOrderByAggregateInput
    _avg?: PaymentAnalyticsAvgOrderByAggregateInput
    _max?: PaymentAnalyticsMaxOrderByAggregateInput
    _min?: PaymentAnalyticsMinOrderByAggregateInput
    _sum?: PaymentAnalyticsSumOrderByAggregateInput
  }

  export type PaymentAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PaymentAnalyticsScalarWhereWithAggregatesInput | PaymentAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PaymentAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PaymentAnalyticsScalarWhereWithAggregatesInput | PaymentAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentAnalytics"> | string
    tenantId?: StringWithAggregatesFilter<"PaymentAnalytics"> | string
    paymentId?: StringNullableWithAggregatesFilter<"PaymentAnalytics"> | string | null
    eventType?: StringWithAggregatesFilter<"PaymentAnalytics"> | string
    amount?: FloatNullableWithAggregatesFilter<"PaymentAnalytics"> | number | null
    processingFee?: FloatNullableWithAggregatesFilter<"PaymentAnalytics"> | number | null
    isAutomated?: BoolWithAggregatesFilter<"PaymentAnalytics"> | boolean
    automationRuleId?: StringNullableWithAggregatesFilter<"PaymentAnalytics"> | string | null
    timeToCash?: IntNullableWithAggregatesFilter<"PaymentAnalytics"> | number | null
    retryCount?: IntNullableWithAggregatesFilter<"PaymentAnalytics"> | number | null
    revenueImpact?: FloatNullableWithAggregatesFilter<"PaymentAnalytics"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"PaymentAnalytics"> | Date | string
  }

  export type FinancialForecastWhereInput = {
    AND?: FinancialForecastWhereInput | FinancialForecastWhereInput[]
    OR?: FinancialForecastWhereInput[]
    NOT?: FinancialForecastWhereInput | FinancialForecastWhereInput[]
    id?: StringFilter<"FinancialForecast"> | string
    tenantId?: StringFilter<"FinancialForecast"> | string
    forecastType?: EnumForecastTypeFilter<"FinancialForecast"> | $Enums.ForecastType
    value?: FloatFilter<"FinancialForecast"> | number
    unit?: StringFilter<"FinancialForecast"> | string
    confidenceScore?: FloatFilter<"FinancialForecast"> | number
    forecastDate?: DateTimeFilter<"FinancialForecast"> | Date | string
    forecastHorizon?: IntFilter<"FinancialForecast"> | number
    formula?: StringFilter<"FinancialForecast"> | string
    assumptions?: JsonFilter<"FinancialForecast">
    dataSources?: JsonFilter<"FinancialForecast">
    historicalBaseline?: JsonNullableFilter<"FinancialForecast">
    calculatedAt?: DateTimeFilter<"FinancialForecast"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type FinancialForecastOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    forecastType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    confidenceScore?: SortOrder
    forecastDate?: SortOrder
    forecastHorizon?: SortOrder
    formula?: SortOrder
    assumptions?: SortOrder
    dataSources?: SortOrder
    historicalBaseline?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type FinancialForecastWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialForecastWhereInput | FinancialForecastWhereInput[]
    OR?: FinancialForecastWhereInput[]
    NOT?: FinancialForecastWhereInput | FinancialForecastWhereInput[]
    tenantId?: StringFilter<"FinancialForecast"> | string
    forecastType?: EnumForecastTypeFilter<"FinancialForecast"> | $Enums.ForecastType
    value?: FloatFilter<"FinancialForecast"> | number
    unit?: StringFilter<"FinancialForecast"> | string
    confidenceScore?: FloatFilter<"FinancialForecast"> | number
    forecastDate?: DateTimeFilter<"FinancialForecast"> | Date | string
    forecastHorizon?: IntFilter<"FinancialForecast"> | number
    formula?: StringFilter<"FinancialForecast"> | string
    assumptions?: JsonFilter<"FinancialForecast">
    dataSources?: JsonFilter<"FinancialForecast">
    historicalBaseline?: JsonNullableFilter<"FinancialForecast">
    calculatedAt?: DateTimeFilter<"FinancialForecast"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type FinancialForecastOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    forecastType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    confidenceScore?: SortOrder
    forecastDate?: SortOrder
    forecastHorizon?: SortOrder
    formula?: SortOrder
    assumptions?: SortOrder
    dataSources?: SortOrder
    historicalBaseline?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    _count?: FinancialForecastCountOrderByAggregateInput
    _avg?: FinancialForecastAvgOrderByAggregateInput
    _max?: FinancialForecastMaxOrderByAggregateInput
    _min?: FinancialForecastMinOrderByAggregateInput
    _sum?: FinancialForecastSumOrderByAggregateInput
  }

  export type FinancialForecastScalarWhereWithAggregatesInput = {
    AND?: FinancialForecastScalarWhereWithAggregatesInput | FinancialForecastScalarWhereWithAggregatesInput[]
    OR?: FinancialForecastScalarWhereWithAggregatesInput[]
    NOT?: FinancialForecastScalarWhereWithAggregatesInput | FinancialForecastScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialForecast"> | string
    tenantId?: StringWithAggregatesFilter<"FinancialForecast"> | string
    forecastType?: EnumForecastTypeWithAggregatesFilter<"FinancialForecast"> | $Enums.ForecastType
    value?: FloatWithAggregatesFilter<"FinancialForecast"> | number
    unit?: StringWithAggregatesFilter<"FinancialForecast"> | string
    confidenceScore?: FloatWithAggregatesFilter<"FinancialForecast"> | number
    forecastDate?: DateTimeWithAggregatesFilter<"FinancialForecast"> | Date | string
    forecastHorizon?: IntWithAggregatesFilter<"FinancialForecast"> | number
    formula?: StringWithAggregatesFilter<"FinancialForecast"> | string
    assumptions?: JsonWithAggregatesFilter<"FinancialForecast">
    dataSources?: JsonWithAggregatesFilter<"FinancialForecast">
    historicalBaseline?: JsonNullableWithAggregatesFilter<"FinancialForecast">
    calculatedAt?: DateTimeWithAggregatesFilter<"FinancialForecast"> | Date | string
  }

  export type ScenarioWhereInput = {
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    id?: StringFilter<"Scenario"> | string
    tenantId?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    scenarioType?: EnumScenarioTypeFilter<"Scenario"> | $Enums.ScenarioType
    config?: JsonFilter<"Scenario">
    baselineRunway?: FloatNullableFilter<"Scenario"> | number | null
    projectedRunway?: FloatNullableFilter<"Scenario"> | number | null
    runwayChange?: FloatNullableFilter<"Scenario"> | number | null
    riskLevel?: EnumRiskLevelNullableFilter<"Scenario"> | $Enums.RiskLevel | null
    riskScore?: FloatNullableFilter<"Scenario"> | number | null
    successProbability?: FloatNullableFilter<"Scenario"> | number | null
    topRiskDrivers?: JsonFilter<"Scenario">
    criticalAssumptions?: JsonFilter<"Scenario">
    cashFlowImpact?: JsonNullableFilter<"Scenario">
    automationImpact?: JsonNullableFilter<"Scenario">
    paymentImpact?: JsonNullableFilter<"Scenario">
    recommendations?: JsonFilter<"Scenario">
    createdBy?: StringFilter<"Scenario"> | string
    isArchived?: BoolFilter<"Scenario"> | boolean
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type ScenarioOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scenarioType?: SortOrder
    config?: SortOrder
    baselineRunway?: SortOrderInput | SortOrder
    projectedRunway?: SortOrderInput | SortOrder
    runwayChange?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    successProbability?: SortOrderInput | SortOrder
    topRiskDrivers?: SortOrder
    criticalAssumptions?: SortOrder
    cashFlowImpact?: SortOrderInput | SortOrder
    automationImpact?: SortOrderInput | SortOrder
    paymentImpact?: SortOrderInput | SortOrder
    recommendations?: SortOrder
    createdBy?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type ScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    tenantId?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    scenarioType?: EnumScenarioTypeFilter<"Scenario"> | $Enums.ScenarioType
    config?: JsonFilter<"Scenario">
    baselineRunway?: FloatNullableFilter<"Scenario"> | number | null
    projectedRunway?: FloatNullableFilter<"Scenario"> | number | null
    runwayChange?: FloatNullableFilter<"Scenario"> | number | null
    riskLevel?: EnumRiskLevelNullableFilter<"Scenario"> | $Enums.RiskLevel | null
    riskScore?: FloatNullableFilter<"Scenario"> | number | null
    successProbability?: FloatNullableFilter<"Scenario"> | number | null
    topRiskDrivers?: JsonFilter<"Scenario">
    criticalAssumptions?: JsonFilter<"Scenario">
    cashFlowImpact?: JsonNullableFilter<"Scenario">
    automationImpact?: JsonNullableFilter<"Scenario">
    paymentImpact?: JsonNullableFilter<"Scenario">
    recommendations?: JsonFilter<"Scenario">
    createdBy?: StringFilter<"Scenario"> | string
    isArchived?: BoolFilter<"Scenario"> | boolean
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type ScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scenarioType?: SortOrder
    config?: SortOrder
    baselineRunway?: SortOrderInput | SortOrder
    projectedRunway?: SortOrderInput | SortOrder
    runwayChange?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    riskScore?: SortOrderInput | SortOrder
    successProbability?: SortOrderInput | SortOrder
    topRiskDrivers?: SortOrder
    criticalAssumptions?: SortOrder
    cashFlowImpact?: SortOrderInput | SortOrder
    automationImpact?: SortOrderInput | SortOrder
    paymentImpact?: SortOrderInput | SortOrder
    recommendations?: SortOrder
    createdBy?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScenarioCountOrderByAggregateInput
    _avg?: ScenarioAvgOrderByAggregateInput
    _max?: ScenarioMaxOrderByAggregateInput
    _min?: ScenarioMinOrderByAggregateInput
    _sum?: ScenarioSumOrderByAggregateInput
  }

  export type ScenarioScalarWhereWithAggregatesInput = {
    AND?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    OR?: ScenarioScalarWhereWithAggregatesInput[]
    NOT?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Scenario"> | string
    tenantId?: StringWithAggregatesFilter<"Scenario"> | string
    name?: StringWithAggregatesFilter<"Scenario"> | string
    description?: StringNullableWithAggregatesFilter<"Scenario"> | string | null
    scenarioType?: EnumScenarioTypeWithAggregatesFilter<"Scenario"> | $Enums.ScenarioType
    config?: JsonWithAggregatesFilter<"Scenario">
    baselineRunway?: FloatNullableWithAggregatesFilter<"Scenario"> | number | null
    projectedRunway?: FloatNullableWithAggregatesFilter<"Scenario"> | number | null
    runwayChange?: FloatNullableWithAggregatesFilter<"Scenario"> | number | null
    riskLevel?: EnumRiskLevelNullableWithAggregatesFilter<"Scenario"> | $Enums.RiskLevel | null
    riskScore?: FloatNullableWithAggregatesFilter<"Scenario"> | number | null
    successProbability?: FloatNullableWithAggregatesFilter<"Scenario"> | number | null
    topRiskDrivers?: JsonWithAggregatesFilter<"Scenario">
    criticalAssumptions?: JsonWithAggregatesFilter<"Scenario">
    cashFlowImpact?: JsonNullableWithAggregatesFilter<"Scenario">
    automationImpact?: JsonNullableWithAggregatesFilter<"Scenario">
    paymentImpact?: JsonNullableWithAggregatesFilter<"Scenario">
    recommendations?: JsonWithAggregatesFilter<"Scenario">
    createdBy?: StringWithAggregatesFilter<"Scenario"> | string
    isArchived?: BoolWithAggregatesFilter<"Scenario"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
  }

  export type ScenarioAnalyticsWhereInput = {
    AND?: ScenarioAnalyticsWhereInput | ScenarioAnalyticsWhereInput[]
    OR?: ScenarioAnalyticsWhereInput[]
    NOT?: ScenarioAnalyticsWhereInput | ScenarioAnalyticsWhereInput[]
    id?: StringFilter<"ScenarioAnalytics"> | string
    tenantId?: StringFilter<"ScenarioAnalytics"> | string
    scenarioId?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    eventType?: StringFilter<"ScenarioAnalytics"> | string
    scenarioType?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    decisionMade?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    decisionOutcome?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    riskAvoided?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    upgradeTriggered?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    planBefore?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    planAfter?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    timeToDecision?: IntNullableFilter<"ScenarioAnalytics"> | number | null
    timestamp?: DateTimeFilter<"ScenarioAnalytics"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type ScenarioAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scenarioId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    scenarioType?: SortOrderInput | SortOrder
    decisionMade?: SortOrderInput | SortOrder
    decisionOutcome?: SortOrderInput | SortOrder
    riskAvoided?: SortOrderInput | SortOrder
    upgradeTriggered?: SortOrderInput | SortOrder
    planBefore?: SortOrderInput | SortOrder
    planAfter?: SortOrderInput | SortOrder
    timeToDecision?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type ScenarioAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScenarioAnalyticsWhereInput | ScenarioAnalyticsWhereInput[]
    OR?: ScenarioAnalyticsWhereInput[]
    NOT?: ScenarioAnalyticsWhereInput | ScenarioAnalyticsWhereInput[]
    tenantId?: StringFilter<"ScenarioAnalytics"> | string
    scenarioId?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    eventType?: StringFilter<"ScenarioAnalytics"> | string
    scenarioType?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    decisionMade?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    decisionOutcome?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    riskAvoided?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    upgradeTriggered?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    planBefore?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    planAfter?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    timeToDecision?: IntNullableFilter<"ScenarioAnalytics"> | number | null
    timestamp?: DateTimeFilter<"ScenarioAnalytics"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type ScenarioAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scenarioId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    scenarioType?: SortOrderInput | SortOrder
    decisionMade?: SortOrderInput | SortOrder
    decisionOutcome?: SortOrderInput | SortOrder
    riskAvoided?: SortOrderInput | SortOrder
    upgradeTriggered?: SortOrderInput | SortOrder
    planBefore?: SortOrderInput | SortOrder
    planAfter?: SortOrderInput | SortOrder
    timeToDecision?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: ScenarioAnalyticsCountOrderByAggregateInput
    _avg?: ScenarioAnalyticsAvgOrderByAggregateInput
    _max?: ScenarioAnalyticsMaxOrderByAggregateInput
    _min?: ScenarioAnalyticsMinOrderByAggregateInput
    _sum?: ScenarioAnalyticsSumOrderByAggregateInput
  }

  export type ScenarioAnalyticsScalarWhereWithAggregatesInput = {
    AND?: ScenarioAnalyticsScalarWhereWithAggregatesInput | ScenarioAnalyticsScalarWhereWithAggregatesInput[]
    OR?: ScenarioAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: ScenarioAnalyticsScalarWhereWithAggregatesInput | ScenarioAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScenarioAnalytics"> | string
    tenantId?: StringWithAggregatesFilter<"ScenarioAnalytics"> | string
    scenarioId?: StringNullableWithAggregatesFilter<"ScenarioAnalytics"> | string | null
    eventType?: StringWithAggregatesFilter<"ScenarioAnalytics"> | string
    scenarioType?: StringNullableWithAggregatesFilter<"ScenarioAnalytics"> | string | null
    decisionMade?: BoolNullableWithAggregatesFilter<"ScenarioAnalytics"> | boolean | null
    decisionOutcome?: StringNullableWithAggregatesFilter<"ScenarioAnalytics"> | string | null
    riskAvoided?: BoolNullableWithAggregatesFilter<"ScenarioAnalytics"> | boolean | null
    upgradeTriggered?: BoolNullableWithAggregatesFilter<"ScenarioAnalytics"> | boolean | null
    planBefore?: StringNullableWithAggregatesFilter<"ScenarioAnalytics"> | string | null
    planAfter?: StringNullableWithAggregatesFilter<"ScenarioAnalytics"> | string | null
    timeToDecision?: IntNullableWithAggregatesFilter<"ScenarioAnalytics"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"ScenarioAnalytics"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    tenantId: string
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    tenantId: string
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardLayoutCreateInput = {
    id?: string
    role?: $Enums.Role | null
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDashboardLayoutsInput
    tenant: TenantCreateNestedOneWithoutDashboardLayoutsInput
  }

  export type DashboardLayoutUncheckedCreateInput = {
    id?: string
    userId?: string | null
    role?: $Enums.Role | null
    tenantId: string
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardLayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDashboardLayoutsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDashboardLayoutsNestedInput
  }

  export type DashboardLayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardLayoutCreateManyInput = {
    id?: string
    userId?: string | null
    role?: $Enums.Role | null
    tenantId: string
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardLayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardLayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    eventId: string
    eventType: string
    featureFlag: string
    featureName: string
    userId: string
    userRole: $Enums.Role
    sessionId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp: Date | string
    serverTimestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    tenant: TenantCreateNestedOneWithoutAnalyticsEventsInput
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    eventId: string
    eventType: string
    featureFlag: string
    featureName: string
    userId: string
    userRole: $Enums.Role
    tenantId: string
    sessionId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp: Date | string
    serverTimestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    featureFlag?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessionId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    serverTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutAnalyticsEventsNestedInput
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    featureFlag?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    serverTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    eventId: string
    eventType: string
    featureFlag: string
    featureName: string
    userId: string
    userRole: $Enums.Role
    tenantId: string
    sessionId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp: Date | string
    serverTimestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    featureFlag?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessionId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    serverTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    featureFlag?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    serverTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutomationRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAutomationRulesInput
    executions?: AutomationExecutionCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAutomationRulesNestedInput
    executions?: AutomationExecutionUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionCreateInput = {
    id?: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    rule: AutomationRuleCreateNestedOneWithoutExecutionsInput
    tenant: TenantCreateNestedOneWithoutAutomationExecutionsInput
  }

  export type AutomationExecutionUncheckedCreateInput = {
    id?: string
    ruleId: string
    tenantId: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AutomationExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: AutomationRuleUpdateOneRequiredWithoutExecutionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutAutomationExecutionsNestedInput
  }

  export type AutomationExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionCreateManyInput = {
    id?: string
    ruleId: string
    tenantId: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AutomationExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmartInsightCreateInput = {
    id?: string
    insightType: $Enums.InsightType
    severity?: $Enums.InsightSeverity
    title: string
    description: string
    explanation: string
    confidence?: number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    dismissReason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutSmartInsightsInput
  }

  export type SmartInsightUncheckedCreateInput = {
    id?: string
    tenantId: string
    insightType: $Enums.InsightType
    severity?: $Enums.InsightSeverity
    title: string
    description: string
    explanation: string
    confidence?: number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    dismissReason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SmartInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    severity?: EnumInsightSeverityFieldUpdateOperationsInput | $Enums.InsightSeverity
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutSmartInsightsNestedInput
  }

  export type SmartInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    severity?: EnumInsightSeverityFieldUpdateOperationsInput | $Enums.InsightSeverity
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SmartInsightCreateManyInput = {
    id?: string
    tenantId: string
    insightType: $Enums.InsightType
    severity?: $Enums.InsightSeverity
    title: string
    description: string
    explanation: string
    confidence?: number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    dismissReason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SmartInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    severity?: EnumInsightSeverityFieldUpdateOperationsInput | $Enums.InsightSeverity
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SmartInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    severity?: EnumInsightSeverityFieldUpdateOperationsInput | $Enums.InsightSeverity
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutomationTemplateCreateInput = {
    id?: string
    name: string
    description: string
    category: string
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    requiredPlan: $Enums.SubscriptionPlan
    popularity?: number
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    category: string
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    requiredPlan: $Enums.SubscriptionPlan
    popularity?: number
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    requiredPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    popularity?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    requiredPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    popularity?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationTemplateCreateManyInput = {
    id?: string
    name: string
    description: string
    category: string
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    requiredPlan: $Enums.SubscriptionPlan
    popularity?: number
    isPublic?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    requiredPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    popularity?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    requiredPlan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    popularity?: IntFieldUpdateOperationsInput | number
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUsageMetricCreateInput = {
    id?: string
    ruleId: string
    executionId: string
    actionType: string
    success: boolean
    executionTime: number
    costImpact?: number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    tenant: TenantCreateNestedOneWithoutAutomationMetricsInput
  }

  export type AutomationUsageMetricUncheckedCreateInput = {
    id?: string
    tenantId: string
    ruleId: string
    executionId: string
    actionType: string
    success: boolean
    executionTime: number
    costImpact?: number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AutomationUsageMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    executionTime?: IntFieldUpdateOperationsInput | number
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAutomationMetricsNestedInput
  }

  export type AutomationUsageMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    executionTime?: IntFieldUpdateOperationsInput | number
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUsageMetricCreateManyInput = {
    id?: string
    tenantId: string
    ruleId: string
    executionId: string
    actionType: string
    success: boolean
    executionTime: number
    costImpact?: number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AutomationUsageMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    executionTime?: IntFieldUpdateOperationsInput | number
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUsageMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    executionTime?: IntFieldUpdateOperationsInput | number
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentMethodsInput
    payments?: PaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    tenantId: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentMethodsNestedInput
    payments?: PaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    tenantId: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutPaymentsInput
    reconciliation?: PaymentReconciliationCreateNestedOneWithoutPaymentInput
    explainability?: PaymentExplainabilityCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    paymentMethodId?: string | null
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reconciliation?: PaymentReconciliationUncheckedCreateNestedOneWithoutPaymentInput
    explainability?: PaymentExplainabilityUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutPaymentsNestedInput
    reconciliation?: PaymentReconciliationUpdateOneWithoutPaymentNestedInput
    explainability?: PaymentExplainabilityUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reconciliation?: PaymentReconciliationUncheckedUpdateOneWithoutPaymentNestedInput
    explainability?: PaymentExplainabilityUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    tenantId: string
    paymentMethodId?: string | null
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReconciliationCreateInput = {
    id?: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutReconciliationInput
    tenant: TenantCreateNestedOneWithoutPaymentReconciliationsInput
  }

  export type PaymentReconciliationUncheckedCreateInput = {
    id?: string
    paymentId: string
    tenantId: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReconciliationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutReconciliationNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentReconciliationsNestedInput
  }

  export type PaymentReconciliationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReconciliationCreateManyInput = {
    id?: string
    paymentId: string
    tenantId: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReconciliationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReconciliationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentExplainabilityCreateInput = {
    id?: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutExplainabilityInput
    tenant: TenantCreateNestedOneWithoutPaymentExplainabilityInput
  }

  export type PaymentExplainabilityUncheckedCreateInput = {
    id?: string
    paymentId: string
    tenantId: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
  }

  export type PaymentExplainabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutExplainabilityNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentExplainabilityNestedInput
  }

  export type PaymentExplainabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentExplainabilityCreateManyInput = {
    id?: string
    paymentId: string
    tenantId: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
  }

  export type PaymentExplainabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentExplainabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashControlRulesInput
    executions?: CashControlExecutionCreateNestedManyWithoutRuleInput
  }

  export type CashControlRuleUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: CashControlExecutionUncheckedCreateNestedManyWithoutRuleInput
  }

  export type CashControlRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashControlRulesNestedInput
    executions?: CashControlExecutionUpdateManyWithoutRuleNestedInput
  }

  export type CashControlRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: CashControlExecutionUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type CashControlRuleCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashControlRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlExecutionCreateInput = {
    id?: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
    rule: CashControlRuleCreateNestedOneWithoutExecutionsInput
    tenant: TenantCreateNestedOneWithoutCashControlExecutionsInput
  }

  export type CashControlExecutionUncheckedCreateInput = {
    id?: string
    ruleId: string
    tenantId: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
  }

  export type CashControlExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: CashControlRuleUpdateOneRequiredWithoutExecutionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashControlExecutionsNestedInput
  }

  export type CashControlExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlExecutionCreateManyInput = {
    id?: string
    ruleId: string
    tenantId: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
  }

  export type CashControlExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAnalyticsCreateInput = {
    id?: string
    paymentId?: string | null
    eventType: string
    amount?: number | null
    processingFee?: number | null
    isAutomated: boolean
    automationRuleId?: string | null
    timeToCash?: number | null
    retryCount?: number | null
    revenueImpact?: number | null
    timestamp?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentAnalyticsInput
  }

  export type PaymentAnalyticsUncheckedCreateInput = {
    id?: string
    tenantId: string
    paymentId?: string | null
    eventType: string
    amount?: number | null
    processingFee?: number | null
    isAutomated: boolean
    automationRuleId?: string | null
    timeToCash?: number | null
    retryCount?: number | null
    revenueImpact?: number | null
    timestamp?: Date | string
  }

  export type PaymentAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeToCash?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentAnalyticsNestedInput
  }

  export type PaymentAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeToCash?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAnalyticsCreateManyInput = {
    id?: string
    tenantId: string
    paymentId?: string | null
    eventType: string
    amount?: number | null
    processingFee?: number | null
    isAutomated: boolean
    automationRuleId?: string | null
    timeToCash?: number | null
    retryCount?: number | null
    revenueImpact?: number | null
    timestamp?: Date | string
  }

  export type PaymentAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeToCash?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeToCash?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialForecastCreateInput = {
    id?: string
    forecastType: $Enums.ForecastType
    value: number
    unit: string
    confidenceScore: number
    forecastDate: Date | string
    forecastHorizon: number
    formula: string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutFinancialForecastsInput
  }

  export type FinancialForecastUncheckedCreateInput = {
    id?: string
    tenantId: string
    forecastType: $Enums.ForecastType
    value: number
    unit: string
    confidenceScore: number
    forecastDate: Date | string
    forecastHorizon: number
    formula: string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type FinancialForecastUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    forecastType?: EnumForecastTypeFieldUpdateOperationsInput | $Enums.ForecastType
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    forecastDate?: DateTimeFieldUpdateOperationsInput | Date | string
    forecastHorizon?: IntFieldUpdateOperationsInput | number
    formula?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutFinancialForecastsNestedInput
  }

  export type FinancialForecastUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    forecastType?: EnumForecastTypeFieldUpdateOperationsInput | $Enums.ForecastType
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    forecastDate?: DateTimeFieldUpdateOperationsInput | Date | string
    forecastHorizon?: IntFieldUpdateOperationsInput | number
    formula?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialForecastCreateManyInput = {
    id?: string
    tenantId: string
    forecastType: $Enums.ForecastType
    value: number
    unit: string
    confidenceScore: number
    forecastDate: Date | string
    forecastHorizon: number
    formula: string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type FinancialForecastUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    forecastType?: EnumForecastTypeFieldUpdateOperationsInput | $Enums.ForecastType
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    forecastDate?: DateTimeFieldUpdateOperationsInput | Date | string
    forecastHorizon?: IntFieldUpdateOperationsInput | number
    formula?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialForecastUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    forecastType?: EnumForecastTypeFieldUpdateOperationsInput | $Enums.ForecastType
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    forecastDate?: DateTimeFieldUpdateOperationsInput | Date | string
    forecastHorizon?: IntFieldUpdateOperationsInput | number
    formula?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateInput = {
    id?: string
    name: string
    description?: string | null
    scenarioType: $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: number | null
    projectedRunway?: number | null
    runwayChange?: number | null
    riskLevel?: $Enums.RiskLevel | null
    riskScore?: number | null
    successProbability?: number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy: string
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutScenariosInput
  }

  export type ScenarioUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    scenarioType: $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: number | null
    projectedRunway?: number | null
    runwayChange?: number | null
    riskLevel?: $Enums.RiskLevel | null
    riskScore?: number | null
    successProbability?: number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy: string
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioType?: EnumScenarioTypeFieldUpdateOperationsInput | $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayChange?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableEnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel | null
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    successProbability?: NullableFloatFieldUpdateOperationsInput | number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutScenariosNestedInput
  }

  export type ScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioType?: EnumScenarioTypeFieldUpdateOperationsInput | $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayChange?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableEnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel | null
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    successProbability?: NullableFloatFieldUpdateOperationsInput | number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    scenarioType: $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: number | null
    projectedRunway?: number | null
    runwayChange?: number | null
    riskLevel?: $Enums.RiskLevel | null
    riskScore?: number | null
    successProbability?: number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy: string
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioType?: EnumScenarioTypeFieldUpdateOperationsInput | $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayChange?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableEnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel | null
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    successProbability?: NullableFloatFieldUpdateOperationsInput | number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioType?: EnumScenarioTypeFieldUpdateOperationsInput | $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayChange?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableEnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel | null
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    successProbability?: NullableFloatFieldUpdateOperationsInput | number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioAnalyticsCreateInput = {
    id?: string
    scenarioId?: string | null
    eventType: string
    scenarioType?: string | null
    decisionMade?: boolean | null
    decisionOutcome?: string | null
    riskAvoided?: boolean | null
    upgradeTriggered?: boolean | null
    planBefore?: string | null
    planAfter?: string | null
    timeToDecision?: number | null
    timestamp?: Date | string
    tenant: TenantCreateNestedOneWithoutScenarioAnalyticsInput
  }

  export type ScenarioAnalyticsUncheckedCreateInput = {
    id?: string
    tenantId: string
    scenarioId?: string | null
    eventType: string
    scenarioType?: string | null
    decisionMade?: boolean | null
    decisionOutcome?: string | null
    riskAvoided?: boolean | null
    upgradeTriggered?: boolean | null
    planBefore?: string | null
    planAfter?: string | null
    timeToDecision?: number | null
    timestamp?: Date | string
  }

  export type ScenarioAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    scenarioType?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMade?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decisionOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    riskAvoided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    upgradeTriggered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    planBefore?: NullableStringFieldUpdateOperationsInput | string | null
    planAfter?: NullableStringFieldUpdateOperationsInput | string | null
    timeToDecision?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutScenarioAnalyticsNestedInput
  }

  export type ScenarioAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scenarioId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    scenarioType?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMade?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decisionOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    riskAvoided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    upgradeTriggered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    planBefore?: NullableStringFieldUpdateOperationsInput | string | null
    planAfter?: NullableStringFieldUpdateOperationsInput | string | null
    timeToDecision?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioAnalyticsCreateManyInput = {
    id?: string
    tenantId: string
    scenarioId?: string | null
    eventType: string
    scenarioType?: string | null
    decisionMade?: boolean | null
    decisionOutcome?: string | null
    riskAvoided?: boolean | null
    upgradeTriggered?: boolean | null
    planBefore?: string | null
    planAfter?: string | null
    timeToDecision?: number | null
    timestamp?: Date | string
  }

  export type ScenarioAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    scenarioType?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMade?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decisionOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    riskAvoided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    upgradeTriggered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    planBefore?: NullableStringFieldUpdateOperationsInput | string | null
    planAfter?: NullableStringFieldUpdateOperationsInput | string | null
    timeToDecision?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scenarioId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    scenarioType?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMade?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decisionOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    riskAvoided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    upgradeTriggered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    planBefore?: NullableStringFieldUpdateOperationsInput | string | null
    planAfter?: NullableStringFieldUpdateOperationsInput | string | null
    timeToDecision?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type DashboardLayoutListRelationFilter = {
    every?: DashboardLayoutWhereInput
    some?: DashboardLayoutWhereInput
    none?: DashboardLayoutWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DashboardLayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    refreshToken?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    refreshToken?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    refreshToken?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiresAt?: SortOrder
    tokenType?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiresAt?: SortOrder
    tokenType?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiresAt?: SortOrder
    tokenType?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type EnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AnalyticsEventListRelationFilter = {
    every?: AnalyticsEventWhereInput
    some?: AnalyticsEventWhereInput
    none?: AnalyticsEventWhereInput
  }

  export type AutomationRuleListRelationFilter = {
    every?: AutomationRuleWhereInput
    some?: AutomationRuleWhereInput
    none?: AutomationRuleWhereInput
  }

  export type AutomationExecutionListRelationFilter = {
    every?: AutomationExecutionWhereInput
    some?: AutomationExecutionWhereInput
    none?: AutomationExecutionWhereInput
  }

  export type SmartInsightListRelationFilter = {
    every?: SmartInsightWhereInput
    some?: SmartInsightWhereInput
    none?: SmartInsightWhereInput
  }

  export type AutomationUsageMetricListRelationFilter = {
    every?: AutomationUsageMetricWhereInput
    some?: AutomationUsageMetricWhereInput
    none?: AutomationUsageMetricWhereInput
  }

  export type PaymentMethodListRelationFilter = {
    every?: PaymentMethodWhereInput
    some?: PaymentMethodWhereInput
    none?: PaymentMethodWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentReconciliationListRelationFilter = {
    every?: PaymentReconciliationWhereInput
    some?: PaymentReconciliationWhereInput
    none?: PaymentReconciliationWhereInput
  }

  export type PaymentExplainabilityListRelationFilter = {
    every?: PaymentExplainabilityWhereInput
    some?: PaymentExplainabilityWhereInput
    none?: PaymentExplainabilityWhereInput
  }

  export type CashControlRuleListRelationFilter = {
    every?: CashControlRuleWhereInput
    some?: CashControlRuleWhereInput
    none?: CashControlRuleWhereInput
  }

  export type CashControlExecutionListRelationFilter = {
    every?: CashControlExecutionWhereInput
    some?: CashControlExecutionWhereInput
    none?: CashControlExecutionWhereInput
  }

  export type PaymentAnalyticsListRelationFilter = {
    every?: PaymentAnalyticsWhereInput
    some?: PaymentAnalyticsWhereInput
    none?: PaymentAnalyticsWhereInput
  }

  export type FinancialForecastListRelationFilter = {
    every?: FinancialForecastWhereInput
    some?: FinancialForecastWhereInput
    none?: FinancialForecastWhereInput
  }

  export type ScenarioListRelationFilter = {
    every?: ScenarioWhereInput
    some?: ScenarioWhereInput
    none?: ScenarioWhereInput
  }

  export type ScenarioAnalyticsListRelationFilter = {
    every?: ScenarioAnalyticsWhereInput
    some?: ScenarioAnalyticsWhereInput
    none?: ScenarioAnalyticsWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SmartInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationUsageMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentReconciliationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentExplainabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashControlRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashControlExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialForecastOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScenarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScenarioAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrder
    logo?: SortOrder
    favicon?: SortOrder
    theme?: SortOrder
    featureFlags?: SortOrder
    settings?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrder
    favicon?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrder
    favicon?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type EnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DashboardLayoutUserIdTenantIdCompoundUniqueInput = {
    userId: string
    tenantId: string
  }

  export type DashboardLayoutRoleTenantIdIsDefaultCompoundUniqueInput = {
    role: $Enums.Role
    tenantId: string
    isDefault: boolean
  }

  export type DashboardLayoutCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    layout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardLayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardLayoutMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    allowed?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    allowed?: SortOrder
    reason?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    allowed?: SortOrder
    reason?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    featureFlag?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    userRole?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    serverTimestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    featureFlag?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    userRole?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    serverTimestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    featureFlag?: SortOrder
    featureName?: SortOrder
    userId?: SortOrder
    userRole?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    serverTimestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EnumAutomationTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel> | $Enums.AutomationTriggerType
  }

  export type EnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AutomationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    status?: SortOrder
    isTemplate?: SortOrder
    requiresApproval?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    lastTriggered?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationRuleAvgOrderByAggregateInput = {
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type AutomationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    status?: SortOrder
    isTemplate?: SortOrder
    requiresApproval?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    lastTriggered?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    status?: SortOrder
    isTemplate?: SortOrder
    requiresApproval?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    lastTriggered?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationRuleSumOrderByAggregateInput = {
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
  }

  export type EnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutomationTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
  }

  export type EnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAutomationExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationExecutionStatus | EnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationExecutionStatusFilter<$PrismaModel> | $Enums.AutomationExecutionStatus
  }

  export type AutomationRuleScalarRelationFilter = {
    is?: AutomationRuleWhereInput
    isNot?: AutomationRuleWhereInput
  }

  export type AutomationExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggeredBy?: SortOrder
    triggerData?: SortOrder
    conditionsEvaluated?: SortOrder
    conditionsMet?: SortOrder
    actionsExecuted?: SortOrder
    isDryRun?: SortOrder
    errorMessage?: SortOrder
    executionTime?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AutomationExecutionAvgOrderByAggregateInput = {
    executionTime?: SortOrder
    retryCount?: SortOrder
  }

  export type AutomationExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggeredBy?: SortOrder
    conditionsMet?: SortOrder
    isDryRun?: SortOrder
    errorMessage?: SortOrder
    executionTime?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AutomationExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggeredBy?: SortOrder
    conditionsMet?: SortOrder
    isDryRun?: SortOrder
    errorMessage?: SortOrder
    executionTime?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AutomationExecutionSumOrderByAggregateInput = {
    executionTime?: SortOrder
    retryCount?: SortOrder
  }

  export type EnumAutomationExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationExecutionStatus | EnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationExecutionStatusFilter<$PrismaModel>
  }

  export type EnumInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeFilter<$PrismaModel> | $Enums.InsightType
  }

  export type EnumInsightSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightSeverity | EnumInsightSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightSeverityFilter<$PrismaModel> | $Enums.InsightSeverity
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SmartInsightCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    insightType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrder
    relatedEntities?: SortOrder
    actionable?: SortOrder
    suggestedActions?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
    dismissReason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SmartInsightAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type SmartInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    insightType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    actionable?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
    dismissReason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SmartInsightMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    insightType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    explanation?: SortOrder
    confidence?: SortOrder
    actionable?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
    dismissReason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SmartInsightSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightTypeFilter<$PrismaModel>
  }

  export type EnumInsightSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightSeverity | EnumInsightSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightSeverityWithAggregatesFilter<$PrismaModel> | $Enums.InsightSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightSeverityFilter<$PrismaModel>
    _max?: NestedEnumInsightSeverityFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AutomationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    requiredPlan?: SortOrder
    popularity?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationTemplateAvgOrderByAggregateInput = {
    popularity?: SortOrder
  }

  export type AutomationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    triggerType?: SortOrder
    requiredPlan?: SortOrder
    popularity?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    triggerType?: SortOrder
    requiredPlan?: SortOrder
    popularity?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutomationTemplateSumOrderByAggregateInput = {
    popularity?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AutomationUsageMetricCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ruleId?: SortOrder
    executionId?: SortOrder
    actionType?: SortOrder
    success?: SortOrder
    executionTime?: SortOrder
    costImpact?: SortOrder
    businessImpact?: SortOrder
    timestamp?: SortOrder
  }

  export type AutomationUsageMetricAvgOrderByAggregateInput = {
    executionTime?: SortOrder
    costImpact?: SortOrder
  }

  export type AutomationUsageMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ruleId?: SortOrder
    executionId?: SortOrder
    actionType?: SortOrder
    success?: SortOrder
    executionTime?: SortOrder
    costImpact?: SortOrder
    timestamp?: SortOrder
  }

  export type AutomationUsageMetricMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ruleId?: SortOrder
    executionId?: SortOrder
    actionType?: SortOrder
    success?: SortOrder
    executionTime?: SortOrder
    costImpact?: SortOrder
    timestamp?: SortOrder
  }

  export type AutomationUsageMetricSumOrderByAggregateInput = {
    executionTime?: SortOrder
    costImpact?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    accountType?: SortOrder
    routingNumber?: SortOrder
    nickname?: SortOrder
    billingAddress?: SortOrder
    metadata?: SortOrder
    isActive?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    accountType?: SortOrder
    routingNumber?: SortOrder
    nickname?: SortOrder
    isActive?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    accountType?: SortOrder
    routingNumber?: SortOrder
    nickname?: SortOrder
    isActive?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
  }

  export type EnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentMethodNullableScalarRelationFilter = {
    is?: PaymentMethodWhereInput | null
    isNot?: PaymentMethodWhereInput | null
  }

  export type PaymentReconciliationNullableScalarRelationFilter = {
    is?: PaymentReconciliationWhereInput | null
    isNot?: PaymentReconciliationWhereInput | null
  }

  export type PaymentExplainabilityNullableScalarRelationFilter = {
    is?: PaymentExplainabilityWhereInput | null
    isNot?: PaymentExplainabilityWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentMethodId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    processorId?: SortOrder
    processorStatus?: SortOrder
    processorResponse?: SortOrder
    automationRuleId?: SortOrder
    automationExecutionId?: SortOrder
    isAutomated?: SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrder
    reconciledAt?: SortOrder
    ledgerEntryId?: SortOrder
    processingFee?: SortOrder
    netAmount?: SortOrder
    isDisputed?: SortOrder
    disputeReason?: SortOrder
    disputedAt?: SortOrder
    requiresApproval?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    metadata?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    processingFee?: SortOrder
    netAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentMethodId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    processorId?: SortOrder
    processorStatus?: SortOrder
    automationRuleId?: SortOrder
    automationExecutionId?: SortOrder
    isAutomated?: SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrder
    reconciledAt?: SortOrder
    ledgerEntryId?: SortOrder
    processingFee?: SortOrder
    netAmount?: SortOrder
    isDisputed?: SortOrder
    disputeReason?: SortOrder
    disputedAt?: SortOrder
    requiresApproval?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentMethodId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    processorId?: SortOrder
    processorStatus?: SortOrder
    automationRuleId?: SortOrder
    automationExecutionId?: SortOrder
    isAutomated?: SortOrder
    scheduledFor?: SortOrder
    processedAt?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    nextRetryAt?: SortOrder
    reconciledAt?: SortOrder
    ledgerEntryId?: SortOrder
    processingFee?: SortOrder
    netAmount?: SortOrder
    isDisputed?: SortOrder
    disputeReason?: SortOrder
    disputedAt?: SortOrder
    requiresApproval?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    processingFee?: SortOrder
    netAmount?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumReconciliationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReconciliationStatus | EnumReconciliationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReconciliationStatusFilter<$PrismaModel> | $Enums.ReconciliationStatus
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PaymentReconciliationCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    ledgerEntryId?: SortOrder
    accountId?: SortOrder
    matchedAmount?: SortOrder
    variance?: SortOrder
    varianceReason?: SortOrder
    reconciledBy?: SortOrder
    reconciledAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentReconciliationAvgOrderByAggregateInput = {
    matchedAmount?: SortOrder
    variance?: SortOrder
  }

  export type PaymentReconciliationMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    ledgerEntryId?: SortOrder
    accountId?: SortOrder
    matchedAmount?: SortOrder
    variance?: SortOrder
    varianceReason?: SortOrder
    reconciledBy?: SortOrder
    reconciledAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentReconciliationMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    ledgerEntryId?: SortOrder
    accountId?: SortOrder
    matchedAmount?: SortOrder
    variance?: SortOrder
    varianceReason?: SortOrder
    reconciledBy?: SortOrder
    reconciledAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentReconciliationSumOrderByAggregateInput = {
    matchedAmount?: SortOrder
    variance?: SortOrder
  }

  export type EnumReconciliationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReconciliationStatus | EnumReconciliationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReconciliationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReconciliationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReconciliationStatusFilter<$PrismaModel>
    _max?: NestedEnumReconciliationStatusFilter<$PrismaModel>
  }

  export type PaymentExplainabilityCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    trigger?: SortOrder
    triggerDetails?: SortOrder
    conditionsMet?: SortOrder
    amountCalculation?: SortOrder
    baseAmount?: SortOrder
    adjustments?: SortOrder
    confidenceScore?: SortOrder
    safeguards?: SortOrder
    riskFactors?: SortOrder
    approvalRequired?: SortOrder
    approvalStatus?: SortOrder
    businessImpact?: SortOrder
    estimatedTimeSaved?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentExplainabilityAvgOrderByAggregateInput = {
    baseAmount?: SortOrder
    confidenceScore?: SortOrder
    estimatedTimeSaved?: SortOrder
  }

  export type PaymentExplainabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    trigger?: SortOrder
    amountCalculation?: SortOrder
    baseAmount?: SortOrder
    confidenceScore?: SortOrder
    approvalRequired?: SortOrder
    approvalStatus?: SortOrder
    estimatedTimeSaved?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentExplainabilityMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    tenantId?: SortOrder
    trigger?: SortOrder
    amountCalculation?: SortOrder
    baseAmount?: SortOrder
    confidenceScore?: SortOrder
    approvalRequired?: SortOrder
    approvalStatus?: SortOrder
    estimatedTimeSaved?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentExplainabilitySumOrderByAggregateInput = {
    baseAmount?: SortOrder
    confidenceScore?: SortOrder
    estimatedTimeSaved?: SortOrder
  }

  export type EnumCashControlRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashControlRuleType | EnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashControlRuleTypeFilter<$PrismaModel> | $Enums.CashControlRuleType
  }

  export type CashControlRuleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ruleType?: SortOrder
    config?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    requiresApproval?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    totalAmountProcessed?: SortOrder
    createdBy?: SortOrder
    lastExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashControlRuleAvgOrderByAggregateInput = {
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    totalAmountProcessed?: SortOrder
  }

  export type CashControlRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ruleType?: SortOrder
    isActive?: SortOrder
    requiresApproval?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    totalAmountProcessed?: SortOrder
    createdBy?: SortOrder
    lastExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashControlRuleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ruleType?: SortOrder
    isActive?: SortOrder
    requiresApproval?: SortOrder
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    totalAmountProcessed?: SortOrder
    createdBy?: SortOrder
    lastExecuted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashControlRuleSumOrderByAggregateInput = {
    executionCount?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    totalAmountProcessed?: SortOrder
  }

  export type EnumCashControlRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashControlRuleType | EnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashControlRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashControlRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashControlRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumCashControlRuleTypeFilter<$PrismaModel>
  }

  export type CashControlRuleScalarRelationFilter = {
    is?: CashControlRuleWhereInput
    isNot?: CashControlRuleWhereInput
  }

  export type CashControlExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    triggerData?: SortOrder
    conditionsEvaluated?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    executionTime?: SortOrder
    isDryRun?: SortOrder
    createdAt?: SortOrder
  }

  export type CashControlExecutionAvgOrderByAggregateInput = {
    amount?: SortOrder
    executionTime?: SortOrder
  }

  export type CashControlExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    executionTime?: SortOrder
    isDryRun?: SortOrder
    createdAt?: SortOrder
  }

  export type CashControlExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    executionTime?: SortOrder
    isDryRun?: SortOrder
    createdAt?: SortOrder
  }

  export type CashControlExecutionSumOrderByAggregateInput = {
    amount?: SortOrder
    executionTime?: SortOrder
  }

  export type PaymentAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    isAutomated?: SortOrder
    automationRuleId?: SortOrder
    timeToCash?: SortOrder
    retryCount?: SortOrder
    revenueImpact?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentAnalyticsAvgOrderByAggregateInput = {
    amount?: SortOrder
    processingFee?: SortOrder
    timeToCash?: SortOrder
    retryCount?: SortOrder
    revenueImpact?: SortOrder
  }

  export type PaymentAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    isAutomated?: SortOrder
    automationRuleId?: SortOrder
    timeToCash?: SortOrder
    retryCount?: SortOrder
    revenueImpact?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    isAutomated?: SortOrder
    automationRuleId?: SortOrder
    timeToCash?: SortOrder
    retryCount?: SortOrder
    revenueImpact?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentAnalyticsSumOrderByAggregateInput = {
    amount?: SortOrder
    processingFee?: SortOrder
    timeToCash?: SortOrder
    retryCount?: SortOrder
    revenueImpact?: SortOrder
  }

  export type EnumForecastTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ForecastType | EnumForecastTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForecastTypeFilter<$PrismaModel> | $Enums.ForecastType
  }

  export type FinancialForecastCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    forecastType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    confidenceScore?: SortOrder
    forecastDate?: SortOrder
    forecastHorizon?: SortOrder
    formula?: SortOrder
    assumptions?: SortOrder
    dataSources?: SortOrder
    historicalBaseline?: SortOrder
    calculatedAt?: SortOrder
  }

  export type FinancialForecastAvgOrderByAggregateInput = {
    value?: SortOrder
    confidenceScore?: SortOrder
    forecastHorizon?: SortOrder
  }

  export type FinancialForecastMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    forecastType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    confidenceScore?: SortOrder
    forecastDate?: SortOrder
    forecastHorizon?: SortOrder
    formula?: SortOrder
    calculatedAt?: SortOrder
  }

  export type FinancialForecastMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    forecastType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    confidenceScore?: SortOrder
    forecastDate?: SortOrder
    forecastHorizon?: SortOrder
    formula?: SortOrder
    calculatedAt?: SortOrder
  }

  export type FinancialForecastSumOrderByAggregateInput = {
    value?: SortOrder
    confidenceScore?: SortOrder
    forecastHorizon?: SortOrder
  }

  export type EnumForecastTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForecastType | EnumForecastTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForecastTypeWithAggregatesFilter<$PrismaModel> | $Enums.ForecastType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForecastTypeFilter<$PrismaModel>
    _max?: NestedEnumForecastTypeFilter<$PrismaModel>
  }

  export type EnumScenarioTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScenarioType | EnumScenarioTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScenarioTypeFilter<$PrismaModel> | $Enums.ScenarioType
  }

  export type EnumRiskLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskLevelNullableFilter<$PrismaModel> | $Enums.RiskLevel | null
  }

  export type ScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scenarioType?: SortOrder
    config?: SortOrder
    baselineRunway?: SortOrder
    projectedRunway?: SortOrder
    runwayChange?: SortOrder
    riskLevel?: SortOrder
    riskScore?: SortOrder
    successProbability?: SortOrder
    topRiskDrivers?: SortOrder
    criticalAssumptions?: SortOrder
    cashFlowImpact?: SortOrder
    automationImpact?: SortOrder
    paymentImpact?: SortOrder
    recommendations?: SortOrder
    createdBy?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioAvgOrderByAggregateInput = {
    baselineRunway?: SortOrder
    projectedRunway?: SortOrder
    runwayChange?: SortOrder
    riskScore?: SortOrder
    successProbability?: SortOrder
  }

  export type ScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scenarioType?: SortOrder
    baselineRunway?: SortOrder
    projectedRunway?: SortOrder
    runwayChange?: SortOrder
    riskLevel?: SortOrder
    riskScore?: SortOrder
    successProbability?: SortOrder
    createdBy?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scenarioType?: SortOrder
    baselineRunway?: SortOrder
    projectedRunway?: SortOrder
    runwayChange?: SortOrder
    riskLevel?: SortOrder
    riskScore?: SortOrder
    successProbability?: SortOrder
    createdBy?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioSumOrderByAggregateInput = {
    baselineRunway?: SortOrder
    projectedRunway?: SortOrder
    runwayChange?: SortOrder
    riskScore?: SortOrder
    successProbability?: SortOrder
  }

  export type EnumScenarioTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScenarioType | EnumScenarioTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScenarioTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScenarioType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScenarioTypeFilter<$PrismaModel>
    _max?: NestedEnumScenarioTypeFilter<$PrismaModel>
  }

  export type EnumRiskLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ScenarioAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scenarioId?: SortOrder
    eventType?: SortOrder
    scenarioType?: SortOrder
    decisionMade?: SortOrder
    decisionOutcome?: SortOrder
    riskAvoided?: SortOrder
    upgradeTriggered?: SortOrder
    planBefore?: SortOrder
    planAfter?: SortOrder
    timeToDecision?: SortOrder
    timestamp?: SortOrder
  }

  export type ScenarioAnalyticsAvgOrderByAggregateInput = {
    timeToDecision?: SortOrder
  }

  export type ScenarioAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scenarioId?: SortOrder
    eventType?: SortOrder
    scenarioType?: SortOrder
    decisionMade?: SortOrder
    decisionOutcome?: SortOrder
    riskAvoided?: SortOrder
    upgradeTriggered?: SortOrder
    planBefore?: SortOrder
    planAfter?: SortOrder
    timeToDecision?: SortOrder
    timestamp?: SortOrder
  }

  export type ScenarioAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scenarioId?: SortOrder
    eventType?: SortOrder
    scenarioType?: SortOrder
    decisionMade?: SortOrder
    decisionOutcome?: SortOrder
    riskAvoided?: SortOrder
    upgradeTriggered?: SortOrder
    planBefore?: SortOrder
    planAfter?: SortOrder
    timeToDecision?: SortOrder
    timestamp?: SortOrder
  }

  export type ScenarioAnalyticsSumOrderByAggregateInput = {
    timeToDecision?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type DashboardLayoutCreateNestedManyWithoutUserInput = {
    create?: XOR<DashboardLayoutCreateWithoutUserInput, DashboardLayoutUncheckedCreateWithoutUserInput> | DashboardLayoutCreateWithoutUserInput[] | DashboardLayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutUserInput | DashboardLayoutCreateOrConnectWithoutUserInput[]
    createMany?: DashboardLayoutCreateManyUserInputEnvelope
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type DashboardLayoutUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DashboardLayoutCreateWithoutUserInput, DashboardLayoutUncheckedCreateWithoutUserInput> | DashboardLayoutCreateWithoutUserInput[] | DashboardLayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutUserInput | DashboardLayoutCreateOrConnectWithoutUserInput[]
    createMany?: DashboardLayoutCreateManyUserInputEnvelope
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type DashboardLayoutUpdateManyWithoutUserNestedInput = {
    create?: XOR<DashboardLayoutCreateWithoutUserInput, DashboardLayoutUncheckedCreateWithoutUserInput> | DashboardLayoutCreateWithoutUserInput[] | DashboardLayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutUserInput | DashboardLayoutCreateOrConnectWithoutUserInput[]
    upsert?: DashboardLayoutUpsertWithWhereUniqueWithoutUserInput | DashboardLayoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DashboardLayoutCreateManyUserInputEnvelope
    set?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    disconnect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    delete?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    update?: DashboardLayoutUpdateWithWhereUniqueWithoutUserInput | DashboardLayoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DashboardLayoutUpdateManyWithWhereWithoutUserInput | DashboardLayoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DashboardLayoutScalarWhereInput | DashboardLayoutScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type DashboardLayoutUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DashboardLayoutCreateWithoutUserInput, DashboardLayoutUncheckedCreateWithoutUserInput> | DashboardLayoutCreateWithoutUserInput[] | DashboardLayoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutUserInput | DashboardLayoutCreateOrConnectWithoutUserInput[]
    upsert?: DashboardLayoutUpsertWithWhereUniqueWithoutUserInput | DashboardLayoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DashboardLayoutCreateManyUserInputEnvelope
    set?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    disconnect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    delete?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    update?: DashboardLayoutUpdateWithWhereUniqueWithoutUserInput | DashboardLayoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DashboardLayoutUpdateManyWithWhereWithoutUserInput | DashboardLayoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DashboardLayoutScalarWhereInput | DashboardLayoutScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DashboardLayoutCreateNestedManyWithoutTenantInput = {
    create?: XOR<DashboardLayoutCreateWithoutTenantInput, DashboardLayoutUncheckedCreateWithoutTenantInput> | DashboardLayoutCreateWithoutTenantInput[] | DashboardLayoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutTenantInput | DashboardLayoutCreateOrConnectWithoutTenantInput[]
    createMany?: DashboardLayoutCreateManyTenantInputEnvelope
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AnalyticsEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<AnalyticsEventCreateWithoutTenantInput, AnalyticsEventUncheckedCreateWithoutTenantInput> | AnalyticsEventCreateWithoutTenantInput[] | AnalyticsEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutTenantInput | AnalyticsEventCreateOrConnectWithoutTenantInput[]
    createMany?: AnalyticsEventCreateManyTenantInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type AutomationRuleCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationRuleCreateWithoutTenantInput, AutomationRuleUncheckedCreateWithoutTenantInput> | AutomationRuleCreateWithoutTenantInput[] | AutomationRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTenantInput | AutomationRuleCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationRuleCreateManyTenantInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type AutomationExecutionCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationExecutionCreateWithoutTenantInput, AutomationExecutionUncheckedCreateWithoutTenantInput> | AutomationExecutionCreateWithoutTenantInput[] | AutomationExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutTenantInput | AutomationExecutionCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationExecutionCreateManyTenantInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type SmartInsightCreateNestedManyWithoutTenantInput = {
    create?: XOR<SmartInsightCreateWithoutTenantInput, SmartInsightUncheckedCreateWithoutTenantInput> | SmartInsightCreateWithoutTenantInput[] | SmartInsightUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SmartInsightCreateOrConnectWithoutTenantInput | SmartInsightCreateOrConnectWithoutTenantInput[]
    createMany?: SmartInsightCreateManyTenantInputEnvelope
    connect?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
  }

  export type AutomationUsageMetricCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationUsageMetricCreateWithoutTenantInput, AutomationUsageMetricUncheckedCreateWithoutTenantInput> | AutomationUsageMetricCreateWithoutTenantInput[] | AutomationUsageMetricUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationUsageMetricCreateOrConnectWithoutTenantInput | AutomationUsageMetricCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationUsageMetricCreateManyTenantInputEnvelope
    connect?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
  }

  export type PaymentMethodCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentMethodCreateWithoutTenantInput, PaymentMethodUncheckedCreateWithoutTenantInput> | PaymentMethodCreateWithoutTenantInput[] | PaymentMethodUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTenantInput | PaymentMethodCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentMethodCreateManyTenantInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentReconciliationCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentReconciliationCreateWithoutTenantInput, PaymentReconciliationUncheckedCreateWithoutTenantInput> | PaymentReconciliationCreateWithoutTenantInput[] | PaymentReconciliationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutTenantInput | PaymentReconciliationCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentReconciliationCreateManyTenantInputEnvelope
    connect?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
  }

  export type PaymentExplainabilityCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutTenantInput, PaymentExplainabilityUncheckedCreateWithoutTenantInput> | PaymentExplainabilityCreateWithoutTenantInput[] | PaymentExplainabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutTenantInput | PaymentExplainabilityCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentExplainabilityCreateManyTenantInputEnvelope
    connect?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
  }

  export type CashControlRuleCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashControlRuleCreateWithoutTenantInput, CashControlRuleUncheckedCreateWithoutTenantInput> | CashControlRuleCreateWithoutTenantInput[] | CashControlRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlRuleCreateOrConnectWithoutTenantInput | CashControlRuleCreateOrConnectWithoutTenantInput[]
    createMany?: CashControlRuleCreateManyTenantInputEnvelope
    connect?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
  }

  export type CashControlExecutionCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashControlExecutionCreateWithoutTenantInput, CashControlExecutionUncheckedCreateWithoutTenantInput> | CashControlExecutionCreateWithoutTenantInput[] | CashControlExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutTenantInput | CashControlExecutionCreateOrConnectWithoutTenantInput[]
    createMany?: CashControlExecutionCreateManyTenantInputEnvelope
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
  }

  export type PaymentAnalyticsCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentAnalyticsCreateWithoutTenantInput, PaymentAnalyticsUncheckedCreateWithoutTenantInput> | PaymentAnalyticsCreateWithoutTenantInput[] | PaymentAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentAnalyticsCreateOrConnectWithoutTenantInput | PaymentAnalyticsCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentAnalyticsCreateManyTenantInputEnvelope
    connect?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
  }

  export type FinancialForecastCreateNestedManyWithoutTenantInput = {
    create?: XOR<FinancialForecastCreateWithoutTenantInput, FinancialForecastUncheckedCreateWithoutTenantInput> | FinancialForecastCreateWithoutTenantInput[] | FinancialForecastUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FinancialForecastCreateOrConnectWithoutTenantInput | FinancialForecastCreateOrConnectWithoutTenantInput[]
    createMany?: FinancialForecastCreateManyTenantInputEnvelope
    connect?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
  }

  export type ScenarioCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScenarioCreateWithoutTenantInput, ScenarioUncheckedCreateWithoutTenantInput> | ScenarioCreateWithoutTenantInput[] | ScenarioUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutTenantInput | ScenarioCreateOrConnectWithoutTenantInput[]
    createMany?: ScenarioCreateManyTenantInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type ScenarioAnalyticsCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScenarioAnalyticsCreateWithoutTenantInput, ScenarioAnalyticsUncheckedCreateWithoutTenantInput> | ScenarioAnalyticsCreateWithoutTenantInput[] | ScenarioAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioAnalyticsCreateOrConnectWithoutTenantInput | ScenarioAnalyticsCreateOrConnectWithoutTenantInput[]
    createMany?: ScenarioAnalyticsCreateManyTenantInputEnvelope
    connect?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DashboardLayoutCreateWithoutTenantInput, DashboardLayoutUncheckedCreateWithoutTenantInput> | DashboardLayoutCreateWithoutTenantInput[] | DashboardLayoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutTenantInput | DashboardLayoutCreateOrConnectWithoutTenantInput[]
    createMany?: DashboardLayoutCreateManyTenantInputEnvelope
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AnalyticsEventCreateWithoutTenantInput, AnalyticsEventUncheckedCreateWithoutTenantInput> | AnalyticsEventCreateWithoutTenantInput[] | AnalyticsEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutTenantInput | AnalyticsEventCreateOrConnectWithoutTenantInput[]
    createMany?: AnalyticsEventCreateManyTenantInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type AutomationRuleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationRuleCreateWithoutTenantInput, AutomationRuleUncheckedCreateWithoutTenantInput> | AutomationRuleCreateWithoutTenantInput[] | AutomationRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTenantInput | AutomationRuleCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationRuleCreateManyTenantInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationExecutionCreateWithoutTenantInput, AutomationExecutionUncheckedCreateWithoutTenantInput> | AutomationExecutionCreateWithoutTenantInput[] | AutomationExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutTenantInput | AutomationExecutionCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationExecutionCreateManyTenantInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type SmartInsightUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SmartInsightCreateWithoutTenantInput, SmartInsightUncheckedCreateWithoutTenantInput> | SmartInsightCreateWithoutTenantInput[] | SmartInsightUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SmartInsightCreateOrConnectWithoutTenantInput | SmartInsightCreateOrConnectWithoutTenantInput[]
    createMany?: SmartInsightCreateManyTenantInputEnvelope
    connect?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
  }

  export type AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AutomationUsageMetricCreateWithoutTenantInput, AutomationUsageMetricUncheckedCreateWithoutTenantInput> | AutomationUsageMetricCreateWithoutTenantInput[] | AutomationUsageMetricUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationUsageMetricCreateOrConnectWithoutTenantInput | AutomationUsageMetricCreateOrConnectWithoutTenantInput[]
    createMany?: AutomationUsageMetricCreateManyTenantInputEnvelope
    connect?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
  }

  export type PaymentMethodUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentMethodCreateWithoutTenantInput, PaymentMethodUncheckedCreateWithoutTenantInput> | PaymentMethodCreateWithoutTenantInput[] | PaymentMethodUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTenantInput | PaymentMethodCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentMethodCreateManyTenantInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentReconciliationCreateWithoutTenantInput, PaymentReconciliationUncheckedCreateWithoutTenantInput> | PaymentReconciliationCreateWithoutTenantInput[] | PaymentReconciliationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutTenantInput | PaymentReconciliationCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentReconciliationCreateManyTenantInputEnvelope
    connect?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
  }

  export type PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutTenantInput, PaymentExplainabilityUncheckedCreateWithoutTenantInput> | PaymentExplainabilityCreateWithoutTenantInput[] | PaymentExplainabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutTenantInput | PaymentExplainabilityCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentExplainabilityCreateManyTenantInputEnvelope
    connect?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
  }

  export type CashControlRuleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashControlRuleCreateWithoutTenantInput, CashControlRuleUncheckedCreateWithoutTenantInput> | CashControlRuleCreateWithoutTenantInput[] | CashControlRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlRuleCreateOrConnectWithoutTenantInput | CashControlRuleCreateOrConnectWithoutTenantInput[]
    createMany?: CashControlRuleCreateManyTenantInputEnvelope
    connect?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
  }

  export type CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashControlExecutionCreateWithoutTenantInput, CashControlExecutionUncheckedCreateWithoutTenantInput> | CashControlExecutionCreateWithoutTenantInput[] | CashControlExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutTenantInput | CashControlExecutionCreateOrConnectWithoutTenantInput[]
    createMany?: CashControlExecutionCreateManyTenantInputEnvelope
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
  }

  export type PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentAnalyticsCreateWithoutTenantInput, PaymentAnalyticsUncheckedCreateWithoutTenantInput> | PaymentAnalyticsCreateWithoutTenantInput[] | PaymentAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentAnalyticsCreateOrConnectWithoutTenantInput | PaymentAnalyticsCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentAnalyticsCreateManyTenantInputEnvelope
    connect?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
  }

  export type FinancialForecastUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<FinancialForecastCreateWithoutTenantInput, FinancialForecastUncheckedCreateWithoutTenantInput> | FinancialForecastCreateWithoutTenantInput[] | FinancialForecastUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FinancialForecastCreateOrConnectWithoutTenantInput | FinancialForecastCreateOrConnectWithoutTenantInput[]
    createMany?: FinancialForecastCreateManyTenantInputEnvelope
    connect?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
  }

  export type ScenarioUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScenarioCreateWithoutTenantInput, ScenarioUncheckedCreateWithoutTenantInput> | ScenarioCreateWithoutTenantInput[] | ScenarioUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutTenantInput | ScenarioCreateOrConnectWithoutTenantInput[]
    createMany?: ScenarioCreateManyTenantInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScenarioAnalyticsCreateWithoutTenantInput, ScenarioAnalyticsUncheckedCreateWithoutTenantInput> | ScenarioAnalyticsCreateWithoutTenantInput[] | ScenarioAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioAnalyticsCreateOrConnectWithoutTenantInput | ScenarioAnalyticsCreateOrConnectWithoutTenantInput[]
    createMany?: ScenarioAnalyticsCreateManyTenantInputEnvelope
    connect?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type EnumTenantStatusFieldUpdateOperationsInput = {
    set?: $Enums.TenantStatus
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DashboardLayoutUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DashboardLayoutCreateWithoutTenantInput, DashboardLayoutUncheckedCreateWithoutTenantInput> | DashboardLayoutCreateWithoutTenantInput[] | DashboardLayoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutTenantInput | DashboardLayoutCreateOrConnectWithoutTenantInput[]
    upsert?: DashboardLayoutUpsertWithWhereUniqueWithoutTenantInput | DashboardLayoutUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DashboardLayoutCreateManyTenantInputEnvelope
    set?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    disconnect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    delete?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    update?: DashboardLayoutUpdateWithWhereUniqueWithoutTenantInput | DashboardLayoutUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DashboardLayoutUpdateManyWithWhereWithoutTenantInput | DashboardLayoutUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DashboardLayoutScalarWhereInput | DashboardLayoutScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AnalyticsEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutTenantInput, AnalyticsEventUncheckedCreateWithoutTenantInput> | AnalyticsEventCreateWithoutTenantInput[] | AnalyticsEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutTenantInput | AnalyticsEventCreateOrConnectWithoutTenantInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutTenantInput | AnalyticsEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AnalyticsEventCreateManyTenantInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutTenantInput | AnalyticsEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutTenantInput | AnalyticsEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type AutomationRuleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutTenantInput, AutomationRuleUncheckedCreateWithoutTenantInput> | AutomationRuleCreateWithoutTenantInput[] | AutomationRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTenantInput | AutomationRuleCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutTenantInput | AutomationRuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationRuleCreateManyTenantInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutTenantInput | AutomationRuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutTenantInput | AutomationRuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type AutomationExecutionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutTenantInput, AutomationExecutionUncheckedCreateWithoutTenantInput> | AutomationExecutionCreateWithoutTenantInput[] | AutomationExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutTenantInput | AutomationExecutionCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutTenantInput | AutomationExecutionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationExecutionCreateManyTenantInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutTenantInput | AutomationExecutionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutTenantInput | AutomationExecutionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type SmartInsightUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SmartInsightCreateWithoutTenantInput, SmartInsightUncheckedCreateWithoutTenantInput> | SmartInsightCreateWithoutTenantInput[] | SmartInsightUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SmartInsightCreateOrConnectWithoutTenantInput | SmartInsightCreateOrConnectWithoutTenantInput[]
    upsert?: SmartInsightUpsertWithWhereUniqueWithoutTenantInput | SmartInsightUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SmartInsightCreateManyTenantInputEnvelope
    set?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    disconnect?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    delete?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    connect?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    update?: SmartInsightUpdateWithWhereUniqueWithoutTenantInput | SmartInsightUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SmartInsightUpdateManyWithWhereWithoutTenantInput | SmartInsightUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SmartInsightScalarWhereInput | SmartInsightScalarWhereInput[]
  }

  export type AutomationUsageMetricUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationUsageMetricCreateWithoutTenantInput, AutomationUsageMetricUncheckedCreateWithoutTenantInput> | AutomationUsageMetricCreateWithoutTenantInput[] | AutomationUsageMetricUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationUsageMetricCreateOrConnectWithoutTenantInput | AutomationUsageMetricCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationUsageMetricUpsertWithWhereUniqueWithoutTenantInput | AutomationUsageMetricUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationUsageMetricCreateManyTenantInputEnvelope
    set?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    disconnect?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    delete?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    connect?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    update?: AutomationUsageMetricUpdateWithWhereUniqueWithoutTenantInput | AutomationUsageMetricUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationUsageMetricUpdateManyWithWhereWithoutTenantInput | AutomationUsageMetricUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationUsageMetricScalarWhereInput | AutomationUsageMetricScalarWhereInput[]
  }

  export type PaymentMethodUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutTenantInput, PaymentMethodUncheckedCreateWithoutTenantInput> | PaymentMethodCreateWithoutTenantInput[] | PaymentMethodUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTenantInput | PaymentMethodCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutTenantInput | PaymentMethodUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentMethodCreateManyTenantInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutTenantInput | PaymentMethodUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutTenantInput | PaymentMethodUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentReconciliationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentReconciliationCreateWithoutTenantInput, PaymentReconciliationUncheckedCreateWithoutTenantInput> | PaymentReconciliationCreateWithoutTenantInput[] | PaymentReconciliationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutTenantInput | PaymentReconciliationCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentReconciliationUpsertWithWhereUniqueWithoutTenantInput | PaymentReconciliationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentReconciliationCreateManyTenantInputEnvelope
    set?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    disconnect?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    delete?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    connect?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    update?: PaymentReconciliationUpdateWithWhereUniqueWithoutTenantInput | PaymentReconciliationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentReconciliationUpdateManyWithWhereWithoutTenantInput | PaymentReconciliationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentReconciliationScalarWhereInput | PaymentReconciliationScalarWhereInput[]
  }

  export type PaymentExplainabilityUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutTenantInput, PaymentExplainabilityUncheckedCreateWithoutTenantInput> | PaymentExplainabilityCreateWithoutTenantInput[] | PaymentExplainabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutTenantInput | PaymentExplainabilityCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentExplainabilityUpsertWithWhereUniqueWithoutTenantInput | PaymentExplainabilityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentExplainabilityCreateManyTenantInputEnvelope
    set?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    disconnect?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    delete?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    connect?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    update?: PaymentExplainabilityUpdateWithWhereUniqueWithoutTenantInput | PaymentExplainabilityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentExplainabilityUpdateManyWithWhereWithoutTenantInput | PaymentExplainabilityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentExplainabilityScalarWhereInput | PaymentExplainabilityScalarWhereInput[]
  }

  export type CashControlRuleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashControlRuleCreateWithoutTenantInput, CashControlRuleUncheckedCreateWithoutTenantInput> | CashControlRuleCreateWithoutTenantInput[] | CashControlRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlRuleCreateOrConnectWithoutTenantInput | CashControlRuleCreateOrConnectWithoutTenantInput[]
    upsert?: CashControlRuleUpsertWithWhereUniqueWithoutTenantInput | CashControlRuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashControlRuleCreateManyTenantInputEnvelope
    set?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    disconnect?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    delete?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    connect?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    update?: CashControlRuleUpdateWithWhereUniqueWithoutTenantInput | CashControlRuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashControlRuleUpdateManyWithWhereWithoutTenantInput | CashControlRuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashControlRuleScalarWhereInput | CashControlRuleScalarWhereInput[]
  }

  export type CashControlExecutionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashControlExecutionCreateWithoutTenantInput, CashControlExecutionUncheckedCreateWithoutTenantInput> | CashControlExecutionCreateWithoutTenantInput[] | CashControlExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutTenantInput | CashControlExecutionCreateOrConnectWithoutTenantInput[]
    upsert?: CashControlExecutionUpsertWithWhereUniqueWithoutTenantInput | CashControlExecutionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashControlExecutionCreateManyTenantInputEnvelope
    set?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    disconnect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    delete?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    update?: CashControlExecutionUpdateWithWhereUniqueWithoutTenantInput | CashControlExecutionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashControlExecutionUpdateManyWithWhereWithoutTenantInput | CashControlExecutionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashControlExecutionScalarWhereInput | CashControlExecutionScalarWhereInput[]
  }

  export type PaymentAnalyticsUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentAnalyticsCreateWithoutTenantInput, PaymentAnalyticsUncheckedCreateWithoutTenantInput> | PaymentAnalyticsCreateWithoutTenantInput[] | PaymentAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentAnalyticsCreateOrConnectWithoutTenantInput | PaymentAnalyticsCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentAnalyticsUpsertWithWhereUniqueWithoutTenantInput | PaymentAnalyticsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentAnalyticsCreateManyTenantInputEnvelope
    set?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    disconnect?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    delete?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    connect?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    update?: PaymentAnalyticsUpdateWithWhereUniqueWithoutTenantInput | PaymentAnalyticsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentAnalyticsUpdateManyWithWhereWithoutTenantInput | PaymentAnalyticsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentAnalyticsScalarWhereInput | PaymentAnalyticsScalarWhereInput[]
  }

  export type FinancialForecastUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FinancialForecastCreateWithoutTenantInput, FinancialForecastUncheckedCreateWithoutTenantInput> | FinancialForecastCreateWithoutTenantInput[] | FinancialForecastUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FinancialForecastCreateOrConnectWithoutTenantInput | FinancialForecastCreateOrConnectWithoutTenantInput[]
    upsert?: FinancialForecastUpsertWithWhereUniqueWithoutTenantInput | FinancialForecastUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FinancialForecastCreateManyTenantInputEnvelope
    set?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    disconnect?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    delete?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    connect?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    update?: FinancialForecastUpdateWithWhereUniqueWithoutTenantInput | FinancialForecastUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FinancialForecastUpdateManyWithWhereWithoutTenantInput | FinancialForecastUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FinancialForecastScalarWhereInput | FinancialForecastScalarWhereInput[]
  }

  export type ScenarioUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScenarioCreateWithoutTenantInput, ScenarioUncheckedCreateWithoutTenantInput> | ScenarioCreateWithoutTenantInput[] | ScenarioUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutTenantInput | ScenarioCreateOrConnectWithoutTenantInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutTenantInput | ScenarioUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScenarioCreateManyTenantInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutTenantInput | ScenarioUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutTenantInput | ScenarioUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type ScenarioAnalyticsUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScenarioAnalyticsCreateWithoutTenantInput, ScenarioAnalyticsUncheckedCreateWithoutTenantInput> | ScenarioAnalyticsCreateWithoutTenantInput[] | ScenarioAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioAnalyticsCreateOrConnectWithoutTenantInput | ScenarioAnalyticsCreateOrConnectWithoutTenantInput[]
    upsert?: ScenarioAnalyticsUpsertWithWhereUniqueWithoutTenantInput | ScenarioAnalyticsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScenarioAnalyticsCreateManyTenantInputEnvelope
    set?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    disconnect?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    delete?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    connect?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    update?: ScenarioAnalyticsUpdateWithWhereUniqueWithoutTenantInput | ScenarioAnalyticsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScenarioAnalyticsUpdateManyWithWhereWithoutTenantInput | ScenarioAnalyticsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScenarioAnalyticsScalarWhereInput | ScenarioAnalyticsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DashboardLayoutCreateWithoutTenantInput, DashboardLayoutUncheckedCreateWithoutTenantInput> | DashboardLayoutCreateWithoutTenantInput[] | DashboardLayoutUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DashboardLayoutCreateOrConnectWithoutTenantInput | DashboardLayoutCreateOrConnectWithoutTenantInput[]
    upsert?: DashboardLayoutUpsertWithWhereUniqueWithoutTenantInput | DashboardLayoutUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DashboardLayoutCreateManyTenantInputEnvelope
    set?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    disconnect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    delete?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    connect?: DashboardLayoutWhereUniqueInput | DashboardLayoutWhereUniqueInput[]
    update?: DashboardLayoutUpdateWithWhereUniqueWithoutTenantInput | DashboardLayoutUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DashboardLayoutUpdateManyWithWhereWithoutTenantInput | DashboardLayoutUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DashboardLayoutScalarWhereInput | DashboardLayoutScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutTenantInput, AnalyticsEventUncheckedCreateWithoutTenantInput> | AnalyticsEventCreateWithoutTenantInput[] | AnalyticsEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutTenantInput | AnalyticsEventCreateOrConnectWithoutTenantInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutTenantInput | AnalyticsEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AnalyticsEventCreateManyTenantInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutTenantInput | AnalyticsEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutTenantInput | AnalyticsEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutTenantInput, AutomationRuleUncheckedCreateWithoutTenantInput> | AutomationRuleCreateWithoutTenantInput[] | AutomationRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTenantInput | AutomationRuleCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutTenantInput | AutomationRuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationRuleCreateManyTenantInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutTenantInput | AutomationRuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutTenantInput | AutomationRuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutTenantInput, AutomationExecutionUncheckedCreateWithoutTenantInput> | AutomationExecutionCreateWithoutTenantInput[] | AutomationExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutTenantInput | AutomationExecutionCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutTenantInput | AutomationExecutionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationExecutionCreateManyTenantInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutTenantInput | AutomationExecutionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutTenantInput | AutomationExecutionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type SmartInsightUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SmartInsightCreateWithoutTenantInput, SmartInsightUncheckedCreateWithoutTenantInput> | SmartInsightCreateWithoutTenantInput[] | SmartInsightUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SmartInsightCreateOrConnectWithoutTenantInput | SmartInsightCreateOrConnectWithoutTenantInput[]
    upsert?: SmartInsightUpsertWithWhereUniqueWithoutTenantInput | SmartInsightUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SmartInsightCreateManyTenantInputEnvelope
    set?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    disconnect?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    delete?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    connect?: SmartInsightWhereUniqueInput | SmartInsightWhereUniqueInput[]
    update?: SmartInsightUpdateWithWhereUniqueWithoutTenantInput | SmartInsightUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SmartInsightUpdateManyWithWhereWithoutTenantInput | SmartInsightUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SmartInsightScalarWhereInput | SmartInsightScalarWhereInput[]
  }

  export type AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AutomationUsageMetricCreateWithoutTenantInput, AutomationUsageMetricUncheckedCreateWithoutTenantInput> | AutomationUsageMetricCreateWithoutTenantInput[] | AutomationUsageMetricUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AutomationUsageMetricCreateOrConnectWithoutTenantInput | AutomationUsageMetricCreateOrConnectWithoutTenantInput[]
    upsert?: AutomationUsageMetricUpsertWithWhereUniqueWithoutTenantInput | AutomationUsageMetricUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AutomationUsageMetricCreateManyTenantInputEnvelope
    set?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    disconnect?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    delete?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    connect?: AutomationUsageMetricWhereUniqueInput | AutomationUsageMetricWhereUniqueInput[]
    update?: AutomationUsageMetricUpdateWithWhereUniqueWithoutTenantInput | AutomationUsageMetricUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AutomationUsageMetricUpdateManyWithWhereWithoutTenantInput | AutomationUsageMetricUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AutomationUsageMetricScalarWhereInput | AutomationUsageMetricScalarWhereInput[]
  }

  export type PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutTenantInput, PaymentMethodUncheckedCreateWithoutTenantInput> | PaymentMethodCreateWithoutTenantInput[] | PaymentMethodUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTenantInput | PaymentMethodCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutTenantInput | PaymentMethodUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentMethodCreateManyTenantInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutTenantInput | PaymentMethodUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutTenantInput | PaymentMethodUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentReconciliationCreateWithoutTenantInput, PaymentReconciliationUncheckedCreateWithoutTenantInput> | PaymentReconciliationCreateWithoutTenantInput[] | PaymentReconciliationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutTenantInput | PaymentReconciliationCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentReconciliationUpsertWithWhereUniqueWithoutTenantInput | PaymentReconciliationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentReconciliationCreateManyTenantInputEnvelope
    set?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    disconnect?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    delete?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    connect?: PaymentReconciliationWhereUniqueInput | PaymentReconciliationWhereUniqueInput[]
    update?: PaymentReconciliationUpdateWithWhereUniqueWithoutTenantInput | PaymentReconciliationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentReconciliationUpdateManyWithWhereWithoutTenantInput | PaymentReconciliationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentReconciliationScalarWhereInput | PaymentReconciliationScalarWhereInput[]
  }

  export type PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutTenantInput, PaymentExplainabilityUncheckedCreateWithoutTenantInput> | PaymentExplainabilityCreateWithoutTenantInput[] | PaymentExplainabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutTenantInput | PaymentExplainabilityCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentExplainabilityUpsertWithWhereUniqueWithoutTenantInput | PaymentExplainabilityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentExplainabilityCreateManyTenantInputEnvelope
    set?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    disconnect?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    delete?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    connect?: PaymentExplainabilityWhereUniqueInput | PaymentExplainabilityWhereUniqueInput[]
    update?: PaymentExplainabilityUpdateWithWhereUniqueWithoutTenantInput | PaymentExplainabilityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentExplainabilityUpdateManyWithWhereWithoutTenantInput | PaymentExplainabilityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentExplainabilityScalarWhereInput | PaymentExplainabilityScalarWhereInput[]
  }

  export type CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashControlRuleCreateWithoutTenantInput, CashControlRuleUncheckedCreateWithoutTenantInput> | CashControlRuleCreateWithoutTenantInput[] | CashControlRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlRuleCreateOrConnectWithoutTenantInput | CashControlRuleCreateOrConnectWithoutTenantInput[]
    upsert?: CashControlRuleUpsertWithWhereUniqueWithoutTenantInput | CashControlRuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashControlRuleCreateManyTenantInputEnvelope
    set?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    disconnect?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    delete?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    connect?: CashControlRuleWhereUniqueInput | CashControlRuleWhereUniqueInput[]
    update?: CashControlRuleUpdateWithWhereUniqueWithoutTenantInput | CashControlRuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashControlRuleUpdateManyWithWhereWithoutTenantInput | CashControlRuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashControlRuleScalarWhereInput | CashControlRuleScalarWhereInput[]
  }

  export type CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashControlExecutionCreateWithoutTenantInput, CashControlExecutionUncheckedCreateWithoutTenantInput> | CashControlExecutionCreateWithoutTenantInput[] | CashControlExecutionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutTenantInput | CashControlExecutionCreateOrConnectWithoutTenantInput[]
    upsert?: CashControlExecutionUpsertWithWhereUniqueWithoutTenantInput | CashControlExecutionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashControlExecutionCreateManyTenantInputEnvelope
    set?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    disconnect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    delete?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    update?: CashControlExecutionUpdateWithWhereUniqueWithoutTenantInput | CashControlExecutionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashControlExecutionUpdateManyWithWhereWithoutTenantInput | CashControlExecutionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashControlExecutionScalarWhereInput | CashControlExecutionScalarWhereInput[]
  }

  export type PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentAnalyticsCreateWithoutTenantInput, PaymentAnalyticsUncheckedCreateWithoutTenantInput> | PaymentAnalyticsCreateWithoutTenantInput[] | PaymentAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentAnalyticsCreateOrConnectWithoutTenantInput | PaymentAnalyticsCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentAnalyticsUpsertWithWhereUniqueWithoutTenantInput | PaymentAnalyticsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentAnalyticsCreateManyTenantInputEnvelope
    set?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    disconnect?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    delete?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    connect?: PaymentAnalyticsWhereUniqueInput | PaymentAnalyticsWhereUniqueInput[]
    update?: PaymentAnalyticsUpdateWithWhereUniqueWithoutTenantInput | PaymentAnalyticsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentAnalyticsUpdateManyWithWhereWithoutTenantInput | PaymentAnalyticsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentAnalyticsScalarWhereInput | PaymentAnalyticsScalarWhereInput[]
  }

  export type FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FinancialForecastCreateWithoutTenantInput, FinancialForecastUncheckedCreateWithoutTenantInput> | FinancialForecastCreateWithoutTenantInput[] | FinancialForecastUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FinancialForecastCreateOrConnectWithoutTenantInput | FinancialForecastCreateOrConnectWithoutTenantInput[]
    upsert?: FinancialForecastUpsertWithWhereUniqueWithoutTenantInput | FinancialForecastUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FinancialForecastCreateManyTenantInputEnvelope
    set?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    disconnect?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    delete?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    connect?: FinancialForecastWhereUniqueInput | FinancialForecastWhereUniqueInput[]
    update?: FinancialForecastUpdateWithWhereUniqueWithoutTenantInput | FinancialForecastUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FinancialForecastUpdateManyWithWhereWithoutTenantInput | FinancialForecastUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FinancialForecastScalarWhereInput | FinancialForecastScalarWhereInput[]
  }

  export type ScenarioUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScenarioCreateWithoutTenantInput, ScenarioUncheckedCreateWithoutTenantInput> | ScenarioCreateWithoutTenantInput[] | ScenarioUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutTenantInput | ScenarioCreateOrConnectWithoutTenantInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutTenantInput | ScenarioUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScenarioCreateManyTenantInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutTenantInput | ScenarioUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutTenantInput | ScenarioUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScenarioAnalyticsCreateWithoutTenantInput, ScenarioAnalyticsUncheckedCreateWithoutTenantInput> | ScenarioAnalyticsCreateWithoutTenantInput[] | ScenarioAnalyticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScenarioAnalyticsCreateOrConnectWithoutTenantInput | ScenarioAnalyticsCreateOrConnectWithoutTenantInput[]
    upsert?: ScenarioAnalyticsUpsertWithWhereUniqueWithoutTenantInput | ScenarioAnalyticsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScenarioAnalyticsCreateManyTenantInputEnvelope
    set?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    disconnect?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    delete?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    connect?: ScenarioAnalyticsWhereUniqueInput | ScenarioAnalyticsWhereUniqueInput[]
    update?: ScenarioAnalyticsUpdateWithWhereUniqueWithoutTenantInput | ScenarioAnalyticsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScenarioAnalyticsUpdateManyWithWhereWithoutTenantInput | ScenarioAnalyticsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScenarioAnalyticsScalarWhereInput | ScenarioAnalyticsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDashboardLayoutsInput = {
    create?: XOR<UserCreateWithoutDashboardLayoutsInput, UserUncheckedCreateWithoutDashboardLayoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDashboardLayoutsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutDashboardLayoutsInput = {
    create?: XOR<TenantCreateWithoutDashboardLayoutsInput, TenantUncheckedCreateWithoutDashboardLayoutsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDashboardLayoutsInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type UserUpdateOneWithoutDashboardLayoutsNestedInput = {
    create?: XOR<UserCreateWithoutDashboardLayoutsInput, UserUncheckedCreateWithoutDashboardLayoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDashboardLayoutsInput
    upsert?: UserUpsertWithoutDashboardLayoutsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDashboardLayoutsInput, UserUpdateWithoutDashboardLayoutsInput>, UserUncheckedUpdateWithoutDashboardLayoutsInput>
  }

  export type TenantUpdateOneRequiredWithoutDashboardLayoutsNestedInput = {
    create?: XOR<TenantCreateWithoutDashboardLayoutsInput, TenantUncheckedCreateWithoutDashboardLayoutsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDashboardLayoutsInput
    upsert?: TenantUpsertWithoutDashboardLayoutsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDashboardLayoutsInput, TenantUpdateWithoutDashboardLayoutsInput>, TenantUncheckedUpdateWithoutDashboardLayoutsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantCreateNestedOneWithoutAnalyticsEventsInput = {
    create?: XOR<TenantCreateWithoutAnalyticsEventsInput, TenantUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAnalyticsEventsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAnalyticsEventsNestedInput = {
    create?: XOR<TenantCreateWithoutAnalyticsEventsInput, TenantUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAnalyticsEventsInput
    upsert?: TenantUpsertWithoutAnalyticsEventsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAnalyticsEventsInput, TenantUpdateWithoutAnalyticsEventsInput>, TenantUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type TenantCreateNestedOneWithoutAutomationRulesInput = {
    create?: XOR<TenantCreateWithoutAutomationRulesInput, TenantUncheckedCreateWithoutAutomationRulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationRulesInput
    connect?: TenantWhereUniqueInput
  }

  export type AutomationExecutionCreateNestedManyWithoutRuleInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type AutomationExecutionUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
  }

  export type EnumAutomationTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.AutomationTriggerType
  }

  export type EnumAutomationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutomationStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutAutomationRulesNestedInput = {
    create?: XOR<TenantCreateWithoutAutomationRulesInput, TenantUncheckedCreateWithoutAutomationRulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationRulesInput
    upsert?: TenantUpsertWithoutAutomationRulesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAutomationRulesInput, TenantUpdateWithoutAutomationRulesInput>, TenantUncheckedUpdateWithoutAutomationRulesInput>
  }

  export type AutomationExecutionUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput | AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput | AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutRuleInput | AutomationExecutionUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput> | AutomationExecutionCreateWithoutRuleInput[] | AutomationExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AutomationExecutionCreateOrConnectWithoutRuleInput | AutomationExecutionCreateOrConnectWithoutRuleInput[]
    upsert?: AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput | AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AutomationExecutionCreateManyRuleInputEnvelope
    set?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    disconnect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    delete?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    connect?: AutomationExecutionWhereUniqueInput | AutomationExecutionWhereUniqueInput[]
    update?: AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput | AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AutomationExecutionUpdateManyWithWhereWithoutRuleInput | AutomationExecutionUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
  }

  export type AutomationRuleCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutExecutionsInput
    connect?: AutomationRuleWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutAutomationExecutionsInput = {
    create?: XOR<TenantCreateWithoutAutomationExecutionsInput, TenantUncheckedCreateWithoutAutomationExecutionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationExecutionsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumAutomationExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutomationExecutionStatus
  }

  export type AutomationRuleUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutExecutionsInput
    upsert?: AutomationRuleUpsertWithoutExecutionsInput
    connect?: AutomationRuleWhereUniqueInput
    update?: XOR<XOR<AutomationRuleUpdateToOneWithWhereWithoutExecutionsInput, AutomationRuleUpdateWithoutExecutionsInput>, AutomationRuleUncheckedUpdateWithoutExecutionsInput>
  }

  export type TenantUpdateOneRequiredWithoutAutomationExecutionsNestedInput = {
    create?: XOR<TenantCreateWithoutAutomationExecutionsInput, TenantUncheckedCreateWithoutAutomationExecutionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationExecutionsInput
    upsert?: TenantUpsertWithoutAutomationExecutionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAutomationExecutionsInput, TenantUpdateWithoutAutomationExecutionsInput>, TenantUncheckedUpdateWithoutAutomationExecutionsInput>
  }

  export type TenantCreateNestedOneWithoutSmartInsightsInput = {
    create?: XOR<TenantCreateWithoutSmartInsightsInput, TenantUncheckedCreateWithoutSmartInsightsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmartInsightsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumInsightTypeFieldUpdateOperationsInput = {
    set?: $Enums.InsightType
  }

  export type EnumInsightSeverityFieldUpdateOperationsInput = {
    set?: $Enums.InsightSeverity
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutSmartInsightsNestedInput = {
    create?: XOR<TenantCreateWithoutSmartInsightsInput, TenantUncheckedCreateWithoutSmartInsightsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSmartInsightsInput
    upsert?: TenantUpsertWithoutSmartInsightsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSmartInsightsInput, TenantUpdateWithoutSmartInsightsInput>, TenantUncheckedUpdateWithoutSmartInsightsInput>
  }

  export type TenantCreateNestedOneWithoutAutomationMetricsInput = {
    create?: XOR<TenantCreateWithoutAutomationMetricsInput, TenantUncheckedCreateWithoutAutomationMetricsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationMetricsInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutAutomationMetricsNestedInput = {
    create?: XOR<TenantCreateWithoutAutomationMetricsInput, TenantUncheckedCreateWithoutAutomationMetricsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAutomationMetricsInput
    upsert?: TenantUpsertWithoutAutomationMetricsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAutomationMetricsInput, TenantUpdateWithoutAutomationMetricsInput>, TenantUncheckedUpdateWithoutAutomationMetricsInput>
  }

  export type TenantCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<TenantCreateWithoutPaymentMethodsInput, TenantUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentMethodsInput
    connect?: TenantWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumPaymentMethodTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethodType
  }

  export type TenantUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentMethodsInput, TenantUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentMethodsInput
    upsert?: TenantUpsertWithoutPaymentMethodsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentMethodsInput, TenantUpdateWithoutPaymentMethodsInput>, TenantUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type PaymentUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type PaymentReconciliationCreateNestedOneWithoutPaymentInput = {
    create?: XOR<PaymentReconciliationCreateWithoutPaymentInput, PaymentReconciliationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutPaymentInput
    connect?: PaymentReconciliationWhereUniqueInput
  }

  export type PaymentExplainabilityCreateNestedOneWithoutPaymentInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutPaymentInput, PaymentExplainabilityUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutPaymentInput
    connect?: PaymentExplainabilityWhereUniqueInput
  }

  export type PaymentReconciliationUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<PaymentReconciliationCreateWithoutPaymentInput, PaymentReconciliationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutPaymentInput
    connect?: PaymentReconciliationWhereUniqueInput
  }

  export type PaymentExplainabilityUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutPaymentInput, PaymentExplainabilityUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutPaymentInput
    connect?: PaymentExplainabilityWhereUniqueInput
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentMethodUpsertWithoutPaymentsInput
    disconnect?: PaymentMethodWhereInput | boolean
    delete?: PaymentMethodWhereInput | boolean
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput, PaymentMethodUpdateWithoutPaymentsInput>, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentReconciliationUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<PaymentReconciliationCreateWithoutPaymentInput, PaymentReconciliationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutPaymentInput
    upsert?: PaymentReconciliationUpsertWithoutPaymentInput
    disconnect?: PaymentReconciliationWhereInput | boolean
    delete?: PaymentReconciliationWhereInput | boolean
    connect?: PaymentReconciliationWhereUniqueInput
    update?: XOR<XOR<PaymentReconciliationUpdateToOneWithWhereWithoutPaymentInput, PaymentReconciliationUpdateWithoutPaymentInput>, PaymentReconciliationUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentExplainabilityUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutPaymentInput, PaymentExplainabilityUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutPaymentInput
    upsert?: PaymentExplainabilityUpsertWithoutPaymentInput
    disconnect?: PaymentExplainabilityWhereInput | boolean
    delete?: PaymentExplainabilityWhereInput | boolean
    connect?: PaymentExplainabilityWhereUniqueInput
    update?: XOR<XOR<PaymentExplainabilityUpdateToOneWithWhereWithoutPaymentInput, PaymentExplainabilityUpdateWithoutPaymentInput>, PaymentExplainabilityUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentReconciliationUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<PaymentReconciliationCreateWithoutPaymentInput, PaymentReconciliationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentReconciliationCreateOrConnectWithoutPaymentInput
    upsert?: PaymentReconciliationUpsertWithoutPaymentInput
    disconnect?: PaymentReconciliationWhereInput | boolean
    delete?: PaymentReconciliationWhereInput | boolean
    connect?: PaymentReconciliationWhereUniqueInput
    update?: XOR<XOR<PaymentReconciliationUpdateToOneWithWhereWithoutPaymentInput, PaymentReconciliationUpdateWithoutPaymentInput>, PaymentReconciliationUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentExplainabilityUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<PaymentExplainabilityCreateWithoutPaymentInput, PaymentExplainabilityUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentExplainabilityCreateOrConnectWithoutPaymentInput
    upsert?: PaymentExplainabilityUpsertWithoutPaymentInput
    disconnect?: PaymentExplainabilityWhereInput | boolean
    delete?: PaymentExplainabilityWhereInput | boolean
    connect?: PaymentExplainabilityWhereUniqueInput
    update?: XOR<XOR<PaymentExplainabilityUpdateToOneWithWhereWithoutPaymentInput, PaymentExplainabilityUpdateWithoutPaymentInput>, PaymentExplainabilityUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentCreateNestedOneWithoutReconciliationInput = {
    create?: XOR<PaymentCreateWithoutReconciliationInput, PaymentUncheckedCreateWithoutReconciliationInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutReconciliationInput
    connect?: PaymentWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutPaymentReconciliationsInput = {
    create?: XOR<TenantCreateWithoutPaymentReconciliationsInput, TenantUncheckedCreateWithoutPaymentReconciliationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentReconciliationsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumReconciliationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReconciliationStatus
  }

  export type PaymentUpdateOneRequiredWithoutReconciliationNestedInput = {
    create?: XOR<PaymentCreateWithoutReconciliationInput, PaymentUncheckedCreateWithoutReconciliationInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutReconciliationInput
    upsert?: PaymentUpsertWithoutReconciliationInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutReconciliationInput, PaymentUpdateWithoutReconciliationInput>, PaymentUncheckedUpdateWithoutReconciliationInput>
  }

  export type TenantUpdateOneRequiredWithoutPaymentReconciliationsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentReconciliationsInput, TenantUncheckedCreateWithoutPaymentReconciliationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentReconciliationsInput
    upsert?: TenantUpsertWithoutPaymentReconciliationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentReconciliationsInput, TenantUpdateWithoutPaymentReconciliationsInput>, TenantUncheckedUpdateWithoutPaymentReconciliationsInput>
  }

  export type PaymentCreateNestedOneWithoutExplainabilityInput = {
    create?: XOR<PaymentCreateWithoutExplainabilityInput, PaymentUncheckedCreateWithoutExplainabilityInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutExplainabilityInput
    connect?: PaymentWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutPaymentExplainabilityInput = {
    create?: XOR<TenantCreateWithoutPaymentExplainabilityInput, TenantUncheckedCreateWithoutPaymentExplainabilityInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentExplainabilityInput
    connect?: TenantWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutExplainabilityNestedInput = {
    create?: XOR<PaymentCreateWithoutExplainabilityInput, PaymentUncheckedCreateWithoutExplainabilityInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutExplainabilityInput
    upsert?: PaymentUpsertWithoutExplainabilityInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutExplainabilityInput, PaymentUpdateWithoutExplainabilityInput>, PaymentUncheckedUpdateWithoutExplainabilityInput>
  }

  export type TenantUpdateOneRequiredWithoutPaymentExplainabilityNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentExplainabilityInput, TenantUncheckedCreateWithoutPaymentExplainabilityInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentExplainabilityInput
    upsert?: TenantUpsertWithoutPaymentExplainabilityInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentExplainabilityInput, TenantUpdateWithoutPaymentExplainabilityInput>, TenantUncheckedUpdateWithoutPaymentExplainabilityInput>
  }

  export type TenantCreateNestedOneWithoutCashControlRulesInput = {
    create?: XOR<TenantCreateWithoutCashControlRulesInput, TenantUncheckedCreateWithoutCashControlRulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashControlRulesInput
    connect?: TenantWhereUniqueInput
  }

  export type CashControlExecutionCreateNestedManyWithoutRuleInput = {
    create?: XOR<CashControlExecutionCreateWithoutRuleInput, CashControlExecutionUncheckedCreateWithoutRuleInput> | CashControlExecutionCreateWithoutRuleInput[] | CashControlExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutRuleInput | CashControlExecutionCreateOrConnectWithoutRuleInput[]
    createMany?: CashControlExecutionCreateManyRuleInputEnvelope
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
  }

  export type CashControlExecutionUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<CashControlExecutionCreateWithoutRuleInput, CashControlExecutionUncheckedCreateWithoutRuleInput> | CashControlExecutionCreateWithoutRuleInput[] | CashControlExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutRuleInput | CashControlExecutionCreateOrConnectWithoutRuleInput[]
    createMany?: CashControlExecutionCreateManyRuleInputEnvelope
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
  }

  export type EnumCashControlRuleTypeFieldUpdateOperationsInput = {
    set?: $Enums.CashControlRuleType
  }

  export type TenantUpdateOneRequiredWithoutCashControlRulesNestedInput = {
    create?: XOR<TenantCreateWithoutCashControlRulesInput, TenantUncheckedCreateWithoutCashControlRulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashControlRulesInput
    upsert?: TenantUpsertWithoutCashControlRulesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCashControlRulesInput, TenantUpdateWithoutCashControlRulesInput>, TenantUncheckedUpdateWithoutCashControlRulesInput>
  }

  export type CashControlExecutionUpdateManyWithoutRuleNestedInput = {
    create?: XOR<CashControlExecutionCreateWithoutRuleInput, CashControlExecutionUncheckedCreateWithoutRuleInput> | CashControlExecutionCreateWithoutRuleInput[] | CashControlExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutRuleInput | CashControlExecutionCreateOrConnectWithoutRuleInput[]
    upsert?: CashControlExecutionUpsertWithWhereUniqueWithoutRuleInput | CashControlExecutionUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: CashControlExecutionCreateManyRuleInputEnvelope
    set?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    disconnect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    delete?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    update?: CashControlExecutionUpdateWithWhereUniqueWithoutRuleInput | CashControlExecutionUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: CashControlExecutionUpdateManyWithWhereWithoutRuleInput | CashControlExecutionUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: CashControlExecutionScalarWhereInput | CashControlExecutionScalarWhereInput[]
  }

  export type CashControlExecutionUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<CashControlExecutionCreateWithoutRuleInput, CashControlExecutionUncheckedCreateWithoutRuleInput> | CashControlExecutionCreateWithoutRuleInput[] | CashControlExecutionUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: CashControlExecutionCreateOrConnectWithoutRuleInput | CashControlExecutionCreateOrConnectWithoutRuleInput[]
    upsert?: CashControlExecutionUpsertWithWhereUniqueWithoutRuleInput | CashControlExecutionUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: CashControlExecutionCreateManyRuleInputEnvelope
    set?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    disconnect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    delete?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    connect?: CashControlExecutionWhereUniqueInput | CashControlExecutionWhereUniqueInput[]
    update?: CashControlExecutionUpdateWithWhereUniqueWithoutRuleInput | CashControlExecutionUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: CashControlExecutionUpdateManyWithWhereWithoutRuleInput | CashControlExecutionUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: CashControlExecutionScalarWhereInput | CashControlExecutionScalarWhereInput[]
  }

  export type CashControlRuleCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<CashControlRuleCreateWithoutExecutionsInput, CashControlRuleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: CashControlRuleCreateOrConnectWithoutExecutionsInput
    connect?: CashControlRuleWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCashControlExecutionsInput = {
    create?: XOR<TenantCreateWithoutCashControlExecutionsInput, TenantUncheckedCreateWithoutCashControlExecutionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashControlExecutionsInput
    connect?: TenantWhereUniqueInput
  }

  export type CashControlRuleUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<CashControlRuleCreateWithoutExecutionsInput, CashControlRuleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: CashControlRuleCreateOrConnectWithoutExecutionsInput
    upsert?: CashControlRuleUpsertWithoutExecutionsInput
    connect?: CashControlRuleWhereUniqueInput
    update?: XOR<XOR<CashControlRuleUpdateToOneWithWhereWithoutExecutionsInput, CashControlRuleUpdateWithoutExecutionsInput>, CashControlRuleUncheckedUpdateWithoutExecutionsInput>
  }

  export type TenantUpdateOneRequiredWithoutCashControlExecutionsNestedInput = {
    create?: XOR<TenantCreateWithoutCashControlExecutionsInput, TenantUncheckedCreateWithoutCashControlExecutionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashControlExecutionsInput
    upsert?: TenantUpsertWithoutCashControlExecutionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCashControlExecutionsInput, TenantUpdateWithoutCashControlExecutionsInput>, TenantUncheckedUpdateWithoutCashControlExecutionsInput>
  }

  export type TenantCreateNestedOneWithoutPaymentAnalyticsInput = {
    create?: XOR<TenantCreateWithoutPaymentAnalyticsInput, TenantUncheckedCreateWithoutPaymentAnalyticsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentAnalyticsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPaymentAnalyticsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentAnalyticsInput, TenantUncheckedCreateWithoutPaymentAnalyticsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentAnalyticsInput
    upsert?: TenantUpsertWithoutPaymentAnalyticsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentAnalyticsInput, TenantUpdateWithoutPaymentAnalyticsInput>, TenantUncheckedUpdateWithoutPaymentAnalyticsInput>
  }

  export type TenantCreateNestedOneWithoutFinancialForecastsInput = {
    create?: XOR<TenantCreateWithoutFinancialForecastsInput, TenantUncheckedCreateWithoutFinancialForecastsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFinancialForecastsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumForecastTypeFieldUpdateOperationsInput = {
    set?: $Enums.ForecastType
  }

  export type TenantUpdateOneRequiredWithoutFinancialForecastsNestedInput = {
    create?: XOR<TenantCreateWithoutFinancialForecastsInput, TenantUncheckedCreateWithoutFinancialForecastsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFinancialForecastsInput
    upsert?: TenantUpsertWithoutFinancialForecastsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutFinancialForecastsInput, TenantUpdateWithoutFinancialForecastsInput>, TenantUncheckedUpdateWithoutFinancialForecastsInput>
  }

  export type TenantCreateNestedOneWithoutScenariosInput = {
    create?: XOR<TenantCreateWithoutScenariosInput, TenantUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScenariosInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumScenarioTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScenarioType
  }

  export type NullableEnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel | null
  }

  export type TenantUpdateOneRequiredWithoutScenariosNestedInput = {
    create?: XOR<TenantCreateWithoutScenariosInput, TenantUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScenariosInput
    upsert?: TenantUpsertWithoutScenariosInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutScenariosInput, TenantUpdateWithoutScenariosInput>, TenantUncheckedUpdateWithoutScenariosInput>
  }

  export type TenantCreateNestedOneWithoutScenarioAnalyticsInput = {
    create?: XOR<TenantCreateWithoutScenarioAnalyticsInput, TenantUncheckedCreateWithoutScenarioAnalyticsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScenarioAnalyticsInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TenantUpdateOneRequiredWithoutScenarioAnalyticsNestedInput = {
    create?: XOR<TenantCreateWithoutScenarioAnalyticsInput, TenantUncheckedCreateWithoutScenarioAnalyticsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScenarioAnalyticsInput
    upsert?: TenantUpsertWithoutScenarioAnalyticsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutScenarioAnalyticsInput, TenantUpdateWithoutScenarioAnalyticsInput>, TenantUncheckedUpdateWithoutScenarioAnalyticsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedEnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionPlan[] | ListEnumSubscriptionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumAutomationTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel> | $Enums.AutomationTriggerType
  }

  export type NestedEnumAutomationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusFilter<$PrismaModel> | $Enums.AutomationStatus
  }

  export type NestedEnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationTriggerType | EnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationTriggerType[] | ListEnumAutomationTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.AutomationTriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumAutomationTriggerTypeFilter<$PrismaModel>
  }

  export type NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationStatus | EnumAutomationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationStatus[] | ListEnumAutomationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAutomationExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationExecutionStatus | EnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationExecutionStatusFilter<$PrismaModel> | $Enums.AutomationExecutionStatus
  }

  export type NestedEnumAutomationExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutomationExecutionStatus | EnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutomationExecutionStatus[] | ListEnumAutomationExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutomationExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutomationExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutomationExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumAutomationExecutionStatusFilter<$PrismaModel>
  }

  export type NestedEnumInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeFilter<$PrismaModel> | $Enums.InsightType
  }

  export type NestedEnumInsightSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightSeverity | EnumInsightSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightSeverityFilter<$PrismaModel> | $Enums.InsightSeverity
  }

  export type NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightTypeFilter<$PrismaModel>
  }

  export type NestedEnumInsightSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightSeverity | EnumInsightSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightSeverity[] | ListEnumInsightSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightSeverityWithAggregatesFilter<$PrismaModel> | $Enums.InsightSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightSeverityFilter<$PrismaModel>
    _max?: NestedEnumInsightSeverityFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeFilter<$PrismaModel> | $Enums.PaymentMethodType
  }

  export type NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodType | EnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodType[] | ListEnumPaymentMethodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumReconciliationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReconciliationStatus | EnumReconciliationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReconciliationStatusFilter<$PrismaModel> | $Enums.ReconciliationStatus
  }

  export type NestedEnumReconciliationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReconciliationStatus | EnumReconciliationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReconciliationStatus[] | ListEnumReconciliationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReconciliationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReconciliationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReconciliationStatusFilter<$PrismaModel>
    _max?: NestedEnumReconciliationStatusFilter<$PrismaModel>
  }

  export type NestedEnumCashControlRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashControlRuleType | EnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashControlRuleTypeFilter<$PrismaModel> | $Enums.CashControlRuleType
  }

  export type NestedEnumCashControlRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashControlRuleType | EnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashControlRuleType[] | ListEnumCashControlRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashControlRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashControlRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashControlRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumCashControlRuleTypeFilter<$PrismaModel>
  }

  export type NestedEnumForecastTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ForecastType | EnumForecastTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForecastTypeFilter<$PrismaModel> | $Enums.ForecastType
  }

  export type NestedEnumForecastTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForecastType | EnumForecastTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForecastType[] | ListEnumForecastTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForecastTypeWithAggregatesFilter<$PrismaModel> | $Enums.ForecastType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForecastTypeFilter<$PrismaModel>
    _max?: NestedEnumForecastTypeFilter<$PrismaModel>
  }

  export type NestedEnumScenarioTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScenarioType | EnumScenarioTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScenarioTypeFilter<$PrismaModel> | $Enums.ScenarioType
  }

  export type NestedEnumRiskLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskLevelNullableFilter<$PrismaModel> | $Enums.RiskLevel | null
  }

  export type NestedEnumScenarioTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScenarioType | EnumScenarioTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScenarioType[] | ListEnumScenarioTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScenarioTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScenarioType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScenarioTypeFilter<$PrismaModel>
    _max?: NestedEnumScenarioTypeFilter<$PrismaModel>
  }

  export type NestedEnumRiskLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRiskLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DashboardLayoutCreateWithoutUserInput = {
    id?: string
    role?: $Enums.Role | null
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDashboardLayoutsInput
  }

  export type DashboardLayoutUncheckedCreateWithoutUserInput = {
    id?: string
    role?: $Enums.Role | null
    tenantId: string
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardLayoutCreateOrConnectWithoutUserInput = {
    where: DashboardLayoutWhereUniqueInput
    create: XOR<DashboardLayoutCreateWithoutUserInput, DashboardLayoutUncheckedCreateWithoutUserInput>
  }

  export type DashboardLayoutCreateManyUserInputEnvelope = {
    data: DashboardLayoutCreateManyUserInput | DashboardLayoutCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: IntNullableFilter<"Account"> | number | null
    tokenType?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    sessionState?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type DashboardLayoutUpsertWithWhereUniqueWithoutUserInput = {
    where: DashboardLayoutWhereUniqueInput
    update: XOR<DashboardLayoutUpdateWithoutUserInput, DashboardLayoutUncheckedUpdateWithoutUserInput>
    create: XOR<DashboardLayoutCreateWithoutUserInput, DashboardLayoutUncheckedCreateWithoutUserInput>
  }

  export type DashboardLayoutUpdateWithWhereUniqueWithoutUserInput = {
    where: DashboardLayoutWhereUniqueInput
    data: XOR<DashboardLayoutUpdateWithoutUserInput, DashboardLayoutUncheckedUpdateWithoutUserInput>
  }

  export type DashboardLayoutUpdateManyWithWhereWithoutUserInput = {
    where: DashboardLayoutScalarWhereInput
    data: XOR<DashboardLayoutUpdateManyMutationInput, DashboardLayoutUncheckedUpdateManyWithoutUserInput>
  }

  export type DashboardLayoutScalarWhereInput = {
    AND?: DashboardLayoutScalarWhereInput | DashboardLayoutScalarWhereInput[]
    OR?: DashboardLayoutScalarWhereInput[]
    NOT?: DashboardLayoutScalarWhereInput | DashboardLayoutScalarWhereInput[]
    id?: StringFilter<"DashboardLayout"> | string
    userId?: StringNullableFilter<"DashboardLayout"> | string | null
    role?: EnumRoleNullableFilter<"DashboardLayout"> | $Enums.Role | null
    tenantId?: StringFilter<"DashboardLayout"> | string
    name?: StringFilter<"DashboardLayout"> | string
    isDefault?: BoolFilter<"DashboardLayout"> | boolean
    layout?: JsonFilter<"DashboardLayout">
    createdAt?: DateTimeFilter<"DashboardLayout"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardLayout"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    allowed?: BoolFilter<"AuditLog"> | boolean
    reason?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    tenantId: string
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    tenantId: string
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DashboardLayoutCreateWithoutTenantInput = {
    id?: string
    role?: $Enums.Role | null
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutDashboardLayoutsInput
  }

  export type DashboardLayoutUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    role?: $Enums.Role | null
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardLayoutCreateOrConnectWithoutTenantInput = {
    where: DashboardLayoutWhereUniqueInput
    create: XOR<DashboardLayoutCreateWithoutTenantInput, DashboardLayoutUncheckedCreateWithoutTenantInput>
  }

  export type DashboardLayoutCreateManyTenantInputEnvelope = {
    data: DashboardLayoutCreateManyTenantInput | DashboardLayoutCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsEventCreateWithoutTenantInput = {
    id?: string
    eventId: string
    eventType: string
    featureFlag: string
    featureName: string
    userId: string
    userRole: $Enums.Role
    sessionId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp: Date | string
    serverTimestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AnalyticsEventUncheckedCreateWithoutTenantInput = {
    id?: string
    eventId: string
    eventType: string
    featureFlag: string
    featureName: string
    userId: string
    userRole: $Enums.Role
    sessionId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp: Date | string
    serverTimestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AnalyticsEventCreateOrConnectWithoutTenantInput = {
    where: AnalyticsEventWhereUniqueInput
    create: XOR<AnalyticsEventCreateWithoutTenantInput, AnalyticsEventUncheckedCreateWithoutTenantInput>
  }

  export type AnalyticsEventCreateManyTenantInputEnvelope = {
    data: AnalyticsEventCreateManyTenantInput | AnalyticsEventCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AutomationRuleCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: AutomationExecutionUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AutomationRuleCreateOrConnectWithoutTenantInput = {
    where: AutomationRuleWhereUniqueInput
    create: XOR<AutomationRuleCreateWithoutTenantInput, AutomationRuleUncheckedCreateWithoutTenantInput>
  }

  export type AutomationRuleCreateManyTenantInputEnvelope = {
    data: AutomationRuleCreateManyTenantInput | AutomationRuleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AutomationExecutionCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    rule: AutomationRuleCreateNestedOneWithoutExecutionsInput
  }

  export type AutomationExecutionUncheckedCreateWithoutTenantInput = {
    id?: string
    ruleId: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AutomationExecutionCreateOrConnectWithoutTenantInput = {
    where: AutomationExecutionWhereUniqueInput
    create: XOR<AutomationExecutionCreateWithoutTenantInput, AutomationExecutionUncheckedCreateWithoutTenantInput>
  }

  export type AutomationExecutionCreateManyTenantInputEnvelope = {
    data: AutomationExecutionCreateManyTenantInput | AutomationExecutionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SmartInsightCreateWithoutTenantInput = {
    id?: string
    insightType: $Enums.InsightType
    severity?: $Enums.InsightSeverity
    title: string
    description: string
    explanation: string
    confidence?: number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    dismissReason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SmartInsightUncheckedCreateWithoutTenantInput = {
    id?: string
    insightType: $Enums.InsightType
    severity?: $Enums.InsightSeverity
    title: string
    description: string
    explanation: string
    confidence?: number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    dismissReason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SmartInsightCreateOrConnectWithoutTenantInput = {
    where: SmartInsightWhereUniqueInput
    create: XOR<SmartInsightCreateWithoutTenantInput, SmartInsightUncheckedCreateWithoutTenantInput>
  }

  export type SmartInsightCreateManyTenantInputEnvelope = {
    data: SmartInsightCreateManyTenantInput | SmartInsightCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AutomationUsageMetricCreateWithoutTenantInput = {
    id?: string
    ruleId: string
    executionId: string
    actionType: string
    success: boolean
    executionTime: number
    costImpact?: number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AutomationUsageMetricUncheckedCreateWithoutTenantInput = {
    id?: string
    ruleId: string
    executionId: string
    actionType: string
    success: boolean
    executionTime: number
    costImpact?: number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AutomationUsageMetricCreateOrConnectWithoutTenantInput = {
    where: AutomationUsageMetricWhereUniqueInput
    create: XOR<AutomationUsageMetricCreateWithoutTenantInput, AutomationUsageMetricUncheckedCreateWithoutTenantInput>
  }

  export type AutomationUsageMetricCreateManyTenantInputEnvelope = {
    data: AutomationUsageMetricCreateManyTenantInput | AutomationUsageMetricCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentMethodCreateWithoutTenantInput = {
    id?: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateWithoutTenantInput = {
    id?: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodCreateOrConnectWithoutTenantInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutTenantInput, PaymentMethodUncheckedCreateWithoutTenantInput>
  }

  export type PaymentMethodCreateManyTenantInputEnvelope = {
    data: PaymentMethodCreateManyTenantInput | PaymentMethodCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTenantInput = {
    id?: string
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethod?: PaymentMethodCreateNestedOneWithoutPaymentsInput
    reconciliation?: PaymentReconciliationCreateNestedOneWithoutPaymentInput
    explainability?: PaymentExplainabilityCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    paymentMethodId?: string | null
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reconciliation?: PaymentReconciliationUncheckedCreateNestedOneWithoutPaymentInput
    explainability?: PaymentExplainabilityUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentCreateManyTenantInputEnvelope = {
    data: PaymentCreateManyTenantInput | PaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentReconciliationCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutReconciliationInput
  }

  export type PaymentReconciliationUncheckedCreateWithoutTenantInput = {
    id?: string
    paymentId: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReconciliationCreateOrConnectWithoutTenantInput = {
    where: PaymentReconciliationWhereUniqueInput
    create: XOR<PaymentReconciliationCreateWithoutTenantInput, PaymentReconciliationUncheckedCreateWithoutTenantInput>
  }

  export type PaymentReconciliationCreateManyTenantInputEnvelope = {
    data: PaymentReconciliationCreateManyTenantInput | PaymentReconciliationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentExplainabilityCreateWithoutTenantInput = {
    id?: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutExplainabilityInput
  }

  export type PaymentExplainabilityUncheckedCreateWithoutTenantInput = {
    id?: string
    paymentId: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
  }

  export type PaymentExplainabilityCreateOrConnectWithoutTenantInput = {
    where: PaymentExplainabilityWhereUniqueInput
    create: XOR<PaymentExplainabilityCreateWithoutTenantInput, PaymentExplainabilityUncheckedCreateWithoutTenantInput>
  }

  export type PaymentExplainabilityCreateManyTenantInputEnvelope = {
    data: PaymentExplainabilityCreateManyTenantInput | PaymentExplainabilityCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CashControlRuleCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: CashControlExecutionCreateNestedManyWithoutRuleInput
  }

  export type CashControlRuleUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: CashControlExecutionUncheckedCreateNestedManyWithoutRuleInput
  }

  export type CashControlRuleCreateOrConnectWithoutTenantInput = {
    where: CashControlRuleWhereUniqueInput
    create: XOR<CashControlRuleCreateWithoutTenantInput, CashControlRuleUncheckedCreateWithoutTenantInput>
  }

  export type CashControlRuleCreateManyTenantInputEnvelope = {
    data: CashControlRuleCreateManyTenantInput | CashControlRuleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CashControlExecutionCreateWithoutTenantInput = {
    id?: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
    rule: CashControlRuleCreateNestedOneWithoutExecutionsInput
  }

  export type CashControlExecutionUncheckedCreateWithoutTenantInput = {
    id?: string
    ruleId: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
  }

  export type CashControlExecutionCreateOrConnectWithoutTenantInput = {
    where: CashControlExecutionWhereUniqueInput
    create: XOR<CashControlExecutionCreateWithoutTenantInput, CashControlExecutionUncheckedCreateWithoutTenantInput>
  }

  export type CashControlExecutionCreateManyTenantInputEnvelope = {
    data: CashControlExecutionCreateManyTenantInput | CashControlExecutionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAnalyticsCreateWithoutTenantInput = {
    id?: string
    paymentId?: string | null
    eventType: string
    amount?: number | null
    processingFee?: number | null
    isAutomated: boolean
    automationRuleId?: string | null
    timeToCash?: number | null
    retryCount?: number | null
    revenueImpact?: number | null
    timestamp?: Date | string
  }

  export type PaymentAnalyticsUncheckedCreateWithoutTenantInput = {
    id?: string
    paymentId?: string | null
    eventType: string
    amount?: number | null
    processingFee?: number | null
    isAutomated: boolean
    automationRuleId?: string | null
    timeToCash?: number | null
    retryCount?: number | null
    revenueImpact?: number | null
    timestamp?: Date | string
  }

  export type PaymentAnalyticsCreateOrConnectWithoutTenantInput = {
    where: PaymentAnalyticsWhereUniqueInput
    create: XOR<PaymentAnalyticsCreateWithoutTenantInput, PaymentAnalyticsUncheckedCreateWithoutTenantInput>
  }

  export type PaymentAnalyticsCreateManyTenantInputEnvelope = {
    data: PaymentAnalyticsCreateManyTenantInput | PaymentAnalyticsCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type FinancialForecastCreateWithoutTenantInput = {
    id?: string
    forecastType: $Enums.ForecastType
    value: number
    unit: string
    confidenceScore: number
    forecastDate: Date | string
    forecastHorizon: number
    formula: string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type FinancialForecastUncheckedCreateWithoutTenantInput = {
    id?: string
    forecastType: $Enums.ForecastType
    value: number
    unit: string
    confidenceScore: number
    forecastDate: Date | string
    forecastHorizon: number
    formula: string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type FinancialForecastCreateOrConnectWithoutTenantInput = {
    where: FinancialForecastWhereUniqueInput
    create: XOR<FinancialForecastCreateWithoutTenantInput, FinancialForecastUncheckedCreateWithoutTenantInput>
  }

  export type FinancialForecastCreateManyTenantInputEnvelope = {
    data: FinancialForecastCreateManyTenantInput | FinancialForecastCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ScenarioCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    scenarioType: $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: number | null
    projectedRunway?: number | null
    runwayChange?: number | null
    riskLevel?: $Enums.RiskLevel | null
    riskScore?: number | null
    successProbability?: number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy: string
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    scenarioType: $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: number | null
    projectedRunway?: number | null
    runwayChange?: number | null
    riskLevel?: $Enums.RiskLevel | null
    riskScore?: number | null
    successProbability?: number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy: string
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioCreateOrConnectWithoutTenantInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutTenantInput, ScenarioUncheckedCreateWithoutTenantInput>
  }

  export type ScenarioCreateManyTenantInputEnvelope = {
    data: ScenarioCreateManyTenantInput | ScenarioCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ScenarioAnalyticsCreateWithoutTenantInput = {
    id?: string
    scenarioId?: string | null
    eventType: string
    scenarioType?: string | null
    decisionMade?: boolean | null
    decisionOutcome?: string | null
    riskAvoided?: boolean | null
    upgradeTriggered?: boolean | null
    planBefore?: string | null
    planAfter?: string | null
    timeToDecision?: number | null
    timestamp?: Date | string
  }

  export type ScenarioAnalyticsUncheckedCreateWithoutTenantInput = {
    id?: string
    scenarioId?: string | null
    eventType: string
    scenarioType?: string | null
    decisionMade?: boolean | null
    decisionOutcome?: string | null
    riskAvoided?: boolean | null
    upgradeTriggered?: boolean | null
    planBefore?: string | null
    planAfter?: string | null
    timeToDecision?: number | null
    timestamp?: Date | string
  }

  export type ScenarioAnalyticsCreateOrConnectWithoutTenantInput = {
    where: ScenarioAnalyticsWhereUniqueInput
    create: XOR<ScenarioAnalyticsCreateWithoutTenantInput, ScenarioAnalyticsUncheckedCreateWithoutTenantInput>
  }

  export type ScenarioAnalyticsCreateManyTenantInputEnvelope = {
    data: ScenarioAnalyticsCreateManyTenantInput | ScenarioAnalyticsCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    tenantId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type DashboardLayoutUpsertWithWhereUniqueWithoutTenantInput = {
    where: DashboardLayoutWhereUniqueInput
    update: XOR<DashboardLayoutUpdateWithoutTenantInput, DashboardLayoutUncheckedUpdateWithoutTenantInput>
    create: XOR<DashboardLayoutCreateWithoutTenantInput, DashboardLayoutUncheckedCreateWithoutTenantInput>
  }

  export type DashboardLayoutUpdateWithWhereUniqueWithoutTenantInput = {
    where: DashboardLayoutWhereUniqueInput
    data: XOR<DashboardLayoutUpdateWithoutTenantInput, DashboardLayoutUncheckedUpdateWithoutTenantInput>
  }

  export type DashboardLayoutUpdateManyWithWhereWithoutTenantInput = {
    where: DashboardLayoutScalarWhereInput
    data: XOR<DashboardLayoutUpdateManyMutationInput, DashboardLayoutUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AnalyticsEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: AnalyticsEventWhereUniqueInput
    update: XOR<AnalyticsEventUpdateWithoutTenantInput, AnalyticsEventUncheckedUpdateWithoutTenantInput>
    create: XOR<AnalyticsEventCreateWithoutTenantInput, AnalyticsEventUncheckedCreateWithoutTenantInput>
  }

  export type AnalyticsEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: AnalyticsEventWhereUniqueInput
    data: XOR<AnalyticsEventUpdateWithoutTenantInput, AnalyticsEventUncheckedUpdateWithoutTenantInput>
  }

  export type AnalyticsEventUpdateManyWithWhereWithoutTenantInput = {
    where: AnalyticsEventScalarWhereInput
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type AnalyticsEventScalarWhereInput = {
    AND?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    OR?: AnalyticsEventScalarWhereInput[]
    NOT?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    eventId?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    featureFlag?: StringFilter<"AnalyticsEvent"> | string
    featureName?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringFilter<"AnalyticsEvent"> | string
    userRole?: EnumRoleFilter<"AnalyticsEvent"> | $Enums.Role
    tenantId?: StringFilter<"AnalyticsEvent"> | string
    sessionId?: StringFilter<"AnalyticsEvent"> | string
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    serverTimestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    ipAddress?: StringNullableFilter<"AnalyticsEvent"> | string | null
    userAgent?: StringNullableFilter<"AnalyticsEvent"> | string | null
  }

  export type AutomationRuleUpsertWithWhereUniqueWithoutTenantInput = {
    where: AutomationRuleWhereUniqueInput
    update: XOR<AutomationRuleUpdateWithoutTenantInput, AutomationRuleUncheckedUpdateWithoutTenantInput>
    create: XOR<AutomationRuleCreateWithoutTenantInput, AutomationRuleUncheckedCreateWithoutTenantInput>
  }

  export type AutomationRuleUpdateWithWhereUniqueWithoutTenantInput = {
    where: AutomationRuleWhereUniqueInput
    data: XOR<AutomationRuleUpdateWithoutTenantInput, AutomationRuleUncheckedUpdateWithoutTenantInput>
  }

  export type AutomationRuleUpdateManyWithWhereWithoutTenantInput = {
    where: AutomationRuleScalarWhereInput
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyWithoutTenantInput>
  }

  export type AutomationRuleScalarWhereInput = {
    AND?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
    OR?: AutomationRuleScalarWhereInput[]
    NOT?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
    id?: StringFilter<"AutomationRule"> | string
    tenantId?: StringFilter<"AutomationRule"> | string
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerType?: EnumAutomationTriggerTypeFilter<"AutomationRule"> | $Enums.AutomationTriggerType
    triggerConfig?: JsonFilter<"AutomationRule">
    conditions?: JsonFilter<"AutomationRule">
    actions?: JsonFilter<"AutomationRule">
    status?: EnumAutomationStatusFilter<"AutomationRule"> | $Enums.AutomationStatus
    isTemplate?: BoolFilter<"AutomationRule"> | boolean
    requiresApproval?: BoolFilter<"AutomationRule"> | boolean
    createdBy?: StringFilter<"AutomationRule"> | string
    updatedBy?: StringNullableFilter<"AutomationRule"> | string | null
    lastTriggered?: DateTimeNullableFilter<"AutomationRule"> | Date | string | null
    executionCount?: IntFilter<"AutomationRule"> | number
    successCount?: IntFilter<"AutomationRule"> | number
    failureCount?: IntFilter<"AutomationRule"> | number
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationRule"> | Date | string
  }

  export type AutomationExecutionUpsertWithWhereUniqueWithoutTenantInput = {
    where: AutomationExecutionWhereUniqueInput
    update: XOR<AutomationExecutionUpdateWithoutTenantInput, AutomationExecutionUncheckedUpdateWithoutTenantInput>
    create: XOR<AutomationExecutionCreateWithoutTenantInput, AutomationExecutionUncheckedCreateWithoutTenantInput>
  }

  export type AutomationExecutionUpdateWithWhereUniqueWithoutTenantInput = {
    where: AutomationExecutionWhereUniqueInput
    data: XOR<AutomationExecutionUpdateWithoutTenantInput, AutomationExecutionUncheckedUpdateWithoutTenantInput>
  }

  export type AutomationExecutionUpdateManyWithWhereWithoutTenantInput = {
    where: AutomationExecutionScalarWhereInput
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyWithoutTenantInput>
  }

  export type AutomationExecutionScalarWhereInput = {
    AND?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
    OR?: AutomationExecutionScalarWhereInput[]
    NOT?: AutomationExecutionScalarWhereInput | AutomationExecutionScalarWhereInput[]
    id?: StringFilter<"AutomationExecution"> | string
    ruleId?: StringFilter<"AutomationExecution"> | string
    tenantId?: StringFilter<"AutomationExecution"> | string
    status?: EnumAutomationExecutionStatusFilter<"AutomationExecution"> | $Enums.AutomationExecutionStatus
    triggeredBy?: StringNullableFilter<"AutomationExecution"> | string | null
    triggerData?: JsonFilter<"AutomationExecution">
    conditionsEvaluated?: JsonFilter<"AutomationExecution">
    conditionsMet?: BoolFilter<"AutomationExecution"> | boolean
    actionsExecuted?: JsonFilter<"AutomationExecution">
    isDryRun?: BoolFilter<"AutomationExecution"> | boolean
    errorMessage?: StringNullableFilter<"AutomationExecution"> | string | null
    executionTime?: IntNullableFilter<"AutomationExecution"> | number | null
    retryCount?: IntFilter<"AutomationExecution"> | number
    nextRetryAt?: DateTimeNullableFilter<"AutomationExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutomationExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"AutomationExecution"> | Date | string
  }

  export type SmartInsightUpsertWithWhereUniqueWithoutTenantInput = {
    where: SmartInsightWhereUniqueInput
    update: XOR<SmartInsightUpdateWithoutTenantInput, SmartInsightUncheckedUpdateWithoutTenantInput>
    create: XOR<SmartInsightCreateWithoutTenantInput, SmartInsightUncheckedCreateWithoutTenantInput>
  }

  export type SmartInsightUpdateWithWhereUniqueWithoutTenantInput = {
    where: SmartInsightWhereUniqueInput
    data: XOR<SmartInsightUpdateWithoutTenantInput, SmartInsightUncheckedUpdateWithoutTenantInput>
  }

  export type SmartInsightUpdateManyWithWhereWithoutTenantInput = {
    where: SmartInsightScalarWhereInput
    data: XOR<SmartInsightUpdateManyMutationInput, SmartInsightUncheckedUpdateManyWithoutTenantInput>
  }

  export type SmartInsightScalarWhereInput = {
    AND?: SmartInsightScalarWhereInput | SmartInsightScalarWhereInput[]
    OR?: SmartInsightScalarWhereInput[]
    NOT?: SmartInsightScalarWhereInput | SmartInsightScalarWhereInput[]
    id?: StringFilter<"SmartInsight"> | string
    tenantId?: StringFilter<"SmartInsight"> | string
    insightType?: EnumInsightTypeFilter<"SmartInsight"> | $Enums.InsightType
    severity?: EnumInsightSeverityFilter<"SmartInsight"> | $Enums.InsightSeverity
    title?: StringFilter<"SmartInsight"> | string
    description?: StringFilter<"SmartInsight"> | string
    explanation?: StringFilter<"SmartInsight"> | string
    confidence?: FloatFilter<"SmartInsight"> | number
    metadata?: JsonFilter<"SmartInsight">
    relatedEntities?: JsonFilter<"SmartInsight">
    actionable?: BoolFilter<"SmartInsight"> | boolean
    suggestedActions?: JsonFilter<"SmartInsight">
    dismissedBy?: StringNullableFilter<"SmartInsight"> | string | null
    dismissedAt?: DateTimeNullableFilter<"SmartInsight"> | Date | string | null
    dismissReason?: StringNullableFilter<"SmartInsight"> | string | null
    createdAt?: DateTimeFilter<"SmartInsight"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SmartInsight"> | Date | string | null
  }

  export type AutomationUsageMetricUpsertWithWhereUniqueWithoutTenantInput = {
    where: AutomationUsageMetricWhereUniqueInput
    update: XOR<AutomationUsageMetricUpdateWithoutTenantInput, AutomationUsageMetricUncheckedUpdateWithoutTenantInput>
    create: XOR<AutomationUsageMetricCreateWithoutTenantInput, AutomationUsageMetricUncheckedCreateWithoutTenantInput>
  }

  export type AutomationUsageMetricUpdateWithWhereUniqueWithoutTenantInput = {
    where: AutomationUsageMetricWhereUniqueInput
    data: XOR<AutomationUsageMetricUpdateWithoutTenantInput, AutomationUsageMetricUncheckedUpdateWithoutTenantInput>
  }

  export type AutomationUsageMetricUpdateManyWithWhereWithoutTenantInput = {
    where: AutomationUsageMetricScalarWhereInput
    data: XOR<AutomationUsageMetricUpdateManyMutationInput, AutomationUsageMetricUncheckedUpdateManyWithoutTenantInput>
  }

  export type AutomationUsageMetricScalarWhereInput = {
    AND?: AutomationUsageMetricScalarWhereInput | AutomationUsageMetricScalarWhereInput[]
    OR?: AutomationUsageMetricScalarWhereInput[]
    NOT?: AutomationUsageMetricScalarWhereInput | AutomationUsageMetricScalarWhereInput[]
    id?: StringFilter<"AutomationUsageMetric"> | string
    tenantId?: StringFilter<"AutomationUsageMetric"> | string
    ruleId?: StringFilter<"AutomationUsageMetric"> | string
    executionId?: StringFilter<"AutomationUsageMetric"> | string
    actionType?: StringFilter<"AutomationUsageMetric"> | string
    success?: BoolFilter<"AutomationUsageMetric"> | boolean
    executionTime?: IntFilter<"AutomationUsageMetric"> | number
    costImpact?: FloatNullableFilter<"AutomationUsageMetric"> | number | null
    businessImpact?: JsonNullableFilter<"AutomationUsageMetric">
    timestamp?: DateTimeFilter<"AutomationUsageMetric"> | Date | string
  }

  export type PaymentMethodUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentMethodWhereUniqueInput
    update: XOR<PaymentMethodUpdateWithoutTenantInput, PaymentMethodUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentMethodCreateWithoutTenantInput, PaymentMethodUncheckedCreateWithoutTenantInput>
  }

  export type PaymentMethodUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentMethodWhereUniqueInput
    data: XOR<PaymentMethodUpdateWithoutTenantInput, PaymentMethodUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentMethodUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentMethodScalarWhereInput
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentMethodScalarWhereInput = {
    AND?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    OR?: PaymentMethodScalarWhereInput[]
    NOT?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    tenantId?: StringFilter<"PaymentMethod"> | string
    customerId?: StringNullableFilter<"PaymentMethod"> | string | null
    type?: EnumPaymentMethodTypeFilter<"PaymentMethod"> | $Enums.PaymentMethodType
    isDefault?: BoolFilter<"PaymentMethod"> | boolean
    token?: StringFilter<"PaymentMethod"> | string
    last4?: StringNullableFilter<"PaymentMethod"> | string | null
    brand?: StringNullableFilter<"PaymentMethod"> | string | null
    expiryMonth?: IntNullableFilter<"PaymentMethod"> | number | null
    expiryYear?: IntNullableFilter<"PaymentMethod"> | number | null
    accountType?: StringNullableFilter<"PaymentMethod"> | string | null
    routingNumber?: StringNullableFilter<"PaymentMethod"> | string | null
    nickname?: StringNullableFilter<"PaymentMethod"> | string | null
    billingAddress?: JsonNullableFilter<"PaymentMethod">
    metadata?: JsonFilter<"PaymentMethod">
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    verifiedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    paymentMethodId?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    description?: StringNullableFilter<"Payment"> | string | null
    processorId?: StringNullableFilter<"Payment"> | string | null
    processorStatus?: StringNullableFilter<"Payment"> | string | null
    processorResponse?: JsonNullableFilter<"Payment">
    automationRuleId?: StringNullableFilter<"Payment"> | string | null
    automationExecutionId?: StringNullableFilter<"Payment"> | string | null
    isAutomated?: BoolFilter<"Payment"> | boolean
    scheduledFor?: DateTimeNullableFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    retryCount?: IntFilter<"Payment"> | number
    maxRetries?: IntFilter<"Payment"> | number
    nextRetryAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    reconciledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    ledgerEntryId?: StringNullableFilter<"Payment"> | string | null
    processingFee?: FloatNullableFilter<"Payment"> | number | null
    netAmount?: FloatNullableFilter<"Payment"> | number | null
    isDisputed?: BoolFilter<"Payment"> | boolean
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    disputedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    requiresApproval?: BoolFilter<"Payment"> | boolean
    approvedBy?: StringNullableFilter<"Payment"> | string | null
    approvedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    metadata?: JsonFilter<"Payment">
    failureReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PaymentReconciliationUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentReconciliationWhereUniqueInput
    update: XOR<PaymentReconciliationUpdateWithoutTenantInput, PaymentReconciliationUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentReconciliationCreateWithoutTenantInput, PaymentReconciliationUncheckedCreateWithoutTenantInput>
  }

  export type PaymentReconciliationUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentReconciliationWhereUniqueInput
    data: XOR<PaymentReconciliationUpdateWithoutTenantInput, PaymentReconciliationUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentReconciliationUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentReconciliationScalarWhereInput
    data: XOR<PaymentReconciliationUpdateManyMutationInput, PaymentReconciliationUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentReconciliationScalarWhereInput = {
    AND?: PaymentReconciliationScalarWhereInput | PaymentReconciliationScalarWhereInput[]
    OR?: PaymentReconciliationScalarWhereInput[]
    NOT?: PaymentReconciliationScalarWhereInput | PaymentReconciliationScalarWhereInput[]
    id?: StringFilter<"PaymentReconciliation"> | string
    paymentId?: StringFilter<"PaymentReconciliation"> | string
    tenantId?: StringFilter<"PaymentReconciliation"> | string
    status?: EnumReconciliationStatusFilter<"PaymentReconciliation"> | $Enums.ReconciliationStatus
    ledgerEntryId?: StringNullableFilter<"PaymentReconciliation"> | string | null
    accountId?: StringNullableFilter<"PaymentReconciliation"> | string | null
    matchedAmount?: FloatNullableFilter<"PaymentReconciliation"> | number | null
    variance?: FloatNullableFilter<"PaymentReconciliation"> | number | null
    varianceReason?: StringNullableFilter<"PaymentReconciliation"> | string | null
    reconciledBy?: StringNullableFilter<"PaymentReconciliation"> | string | null
    reconciledAt?: DateTimeNullableFilter<"PaymentReconciliation"> | Date | string | null
    notes?: StringNullableFilter<"PaymentReconciliation"> | string | null
    createdAt?: DateTimeFilter<"PaymentReconciliation"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentReconciliation"> | Date | string
  }

  export type PaymentExplainabilityUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentExplainabilityWhereUniqueInput
    update: XOR<PaymentExplainabilityUpdateWithoutTenantInput, PaymentExplainabilityUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentExplainabilityCreateWithoutTenantInput, PaymentExplainabilityUncheckedCreateWithoutTenantInput>
  }

  export type PaymentExplainabilityUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentExplainabilityWhereUniqueInput
    data: XOR<PaymentExplainabilityUpdateWithoutTenantInput, PaymentExplainabilityUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentExplainabilityUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentExplainabilityScalarWhereInput
    data: XOR<PaymentExplainabilityUpdateManyMutationInput, PaymentExplainabilityUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentExplainabilityScalarWhereInput = {
    AND?: PaymentExplainabilityScalarWhereInput | PaymentExplainabilityScalarWhereInput[]
    OR?: PaymentExplainabilityScalarWhereInput[]
    NOT?: PaymentExplainabilityScalarWhereInput | PaymentExplainabilityScalarWhereInput[]
    id?: StringFilter<"PaymentExplainability"> | string
    paymentId?: StringFilter<"PaymentExplainability"> | string
    tenantId?: StringFilter<"PaymentExplainability"> | string
    trigger?: StringFilter<"PaymentExplainability"> | string
    triggerDetails?: JsonFilter<"PaymentExplainability">
    conditionsMet?: JsonFilter<"PaymentExplainability">
    amountCalculation?: StringFilter<"PaymentExplainability"> | string
    baseAmount?: FloatFilter<"PaymentExplainability"> | number
    adjustments?: JsonFilter<"PaymentExplainability">
    confidenceScore?: FloatFilter<"PaymentExplainability"> | number
    safeguards?: JsonFilter<"PaymentExplainability">
    riskFactors?: JsonFilter<"PaymentExplainability">
    approvalRequired?: BoolFilter<"PaymentExplainability"> | boolean
    approvalStatus?: StringNullableFilter<"PaymentExplainability"> | string | null
    businessImpact?: JsonFilter<"PaymentExplainability">
    estimatedTimeSaved?: IntNullableFilter<"PaymentExplainability"> | number | null
    explanation?: StringFilter<"PaymentExplainability"> | string
    createdAt?: DateTimeFilter<"PaymentExplainability"> | Date | string
  }

  export type CashControlRuleUpsertWithWhereUniqueWithoutTenantInput = {
    where: CashControlRuleWhereUniqueInput
    update: XOR<CashControlRuleUpdateWithoutTenantInput, CashControlRuleUncheckedUpdateWithoutTenantInput>
    create: XOR<CashControlRuleCreateWithoutTenantInput, CashControlRuleUncheckedCreateWithoutTenantInput>
  }

  export type CashControlRuleUpdateWithWhereUniqueWithoutTenantInput = {
    where: CashControlRuleWhereUniqueInput
    data: XOR<CashControlRuleUpdateWithoutTenantInput, CashControlRuleUncheckedUpdateWithoutTenantInput>
  }

  export type CashControlRuleUpdateManyWithWhereWithoutTenantInput = {
    where: CashControlRuleScalarWhereInput
    data: XOR<CashControlRuleUpdateManyMutationInput, CashControlRuleUncheckedUpdateManyWithoutTenantInput>
  }

  export type CashControlRuleScalarWhereInput = {
    AND?: CashControlRuleScalarWhereInput | CashControlRuleScalarWhereInput[]
    OR?: CashControlRuleScalarWhereInput[]
    NOT?: CashControlRuleScalarWhereInput | CashControlRuleScalarWhereInput[]
    id?: StringFilter<"CashControlRule"> | string
    tenantId?: StringFilter<"CashControlRule"> | string
    name?: StringFilter<"CashControlRule"> | string
    description?: StringNullableFilter<"CashControlRule"> | string | null
    ruleType?: EnumCashControlRuleTypeFilter<"CashControlRule"> | $Enums.CashControlRuleType
    config?: JsonFilter<"CashControlRule">
    conditions?: JsonFilter<"CashControlRule">
    isActive?: BoolFilter<"CashControlRule"> | boolean
    requiresApproval?: BoolFilter<"CashControlRule"> | boolean
    executionCount?: IntFilter<"CashControlRule"> | number
    successCount?: IntFilter<"CashControlRule"> | number
    failureCount?: IntFilter<"CashControlRule"> | number
    totalAmountProcessed?: FloatFilter<"CashControlRule"> | number
    createdBy?: StringFilter<"CashControlRule"> | string
    lastExecuted?: DateTimeNullableFilter<"CashControlRule"> | Date | string | null
    createdAt?: DateTimeFilter<"CashControlRule"> | Date | string
    updatedAt?: DateTimeFilter<"CashControlRule"> | Date | string
  }

  export type CashControlExecutionUpsertWithWhereUniqueWithoutTenantInput = {
    where: CashControlExecutionWhereUniqueInput
    update: XOR<CashControlExecutionUpdateWithoutTenantInput, CashControlExecutionUncheckedUpdateWithoutTenantInput>
    create: XOR<CashControlExecutionCreateWithoutTenantInput, CashControlExecutionUncheckedCreateWithoutTenantInput>
  }

  export type CashControlExecutionUpdateWithWhereUniqueWithoutTenantInput = {
    where: CashControlExecutionWhereUniqueInput
    data: XOR<CashControlExecutionUpdateWithoutTenantInput, CashControlExecutionUncheckedUpdateWithoutTenantInput>
  }

  export type CashControlExecutionUpdateManyWithWhereWithoutTenantInput = {
    where: CashControlExecutionScalarWhereInput
    data: XOR<CashControlExecutionUpdateManyMutationInput, CashControlExecutionUncheckedUpdateManyWithoutTenantInput>
  }

  export type CashControlExecutionScalarWhereInput = {
    AND?: CashControlExecutionScalarWhereInput | CashControlExecutionScalarWhereInput[]
    OR?: CashControlExecutionScalarWhereInput[]
    NOT?: CashControlExecutionScalarWhereInput | CashControlExecutionScalarWhereInput[]
    id?: StringFilter<"CashControlExecution"> | string
    ruleId?: StringFilter<"CashControlExecution"> | string
    tenantId?: StringFilter<"CashControlExecution"> | string
    status?: StringFilter<"CashControlExecution"> | string
    triggerData?: JsonFilter<"CashControlExecution">
    conditionsEvaluated?: JsonFilter<"CashControlExecution">
    paymentId?: StringNullableFilter<"CashControlExecution"> | string | null
    amount?: FloatNullableFilter<"CashControlExecution"> | number | null
    success?: BoolFilter<"CashControlExecution"> | boolean
    errorMessage?: StringNullableFilter<"CashControlExecution"> | string | null
    executionTime?: IntNullableFilter<"CashControlExecution"> | number | null
    isDryRun?: BoolFilter<"CashControlExecution"> | boolean
    createdAt?: DateTimeFilter<"CashControlExecution"> | Date | string
  }

  export type PaymentAnalyticsUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentAnalyticsWhereUniqueInput
    update: XOR<PaymentAnalyticsUpdateWithoutTenantInput, PaymentAnalyticsUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentAnalyticsCreateWithoutTenantInput, PaymentAnalyticsUncheckedCreateWithoutTenantInput>
  }

  export type PaymentAnalyticsUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentAnalyticsWhereUniqueInput
    data: XOR<PaymentAnalyticsUpdateWithoutTenantInput, PaymentAnalyticsUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentAnalyticsUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentAnalyticsScalarWhereInput
    data: XOR<PaymentAnalyticsUpdateManyMutationInput, PaymentAnalyticsUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentAnalyticsScalarWhereInput = {
    AND?: PaymentAnalyticsScalarWhereInput | PaymentAnalyticsScalarWhereInput[]
    OR?: PaymentAnalyticsScalarWhereInput[]
    NOT?: PaymentAnalyticsScalarWhereInput | PaymentAnalyticsScalarWhereInput[]
    id?: StringFilter<"PaymentAnalytics"> | string
    tenantId?: StringFilter<"PaymentAnalytics"> | string
    paymentId?: StringNullableFilter<"PaymentAnalytics"> | string | null
    eventType?: StringFilter<"PaymentAnalytics"> | string
    amount?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    processingFee?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    isAutomated?: BoolFilter<"PaymentAnalytics"> | boolean
    automationRuleId?: StringNullableFilter<"PaymentAnalytics"> | string | null
    timeToCash?: IntNullableFilter<"PaymentAnalytics"> | number | null
    retryCount?: IntNullableFilter<"PaymentAnalytics"> | number | null
    revenueImpact?: FloatNullableFilter<"PaymentAnalytics"> | number | null
    timestamp?: DateTimeFilter<"PaymentAnalytics"> | Date | string
  }

  export type FinancialForecastUpsertWithWhereUniqueWithoutTenantInput = {
    where: FinancialForecastWhereUniqueInput
    update: XOR<FinancialForecastUpdateWithoutTenantInput, FinancialForecastUncheckedUpdateWithoutTenantInput>
    create: XOR<FinancialForecastCreateWithoutTenantInput, FinancialForecastUncheckedCreateWithoutTenantInput>
  }

  export type FinancialForecastUpdateWithWhereUniqueWithoutTenantInput = {
    where: FinancialForecastWhereUniqueInput
    data: XOR<FinancialForecastUpdateWithoutTenantInput, FinancialForecastUncheckedUpdateWithoutTenantInput>
  }

  export type FinancialForecastUpdateManyWithWhereWithoutTenantInput = {
    where: FinancialForecastScalarWhereInput
    data: XOR<FinancialForecastUpdateManyMutationInput, FinancialForecastUncheckedUpdateManyWithoutTenantInput>
  }

  export type FinancialForecastScalarWhereInput = {
    AND?: FinancialForecastScalarWhereInput | FinancialForecastScalarWhereInput[]
    OR?: FinancialForecastScalarWhereInput[]
    NOT?: FinancialForecastScalarWhereInput | FinancialForecastScalarWhereInput[]
    id?: StringFilter<"FinancialForecast"> | string
    tenantId?: StringFilter<"FinancialForecast"> | string
    forecastType?: EnumForecastTypeFilter<"FinancialForecast"> | $Enums.ForecastType
    value?: FloatFilter<"FinancialForecast"> | number
    unit?: StringFilter<"FinancialForecast"> | string
    confidenceScore?: FloatFilter<"FinancialForecast"> | number
    forecastDate?: DateTimeFilter<"FinancialForecast"> | Date | string
    forecastHorizon?: IntFilter<"FinancialForecast"> | number
    formula?: StringFilter<"FinancialForecast"> | string
    assumptions?: JsonFilter<"FinancialForecast">
    dataSources?: JsonFilter<"FinancialForecast">
    historicalBaseline?: JsonNullableFilter<"FinancialForecast">
    calculatedAt?: DateTimeFilter<"FinancialForecast"> | Date | string
  }

  export type ScenarioUpsertWithWhereUniqueWithoutTenantInput = {
    where: ScenarioWhereUniqueInput
    update: XOR<ScenarioUpdateWithoutTenantInput, ScenarioUncheckedUpdateWithoutTenantInput>
    create: XOR<ScenarioCreateWithoutTenantInput, ScenarioUncheckedCreateWithoutTenantInput>
  }

  export type ScenarioUpdateWithWhereUniqueWithoutTenantInput = {
    where: ScenarioWhereUniqueInput
    data: XOR<ScenarioUpdateWithoutTenantInput, ScenarioUncheckedUpdateWithoutTenantInput>
  }

  export type ScenarioUpdateManyWithWhereWithoutTenantInput = {
    where: ScenarioScalarWhereInput
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyWithoutTenantInput>
  }

  export type ScenarioScalarWhereInput = {
    AND?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    OR?: ScenarioScalarWhereInput[]
    NOT?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    id?: StringFilter<"Scenario"> | string
    tenantId?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    scenarioType?: EnumScenarioTypeFilter<"Scenario"> | $Enums.ScenarioType
    config?: JsonFilter<"Scenario">
    baselineRunway?: FloatNullableFilter<"Scenario"> | number | null
    projectedRunway?: FloatNullableFilter<"Scenario"> | number | null
    runwayChange?: FloatNullableFilter<"Scenario"> | number | null
    riskLevel?: EnumRiskLevelNullableFilter<"Scenario"> | $Enums.RiskLevel | null
    riskScore?: FloatNullableFilter<"Scenario"> | number | null
    successProbability?: FloatNullableFilter<"Scenario"> | number | null
    topRiskDrivers?: JsonFilter<"Scenario">
    criticalAssumptions?: JsonFilter<"Scenario">
    cashFlowImpact?: JsonNullableFilter<"Scenario">
    automationImpact?: JsonNullableFilter<"Scenario">
    paymentImpact?: JsonNullableFilter<"Scenario">
    recommendations?: JsonFilter<"Scenario">
    createdBy?: StringFilter<"Scenario"> | string
    isArchived?: BoolFilter<"Scenario"> | boolean
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
  }

  export type ScenarioAnalyticsUpsertWithWhereUniqueWithoutTenantInput = {
    where: ScenarioAnalyticsWhereUniqueInput
    update: XOR<ScenarioAnalyticsUpdateWithoutTenantInput, ScenarioAnalyticsUncheckedUpdateWithoutTenantInput>
    create: XOR<ScenarioAnalyticsCreateWithoutTenantInput, ScenarioAnalyticsUncheckedCreateWithoutTenantInput>
  }

  export type ScenarioAnalyticsUpdateWithWhereUniqueWithoutTenantInput = {
    where: ScenarioAnalyticsWhereUniqueInput
    data: XOR<ScenarioAnalyticsUpdateWithoutTenantInput, ScenarioAnalyticsUncheckedUpdateWithoutTenantInput>
  }

  export type ScenarioAnalyticsUpdateManyWithWhereWithoutTenantInput = {
    where: ScenarioAnalyticsScalarWhereInput
    data: XOR<ScenarioAnalyticsUpdateManyMutationInput, ScenarioAnalyticsUncheckedUpdateManyWithoutTenantInput>
  }

  export type ScenarioAnalyticsScalarWhereInput = {
    AND?: ScenarioAnalyticsScalarWhereInput | ScenarioAnalyticsScalarWhereInput[]
    OR?: ScenarioAnalyticsScalarWhereInput[]
    NOT?: ScenarioAnalyticsScalarWhereInput | ScenarioAnalyticsScalarWhereInput[]
    id?: StringFilter<"ScenarioAnalytics"> | string
    tenantId?: StringFilter<"ScenarioAnalytics"> | string
    scenarioId?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    eventType?: StringFilter<"ScenarioAnalytics"> | string
    scenarioType?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    decisionMade?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    decisionOutcome?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    riskAvoided?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    upgradeTriggered?: BoolNullableFilter<"ScenarioAnalytics"> | boolean | null
    planBefore?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    planAfter?: StringNullableFilter<"ScenarioAnalytics"> | string | null
    timeToDecision?: IntNullableFilter<"ScenarioAnalytics"> | number | null
    timestamp?: DateTimeFilter<"ScenarioAnalytics"> | Date | string
  }

  export type UserCreateWithoutDashboardLayoutsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDashboardLayoutsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    tenantId: string
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDashboardLayoutsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDashboardLayoutsInput, UserUncheckedCreateWithoutDashboardLayoutsInput>
  }

  export type TenantCreateWithoutDashboardLayoutsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDashboardLayoutsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDashboardLayoutsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDashboardLayoutsInput, TenantUncheckedCreateWithoutDashboardLayoutsInput>
  }

  export type UserUpsertWithoutDashboardLayoutsInput = {
    update: XOR<UserUpdateWithoutDashboardLayoutsInput, UserUncheckedUpdateWithoutDashboardLayoutsInput>
    create: XOR<UserCreateWithoutDashboardLayoutsInput, UserUncheckedCreateWithoutDashboardLayoutsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDashboardLayoutsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDashboardLayoutsInput, UserUncheckedUpdateWithoutDashboardLayoutsInput>
  }

  export type UserUpdateWithoutDashboardLayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDashboardLayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantUpsertWithoutDashboardLayoutsInput = {
    update: XOR<TenantUpdateWithoutDashboardLayoutsInput, TenantUncheckedUpdateWithoutDashboardLayoutsInput>
    create: XOR<TenantCreateWithoutDashboardLayoutsInput, TenantUncheckedCreateWithoutDashboardLayoutsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDashboardLayoutsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDashboardLayoutsInput, TenantUncheckedUpdateWithoutDashboardLayoutsInput>
  }

  export type TenantUpdateWithoutDashboardLayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDashboardLayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutUserInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    tenantId: string
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutUserNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAnalyticsEventsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAnalyticsEventsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAnalyticsEventsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAnalyticsEventsInput, TenantUncheckedCreateWithoutAnalyticsEventsInput>
  }

  export type TenantUpsertWithoutAnalyticsEventsInput = {
    update: XOR<TenantUpdateWithoutAnalyticsEventsInput, TenantUncheckedUpdateWithoutAnalyticsEventsInput>
    create: XOR<TenantCreateWithoutAnalyticsEventsInput, TenantUncheckedCreateWithoutAnalyticsEventsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAnalyticsEventsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAnalyticsEventsInput, TenantUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type TenantUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAutomationRulesInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAutomationRulesInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAutomationRulesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAutomationRulesInput, TenantUncheckedCreateWithoutAutomationRulesInput>
  }

  export type AutomationExecutionCreateWithoutRuleInput = {
    id?: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAutomationExecutionsInput
  }

  export type AutomationExecutionUncheckedCreateWithoutRuleInput = {
    id?: string
    tenantId: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AutomationExecutionCreateOrConnectWithoutRuleInput = {
    where: AutomationExecutionWhereUniqueInput
    create: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput>
  }

  export type AutomationExecutionCreateManyRuleInputEnvelope = {
    data: AutomationExecutionCreateManyRuleInput | AutomationExecutionCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAutomationRulesInput = {
    update: XOR<TenantUpdateWithoutAutomationRulesInput, TenantUncheckedUpdateWithoutAutomationRulesInput>
    create: XOR<TenantCreateWithoutAutomationRulesInput, TenantUncheckedCreateWithoutAutomationRulesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAutomationRulesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAutomationRulesInput, TenantUncheckedUpdateWithoutAutomationRulesInput>
  }

  export type TenantUpdateWithoutAutomationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAutomationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AutomationExecutionUpsertWithWhereUniqueWithoutRuleInput = {
    where: AutomationExecutionWhereUniqueInput
    update: XOR<AutomationExecutionUpdateWithoutRuleInput, AutomationExecutionUncheckedUpdateWithoutRuleInput>
    create: XOR<AutomationExecutionCreateWithoutRuleInput, AutomationExecutionUncheckedCreateWithoutRuleInput>
  }

  export type AutomationExecutionUpdateWithWhereUniqueWithoutRuleInput = {
    where: AutomationExecutionWhereUniqueInput
    data: XOR<AutomationExecutionUpdateWithoutRuleInput, AutomationExecutionUncheckedUpdateWithoutRuleInput>
  }

  export type AutomationExecutionUpdateManyWithWhereWithoutRuleInput = {
    where: AutomationExecutionScalarWhereInput
    data: XOR<AutomationExecutionUpdateManyMutationInput, AutomationExecutionUncheckedUpdateManyWithoutRuleInput>
  }

  export type AutomationRuleCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAutomationRulesInput
  }

  export type AutomationRuleUncheckedCreateWithoutExecutionsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationRuleCreateOrConnectWithoutExecutionsInput = {
    where: AutomationRuleWhereUniqueInput
    create: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
  }

  export type TenantCreateWithoutAutomationExecutionsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAutomationExecutionsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAutomationExecutionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAutomationExecutionsInput, TenantUncheckedCreateWithoutAutomationExecutionsInput>
  }

  export type AutomationRuleUpsertWithoutExecutionsInput = {
    update: XOR<AutomationRuleUpdateWithoutExecutionsInput, AutomationRuleUncheckedUpdateWithoutExecutionsInput>
    create: XOR<AutomationRuleCreateWithoutExecutionsInput, AutomationRuleUncheckedCreateWithoutExecutionsInput>
    where?: AutomationRuleWhereInput
  }

  export type AutomationRuleUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: AutomationRuleWhereInput
    data: XOR<AutomationRuleUpdateWithoutExecutionsInput, AutomationRuleUncheckedUpdateWithoutExecutionsInput>
  }

  export type AutomationRuleUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAutomationRulesNestedInput
  }

  export type AutomationRuleUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutAutomationExecutionsInput = {
    update: XOR<TenantUpdateWithoutAutomationExecutionsInput, TenantUncheckedUpdateWithoutAutomationExecutionsInput>
    create: XOR<TenantCreateWithoutAutomationExecutionsInput, TenantUncheckedCreateWithoutAutomationExecutionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAutomationExecutionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAutomationExecutionsInput, TenantUncheckedUpdateWithoutAutomationExecutionsInput>
  }

  export type TenantUpdateWithoutAutomationExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAutomationExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSmartInsightsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSmartInsightsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSmartInsightsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSmartInsightsInput, TenantUncheckedCreateWithoutSmartInsightsInput>
  }

  export type TenantUpsertWithoutSmartInsightsInput = {
    update: XOR<TenantUpdateWithoutSmartInsightsInput, TenantUncheckedUpdateWithoutSmartInsightsInput>
    create: XOR<TenantCreateWithoutSmartInsightsInput, TenantUncheckedCreateWithoutSmartInsightsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSmartInsightsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSmartInsightsInput, TenantUncheckedUpdateWithoutSmartInsightsInput>
  }

  export type TenantUpdateWithoutSmartInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSmartInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAutomationMetricsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAutomationMetricsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAutomationMetricsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAutomationMetricsInput, TenantUncheckedCreateWithoutAutomationMetricsInput>
  }

  export type TenantUpsertWithoutAutomationMetricsInput = {
    update: XOR<TenantUpdateWithoutAutomationMetricsInput, TenantUncheckedUpdateWithoutAutomationMetricsInput>
    create: XOR<TenantCreateWithoutAutomationMetricsInput, TenantUncheckedCreateWithoutAutomationMetricsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAutomationMetricsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAutomationMetricsInput, TenantUncheckedUpdateWithoutAutomationMetricsInput>
  }

  export type TenantUpdateWithoutAutomationMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAutomationMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutPaymentMethodsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentMethodsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentMethodsInput, TenantUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type PaymentCreateWithoutPaymentMethodInput = {
    id?: string
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    reconciliation?: PaymentReconciliationCreateNestedOneWithoutPaymentInput
    explainability?: PaymentExplainabilityCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutPaymentMethodInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reconciliation?: PaymentReconciliationUncheckedCreateNestedOneWithoutPaymentInput
    explainability?: PaymentExplainabilityUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentCreateManyPaymentMethodInputEnvelope = {
    data: PaymentCreateManyPaymentMethodInput | PaymentCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutPaymentMethodsInput = {
    update: XOR<TenantUpdateWithoutPaymentMethodsInput, TenantUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<TenantCreateWithoutPaymentMethodsInput, TenantUncheckedCreateWithoutPaymentMethodsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentMethodsInput, TenantUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type TenantUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentMethodCreateWithoutPaymentsInput = {
    id?: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentMethodsInput
  }

  export type PaymentMethodUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodCreateOrConnectWithoutPaymentsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentReconciliationCreateWithoutPaymentInput = {
    id?: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentReconciliationsInput
  }

  export type PaymentReconciliationUncheckedCreateWithoutPaymentInput = {
    id?: string
    tenantId: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReconciliationCreateOrConnectWithoutPaymentInput = {
    where: PaymentReconciliationWhereUniqueInput
    create: XOR<PaymentReconciliationCreateWithoutPaymentInput, PaymentReconciliationUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentExplainabilityCreateWithoutPaymentInput = {
    id?: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentExplainabilityInput
  }

  export type PaymentExplainabilityUncheckedCreateWithoutPaymentInput = {
    id?: string
    tenantId: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
  }

  export type PaymentExplainabilityCreateOrConnectWithoutPaymentInput = {
    where: PaymentExplainabilityWhereUniqueInput
    create: XOR<PaymentExplainabilityCreateWithoutPaymentInput, PaymentExplainabilityUncheckedCreateWithoutPaymentInput>
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PaymentMethodUpsertWithoutPaymentsInput = {
    update: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReconciliationUpsertWithoutPaymentInput = {
    update: XOR<PaymentReconciliationUpdateWithoutPaymentInput, PaymentReconciliationUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentReconciliationCreateWithoutPaymentInput, PaymentReconciliationUncheckedCreateWithoutPaymentInput>
    where?: PaymentReconciliationWhereInput
  }

  export type PaymentReconciliationUpdateToOneWithWhereWithoutPaymentInput = {
    where?: PaymentReconciliationWhereInput
    data: XOR<PaymentReconciliationUpdateWithoutPaymentInput, PaymentReconciliationUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentReconciliationUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentReconciliationsNestedInput
  }

  export type PaymentReconciliationUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentExplainabilityUpsertWithoutPaymentInput = {
    update: XOR<PaymentExplainabilityUpdateWithoutPaymentInput, PaymentExplainabilityUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentExplainabilityCreateWithoutPaymentInput, PaymentExplainabilityUncheckedCreateWithoutPaymentInput>
    where?: PaymentExplainabilityWhereInput
  }

  export type PaymentExplainabilityUpdateToOneWithWhereWithoutPaymentInput = {
    where?: PaymentExplainabilityWhereInput
    data: XOR<PaymentExplainabilityUpdateWithoutPaymentInput, PaymentExplainabilityUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentExplainabilityUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentExplainabilityNestedInput
  }

  export type PaymentExplainabilityUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateWithoutReconciliationInput = {
    id?: string
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutPaymentsInput
    explainability?: PaymentExplainabilityCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutReconciliationInput = {
    id?: string
    tenantId: string
    paymentMethodId?: string | null
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    explainability?: PaymentExplainabilityUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutReconciliationInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReconciliationInput, PaymentUncheckedCreateWithoutReconciliationInput>
  }

  export type TenantCreateWithoutPaymentReconciliationsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentReconciliationsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentReconciliationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentReconciliationsInput, TenantUncheckedCreateWithoutPaymentReconciliationsInput>
  }

  export type PaymentUpsertWithoutReconciliationInput = {
    update: XOR<PaymentUpdateWithoutReconciliationInput, PaymentUncheckedUpdateWithoutReconciliationInput>
    create: XOR<PaymentCreateWithoutReconciliationInput, PaymentUncheckedCreateWithoutReconciliationInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutReconciliationInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutReconciliationInput, PaymentUncheckedUpdateWithoutReconciliationInput>
  }

  export type PaymentUpdateWithoutReconciliationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutPaymentsNestedInput
    explainability?: PaymentExplainabilityUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReconciliationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    explainability?: PaymentExplainabilityUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type TenantUpsertWithoutPaymentReconciliationsInput = {
    update: XOR<TenantUpdateWithoutPaymentReconciliationsInput, TenantUncheckedUpdateWithoutPaymentReconciliationsInput>
    create: XOR<TenantCreateWithoutPaymentReconciliationsInput, TenantUncheckedCreateWithoutPaymentReconciliationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentReconciliationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentReconciliationsInput, TenantUncheckedUpdateWithoutPaymentReconciliationsInput>
  }

  export type TenantUpdateWithoutPaymentReconciliationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentReconciliationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PaymentCreateWithoutExplainabilityInput = {
    id?: string
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    paymentMethod?: PaymentMethodCreateNestedOneWithoutPaymentsInput
    reconciliation?: PaymentReconciliationCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutExplainabilityInput = {
    id?: string
    tenantId: string
    paymentMethodId?: string | null
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reconciliation?: PaymentReconciliationUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutExplainabilityInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutExplainabilityInput, PaymentUncheckedCreateWithoutExplainabilityInput>
  }

  export type TenantCreateWithoutPaymentExplainabilityInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentExplainabilityInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentExplainabilityInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentExplainabilityInput, TenantUncheckedCreateWithoutPaymentExplainabilityInput>
  }

  export type PaymentUpsertWithoutExplainabilityInput = {
    update: XOR<PaymentUpdateWithoutExplainabilityInput, PaymentUncheckedUpdateWithoutExplainabilityInput>
    create: XOR<PaymentCreateWithoutExplainabilityInput, PaymentUncheckedCreateWithoutExplainabilityInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutExplainabilityInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutExplainabilityInput, PaymentUncheckedUpdateWithoutExplainabilityInput>
  }

  export type PaymentUpdateWithoutExplainabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneWithoutPaymentsNestedInput
    reconciliation?: PaymentReconciliationUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutExplainabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reconciliation?: PaymentReconciliationUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type TenantUpsertWithoutPaymentExplainabilityInput = {
    update: XOR<TenantUpdateWithoutPaymentExplainabilityInput, TenantUncheckedUpdateWithoutPaymentExplainabilityInput>
    create: XOR<TenantCreateWithoutPaymentExplainabilityInput, TenantUncheckedCreateWithoutPaymentExplainabilityInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentExplainabilityInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentExplainabilityInput, TenantUncheckedUpdateWithoutPaymentExplainabilityInput>
  }

  export type TenantUpdateWithoutPaymentExplainabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentExplainabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutCashControlRulesInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCashControlRulesInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCashControlRulesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCashControlRulesInput, TenantUncheckedCreateWithoutCashControlRulesInput>
  }

  export type CashControlExecutionCreateWithoutRuleInput = {
    id?: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashControlExecutionsInput
  }

  export type CashControlExecutionUncheckedCreateWithoutRuleInput = {
    id?: string
    tenantId: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
  }

  export type CashControlExecutionCreateOrConnectWithoutRuleInput = {
    where: CashControlExecutionWhereUniqueInput
    create: XOR<CashControlExecutionCreateWithoutRuleInput, CashControlExecutionUncheckedCreateWithoutRuleInput>
  }

  export type CashControlExecutionCreateManyRuleInputEnvelope = {
    data: CashControlExecutionCreateManyRuleInput | CashControlExecutionCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCashControlRulesInput = {
    update: XOR<TenantUpdateWithoutCashControlRulesInput, TenantUncheckedUpdateWithoutCashControlRulesInput>
    create: XOR<TenantCreateWithoutCashControlRulesInput, TenantUncheckedCreateWithoutCashControlRulesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCashControlRulesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCashControlRulesInput, TenantUncheckedUpdateWithoutCashControlRulesInput>
  }

  export type TenantUpdateWithoutCashControlRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCashControlRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CashControlExecutionUpsertWithWhereUniqueWithoutRuleInput = {
    where: CashControlExecutionWhereUniqueInput
    update: XOR<CashControlExecutionUpdateWithoutRuleInput, CashControlExecutionUncheckedUpdateWithoutRuleInput>
    create: XOR<CashControlExecutionCreateWithoutRuleInput, CashControlExecutionUncheckedCreateWithoutRuleInput>
  }

  export type CashControlExecutionUpdateWithWhereUniqueWithoutRuleInput = {
    where: CashControlExecutionWhereUniqueInput
    data: XOR<CashControlExecutionUpdateWithoutRuleInput, CashControlExecutionUncheckedUpdateWithoutRuleInput>
  }

  export type CashControlExecutionUpdateManyWithWhereWithoutRuleInput = {
    where: CashControlExecutionScalarWhereInput
    data: XOR<CashControlExecutionUpdateManyMutationInput, CashControlExecutionUncheckedUpdateManyWithoutRuleInput>
  }

  export type CashControlRuleCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashControlRulesInput
  }

  export type CashControlRuleUncheckedCreateWithoutExecutionsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashControlRuleCreateOrConnectWithoutExecutionsInput = {
    where: CashControlRuleWhereUniqueInput
    create: XOR<CashControlRuleCreateWithoutExecutionsInput, CashControlRuleUncheckedCreateWithoutExecutionsInput>
  }

  export type TenantCreateWithoutCashControlExecutionsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCashControlExecutionsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCashControlExecutionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCashControlExecutionsInput, TenantUncheckedCreateWithoutCashControlExecutionsInput>
  }

  export type CashControlRuleUpsertWithoutExecutionsInput = {
    update: XOR<CashControlRuleUpdateWithoutExecutionsInput, CashControlRuleUncheckedUpdateWithoutExecutionsInput>
    create: XOR<CashControlRuleCreateWithoutExecutionsInput, CashControlRuleUncheckedCreateWithoutExecutionsInput>
    where?: CashControlRuleWhereInput
  }

  export type CashControlRuleUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: CashControlRuleWhereInput
    data: XOR<CashControlRuleUpdateWithoutExecutionsInput, CashControlRuleUncheckedUpdateWithoutExecutionsInput>
  }

  export type CashControlRuleUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashControlRulesNestedInput
  }

  export type CashControlRuleUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutCashControlExecutionsInput = {
    update: XOR<TenantUpdateWithoutCashControlExecutionsInput, TenantUncheckedUpdateWithoutCashControlExecutionsInput>
    create: XOR<TenantCreateWithoutCashControlExecutionsInput, TenantUncheckedCreateWithoutCashControlExecutionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCashControlExecutionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCashControlExecutionsInput, TenantUncheckedUpdateWithoutCashControlExecutionsInput>
  }

  export type TenantUpdateWithoutCashControlExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCashControlExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutPaymentAnalyticsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentAnalyticsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentAnalyticsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentAnalyticsInput, TenantUncheckedCreateWithoutPaymentAnalyticsInput>
  }

  export type TenantUpsertWithoutPaymentAnalyticsInput = {
    update: XOR<TenantUpdateWithoutPaymentAnalyticsInput, TenantUncheckedUpdateWithoutPaymentAnalyticsInput>
    create: XOR<TenantCreateWithoutPaymentAnalyticsInput, TenantUncheckedCreateWithoutPaymentAnalyticsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentAnalyticsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentAnalyticsInput, TenantUncheckedUpdateWithoutPaymentAnalyticsInput>
  }

  export type TenantUpdateWithoutPaymentAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutFinancialForecastsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutFinancialForecastsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutFinancialForecastsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutFinancialForecastsInput, TenantUncheckedCreateWithoutFinancialForecastsInput>
  }

  export type TenantUpsertWithoutFinancialForecastsInput = {
    update: XOR<TenantUpdateWithoutFinancialForecastsInput, TenantUncheckedUpdateWithoutFinancialForecastsInput>
    create: XOR<TenantCreateWithoutFinancialForecastsInput, TenantUncheckedCreateWithoutFinancialForecastsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutFinancialForecastsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutFinancialForecastsInput, TenantUncheckedUpdateWithoutFinancialForecastsInput>
  }

  export type TenantUpdateWithoutFinancialForecastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutFinancialForecastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutScenariosInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutScenariosInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutScenariosInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutScenariosInput, TenantUncheckedCreateWithoutScenariosInput>
  }

  export type TenantUpsertWithoutScenariosInput = {
    update: XOR<TenantUpdateWithoutScenariosInput, TenantUncheckedUpdateWithoutScenariosInput>
    create: XOR<TenantCreateWithoutScenariosInput, TenantUncheckedCreateWithoutScenariosInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutScenariosInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutScenariosInput, TenantUncheckedUpdateWithoutScenariosInput>
  }

  export type TenantUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarioAnalytics?: ScenarioAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutScenarioAnalyticsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutScenarioAnalyticsInput = {
    id?: string
    name: string
    subdomain: string
    customDomain?: string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: $Enums.SubscriptionPlan
    status?: $Enums.TenantStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    dashboardLayouts?: DashboardLayoutUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutTenantInput
    automationRules?: AutomationRuleUncheckedCreateNestedManyWithoutTenantInput
    automationExecutions?: AutomationExecutionUncheckedCreateNestedManyWithoutTenantInput
    smartInsights?: SmartInsightUncheckedCreateNestedManyWithoutTenantInput
    automationMetrics?: AutomationUsageMetricUncheckedCreateNestedManyWithoutTenantInput
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentReconciliations?: PaymentReconciliationUncheckedCreateNestedManyWithoutTenantInput
    paymentExplainability?: PaymentExplainabilityUncheckedCreateNestedManyWithoutTenantInput
    cashControlRules?: CashControlRuleUncheckedCreateNestedManyWithoutTenantInput
    cashControlExecutions?: CashControlExecutionUncheckedCreateNestedManyWithoutTenantInput
    paymentAnalytics?: PaymentAnalyticsUncheckedCreateNestedManyWithoutTenantInput
    financialForecasts?: FinancialForecastUncheckedCreateNestedManyWithoutTenantInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutScenarioAnalyticsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutScenarioAnalyticsInput, TenantUncheckedCreateWithoutScenarioAnalyticsInput>
  }

  export type TenantUpsertWithoutScenarioAnalyticsInput = {
    update: XOR<TenantUpdateWithoutScenarioAnalyticsInput, TenantUncheckedUpdateWithoutScenarioAnalyticsInput>
    create: XOR<TenantCreateWithoutScenarioAnalyticsInput, TenantUncheckedCreateWithoutScenarioAnalyticsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutScenarioAnalyticsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutScenarioAnalyticsInput, TenantUncheckedUpdateWithoutScenarioAnalyticsInput>
  }

  export type TenantUpdateWithoutScenarioAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutScenarioAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableJsonNullValueInput | InputJsonValue
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    featureFlags?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    plan?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutTenantNestedInput
    automationRules?: AutomationRuleUncheckedUpdateManyWithoutTenantNestedInput
    automationExecutions?: AutomationExecutionUncheckedUpdateManyWithoutTenantNestedInput
    smartInsights?: SmartInsightUncheckedUpdateManyWithoutTenantNestedInput
    automationMetrics?: AutomationUsageMetricUncheckedUpdateManyWithoutTenantNestedInput
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentReconciliations?: PaymentReconciliationUncheckedUpdateManyWithoutTenantNestedInput
    paymentExplainability?: PaymentExplainabilityUncheckedUpdateManyWithoutTenantNestedInput
    cashControlRules?: CashControlRuleUncheckedUpdateManyWithoutTenantNestedInput
    cashControlExecutions?: CashControlExecutionUncheckedUpdateManyWithoutTenantNestedInput
    paymentAnalytics?: PaymentAnalyticsUncheckedUpdateManyWithoutTenantNestedInput
    financialForecasts?: FinancialForecastUncheckedUpdateManyWithoutTenantNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardLayoutCreateManyUserInput = {
    id?: string
    role?: $Enums.Role | null
    tenantId: string
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tenantId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardLayoutUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDashboardLayoutsNestedInput
  }

  export type DashboardLayoutUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardLayoutUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.Role
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
  }

  export type DashboardLayoutCreateManyTenantInput = {
    id?: string
    userId?: string | null
    role?: $Enums.Role | null
    name: string
    isDefault?: boolean
    layout: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    userId: string
    action: string
    resource?: string | null
    resourceId?: string | null
    allowed: boolean
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AnalyticsEventCreateManyTenantInput = {
    id?: string
    eventId: string
    eventType: string
    featureFlag: string
    featureName: string
    userId: string
    userRole: $Enums.Role
    sessionId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp: Date | string
    serverTimestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AutomationRuleCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    triggerType: $Enums.AutomationTriggerType
    triggerConfig: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: $Enums.AutomationStatus
    isTemplate?: boolean
    requiresApproval?: boolean
    createdBy: string
    updatedBy?: string | null
    lastTriggered?: Date | string | null
    executionCount?: number
    successCount?: number
    failureCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationExecutionCreateManyTenantInput = {
    id?: string
    ruleId: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SmartInsightCreateManyTenantInput = {
    id?: string
    insightType: $Enums.InsightType
    severity?: $Enums.InsightSeverity
    title: string
    description: string
    explanation: string
    confidence?: number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    dismissReason?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AutomationUsageMetricCreateManyTenantInput = {
    id?: string
    ruleId: string
    executionId: string
    actionType: string
    success: boolean
    executionTime: number
    costImpact?: number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type PaymentMethodCreateManyTenantInput = {
    id?: string
    customerId?: string | null
    type: $Enums.PaymentMethodType
    isDefault?: boolean
    token: string
    last4?: string | null
    brand?: string | null
    expiryMonth?: number | null
    expiryYear?: number | null
    accountType?: string | null
    routingNumber?: string | null
    nickname?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyTenantInput = {
    id?: string
    paymentMethodId?: string | null
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReconciliationCreateManyTenantInput = {
    id?: string
    paymentId: string
    status?: $Enums.ReconciliationStatus
    ledgerEntryId?: string | null
    accountId?: string | null
    matchedAmount?: number | null
    variance?: number | null
    varianceReason?: string | null
    reconciledBy?: string | null
    reconciledAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentExplainabilityCreateManyTenantInput = {
    id?: string
    paymentId: string
    trigger: string
    triggerDetails: JsonNullValueInput | InputJsonValue
    conditionsMet: JsonNullValueInput | InputJsonValue
    amountCalculation: string
    baseAmount: number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore: number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired: boolean
    approvalStatus?: string | null
    businessImpact: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: number | null
    explanation: string
    createdAt?: Date | string
  }

  export type CashControlRuleCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    requiresApproval?: boolean
    executionCount?: number
    successCount?: number
    failureCount?: number
    totalAmountProcessed?: number
    createdBy: string
    lastExecuted?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashControlExecutionCreateManyTenantInput = {
    id?: string
    ruleId: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
  }

  export type PaymentAnalyticsCreateManyTenantInput = {
    id?: string
    paymentId?: string | null
    eventType: string
    amount?: number | null
    processingFee?: number | null
    isAutomated: boolean
    automationRuleId?: string | null
    timeToCash?: number | null
    retryCount?: number | null
    revenueImpact?: number | null
    timestamp?: Date | string
  }

  export type FinancialForecastCreateManyTenantInput = {
    id?: string
    forecastType: $Enums.ForecastType
    value: number
    unit: string
    confidenceScore: number
    forecastDate: Date | string
    forecastHorizon: number
    formula: string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type ScenarioCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    scenarioType: $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: number | null
    projectedRunway?: number | null
    runwayChange?: number | null
    riskLevel?: $Enums.RiskLevel | null
    riskScore?: number | null
    successProbability?: number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy: string
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioAnalyticsCreateManyTenantInput = {
    id?: string
    scenarioId?: string | null
    eventType: string
    scenarioType?: string | null
    decisionMade?: boolean | null
    decisionOutcome?: string | null
    riskAvoided?: boolean | null
    upgradeTriggered?: boolean | null
    planBefore?: string | null
    planAfter?: string | null
    timeToDecision?: number | null
    timestamp?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    dashboardLayouts?: DashboardLayoutUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DashboardLayoutUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDashboardLayoutsNestedInput
  }

  export type DashboardLayoutUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardLayoutUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    layout?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    featureFlag?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessionId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    serverTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    featureFlag?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessionId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    serverTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    featureFlag?: StringFieldUpdateOperationsInput | string
    featureName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userRole?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessionId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    serverTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AutomationRuleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: AutomationExecutionUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AutomationRuleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: EnumAutomationTriggerTypeFieldUpdateOperationsInput | $Enums.AutomationTriggerType
    triggerConfig?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    status?: EnumAutomationStatusFieldUpdateOperationsInput | $Enums.AutomationStatus
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: AutomationRuleUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type AutomationExecutionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmartInsightUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    severity?: EnumInsightSeverityFieldUpdateOperationsInput | $Enums.InsightSeverity
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SmartInsightUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    severity?: EnumInsightSeverityFieldUpdateOperationsInput | $Enums.InsightSeverity
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SmartInsightUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    severity?: EnumInsightSeverityFieldUpdateOperationsInput | $Enums.InsightSeverity
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    relatedEntities?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    suggestedActions?: JsonNullValueInput | InputJsonValue
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dismissReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutomationUsageMetricUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    executionTime?: IntFieldUpdateOperationsInput | number
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUsageMetricUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    executionTime?: IntFieldUpdateOperationsInput | number
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUsageMetricUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    executionId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    executionTime?: IntFieldUpdateOperationsInput | number
    costImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    businessImpact?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentMethodTypeFieldUpdateOperationsInput | $Enums.PaymentMethodType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expiryYear?: NullableIntFieldUpdateOperationsInput | number | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    routingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: PaymentMethodUpdateOneWithoutPaymentsNestedInput
    reconciliation?: PaymentReconciliationUpdateOneWithoutPaymentNestedInput
    explainability?: PaymentExplainabilityUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reconciliation?: PaymentReconciliationUncheckedUpdateOneWithoutPaymentNestedInput
    explainability?: PaymentExplainabilityUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReconciliationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutReconciliationNestedInput
  }

  export type PaymentReconciliationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReconciliationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    status?: EnumReconciliationStatusFieldUpdateOperationsInput | $Enums.ReconciliationStatus
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    varianceReason?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledBy?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentExplainabilityUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutExplainabilityNestedInput
  }

  export type PaymentExplainabilityUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentExplainabilityUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    triggerDetails?: JsonNullValueInput | InputJsonValue
    conditionsMet?: JsonNullValueInput | InputJsonValue
    amountCalculation?: StringFieldUpdateOperationsInput | string
    baseAmount?: FloatFieldUpdateOperationsInput | number
    adjustments?: JsonNullValueInput | InputJsonValue
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    safeguards?: JsonNullValueInput | InputJsonValue
    riskFactors?: JsonNullValueInput | InputJsonValue
    approvalRequired?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    businessImpact?: JsonNullValueInput | InputJsonValue
    estimatedTimeSaved?: NullableIntFieldUpdateOperationsInput | number | null
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlRuleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: CashControlExecutionUpdateManyWithoutRuleNestedInput
  }

  export type CashControlRuleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: CashControlExecutionUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type CashControlRuleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumCashControlRuleTypeFieldUpdateOperationsInput | $Enums.CashControlRuleType
    config?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    executionCount?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    totalAmountProcessed?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    lastExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlExecutionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: CashControlRuleUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type CashControlExecutionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlExecutionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAnalyticsUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeToCash?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAnalyticsUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeToCash?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAnalyticsUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeToCash?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: NullableIntFieldUpdateOperationsInput | number | null
    revenueImpact?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialForecastUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    forecastType?: EnumForecastTypeFieldUpdateOperationsInput | $Enums.ForecastType
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    forecastDate?: DateTimeFieldUpdateOperationsInput | Date | string
    forecastHorizon?: IntFieldUpdateOperationsInput | number
    formula?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialForecastUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    forecastType?: EnumForecastTypeFieldUpdateOperationsInput | $Enums.ForecastType
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    forecastDate?: DateTimeFieldUpdateOperationsInput | Date | string
    forecastHorizon?: IntFieldUpdateOperationsInput | number
    formula?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialForecastUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    forecastType?: EnumForecastTypeFieldUpdateOperationsInput | $Enums.ForecastType
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    forecastDate?: DateTimeFieldUpdateOperationsInput | Date | string
    forecastHorizon?: IntFieldUpdateOperationsInput | number
    formula?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    dataSources?: JsonNullValueInput | InputJsonValue
    historicalBaseline?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioType?: EnumScenarioTypeFieldUpdateOperationsInput | $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayChange?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableEnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel | null
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    successProbability?: NullableFloatFieldUpdateOperationsInput | number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioType?: EnumScenarioTypeFieldUpdateOperationsInput | $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayChange?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableEnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel | null
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    successProbability?: NullableFloatFieldUpdateOperationsInput | number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scenarioType?: EnumScenarioTypeFieldUpdateOperationsInput | $Enums.ScenarioType
    config?: JsonNullValueInput | InputJsonValue
    baselineRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    projectedRunway?: NullableFloatFieldUpdateOperationsInput | number | null
    runwayChange?: NullableFloatFieldUpdateOperationsInput | number | null
    riskLevel?: NullableEnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel | null
    riskScore?: NullableFloatFieldUpdateOperationsInput | number | null
    successProbability?: NullableFloatFieldUpdateOperationsInput | number | null
    topRiskDrivers?: JsonNullValueInput | InputJsonValue
    criticalAssumptions?: JsonNullValueInput | InputJsonValue
    cashFlowImpact?: NullableJsonNullValueInput | InputJsonValue
    automationImpact?: NullableJsonNullValueInput | InputJsonValue
    paymentImpact?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioAnalyticsUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    scenarioType?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMade?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decisionOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    riskAvoided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    upgradeTriggered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    planBefore?: NullableStringFieldUpdateOperationsInput | string | null
    planAfter?: NullableStringFieldUpdateOperationsInput | string | null
    timeToDecision?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioAnalyticsUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    scenarioType?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMade?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decisionOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    riskAvoided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    upgradeTriggered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    planBefore?: NullableStringFieldUpdateOperationsInput | string | null
    planAfter?: NullableStringFieldUpdateOperationsInput | string | null
    timeToDecision?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioAnalyticsUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    scenarioType?: NullableStringFieldUpdateOperationsInput | string | null
    decisionMade?: NullableBoolFieldUpdateOperationsInput | boolean | null
    decisionOutcome?: NullableStringFieldUpdateOperationsInput | string | null
    riskAvoided?: NullableBoolFieldUpdateOperationsInput | boolean | null
    upgradeTriggered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    planBefore?: NullableStringFieldUpdateOperationsInput | string | null
    planAfter?: NullableStringFieldUpdateOperationsInput | string | null
    timeToDecision?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionCreateManyRuleInput = {
    id?: string
    tenantId: string
    status?: $Enums.AutomationExecutionStatus
    triggeredBy?: string | null
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    conditionsMet: boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: boolean
    errorMessage?: string | null
    executionTime?: number | null
    retryCount?: number
    nextRetryAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AutomationExecutionUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAutomationExecutionsNestedInput
  }

  export type AutomationExecutionUncheckedUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationExecutionUncheckedUpdateManyWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutomationExecutionStatusFieldUpdateOperationsInput | $Enums.AutomationExecutionStatus
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    conditionsMet?: BoolFieldUpdateOperationsInput | boolean
    actionsExecuted?: JsonNullValueInput | InputJsonValue
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyPaymentMethodInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    type: $Enums.PaymentType
    status?: $Enums.PaymentStatus
    amount: number
    currency?: string
    description?: string | null
    processorId?: string | null
    processorStatus?: string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: string | null
    automationExecutionId?: string | null
    isAutomated?: boolean
    scheduledFor?: Date | string | null
    processedAt?: Date | string | null
    retryCount?: number
    maxRetries?: number
    nextRetryAt?: Date | string | null
    reconciledAt?: Date | string | null
    ledgerEntryId?: string | null
    processingFee?: number | null
    netAmount?: number | null
    isDisputed?: boolean
    disputeReason?: string | null
    disputedAt?: Date | string | null
    requiresApproval?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    reconciliation?: PaymentReconciliationUpdateOneWithoutPaymentNestedInput
    explainability?: PaymentExplainabilityUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reconciliation?: PaymentReconciliationUncheckedUpdateOneWithoutPaymentNestedInput
    explainability?: PaymentExplainabilityUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    processorId?: NullableStringFieldUpdateOperationsInput | string | null
    processorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    processorResponse?: NullableJsonNullValueInput | InputJsonValue
    automationRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    automationExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    isAutomated?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    processingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    netAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isDisputed?: BoolFieldUpdateOperationsInput | boolean
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    disputedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlExecutionCreateManyRuleInput = {
    id?: string
    tenantId: string
    status: string
    triggerData: JsonNullValueInput | InputJsonValue
    conditionsEvaluated: JsonNullValueInput | InputJsonValue
    paymentId?: string | null
    amount?: number | null
    success: boolean
    errorMessage?: string | null
    executionTime?: number | null
    isDryRun?: boolean
    createdAt?: Date | string
  }

  export type CashControlExecutionUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashControlExecutionsNestedInput
  }

  export type CashControlExecutionUncheckedUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashControlExecutionUncheckedUpdateManyWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    triggerData?: JsonNullValueInput | InputJsonValue
    conditionsEvaluated?: JsonNullValueInput | InputJsonValue
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTime?: NullableIntFieldUpdateOperationsInput | number | null
    isDryRun?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}